NEW
AUTO 3,1
*--------------------------------------

*************************************************************************
* APPLE /// SOS 1.3 SOURCE CODE FILE: FNDFIL
*************************************************************************
* ASSEMBLER: APPLE ][ 6502 ASSEMBLER from APPLE COMPUTER TOOLKIT

* PAGE
*
*
FINDFILE		jsr LOOKFILE ; SEE IF FILE EXISTS
				bcs NOFIND ; BRANCH IF AN ERROR WAS ENCOUNTERED
MOVENTRY		ldy H.ENTLN ; MOVE ENTIRE ENTRY INFO TO A SAFE AREA
MOVENT1			lda (DRBUFPL),Y
				sta DFIL+D.STOR,Y
				dey 
				bpl MOVENT1
				lda #0 ; TO INDICATE ALL IS WELL
NOFIND			rts ; RETURN CONDITION CODES.
* PAGE
*
*
LOOKFILE		jsr PREPROOT ; FIND VOLUME AND SET UP OTHER BORING STUFF
				bcs FNDERR ; PASS BACK ANY ERROR ENCOUNTERED
				ldy #0 ; TEST TO SEE IF ONLY ROOT WAS SPECIFIED.
				lda (PATHNML),Y
				bne LOOKFIL0 ; BRANCH IF MORE THAN ROOT.
				lda #GBUF/256 ; OTHERWISE, REPORT A BADPATH ERROR
				sta DRBUFPH ; (BUT FIRST CREATE A PHANTOM ENTRY FOR OPEN)
				lda #4
				sta DRBUFPL
				ldy #D.AUXID ; FIRST MOVE IN ID, AND DATE STUFF.
PHANTM1			lda (DRBUFPL),Y
				sta DFIL,Y
				dey 
				cpy #D.CREDT-1
				bne PHANTM1
PHANTM2			lda ROOTSTUF-D.FILID,Y
				sta DFIL,Y
				dey 
				cpy #D.FILID-1
				bne PHANTM2
				lda #DIRTYP*$10 ; FAKE DIRECTORY FILE
				sta DFIL+D.STOR
				lda #BADPATH ; (CARRY IS SET)
				rts 
*
ROOTSTUF		.da 0,2,0,4
				.da 0,0,8,0
*
LOOKFIL0		lda #0 ; RESET FREE ENTRY INDICATOR
				sta NOFREE
				sec ; INDICATE THAT THE DIRECTORY TO BE SEARCHED HAS HEADER IN THIS BLOCK
LOOKFIL1		lda #0 ; RESET ENTRY COUNTER
				sta TOTENT
				jsr LOOKNAM ; LOOK FOR NAME POINTED TO BY 'PATHNML'
				bcc NAMFOJMP ; BRANCH IF NAME WAS FOUND.
				lda ENTCNTL ; HAVE WE LOOKED AT ALL OF THE
				sbc TOTENT ; ENTRIES IN THIS DIRECTORY?
				bcc DCRENTH ; MAYBE, CHECK HI COUNT.
				bne LOOKFIL2 ; NO, READ NEXT DIRECTORY BLOCK
				cmp ENTCNTH ; HAS THE LAST ENTRY BEEN LOOKED AT (ACC=0)
				beq ERRFNF ; YES, GIVE 'FILE NOT FOUND' ERROR.
				bne LOOKFIL2 ; BRANCH ALWAYS.
DCRENTH			dec ENTCNTH ; SHOULD BE AT LEAST 1
				bpl LOOKFIL2 ; (THIS SHOULD BE BRANCH ALWAYS...)
ERRDIR			lda #DIRERR ; REPORT DIRECTORY MESSED UP.
FNDERR			sec ; INDICATE ERROR HAS BEEN ENCOUNTERED.
				rts 
NAMFOJMP		jmp NAMFOUND ; AVOID BRANCH OUT OF RANGE
*
* PAGE
LOOKFIL2		sta ENTCNTL ; KEEP RUNNING COUNT
				lda #GBUF/256 ; RESET INDIRECT POINTER
				sta DRBUFPH
				lda GBUF+2 ; GET LINK TO NEXT DIRECTORY BLOCK
				bne NXTDIR0 ; (IF THERE IS ONE)
				cmp GBUF+3 ; ARE BOTH ZERO, I.E. NO LINK?

				beq ERRDIR ; IF SO, THEN NOT ALL ENTRIES WERE ACCOUNTED FOR.
NXTDIR0			sta BLOKNML
				lda GBUF+3
				sta BLOKNMH
				jsr RDGBUF ; GO READ THE NEXT LINKED DIRECTORY IN.
				bcc LOOKFIL1 ; BRANCH IF NO ERROR.
				rts ; RETURN ERROR (IN ACCUMULATOR).
TELFREEX		jmp TELFREE
*
FNF0X			jmp FNF0 ; AVOID BRANCH OUT OF RANGE
*
CFLAG			.bs 1 ; AM I CREATING?
TTSAVE			.bs 2 ; CURRENT BLOCK ADDR
BLOKSAVE		.bs 2 ; PARENT DIR ADDR
*
ERRFNF			lda NOFREE ; WAS ANY FREE ENTRY FOUND?
				bne FNF0X
				lda GBUF+2 ; TEST LINK
				bne TELFREEX
				cmp GBUF+3 ; IF BOTH ARE ZERO, THEN GIVE UP
				bne TELFREEX ; BRANCH IF NOT LAST DIR BLOCK
				lda CFLAG ; DOING A CREATE?
				beq FNF0X ; NO, SIMPLY REPORT NOT FOUND
*
* EXTEND THE DIRECTORY BY A BLOCK
*
				lda BLOKSAVE ; BUT NOT
				ora BLOKSAVE+1 ; IF A ROOT DIRECTORY!
				beq FNF0X ; FORU BLOCKS HARD CODED
				lda TTLINK ; FETCH CURRENT DIRECTORY
				sta TLINK ; ADDR (GBUF)
				lda TTLINK+1 ; AND ALLLOCATE A NEW
				sta TLINK+1 ; BY LINKING TO CURRENT
				jsr DIRWRT
				bcs FNF0 ; RATS! NO SPACE SAY "DIRFULL"
*
* SAVE CURRENT BLOCK ADDR
*
				lda TTLINK
				sta TTSAVE
				lda TTLINK+1
				sta TTSAVE+1
*
* FETCH DESCENDENT
*
				lda GBUF+2
				sta BLOKNML
				lda GBUF+3
				sta BLOKNMH
				jsr ZERGBUF ; INIT THE NEW DIR BLOCK
*
* AND INSERT BACK POINTER
* TO "CURRENT BLOCK"
*
				lda TTSAVE
				sta GBUF
				lda TTSAVE+1
				sta GBUF+1
				jsr WRTGBUF
				bcs ERTS
*
* UPDATE DIR'S HEADER IN PARENT
*
				lda BLOKSAVE
				sta BLOKNML ; PREPARE TO READ PARENT
				ldx BLOKSAVE+1
				stx BLOKNMH
				jsr RDGBUF ; FETCH PARENT
				ldy #D.USAGE ; BUMP BLOCKS USED BY HEADER
				lda (DEBUPTR),Y
				sec 
				adc #0 ; BY JUST ONE BLOCK
				sta (DEBUPTR),Y
				iny 
				lda (DEBUPTR),Y ; TWO BYTE BLOCKS USED
				adc #0
				sta (DEBUPTR),Y
				ldy #D.EOF+1 ; INCREASE EOF BY $200
				lda (DEBUPTR),Y
				clc 
				adc #2

				sta (DEBUPTR),Y
				iny 
				lda (DEBUPTR),Y
				adc #0
				sta (DEBUPTR),Y
				jsr WRTGBUF ; REWRITE PARENT DIR BLOCK
				lda TTSAVE+1 ; REFETCH CURRENT DIR BLOCK
				sta BLOKNMH
				lda TTSAVE
				sta BLOKNML
				jsr RDGBUF ; BACK FROM THE SHADOWS AGAIN
				jmp ERRFNF ; VOILA! WE HAVE EXTENDED THE DIRECTORY!
*
TELFREE			sta D.ENTBLK
				lda GBUF+3
				sta D.ENTBLK+1 ; ASSUME FIRST ENTRY OF NEXT BLOCK
				lda #1 ; IS FREE FOR USE.
				sta D.ENTNUM
				sta NOFREE ; MARK D.ENTNUM AS VALID (FOR CREATE)
FNF0			ldy #0 ; TEST FOR 'FILE NOT FOUND' VERSUS 'PATH NOT FOUND'
				lda (PATHNML),Y
				tay 
				iny 
				lda (PATHNML),Y ; IF NON-ZERO THEN 'PATH NOT FOUND'
ERRPATH1		sec ; IN EITHER CASE, INDICATE ERROR.
				beq FNF1
				lda #PATHNOTFND ; REPORT NO SUCH PATH.
ERTS			rts
FNF1			lda #FNFERR ; REPORT FILE NOT FOUND.
				rts 
* PAGE
*
NAMFOUND		lda (PATHNML),Y ; (Y=0)
				sec 
				adc PATHNML ; TEST FOR LAST NAME IN PATH
				tay ; IF ZERO, THEN THAT WAS LAST NAME
				clc ; TO INDICATE SUCCESS
				lda PATHBUF,Y
				beq FILFOUND
*NOW CHANGE THE PATHNAME POINTER TO POINT AT THE NEXT NAME IN THE PATH
				sty PATHNML
				lda DRBUFPL ; SAVE PARENTS
				sta DEBUPTR ; ENTRY POINTER
				lda DRBUFPH
				sta DEBUPTR+1 ; IN CASE ENTRY ON PAGE 2
				lda BLOKNML ; ADDRESS (DIR EXTEND)
				sta BLOKSAVE
				lda BLOKNMH
				sta BLOKSAVE+1
				ldy #D.STOR ; BE SURE THIS IS A DIRECTORY ENTRY
				lda (DRBUFPL),Y ; HIGH NIBBLE WILL TELL
				and #$F0
				cmp #DIRTYP*16 ; IS IT A SUB-DIRECTORY?
				bne ERRPATH1 ; REPORT THE USER'S MISTAKE
				ldy #D.FRST ; GET ADDRESS OF FIRST SUB-DIRECTORY BLOCK
				lda (DRBUFPL),Y
				sta BLOKNML ; (NO CHECKING IS DONE HERE FOR A VALID
				iny ; BLOCK NUMBER... )
				sta D.HEAD ; SAVE AS FILE'S HEADER BLOCK TOO.
				lda (DRBUFPL),Y
				sta BLOKNMH
				sta D.HEAD+1
				jsr RDGBUF ; READ SUB-DIRECTORY INTO GBUF
				bcs FNDERR1 ; RETURN IMMEDIATELY ANY ERROR ENCOUNTERED.
				lda GBUF+HCENT+4 ; GET THE NUMBER OF FILES
				sta ENTCNTL ; CONTAINED IN THIS DIRECTORY
				lda GBUF+HCENT+5
				sta ENTCNTH
				lda GBUF+HCMP+4 ; TEST BACKWARD COMPATIBILITY
				beq MOVHEAD
ERRCOMP			lda #CPTERR ; TELL THEM THIS DIRECTORY IS NOT COMPATABLE
NONAME			.eq *
FNDERR1			sec
				rts 
MOVHEAD			jsr MOVHED0 ; MOVE INFO ABOUT THIS DIRECTORY
				jmp LOOKFIL0 ; DO NEXT LOCAL PATHNAME
*
MOVHED0			ldx #$A ; MOVE INFO ABOUT THIS DIRECTORY
MOVHED1			lda GBUF+HCRDT+4,X
				sta H.CREDT,X
				dex 

				bpl MOVHED1
				rts 
*
* PAGE
*
*
FILFOUND		.eq *
ENTADR			lda H.MAXENT ; FIGURE OUT WHICH IS ENTRY NUMBER THIS IS.
				sec 
				sbc CNTENT ; MAX ENTRIES - COUNT ENTRIES + 1 = ENTRY NUMBER
				adc #0 ; (CARRY IS/WAS SET)
				sta D.ENTNUM
				lda BLOKNML
				sta D.ENTBLK
				lda BLOKNMH ; AND INDICATE BLOCK NUMBER OF THIS DIRECTORY.
				sta D.ENTBLK+1
				clc 
				rts 
*
LOOKNAM			lda H.MAXENT ; RESET COUNT OF FILES PER BLOCK
				sta CNTENT
				lda #GBUF/256
				sta DRBUFPH
				lda #4
LOKNAM1			sta DRBUFPL ; RESET INDIRECT POINTER TO GBUF
				bcs LOKNAM2 ; BRANCH IF THIS BLOCK CONTAINS A HEADER
				ldy #D.STOR
				lda (DRBUFPL),Y ; GET LENGTH OF NAME IN DIRECTORY
				bne ISNAME ; BRANCH IF THERE IS A NAME.
				lda NOFREE ; TEST TO SEE IF A FREE ENTRY HAS BEEN DECLARED.
				bne LOKNAM2 ; YES BUMP TO NEXT ENTRY
				jsr ENTADR ; SET ADDRESS FOR CURRENT ENTRY
				inc NOFREE ; INDICATE A FREE SPOT HAS BEEN FOUND
				bne LOKNAM2 ; BRANCH ALWAYS.
*
ISNAME			and #$F ; STRIP TYPE (THIS IS CHECKED BY 'FILFOUND')
				inc TOTENT ; (BUMP COUNT OF VALID FILES FOUND)
				cmp (PATHNML),Y ; ARE BOTH NAMES OF THE SAME LENGTH?
				bne LOKNAM2 ; NO, BUMP TO NEXT ENTRY
				tay 
CMPNAME			lda (DRBUFPL),Y ; COMPARE NAMES LETTER BY LETTER
				cmp (PATHNML),Y
				bne LOKNAM2
				dey ; HAVE ALL LETTERS BEEN COMPARED?
				bne CMPNAME ; NO, CONTINUE..
				clc ; BY GOLLY, WE GOT US A MATCH!
				rts 
*
LOKNAM2			dec CNTENT ; HAVE WE CHECKED ALL POSSIBLE ENTRIES IN THIS BLOCK?
				beq NONAME ; YES, GIVE UP.
				lda H.ENTLN ; ADD ENTRY LENGTH TO CURRENT POINTER
				clc 
				adc DRBUFPL
				bcc LOKNAM1 ; BRANCH IF WE'RE STILL IN THE FIRST PAGE.
				inc DRBUFPH ; LOOK ON SECOND PAGE
				clc ; CARRY SHOULD ALWAYS BE CLEAR BEFORE LOOKING AT NEXT.
				bcc LOKNAM1 ; BRANCH ALWAYS...
* PAGE
*
*
PREPROOT		jsr FINDVOL ; FIND CORRECT VOLUME AND DEVICE NUMBER
				bcc ROOT1 ; BRANCH IF IT WAS FOUND.
ROOT0			jsr LOOKVOL ; OTHERWISE LOOK ON ALL DEVICES.
				bcs SRITZ ; CAN'T FIND IT.
ROOT1			lda #0 ; ZERO OUT DIRECTORY TEMPS
				ldy #42 ; (DECIMAL)
CLRDSP			sta D.DEV,Y
				dey 
				bpl CLRDSP
				ldy #VCBDEV ; SET UP DEVICE NUMBER
				lda (VCBPTR),Y
				sta DEVNUM
				sta D.DEV ; FOR FUTURE REFERENCE
				iny 
				lda (VCBPTR),Y ; GET CURRENT STATUS OF THIS VOLUME
				sta V.STATUS
				ldy #VCBROOT ; GET BLOCK ADDRESS OF ROOT DIRECTORY TOO.
				lda (VCBPTR),Y
				sta BLOKNML
				sta D.HEAD ; PRESERVE AS HEADER
				iny 

				lda (VCBPTR),Y
				sta BLOKNMH
				sta D.HEAD+1
				jsr RDGBUF ; GO READ IN ROOT
				bcc ROOT2 ; BRANCH IF NO ERROR
				pha ; SAVE ERROR CODE
				ldy #VCBSTAT ; CHECK THIS BUGGER FOR AN OPEN FILE.
				lda (VCBPTR),Y
				asl
				pla ; GET ERROR CODE AGAIN
				bcs ROOTERR ; BRANCH IF ERROR NEEDS TO BE REPORTED
				bne ROOT0 ; OTHERWISE, LOOK ELSEWHERE (BRANCH ALWAYS).
*
ROOT2			jsr CHKROOT ; VERIFY ROOT NAME
				beq ROOT3 ; BRANCH IF MATCHED.
				ldy #VCBSTAT ; TEST FOR OPEN FILES ON THIS VOLUME BEFORE
				lda (VCBPTR),Y ; LOOKING FOR IT ELSEWHERE.
				bpl ROOT0
				jsr USRREQ ; REQUEST USER MOUNT VOLUME
				bcc ROOT1 ; USER SAID S/HE DID-- CHECK IT
				lda #VNFERR ; REPORT VOLUME NOT FOUND ERR IF REFUSE TO INSERT
SRITZ			rts
*
* PAGE
ROOT3			ldy #$F ; (NOTE: X CONTAINS THE LENGTH OF THE ROOT NAME)
ROOTINFO		lda GBUF+HCRDT+3,Y ; SAVE HEADER INFO.
				sta V.STATUS,Y
				dey 
				bne ROOTINFO ; LOOP TIL ALL 15 BYTES MOVED
				lda H.FCNT
				sta ENTCNTL
				lda H.FCNT+1
				sta ENTCNTH
				txa ; NOW THAT ROOT IS IDENTIFIED, ADJUST
				sec ; PATH NAME POINTER TO NEXT NAME IN THE PATH
				adc PATHNML
				sta PATHNML
				clc ; INDICATE NO ERROR
ROOTERR			rts
*
*
CHKROOT			ldy #0 ; GET LENGTH OF NAME
				lda (PATHNML),Y
				tay 
				tax ; SAVE IN X FOR LATTER ADJUSTMENT TO PATH POINTER
				eor GBUF+4
				and #$F ; DOES PATHNAME HAVE SAME LENGTH AS DIRECTORY NAME?
				bne NOTROOT ; BRANCH IF NOT
CKROOT1			lda (PATHNML),Y ; COMPARE CHARACTER BY CHARACTER
				cmp GBUF+4,Y
				bne NOTROOT
				dey 
				bne CKROOT1 ; LOOP UNTIL ALL CHARACTERS MATCH
NOTROOT			rts
*
* PAGE
FINDVOL			lda #VCB/256 ; SEARCH VCB FOR VOLUME NAME
				sta VCBPTR+1
				lda #0
				sta D.DEV
				sta VCBPTR
FNDVOL1			pha ; SAVE LAST SEARCH POSITION
				tax 
				ldy #0 ; (INDEX TO PATHNAME POINTER)
				lda VCB,X ; GET LENGTH OF VOLUME NAME TO COMPARE
				beq NXTVCB ; BRANCH IF VCB ENTRY IS EMPTY
				cmp (PATHNML),Y ; ARE NAMES OF SAME LENGTH?
				bne NXTVCB ; NO, INDEX NEXT VCB
				clc ; SCAN NAME BACKWARDS
				tay 
				txa 
				adc VCB,X
				tax ; NOW BOTH INDEXES POINT TO LAST CHARACTER OF THE NAMES TO COMPARE
VOLNAM			lda (PATHNML),Y
				cmp VCB,X
				bne NXTVCB
				dex 
				dey 
				bne VOLNAM ; CHECK ALL CHARACTERS
				pla ; SINCE A MATCH IS FOUND
				sta VCBPTR ; SET UP INDEX TO VCB ENTRY

				tax 
				lda VCB+VCBSWAP,X ; BRANCH IF
				beq FOUNDVOL ; VOLUME NOT SWAPPED
				jsr SWAPIN ; IF USER REALLY WANTS IT, THEN BRING IN IF SWAPPED
				bcc FOUNDVOL ; BRANCH IF SUCCESS
				lda #XIOERROR ; USER REFUSES TO MOUNT
				rts 
FOUNDVOL		clc ; INDICATE VOLUME FOUND
				rts 
*
NXTVCB			pla ; GET CURRENT INDEX AGAIN.
				clc 
				adc #VCBSIZE ; VCB ENTRY LENGTH.
				bcc FNDVOL1 ; BRANCH IF THER IS ANOTHER TO CHECK
				rts ; RETURN WITH CARRY SET TO SHOW FAILURE.
* PAGE
*
*
LOOKVOL			ldx #12 ; (1) COUNT+(12)DEVICE LIST
LOOKVOL1		lda BLKDLST,X ; EXTRN
				sta SCRTCH,X ; MY CHANGEABLE COPY
				dex 
				bpl LOOKVOL1 ; WORK BACKWARDS SO
				sta TOTDEVS ; ENTRY ZERO IS TOTAL DEVICES LISTED
				inx ; MAKE XREG = ZERO
LOKDEV1			inx
				stx SCRTCH
				lda SCRTCH,X
				cmp D.DEV
				beq NXTDEV ; DON'T LOOK AGAIN ON A DRIVE THAT HAS BEEN CHECKED
				sta DEVNUM ; CHECK FOR DEVICE ALREADY LOGGED IN A VCB
				jsr DEVVCB ; (CARRY CLEAR IF IT'S THERE)
				bcc LOKVOL1
				lda #0 ; FIND A FREE VCB TO LOG THIS GUY IN
ENTVCB			tax ; INDEX TO NEXT VCB ENTRY
				lda VCB,X
				beq FREEVCB ; FOUND A FREE SPOT.
				txa ; NOW INDEX TO NEXT, AND KEEP LOOKIN
				clc 
				adc #VCBSIZE ; (EACH VCB ENTRY IS 32 BYTES)
				bcc ENTVCB ; BRANCH IF MORE TO FIND
				lda #0
ENTVCB2			.eq * ; SEE IF WE CAN REPLACE A DEVICE
				tax 
				lda VCB+VCBSTAT,X ; VCB HAS FILES OPEN?
				beq FREEVCB ; NO, USE IT!
				txa 
				clc 
				adc #VCBSIZE ; SEARCH NEXT VCB ENTRY
				bcc ENTVCB2
				rts ; FAILED TO FIND A FREE VCB ENTRY
*
CHKVLOG			ldy #0 ; MAKE SURE VOLUME WAS ACTUALLY LOGGED IN
				lda (VCBPTR),Y
				bne FOUNDVOL ; AH, MADE IT...
				lda #DUPVOL ; WELL, NOT QUITE, THIS VOLUME CAN'T BE LOGGED
				sec 
				rts 
* PAGE
*
FREEVCB			stx VCBPTR ; NOW THIS IS THE POINTER TO A FREE VCB
				lda #2 ; ROOT DIRECTORIES ALWAYS AT BLOCK 2
				ldx #0
				beq GETROOT ; BRANCH ALWAYS
LOKVOL1			ldy #VCBSTAT ; MAKE SURE NO FILES ARE ACTIVE ON
				lda (VCBPTR),Y ; THE VOLUME BEFORE LOGGING IT IN.
				bmi SNSWIT ; BRANCH IF FILES ACTIVE
				ldy #VCBROOT+1 ; GET ADDRESS OF ROOT DIRECTORY
				lda (VCBPTR),Y ; HIGH FIRST.
				tax 
				dey ; THEN LOW.
				lda (VCBPTR),Y
GETROOT			jsr GETROT0
				bcc LOKVOL2 ; BRANCH IF SUCCESSFULLY READ.
				lda #0 ; OTHERWISE, TAKE THIS DEVICE OUT OF VCB
				tay 
				sta (VCBPTR),Y ; (VOLUME 'OFF LINE')
				beq NXTDEV ; BRANCH ALWAYS
*
LOKVOL2			jsr LOGVCB ; GO UPDATE VCB TO INCLUDE CURRENT VOLUME INFO
				bcs NXTDEV ; IF NOT A SOS DISKETTE, SKIP TO NEXT DEVICE

				jsr CHKROOT ; GO COMPARE TO SEE IF WE FOUND WHAT WE'RE
				beq CHKVLOG ; LOOKING FOR...
*
NXTDEV			ldx SCRTCH ; LOOK AT OTHER DEVICES?
				cpx TOTDEVS
				bcc LOKDEV1 ; YES.
				lda #VNFERR ; REPORT VOLUME NOT FOUND.
				rts 
*
SNSWIT			.eq * ; SENSE DSWITCH
				ldy #VCBDEV
				lda (VCBPTR),Y
				sta DEVNUM ; MAKE SURE DEVICE NUMBER IS CURRENT
				jsr TWRPROT1 ; USES DEVNUM
				lda DSWGLOB ; DISK SWITCH GLOBAL
				beq NXTDEV ; BRANCH IF NO DISK SWITCH
				jsr VERFYVOL ; COMPARES VCBPTR VS. DEVNUM CONTENTS
				bcc NXTDEV ; BRANCH IF DISK HAS NOT BEEN SWITCHED
				jsr CHKROOT ; COMPARES PATHNML VS. GBUF
				bne NXTDEV ; IGNORE IF NOT WHAT WE ARE LOOKING FOR
				ldx #0 ; LOOK FOR FREE
				jsr SNSWIT1
				bcs NXTDEV ; ANY ERRORS LOGGING IN THE NEW VOLUME
				jmp CHKVLOG ; MAKE SURE THE NEW VOLUME IS LOGGED
SNSWIT1			lda VCB,X ; VCB ENTRY
				beq SNSWIT2 ; BRANCH IF FOUND
				txa 
				clc 
				adc #VCBSIZE ; LOOK AT NEXT VCB AREA
				tax 
				bcc SNSWIT1
				rts ; CAN'T BE LOGGED IN!
SNSWIT2			lda #0
				sta DUPLFLAG ; TURN OFF DUPLICATE VOLUME FLAG
				stx VCBPTR
				jsr LOGVCB1 ; PARTIALLY LOG IN THE NEW VOLUME
				bcs NONSOS ; CS MEANS NONSOS ERROR
				lda DUPLFLAG ; WAS IT A DUPLICATE VOLUME?
				bne SNSWIT6 ; BRANCH IF YES
				ldy #VCBSWAP ; BY MAKING SWAP BYTE NON ZERO
				lda #1
				sta (VCBPTR),Y ; SO SWAPOUT WON'T AFFECT
				lda DEVNUM ; A REG PASSES DEVNUM TO SWAPOUT
				jsr SWAPOUT ; OLD ACTIVE MOUNT MUST BE SWAPPED
				bcc SNSWIT3
				lda #XIOERROR ; USER REFUSED TO REPLACE OLD VOLUME
				rts 
SNSWIT3			ldy #VCBSWAP ; NOW LOG IN THE NEW ALL THE WAY
				lda #0
				sta (VCBPTR),Y
SNSWIT4			jsr VERFYVOL ; DON'T BOTHER TO ASK IF NEW VOLUME IS ALREADY MOUNTED
				bcc SNSWIT5 ; BRANCH IF NEW VOLUME ON LINE
				jsr USRREQ ; ASK USER TO REMOUNT NEW VOLUME
				bcc SNSWIT4 ; USER SAYS THEY DID: CHECK IT OUT
				lda #VNFERR
SNSWIT5			rts
SNSWIT6			lda #DUPVOL
				sec 
				rts 
* PAGE
*
NONSOS			lda #NOTSOS ; TELL EM IT'S NOT A SOS DISK (COULD BE PASCAL)
				rts ; CARRY SHOULD ALREADY BE SET
*
*
DEVVCB			lda #0 ; SCAN VCB FOR DEVICE SPECIFIED IN 'DEVNUM'
DVCB1			tax ; FIRST TEST FOR VALID VCB.
				lda VCB,X
				beq DVCB2
				lda VCB+VCBSWAP,X ; SWAPPED VOLUMES DON'T COUNT
				bne DVCB2 ; AS LOGGED IN
				lda VCB+VCBDEV,X ; GET DEVICE NUMBER
				cmp DEVNUM ; TEST AGAINST REQUESTED DEVICE
				beq FOUNDEV ; YES, SET UP A POINTER TO IT
DVCB2			txa ; BUMP TO NEXT VCB
				clc 
				adc #VCBSIZE
				bcc DVCB1 ; BRANCH IF MORE TO LOOK AT.
				rts ; RETURN CARRY SET TO INDICATE NOT FOUND
*
TSTDUPVOL		ldx VCBPTR ; PRESERVE CURRENT ADDR OF FREE VCB

				lda #0 ; LOOK FOR A CURRENTLY LOGGED ON VOLUME OF THE SAME NAME.
TSDUPV1			sta VCBPTR
				jsr CMPVCB
				bcs TSDUPV2 ; BRANCH IF NO MATCH.
				ldy #VCBSTAT ; TEST FOR ANY OPEN FILES.
				lda (VCBPTR),Y
				bmi FOUNDDUP ; TELL THE SUCKER HE CAN'T LOOK AT THIS VOLUME!
				lda #0 ; TAKE DUPLICATE OFF LINE IF NO OPEN FILES.
				tay 
				sta (VCBPTR),Y
				beq NODUPVOL ; RETURN THAT ALL IS OK TO LOG IN NEW.
TSDUPV2			lda VCBPTR
				clc 
				adc #VCBSIZE ; BUMP TO NEXT ENTRY.
				bcc TSDUPV1
NODUPVOL		.eq *
FOUNDEV			clc
FNDDUP1			stx VCBPTR
				rts 
*
FOUNDDUP		sta DUPLFLAG ; A DUPLICATE HAS BEEN DETECTED.
				sec ; INDICATE ERROR
				lda VCBPTR ; SAVE ADDRESS OF DUPLICATE
				sta VCBENTRY
				bcs FNDDUP1 ; BRANCH ALWAYS TAKEN
* PAGE
*
*
LOGVCB			ldy #VCBNML ; IS THIS A PREVIOUSLY LOGGED IN VOLUME
				lda (VCBPTR),Y ; (ACC=0?)
				beq LOGVCB1 ; NO, GO AHEAD AND PREPARE VCB.
				jsr CMPVCB ; DOES VCB MATCH VOLUME READ?
				bcc VCBLOGD ; YES, DON'T DISTURB IT.
LOGVCB1			lda #0 ; ZERO OUT VCB ENTRY
				ldy #VCBSIZE-1
ZERVCB			sta (VCBPTR),Y
				dey 
				bpl ZERVCB
				jsr TSTSOS ; MAKE SURE IT'S A SOS DISKETTE.
				bcs VCBLOGD ; IF NOT, RETURN CARRY SET.
				jsr TSTDUPVOL ; FIND OUT IF A DUPLICATE WITH OPEN FILES ALREADY EXISTS
				bcs NOTLOG0
				lda GBUF+4 ; MOVE VOLUME NAME TO VCB
				and #$F ; STRIP ROOT MARKER
				tay 
				pha 
MOVOLNM			lda GBUF+4,Y
				sta (VCBPTR),Y
				dey 
				bne MOVOLNM
				pla ; GET LENGTH AGAIN
				sta (VCBPTR),Y ; SAVE THAT TOO.
				ldy #VCBDEV ; SAVE DEVICE NUMBER ALSO.
				lda DEVNUM
				sta (VCBPTR),Y
				jsr CLEARBMS ; MARKS THIS DEVICES OLD BITMAPS AS INVALID (A REG PASSED)
				lda GBUF+VTBLK+4 ; AND TOTOL NUMBER OF BLOCKS ON THIS UNIT,
				ldy #VCBTBLK
				sta (VCBPTR),Y
				lda GBUF+VTBLK+5
				iny 
				sta (VCBPTR),Y
				ldy #VCBROOT
				lda BLOKNML ; AND ADDRESS OF ROOT DIRECTORY
				sta (VCBPTR),Y
				iny 
				lda BLOKNMH
				sta (VCBPTR),Y
				ldy #VCBDMAP
				lda GBUF+VBMAP+4 ; AND LASTLY, THE ADDRESS
				sta (VCBPTR),Y ; OF THE FIRST BITMAP
				lda GBUF+VBMAP+5
				iny 
				sta (VCBPTR),Y
				clc ; INDICATE THAT IT WAS LOGGED IF POSIBLE.
VCBLOGD			rts
NOTLOG0			jmp NOTLOG1
* PAGE
CMPVCB			lda GBUF+4 ; COMPARE VOLUME NAME IN VCB
				and #$F
				ldy #VCBNML ; WITH NAME IN DIRECTORY

				cmp (VCBPTR),Y ; ARE THEY SAME LENGTH
				bne NOTSAME
				tay 
VCBCMP1			lda GBUF+4,Y
				cmp (VCBPTR),Y
				bne NOTSAME
				dey 
				bne VCBCMP1
				clc ; INDICATE MATCH.
				rts 
*
VERFYVOL		ldx #0 ; READ IN ROOT DIRECTORY HEADER.
				lda #2
				jsr GETROT0
				bcs NOVRFY1 ; PASS BACK WHATEVER OTHER ERROR OCCURS.
				jsr CMPVCB ; TEST ROOT WITH VOLUME NAME IN VCB.
				bcc NOVRFY ; BRANCH IF ROOT MATCHES VCB
				lda #0 ; OTHERWISE, PASS BACK FOREIGN VOLUME ERROR (SOS OR UCSD)
NOVRFY			rts ; RETURN RESULTS IN CARRY.
NOVRFY1			lda #VNFERR ; NOTHING IN DRIVE
				rts 
*
GETROT0			sta BLOKNML
				stx BLOKNMH ; STORE ADDRESS AND READ IN ROOT
				jsr RDGBUF
				bcc RETROT2 ; BRANCH IF SUCCESSFULLY READ.
NOTSAME			.eq *
				sec ; INDICATE ERROR
RETROT2			rts
*
NOTLOG1			ldx VCBPTR ; LOAD THE VCB ADDRESS
				lda VCBENTRY ; OF THE DUPLICATE VOLUME
				sta VCBPTR
				stx VCBENTRY ; AND SAVE THE FREE VCB SPACE ADDR
				ldy #VCBDEV ; IS DUPLICATE ON SAME DEVICE?
				lda DEVNUM
				cmp (VCBPTR),Y
				bne NOTLOG2 ; BRANCH IF NOT
				jsr SWAPIN ; SWAP IN IF NECESSARY
				lda #0
				sta DUPLFLAG ; NO MORE DUPLICATE VOLUME STATUS
				lda VCBPTR ; MAKE CHKROOT WORK IN A MOMENT
				sta PATHNML ; THIS IS INCREDIBLY GROSS
; BUT IS A RESULT OF MAKING VOLUME A SPECIAL
; CASE OF SEARCHING ALL DEVICES FOR
; A KNOWN VOLUME
				clc 
				rts 
NOTLOG2			lda VCBENTRY ; REACH HERE IF REAL DUPLICATE VOLUME
				sta VCBPTR ; RESOTRE FREE VCB PTR
				clc 
				rts ; DUPLICATE VOLUME PRETENDS TO BE NO ERROR
* PAGE
*
TSFRBLK			ldy #VCBTFRE+1
				lda (VCBPTR),Y ; FIND OUT IF ENOUGH FREE BLOCKS
				dey ; ARE AVAILABLE TO ACCOMODATE REQEST.
				ora (VCBPTR),Y ; BUT FIRST FIND OUT IF WE GOT A PROPER COUNT FOR THIS VOLUME.
				bne CMPFREB ; BRANCH IF COUNT IS NON-ZERO
				dey ; IF ZERO, THEN COUNT MUST BE TAKEN
				lda (VCBPTR),Y ; GET HIGH TOTAL BLKS
				tax ; SAVE IT
				dey ; GET LOW
				lda (VCBPTR),Y ; TOTAL BLKS
				bne TSFR01
				dex ; ADJUST FOR BITMAP BLOCK BOUNDARY
TSFR01			txa
				lsr
				lsr
				lsr
				lsr
				sta BMCNT ; SAVE IT.
				lda #0 ; START COUNT AT ZERO.
				sta SCRTCH
				sta SCRTCH+1
				lda #$FF ; MARK 'FIRST FREE' TEMP AS UNKNOWN
				sta NOFREE
				ldy #VCBDEV ; MAKE SURE BIT MAP IS UP TO DATE
				lda (VCBPTR),Y ; GET DEVICE NUMBER
				tax ; PASS TO 'UPBMAP' IN X
				jsr UPBMAP ; (NOTHING HAPPENS IF IT DON'T HAFTA.)

				bcs TFBERR ; BRANCH IF WE GOT TROUBLE,
				ldy #VCBDMAP ; GET ADDRESS OF FIRST BIT MAP.
				lda (VCBPTR),Y
				sta BLOKNML
				iny ; (FOR HIGH ADDRESS)
				lda (VCBPTR),Y
				sta BLOKNMH
BMAPRD			jsr RDGBUF ; USE G(ENERAL)BUFF(ER) FOR TEMPORARY
				bcs TFBERR ; SPACE TO COUNT FREE BLOCKS (BITS)
				jsr COUNT ; GO COUNT EM
				dec BMCNT ; WAS THAT THE LAST BIT MAP?
				bmi CHGVCB ; IF SO, GO CHANGE FCB TO AVOID DOING THIS AGAIN!
				inc BLOKNML ; NOTE: THE ORGANIZATION OF THE BIT MAPS
				bne BMAPRD ; ARE CONTIGUOUS FOR SOS VERSION 0
				inc BLOKNMH ; IF SOME OTHER ORGANIZATION IS IMPLEMENTED, THIS CODE
				jmp BMAPRD ; MUST BE CHANGED!
* PAGE
*
CHGVCB			ldy #VCBCMAP ; MARK WHICH BLOCK HAD FIRST FREE SPACE
				lda NOFREE
				bmi DSKFULL ; BRANCH IF NO FREE SPACE WAS FOUND.
				sta (VCBPTR),Y
				ldy #VCBTFRE+1 ; UPDATE THE FREE COUNT.
				lda SCRTCH+1 ; GET HIGH COUNT BYTE
				sta (VCBPTR),Y ; UPDATE VOLUME CONTROL BLOCK.
				dey 
				lda SCRTCH
				sta (VCBPTR),Y ; AND LOW BYTE TOO...
CMPFREB			lda (VCBPTR),Y ; COMPARE TOTAL AVAILABLE
				sec 
				sbc REQL ; FREE BLOCKS ON THIS VOLUME.
				iny 
				lda (VCBPTR),Y
				sbc REQH
				bcc DSKFULL
				clc 
				rts 
DSKFULL			lda #OVRERR
				sec 
TFBERR			rts
* PAGE
*
COUNT			ldy #0 ; BEGIN AT THE BEGINNING.
FRCONT			lda GBUF,Y ; GET BIT PATTERN
				beq FRCNT1 ; DON'T BOTHER COUNTING NOTHIN'
				jsr CNTFREE
FRCNT1			lda GBUF+$100,Y ; DO BOTH PAGES WITH SAME LOOP
				beq FRCNT2
				jsr CNTFREE
FRCNT2			iny
				bne FRCONT ; LOOP TILL ALL 512 BYTES COUNTED
				bit NOFREE ; HAS FIRST BLOCK WITH FREE SPACE BEEN FOUND YET?
				bpl FRCNT3 ; BRANCH IF IT HAS.
				lda SCRTCH ; TEST TO SEE IF ANY BLOCKS WERE COUNTED
				ora SCRTCH+1
				beq FRCNT3 ; BRANCH IF NONE COUNTED.
				ldy #VCBTBLK+1
				lda (VCBPTR),Y ; SHOW THIS MAP IS FIRST WITH FREE SPACE
				sec ; CORRECT FOR EXACT MULTIPLES OF $1000
				sbc #$01
				lsr
				lsr
				lsr
				lsr
				sec ; SUBTRACT COUNTDOWN FROM TOTAL BIT MAPS
				sbc BMCNT
				sta NOFREE
FRCNT3			rts
*
CNTFREE			asl
				bcc CFREE1
				inc SCRTCH
				bne CFREE1
				inc SCRTCH+1
CFREE1			tax
				bne CNTFREE ; LOOP UNTIL ALL BITS COUNTED.
				rts 

* CHN ALLOC,4,1

*************************************************************************

* END OF APPLE /// SOS 1.3 SOURCE CODE FILE: FNDFIL
*************************************************************************





*--------------------------------------
MAN
SAVE /A3OSX.BUILD/SOS.ORIG/SOS.S.FNDFIL
LOAD /A3OSX.BUILD/SOS.ORIG/SOS.S
ASM
