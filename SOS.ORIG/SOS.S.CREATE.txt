NEW
AUTO 3,1
*--------------------------------------

*************************************************************************
* APPLE /// SOS 1.3 SOURCE CODE FILE: CREATE
*************************************************************************
* ASSEMBLER: APPLE ][ 6502 ASSEMBLER from APPLE COMPUTER TOOLKIT

* PAGE
CREATE			.eq *
				inc CFLAG ; SAY WE ARE IN CREATE (DIR EXTEND)
				jsr LOOKFILE ; CHECK FOR DUPLICATE / GET FREE ENTRY
				bcs TSTFNF ; ERROR CODE IN ACC MAY BE 'FILE NOT FOUND'
				lda #DUPERR ; TELL EM A FILE OF THAT NAME ALREADY EXISTS
CRERR1			sec ; INDICATE ERROR ENCOUNTERED
				rts ; RETURN ERROR IN ACC.
*
TSTFNF			cmp #FNFERR ; 'FILE NOT FOUND' IS WHAT WE WANT
				bne CRERR1 ; PASS BACK OTHER ERROR.
				lda NOFREE ; TEST FOR DIRECTORY SPACE
				bne CREAT1 ; BRANCH IF VALID FREE ENTRY WAS FOUND.
				lda #DIRFULL ; RETURN DIRECTORY FULL ERROR
				sec 
				rts 
*
CREAT1			ldy #$9 ; SET UP DEFAULT PARAMETERS FOR CREATE
				lda #0 ; IN THE SPACE DIRECTLY FOLLOWING THE
ZERCALL			sta C.FILID,Y ; CALL SPECIFCATION AND THEN
				dey ; CHECK FOR ADDITIONAL PARAMETERS FROM
				bpl ZERCALL ; USER'S CALL SPEC VIA 'C.CLIST'
				lda #SEEDTYP ; DEFAULT TYPE IS 'SEED' TREE INDEX
				sta C.STOR
				ldy C.XLEN ; GET THE LENGTH OF THE CALL XTENSION LIST
				beq CRENAM ; IF ZERO THEN USE DEFAULTS
				dey ; (SINCE THE POINTER IS AT BYTE 0)
				cpy #$9 ; MAKE SURE WE DON'T HAVE TOO MANY PARAMETERS
				bcc MOVPARM ; MOVE 'EM IF REASONABLE COUNT.
				lda #BADLSTCNT ; INVALID LIST COUNT
				rts ; RETURN ERROR.
*
MOVPARM			lda (C.XLIST),Y ; MOVE IN THE USER SPECIFIED
				sta C.FILID,Y ; PARAMETERS. VALIDITY IS CHECKED
				dey ; AT VARIOUS POINTS FURTHER ALONG IN
				bpl MOVPARM ; THIS PROCESS.
CRENAM			ldy #0 ; MOVE LOCAL FILE NAME TO ENTRY BUFFER.
				lda (PATHNML),Y ; GET LENGTH OF LOCAL NAME
				tay 
CRENAM1			lda (PATHNML),Y
				sta DFIL+D.STOR,Y
				dey ; (MOVE ALL, INCLUDING LENGTH BYTE.)
				bpl CRENAM1
				lda C.FILID ; MOVE FILE AND AUX ID.
				sta DFIL+D.FILID
				lda C.AUXID
				sta DFIL+D.AUXID
				lda C.AUXID+1
				sta DFIL+D.AUXID+1
				lda #READEN+WRITEN+RENAMEN+DSTROYEN
				sta DFIL+D.ATTR
				lda D.HEAD ; SAVE FILE'S HEADER ADDRESS TOO.
				sta DFIL+D.DHDR
				lda D.HEAD+1
				sta DFIL+D.DHDR+1
				jsr TWRPROT1 ; CAN WE WRITE TO THIS DISKETTE?
				bcs CRERR1
				lda C.STOR ; NOW TEST STORAGE TYPE FOR TREE TYPE FILES
				cmp #4 ; NOTE: THIS IS HARD CODED SINCE ALL TREES ARE LESS THAN 4 ***********
				bcc SEED ; BRANCH IF SOME TYPE OF TREE (SEED, SAPLING...)
				jmp NOTREE ; GO TEST FOR SOME OTHER TYPE (SUCH AS DIRECTORY).
* PAGE
*
SEED			ldx #SEEDTYP ; START OUT ASSUMING A SEED FILE
				lda C.EOFHH ; TEST FOR OUT OF RANGE PREALLOCATION
				beq SEED1 ; (HOPEFULLY BRANCH ALWAYS)
OVFLOW			lda #OVRERR ; REPORT UNABLE TO SATISFY REQUEST.
				sec ; INDICATE ERROR
				rts 
*
SEED1			lda C.EOFHL ; CALCULATE THE NUMBER OF

				sta DFIL+D.EOF+2 ; BLOCKS NEEDED FOR PRE-ALLOCATION
				lsr
				tay ; Y HOLDS THE NUMBER OF INDEX BLOCKS NEEDED
				sta DATBLKH
				lda C.EOFLH ; (CARRY UNDISTURBED FROM LAST SHIFT)
				sta DFIL+D.EOF+1
				ror
				sta DATBLKL
				lda C.EOFLL
				sta DFIL+D.EOF ; (CARRY IN TACT FROM LOW COUNT)
				bne INCDATA ; BUMP THE COUNT ON DATA BLOCKS IF REQUEST
				bcc TSTSAP ; IS NOT A MULTIPLE OF 512.
INCDATA			inc DATBLKL
				bne TSTSAP
				iny ; MUST INCREASE NUMBER OF INDEXES ALSO.
				inc DATBLKH
TSTSAP			tya ; IF NON ZERO, THEN IT'S AT LEAST A SAPLING.
				bne SAPLING
				lda DATBLKL ; TO QUALIFY AS AN HONEST SEED,
				bne TSTSEED ; THEN ONE OR LESS DATA BLOCKS REQUESTED
				inc DATBLKL ; (MUST BE AT LEAST ONE BLOCK ALLOCATED
				bne CREALC ; TYPE IS SEED. BRANCH ALWAYS
TSTSEED			cmp #1 ; IF GREATER THAN ONE, IT'S NOT A SEED.
				beq CREALC ; IT IS A SEED. CONTINUE CREATION
				inx ; THE TYPE IS SAPLING.
				iny ; ONE INDEX BLOCK IS NEEDED.
				bne CREALC ; BRANCH ALWAYS
* PAGE
*
SAPLING			inx ; TYPE IS AT LEAST SAPLING.
				cmp #1 ; NO MORE THAN ONE INDEX BLOCK FOR A SAPLING
				bne TREE
				lda DATBLKL ; MUST BE SURE THIS IS REAL MAX SAPLING (128K FILE)
				beq CREALC ; BRANCH IF IT IS.
TREE			iny ; ACCOUNT FOR ADDITIONAL 2ND LEVEL INDEX
*
				inx ; TYPE IS TREE (2 LEVEL INDEX)
				iny ; ADD AN EXTRA INDEX BLOCK FOR TOP INDEX
CREALC			sty INDXBLK ; STORE INDEX BLOCK COUNT
				txa ; PUT STORAGE TYPE IN DIRECTORY ENTRY
				asl
				asl
				asl
				asl
				ora DFIL+D.STOR
				sta DFIL+D.STOR
				stx LEVELS ; SAVE NUMBER OF INDEX LEVELS FOR PREALLOCATION.
				tya ; NOW FIGURE THE TOTAL NUMBER OF
				clc ; BLOCKS NEEDED (DATA + INDEX BLOCKS)
				adc DATBLKL
				sta DFIL+D.USAGE ; (MIGHT AS WELL RECORD IT IN DIR
				sta REQL ; WHILE WE'RE AT IT.)
				lda DATBLKH
				adc #0 ; UPDATE HI BYTE TOO
				sta DFIL+D.USAGE+1
				sta REQH
				ldx D.DEV ; PASS ALONG THE DEVICE WE'RE TALKIN ABOUT.
				jsr TSFRBLK ; 'TEST FREE BLOCKS' FINDS OUT IF ENOUGH FREE SPACE EXISTS
				bcs OVFLOW ; BRANCH IF NOT ENOUGH SPACE.
				jsr ALC1BLK ; GO ALLOCATE FIRST BLOCK
				bcs CRERR
				sta DFIL+D.FRST ; (RETURNS ACC=LOW Y=HIGH)
				sta IDXADRL ; SAVE AS ADDRESS FOR INCORE INDEX ALSO.
				sty DFIL+D.FRST+1
				sty IDXADRH
				jsr ZERGBUF ; GO CLEAN OUT GBUF
				jsr GTTINDX ; GET TEMPORARY SPACE FOR AN INDEX BLOCK
				jsr ZTMPIDX ; AND ZERO IT OUT.
				ldx LEVELS
				dex ; TEST FOR NUMBER OF LEVELS NEEDED.
				beq ENDCRE ; BRANCH IF SEED FILE.
				dex ; IS IT A SAPLING PRE-ALLOCATION.
				beq SAPFILE
				ldy INDXBLK ; LOAD NUMBER OF INDEX BLOCKS NEEDED
				dey ; REMOVE THE ONE JUST ALLOCATED.
				sty REQL
				sty INDXBLK
				jsr ALCIDXS ; GO ALLOCATE INDEXES FOR LOWER INDEX BLOCKS.
				bcs CRERR
				jsr WRTDFRST ; GO WRITE TREE TOP INDEX BLOCK.
				bcs CRERR ; BRANCH IF UNABLE TO DO THIS.

				lda #0 ; INIT INDEX POINTER
				sta TREPTR
* PAGE
FILLTREE		ldy TREPTR
				lda (TINDX),Y ; GET ADDRESS OF LOWER BLOCK
				sta IDXADRL
				inc TINDX+1 ; BUMP TO PAGE 2 TO GET HI ADDRESS.
				lda (TINDX),Y ; GET HIGH ADDRESS.
				sta IDXADRH
				dec TINDX+1 ; CLEAN UP AFTER SELF...
				dec INDXBLK ; IS THIS THE LAST BLOCK ALLOCATED?
				beq LSTSAP ; YES, ALLOCATE PARTIAL FILLED INDEX BLOCK
				lda #0 ; ALLOCATE ALL 256 INDEXES
				sta REQL
				jsr SAPINDX ; AND WRITE ZEROED DATA BLOCKS.
				bcs CRERR ; STOP IF ERROR ENCOUNTERED.
				jsr WRTINDX ; WRITE INDEX BLOCK
				bcs CRERR ; HOPEFULLY NEVER TAKEN.
				inc TREPTR
				jsr RDFRST ; READ IN TOP INDEX AGAIN.
				bcc FILLTREE ; BRANCH IF NO ERROR.
CRERR			sec ; JUST IN CASE IT WAS CLEAR.
				rts ; RETURN ERROR.
*
*
SAPFILE			.eq *
* LSTSAP LDA DATBLKL ; GET NUMBER OF DATA BLOCKS (LOW BYTE) REQUESTED.
				sta REQL
				jsr SAPINDX ; GO ALLOCATE DATA BLOCKS AND WRITE EM.
				bcs CRERR
ENDCRE			jsr WRTINDX ; GO WRITE INDEX BLOCK. (FOR SEED THIS IS DATA.)
				bcs CRERR
				ldx #3 ; MOVE CREATION TIME FOR THIS ENTRY
TRETIME			lda DATELO,X
				sta DFIL+D.CREDT,X
				dex 
				bpl TRETIME
ENDCRE0			inc H.FCNT ; ADD ONE TO TOTAL NUMBER OF FILES IN SPECIFIED DIRECTORY.
				bne ENDCRE1
				inc H.FCNT+1
				ldx #3 ; ENSURE MOD
ENDCRX			lda DATELO,X ; DATE/TIME
				sta DFIL+D.MODDT,X ; IS
				dex ; INITIALIZED
				bpl ENDCRX
ENDCRE1			ldx D.DEV ; UPDATE APPROPRIATE BIT MAP
				jsr UPBMAP
				bcs CRERR2 ; BRANCH ON BITMAP UPDATE ERR
				jsr DREVISE ; UPDATE DIRECTORY LAST
				rts ; RETURN ERRORS OR OK RESULT
*
* PAGE
SAPINDX			jsr ZTMPIDX ; ZERO OUT ANY STUFF LEFT OVER.
				lda REQL ; PRESERVE REQUEST COUNT
				sta TLINK
				jsr ALCIDXS ; GO ALLOCATE REQUESTED NUMBER OF BLOCKS.
				bcs CRERR
				ldy #0 ; THEN WRITE ZEROS TO DATA BLOCKS.
				sty SAPTR ; USE AS POINTER TO INDEX BLOCK
				lda (TINDX),Y ; GET DATA BLOCK ADDRESS (LOW BYTE).
				sta BLOKNML
				inc TINDX+1
				lda (TINDX),Y ; GET HIGH ADRRESS OF PRE-ALLOCATED DATA BLOCK.
				sta BLOKNMH
				dec TINDX+1 ; (RESET BUFFER ADDRESS)
				jsr WRTGBUF ; WRITE DATA BLOCK
				bcs CRERR
				lda TLINK ; GET NUMBER REQUESTED AGAIN
				sta REQL
DATINIT			ldy SAPTR ; GET POINTER TO INDEX BLOCK AGAIN.
				iny ; ANTICIPATE DOIN' THE NEXT DATA BLOCK
				dec REQL ; DO WE INDEED HAVE ANOTHER BLOCK TO WRITE.
				beq DATDONE ; NO, ALL DONE (CARRY CLEAR).
				sty SAPTR ; USE AS POINTER TO INDEX BLOCK
				lda (TINDX),Y ; GET DATA BLOCK ADDRESS (LOW BYTE).
				sta BLOKNML
				inc TINDX+1 ; BUMP HI ADDR OF INDEX BUFFER TO ACCESS HIGH ADDR.
				tax ; WAS LOW ADDRESS A ZERO?
				bne DATIT1 ; IF NOT, NO NEED TO CHECK VALIDITH OF HI BYTE
				cmp (TINDX),Y
				bne DATIT1 ; BOTH BYTES CAN'T BE ZERO.

				lda #ALCERR
				jsr SYSDEATH
DATIT1			lda (TINDX),Y ; GET HIGH ADRRESS OF PRE-ALLOCATED DATA BLOCK.
				sta BLOKNMH
				dec TINDX+1 ; (RESET BUFFER ADDRESS)
				lda #GBUF/256
				sta DBUFPH ; RESET TO ADDR TO GBUF JUST TO BE SURE.
				jsr REPEATIO ; WRITE DATA BLOCK
				bcc DATINIT
DATDONE			rts ; RETURN STATUS (CARRY SET IF ERROR)
*
REPEATIO		.eq *
				lda #RPTCMD
				sta DHPCMD
				jmp RPEATIO1
*
ZERGBUF			ldy #0 ; ZERO OUT THE GENERAL PURPOSE BUFFER
				tya 
ZGBUF			sta GBUF,Y ; WIPE OUT BOTH PAGES
				sta GBUF+$100,Y ; WITH SAME LOOP.
				iny 
				bne ZGBUF
				rts 
*
*
ZTMPIDX			ldy #0 ; ZERO OUT TEMPORARY INDEX BLOCK
				tya 
ZINDX1			sta (TINDX),Y ; THIS HAS TO BE DONE A
				iny ; TIME SINCE IT'S INDIRECT.
				bne ZINDX1
				inc TINDX+1
ZINDX2			sta (TINDX),Y
				iny 
				bne ZINDX2
				dec TINDX+1 ; RESTORE PROPER ADDRESS
CRERR2			rts
* PAGE
NOTREE			cmp #DIRTYP ; IS A DIRECTORY TO BE CREATED?
				beq ISDIR ; YES, DO SO...
				jmp NOTDIR ; NO, TRY NEXT TYPE.
*
ISDIR			lda C.EOFHH ; CAN'T CREATE A DIRECTORY LARGER THAN
				ora C.EOFHL ; 127 BLOCKS (THAT'S HUGE!)
				beq ISDIR1 ; BRANCH IF WITHIN LIMITS, OTHEWISE
DIROVR			lda #OVRERR ; REQUESTED DIRECTORY SIZE CAN'T BE
				sec ; CREATED. SET CARRY TO INDICATE ERROR.
				rts 
*
ISDIR1			lda C.EOFLH ; CALCULATE HOW MANY BLOCKS WILL
				lsr
				tay ; (SAVE INITIAL COUNT IN Y)
				lda C.EOFLL ; IF REQUESTED EOF IS NOT AN EVEN BLOCK
				bne DADD1 ; SIZE, THEN ROUND UP.
				bcc TSDIRSZ ; BRANCH IF ROUNING UNNECESSARY.
DADD1			iny ; ADD ONE TO BLOCK COUNT.
TSDIRSZ			tya ; TEST TO BE SURE SIZE IS GREATER THAN ZERO
				beq DADD1 ; IF ZERO THEN SIZE=1
				sta DFIL+D.USAGE ; SAVE NUMBER OF BLOCKS TO BE USED.
				sta REQL
				asl
				sta DFIL+D.EOF+1
				lda #0
				sta DFIL+D.EOF
				sta DFIL+D.EOF+2
				sta REQH ; REQUESTED NUMBER OF BLOCKS NEVER EXCEEDS 128.
				jsr TSFRBLK ; TEST TO BE SURE ENOUGH DISK SPACE IS FREE.
				bcs DIROVR ; BRANCH IF REQUEST TOO LARGE.
				jsr ZERGBUF ; CLEAR CRAP FROM GBUF.
				jsr ALC1BLK ; GET ADDRESS OF FIRST (HEADER) BLOCK.
				bcs CRERR2
				sta DFIL+D.FRST
				sta TLINK
				sty DFIL+D.FRST+1
				sty TLINK+1 ; (TLINK IS FOR REVERSE LINKAGE.)
				lda SOSTMPL ; STORE SOS STAMP IN NEW DIRECTORY
				sta GBUF
				lda SOSTMPH
				sta GBUF+1
				ldy #4 ; MOVE OTHER VARIOUS THINGS
				bne DRSTUF1 ; BRANCH ALWAYS
DRSTUF			lda D.ENTBLK,Y ; MOVE OWNING ENTRY'S

				sta GBUF+HRBLK+4,Y ; BLOCK ADDRESSES AND NUMBER TO NEW HEADER.
DRSTUF1			lda SOSVER,Y ; MOVE VERSION, COMPATABLITY,
				sta GBUF+HVER+4,Y ; ATTRIBUTES, AND ENTRY SIZE
				dey 
				bpl DRSTUF
				lda H.ENTLN ; OVER WRITE LAST BYTE MOVED IN ABOVE LOOP WITH
				sta GBUF+HRELN+4 ; THE PARENT DIRECTORY ENTRY LENGTH.
				lda DFIL+D.STOR ; SET HEADER TYPE AND NAME
				tay 
				ora #HEDTYP*16
				sta GBUF+HNLEN+4
				tya ; (AND WHILE WE'RE AT IT SET DIRECTORY TYPE)
				ora #DIRTYP*16
				sta DFIL+D.STOR
*
MVHNAME			lda DFIL+D.STOR,Y
				sta GBUF+HNLEN+4,Y ; MOVE HEADER NAME
				dey 
				bne MVHNAME
				ldx #3 ; GET CURRENT DATE.
CRETIME			lda DATELO,X
				sta GBUF+HCRDT+4,X ; SAVE AS HEADER CREATION TIME
				sta DFIL+D.CREDT,X ; AND DATE OF FILE CREATE.
				dex 
				bpl CRETIME
				lda #$76
				sta GBUF+HPENAB+4 ; DUMMY PASSWORD
				dec REQL ; TEST FOR ONE BLOCK DIRECTORY
				beq DIRCREND ; IT IS, FINISH UP.
				jsr DIRWRT ; GO WRITE FIRST DIRECTORY BLOCK AND ALLOCATE NEXT
				bcs DERROR ; PASS BACK ERROR.
				jsr ZERGBUF ; CLEAN OUT GENERAL BUFFER AGAIN.
CRNXTDIR		lda TLINK ; MOVE LAST BLOCK ADDRESS
				sta GBUF ; AS BACKWARD LINK.
				lda TLINK+1
				sta GBUF+1
				lda FLINK ; MAKE FORWARD LINK INTO CURRENT ADDRESS
				sta TLINK
				lda FLINK+1
				sta TLINK+1
				dec REQL ; IS THIS THE LAST BLOCK?
				beq DIRCREND
				jsr DIRWRT ; WRITE THIS BLOCK AND ALLOCATE NEXT.
				bcs DERROR
				lda #0 ; ZERO OUT FORWARD LINK
				sta GBUF+2
				sta GBUF+3
				beq CRNXTDIR ; BRANCH ALWAYS
*
DIRCREND		jsr DIRWRT1 ; WRITE LAST BLOCK OF THIS DIRECTORY
				bcs DERROR
				jmp ENDCRE0 ; FINISH UP WRITING OWNER DIRECTORY STUFF.
*
DIRWRT			jsr ALC1BLK ; GET ADDRESS OF NEXT BLOCK.
				bcs DERROR
				sta GBUF+2
				sty GBUF+3 ; SAVE LINK ADDRESS
				sta FLINK
				sty FLINK+1
DIRWRT1			lda TLINK ; GET ADDRESS OF CURRENT BLOCK
				sta BLOKNML
				lda TLINK+1
				sta BLOKNMH
				jmp WRTGBUF ; GO WRITE IT OUT
* PAGE
*
ERRGBUF			.eq *
DERROR			rts
*
*
SOSTMPL			.da 00 ; THE FOLLOWING TWO BYTES ARE THE 'SOS STAMP'
SOSTMPH			.da 00
*
SOSVER			.da 00,00,00,27,0D
*
*
RNDTAB			.eq *
ENTCALC			lda #GBUF/256 ; SET HIGH ADDRESS OF DIRECTORY ENTRY INDEX POINTER
				sta DRBUFPH
				lda #4 ; CALCULATE ADDRESS OF ENTRY BASED
				ldx D.ENTNUM ; ON THE ENTRY NUMBER

ECALC0			clc
ECALC1			dex ; ADDR=GBUF+((ENTNUM-1)*ENTLEN)
				beq ECALC2
				adc H.ENTLN
				bcc ECALC1
				inc DRBUFPH ; BUMP HI ADDRESS
				bcs ECALC0 ; BRANCH ALWAYS.
*
ECALC2			sta DRBUFPL ; SAVE NEWLY CALCULATED LOW ADDRESS
				rts 
* PAGE
DERROR2			rts
*
DREVISE			lda DATELO ; IF NO CLOCK,
				beq DREVISE1 ; THEN DON'T TOUCH MOD T/D
				ldx #3 ; MOVE LAST MODIFICATION DATE/TIME TO ENTRY BEING UPDATED.
MODTIME			lda DATELO,X
				sta DFIL+D.MODDT,X
				dex 
				bpl MODTIME
*
DREVISE1		lda DFIL+D.ATTR ; MARK ENTRY AS BACKUPABLE
				ora BKBITFLG ; BIT 5 = BACKUP NEEDED BIT
				sta DFIL+D.ATTR
				lda D.DEV ; GET DEVICE NUMBER OF DIRECTORY
				sta DEVNUM ; TO BE REVISED.
				lda D.ENTBLK ; AND ADDRESS OF DIRECTORY BLOCK
				sta BLOKNML ; THAT CONTAINS THE ENTRY.
				lda D.ENTBLK+1
				sta BLOKNMH
				jsr RDGBUF ; READ BLOCK INTO GENERAL PURPOSE BUFFER.
				bcs ERRGBUF
				jsr ENTCALC ; FIX UP POINTER TO ENTRY LOCATION WITHIN GBUF.
				ldy H.ENTLN ; NOW MOVE 'D.' STUFF TO DIRECTORY.
				dey 
MVDENT			lda DFIL+D.STOR,Y
				sta (DRBUFPL),Y
				dey 
				bpl MVDENT
				lda D.HEAD ; IS THE ENTRY BLOCK THE SAME AS THE
				cmp BLOKNML ; ENTRY'S HEADER BLOCK?
				bne SVENTDIR ; NO, SAVE ENTRY BLOCK
				lda D.HEAD+1 ; MAYBE, TEST HIGH ADDRESSES
				cmp BLOKNMH
				beq UPHEAD ; BRANCH IF THEY ARE THE SAME BLOCK.
SVENTDIR		jsr WRTGBUF ; WRITE UPDATED DIRECTORY BLOCK
				bcs DERROR2 ; RETURN ANY ERROR.
				lda D.HEAD ; GET ADDRESS OF HEADER BLOCK
				sta BLOKNML
				lda D.HEAD+1
				sta BLOKNMH
				jsr RDGBUF ; READ IN HEADER BLOCK FOR MODIFICATION
				bcs DERROR2
UPHEAD			ldy #1 ; UPDATE CURRENT NUMBER OF FILES IN THIS DIRECTORY
UPHED1			lda H.FCNT,Y
				sta GBUF+HCENT+4,Y ; (CURRENT ENTRY COUNT)
				dey 
				bpl UPHED1
				lda H.ATTR ; ALSO UPDATE HEADER'S ATTRIBUTES.
				sta GBUF+HATTR+4
				jsr WRTGBUF ; GO WRITE UPDATED HEADER
DERROR1			rts ; IMPLICITLY RETURN ANY ERRORS
*
* PAGE
*
NOTDIR			lda #TYPERR ; NOT TREE OR DIRECTORY- NOT A RECOGNIZED TYPE!
TSTERR			sec
				rts ; DO NOTHING.
*
*
TSTSOS			lda GBUF ; TEST SOS STAMP
				cmp SOSTMPL
				bne TSTERR
				lda GBUF+1
				cmp SOSTMPH
				bne TSTERR
				lda GBUF+4 ; TEST FOR HEADER
				and #$E0
				cmp #HEDTYP*16
				bne TSTERR ; BRANCH IF NOT SOS HEADER (NO ERROR NUMBER)
				clc ; INDICATE NO ERROR

				rts 
*
* CHN FNDFIL,4,1
NE TSTERR
				lda GBUF+4 ; TEST FOR HEADER
				and #$E0
				cmp #HEDTYP*16
				bne TSTERR ; BRANCH IF NOT SOS HEADER (NO ERROR NUMBER)
				clc ; INDICATE NO ERROR
				rts 
*
* CHN FNDFIL,4,1
O ERROR
				rts 
*
* CHN FNDFIL,4,1
* ENTRY TOO.
				ldy #D.MODDT+3
RIPTIME			lda DATELO,X
				sta (DRBUFPL),Y
				dey 
				dex 
				bpl RIPTIME ;MOVE ALL FOR BYTES...
RUPDATE			jsr WRTGBUF ;WRITE UPDATED ENTRY BACK TO DISK. (ASSUMES BLOKNM UNDISTURBEDD)
				bcs DERROR1 ;GIVE UP ON ANY ERROR.
				ldy #D.DHDR ;NOW COMPARE CURRENT BLOCK NUMBER TO THIS
				lda (DRBUFPL),Y ; ENTRY'S HEADER BLOCK
				iny 
				cmp BLOKNML ;ARE LOW ADDRESSES THE SAME?
				sta BLOKNML ;(SAVE IT IN CASE IT'S NOT)
				bne RIPPLE2 ;BRANCH IF ENTRY DOES NOT RESIDE IN SAME BLOCK AS HEADER.
				lda (DRBUFPL),Y ;CHECK HIGH ADDRESS JUST TO BE SURE.
				cmp BLOKNMH
				beq RIPPLE ;THEY ARE THE SAME, CONTINUE RIPPLE TO ROOT DIRECTORY.
RIPPLE2			lda (DRBUFPL),Y ;THEY AREN'T THE SAME, READ IN THIS DIRECTORY'S HEADER.
				sta BLOKNMH
				jsr RDGBUF
				bcc RIPPLE ;CONTINUE IF READ WAS GOOD.
DERROR1			.eq *
				rts 
* PAGE
*
NOTDIR			lda #TYPERR ;NOT TREE OR DIRECTORY- NOT A RECOGNIZED TYPE!
TSTERR			sec
				rts ;DO NOTHING.
*
*
TSTSOS			lda GBUF ;TEST SOS STAMP
				cmp SOSTMPL
				bne TSTERR
				lda GBUF+1
				cmp SOSTMPH
				bne TSTERR
				lda GBUF+4 ;TEST FOR HEADER
				and #$E0
				cmp #HEDTYP*16
				bne TSTERR ;BRANCH IF NOT SOS HEADER (NO ERROR NUMBER)
DRVISDNE		clc ;INDICATE NO ERROR./
				rts 
*
* CHN FNDFIL,4,1


*************************************************************************
* END OF APPLE /// SOS 1.3 SOURCE CODE FILE: CREATE
*************************************************************************



*--------------------------------------
MAN
SAVE /A3OSX.BUILD/SOS.ORIG/SOS.S.CREATE
LOAD /A3OSX.BUILD/SOS.ORIG/SOS.S
ASM
