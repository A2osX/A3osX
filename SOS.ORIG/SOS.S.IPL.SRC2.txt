NEW
  AUTO 3,1
*--------------------------------------

*************************************************************************
* APPLE /// SOS 1.3 SOURCE CODE FILE: IPL.SRC2
*************************************************************************
* ASSEMBLER: APPLE ][ 6502 ASSEMBLER from APPLE COMPUTER TOOLKIT

*				.TI "SYSTEM INTERNAL RESOURCES"
* REP 60
*
* SYSTEM INTERNAL RESOURCE NUMBERS
*
*
* SIR RESOURCE
*
* 0 SOUND PORT / I/O NMI
* 1 ACIA
* 2 E.CA2 -- KEYBOARD
* 3 E.CA1 -- CLOCK
* 4 E.SR
* 5 E.CB2 -- VBL +
* 6 E.CB1 -- VBL -
* 7 E.T2
* 8 E.T1
* 9 D.CA2 -- CSP INPUT FLAG / INPUT SWITCH 1
* A D.CA1 -- ANY SLOT (RESERVED FOR SOS)
* B D.SR -- CSP DATA REGISTER
* C D.CB2 -- CSP DATA I/O / ENSIO
* D D.CB1 -- CSP CLOCK / ENSEL / A/D SELECT / INPUT SW3
* E D.T2
* F D.T1
* 10 DISK STEPPER / GRAPHICS SCROLL / CHARACTER DOWNLOAD
* 11 SLOT 1
* 12 SLOT 2
* 13 SLOT 3
* 14 SLOT 4
* 15 (UNASSIGNED)
* 16 (UNASSIGNED)
* 17 (UNASSIGNED)
*
* REP 60
*				.TI "RESOURCE ALLOCATION & DEALLOCATION"
* REP 60
*
* RESOURCE ALLOCATION AND DEALLOCATION
*
* SIRS ARE ALLOCATED AND DEALLOCATED BY THE SUBROUTINES
* 'ALLOCSIR' AND 'DEALCSIR'. THE RESOURCE PARAMETERS ARE
* PASSED IN A TABLE THAT CONTAINS ONE FIVE-BYTE ENTRY FOR
* EACH SIR THAT IS TO BE ALLOCATED OR DEALLOCATED. THE
* TABLE ENTRY FORMAT IS SHOWN BELOW:
*
* 0 1 2 3 4
* +-------+-------+-------+-------+-------+
* | SIR # | ID | ADR.L | ADR.H | ADR.B |
* +-------+-------+-------+-------+-------+
*
* SIR # -- SYSTEM INTERNAL RESOURCE NUMBER
* ID -- IDENTIFICATION BYTE
* SUPPLIED BY ALLOCSIR, CHECKED BY DEALCSIR
* ADR -- INTERRUPT ADDRESS (LOW, HIGH, BANK)
* ZERO IF NO INTERRUPT HANDLER
*
*
* ALLOCSIR -- ALLOCATE SYSTEM INTERNAL RESOURCES
*
* PARAMETERS:
* A: NUMBER OF BYTES IN TABLE
* X: TABLE ADDRESS (LOW BYTE)
* Y: TABLE ADDRESS (HIGH BYTE)
*
* NORMAL EXIT -- SIRS ALLOCATED
* CARRY: CLEAR
* A, X, Y: UNDEFINED
*
* ERROR EXIT -- SIRS NOT ALLOCATED
* CARRY: SET
* X: SIR NUMBER

* A, Y: UNDEFINED
*
*
* DEALCSIR -- DEALLOCATE SYSTEM INTERNAL RESOURCES
*
* PARAMETERS:
* A: NUMBER OF BYTES IN TABLE
* X: TABLE ADDRESS (LOW BYTE)
* Y: TABLE ADDRESS (HIGH BYTE)
*
* NORMAL EXIT -- SIRS DEALLOCATED
* CARRY: CLEAR
* A, X, Y: UNDEFINED
*
* ERROR EXIT -- SIRS NOT DEALLOCATED
* CARRY: SET
* X: SIR NUMBER
* A, Y: UNDEFINED
*
* REP 60
* PAGE
*
IDBYTE			.hs 81
*
ALLOCSIR		.eq *
				clc 
				php 
				sei 
				sta SIRARGSIZ ;SAVE TABLE SIZE
				lda E.REG
				sta SIRTEMP
				ora #BITON2 ;FORCE PRIMARY STACK
				and #BITOFF3 ; AND WRITE ENABLE
				sta E.REG
				lda SIRTEMP
				pha 
				lda Z.REG
				pha 
				lda #$00
				sta Z.REG ;SET ZERO PAGE := $00
				stx SIRARGS
				sty SIRARGS+1 ;SET POINTER TO TABLE
*
				ldy #$00
ASIR010			lda (SIRARGS),Y ;GET SIR NUMBER
				cmp #SIRTBLSIZ
				tax 
				bcs ASIR020
				lda SIRTABLE,X ;CHECK ALLOCATION
				bmi ASIR020
				lda IDBYTE
				sta SIRTABLE,X ;ALLOCATE SIR
				iny 
				sta (SIRARGS),Y ;RETURN ID BYTE
				iny 
				lda (SIRARGS),Y
				sta SIRADR.L,X ;SAVE INTERRUPT ADDRESS
				iny 
				lda (SIRARGS),Y
				sta SIRADR.H,X
				iny 
				lda (SIRARGS),Y
				sta SIRADR.B,X
				iny 
				cpy SIRARGSIZ
				bcc ASIR010
*
				clc 
				inc IDBYTE ;BUMP ID BYTE
				bmi SIREXIT
				lda #$81
				sta IDBYTE
				bmi SIREXIT
*
ASIR020			stx SIRTEMP ;SAVE BAD SIR NUMBER
ASIR030			sec
				tya 
				sbc #5
				tay 
				bcc ASIR040
				lda (SIRARGS),Y ;GET SIR NUMBER

				tax 
				lda #FALSE
				sta SIRTABLE,X ;RELEASE ALLOCATED SIRS
				beq ASIR030
*
ASIR040			ldx SIRTEMP ;RETURN BAD SIR
				sec 
*
*
*
SIREXIT			pla
				sta Z.REG ;RESTORE Z REGISTER
				pla 
				sta E.REG ;RESTORE E REGISTER
				bcc SIREXIT1
				pla 
				ora #BITON0
				pha 
SIREXIT1		plp
				rts 
*
*
*
DEALCSIR		.eq *
				clc 
				php 
				sei 
				sta SIRARGSIZ ;SAVE TABLE SIZE
				lda E.REG
				sta SIRTEMP
				ora #BITON2 ;FORCE PRIMARY STACK
				and #BITOFF3 ; AND WRITE ENABLE
				sta E.REG
				lda SIRTEMP
				pha 
				lda Z.REG
				pha 
				lda #$00
				sta Z.REG ;SET ZERO PAGE := $00
				stx SIRARGS
				sty SIRARGS+1 ;SET POINTER TO TABLE
*
				ldy #$00
DSIR010			lda (SIRARGS),Y ;GET SIR NUMBER
				tax 
				cpx #SIRTBLSIZ
				bcs DSIR030
				iny 
				lda SIRTABLE,X
				bpl DSIR030 ;VERIFY ALLOCATION
				cmp (SIRARGS),Y
				bne DSIR030
				iny 
				iny 
				iny 
				iny 
				cpy SIRARGSIZ
				bcc DSIR010
*
				ldy SIRARGSIZ
DSIR020			sec
				tya 
				sbc #5
				tay 
				bcc SIREXIT
				lda (SIRARGS),Y ;GET SIR NUMBER
				tax 
				lda #FALSE
				sta SIRTABLE,X
				beq DSIR020
*
DSIR030			sec
				bcs SIREXIT
*				.TI "SELECT I/O EXPANSION ROM"
* REP 60
*
* SUBROUTINE 'SELC800' IS CALLED TO SELECT THE C800 I/O EX-
* PANSION ADDRESS SPACE FOR A PERIPHERAL SLOT. ON ENTRY,
* THE SLOT NUMBER IS PASSED IN THE ACCUMULATOR. IF NO
* ERROR OCCURS, CARRY IS CLEARED; OTHERWISE, CARRY IS SET
* AND THE PREVIOUS SLOT REMAINS SELECTED.

*
* PARAMETERS:
* A: SLOT NUMBER
*
* NORMAL EXIT -- NEW SLOT SELECTED
* CARRY: CLEAR
* A: UNDEFINED
* X, Y: UNCHANGED
*
* ERROR EXIT -- SLOT NOT CHANGED
* CARRY: SET
* A, X, Y: UNCHANGED
*
* WARNING !!!
* 'SELC800' USES SELF-MODIFYING CODE!
*
* REP 60
*
SELC800			.eq *
				cmp #$05 ;CHECK SLOT NUMBER
				bcs SC8EXIT ; INVALID
				php 
				sei 
				sta EXPNSLOT
				ora #$C0 ;MAKE SLOT INTO $CN00
				sta CNADDR+2 ; AND MODIFY BIT ADDRESS
				bit $C020
				bit $CFFF ;DESELECT PREVIOUS SLOT
CNADDR			bit $C0FF ; AND SELECT CURRENT SLOT
				plp 
SC8EXIT			rts
*				.TI "NMI DISABLE / ENABLE"
* REP 60
*
* THE SUBROUTINES NMIDSBL AND NMIENBL ARE CALLED TO
* DISABLE AND ENABLE NMI, RESPECTIVELY. THERE ARE NO
* INPUT PARAMETERS. ON EXIT, THE REGISTERS ARE UN-
* DEFINED. NMIDSBL CLEARS THE CARRY FLAG IF NMI WAS
* SUCCESSFULLY DISABLED; OTHERWISE, CARRY IS SET.
*
* REP 60
*
NMIDSBL			.eq *
				ldx E.REG
				bit NMIFLAG
				bpl NDS020
				txa 
				ora #BITON7
				sta E.REG ;SET 1MHZ
				lda #$00
				sta NMICNTR
				sta NMICNTR+1
NDS010			bit NMIFLAG ;NMI PENDING?
				bpl NDS020 ; NO
				inc NMICNTR ;BUMP NMI COUNTER
				bne NDS010 ; AND RECHECK NMI FLAG
				inc NMICNTR+1
				bne NDS010
				lda #NMIHANG ;CAN'T LOCK NMI
				jsr SYSDEATH
NDS020			txa ;GET E.REG
				and #BITOFF4 ;DISABLE NMI
				sta E.REG
				rts 
*
*
*
NMIENBL			.eq *
				lda E.REG
				ora #BITON4 ;ENABLE NMI
				sta E.REG
				rts 
*				.TI "KEYBOARD NMI HANDLER"
* REP 60
*
* BY DEFAULT, KEYBOARD NMI IS IGNORED. THE USER MAY
* PROCESS NMI BY CHANGING THE ADDRESS IN SYSTEM GLOBAL.
*
* REP 60
*
NMIDBUG			.eq *

				tsx ;SAVE THE STACK POINTER
				stx NMISPSV
				lda #$03 ;SELECT MONITOR'S ZERO PAGE
				sta Z.REG
				lda E.REG
				ora #$03 ;SELECT MONITOR ROM
				sta E.REG
				jsr $F901 ;CALL THE MONITOR
*
NMICONT			.eq *
				lda E.REG
				ora #BITON2 ;FORCE PRIMARY STACK
				sta E.REG
				ldx NMISPSV
				txs ;RESTORE STACK POINTER
				rts 
*				.TI "EVENT QUEUE MANAGER"
* REP 60
*
* THE EVENT QUEUE IS USED TO HOLD THE PARAMETERS OF EVENTS
* THAT HAVE BEEN DETECTED BUT NOT YET RECOGNIZED. EVENT
* QUEUE ENTRIES ARE ORGANIZED INTO TWO LINKED LISTS; A FREE
* LIST AND AN ACTIVE LIST. EACH ENTRY IS SIX BYTES LONG,
* WITH THE FIRST BYTE (BYTE 0) USED AS A LINK. THE LINK
* BYTE CONTAINS THE TABLE INDEX OF THE NEXT ENTRY IN THE
* LIST. BECAUSE OF THE INDEXING METHOD, THE EVENT QUEUE
* MUST NOT EXCEED 256 BYTES.
*
* ENTRY ZERO IS A SPECIAL ENTRY. BYTE 0 IS THE INDEX OF
* THE FIRST ACTIVE ENTRY; BYTE 1 CONTAINS A ZERO, ALLOWING
* ENTRY 0 TO BE USED AS THE ACTIVE EVENT LIST TERMINATER;
* BYTE 2 CONTAINS THE INDEX OF THE FIRST FREE ENTRY; AND
* BYTES 4 THROUGH 6 ARE UNUSED.
*
* THE FREE LIST IS LINKED LIFO. THE ONLY VALID BYTE IN A
* FREE ENTRY IS THE LINK BYTE; THE REMAINING BYTES ARE
* UNDEFINED. THE FREE LIST IS TERMINATED BY A LINK BYTE
* CONTAINING A ZERO.
*
* THE ACTIVE LIST IS LINKED IN DECREASING PRIORITY ORDER
* WITH ENTRIES OF EQUAL PRIORITY LINKED FIFO. BYTES 1
* THROUGH 5 CONTAIN THE EVENT PRIORITY, EVENT ID, LOW BYTE
* OF THE EVENT ADDRESS, HIGH BYTE OF THE EVENT ADDRESS, AND
* THE ADDRESS BANK. THE ACTIVE LIST IS TERMINATED BY AN
* ENTRY WITH AN EVENT PRIORITY OF ZERO.
*
* REP 60
* PAGE
* REP 60
*
* SUBROUTINE 'QUEEVENT' IS USED TO ENTER AN EVENT INTO THE
* EVENT QUEUE. ACTIVE EVENTS ARE LINKED IN DECREASING
* PRIORITY ORDER WITH EVENTS OF EQUAL PRIORITY LINKED FIFO.
* EVENTS ARE REMOVED FROM THE QUEUE AS THEY ARE RECOGNIZED
* BY THE DISPATCHER.
*
* PARAMETERS:
* X: EVENT PARAMETER ADDRESS (LOW BYTE)
* Y: EVENT PARAMETER ADDRESS (HIGH BYTE)
*
* EVENT 0 1 2 3 4
* PARMS: +-------+-------+-------+-------+-------+
* | PRI | ID | ADR.L | ADR.H | ADR.B |
* +-------+-------+-------+-------+-------+
* PRI: EVENT PRIORITY
* ID: EVENT ID BYTE
* ADR: EVENT ADDRESS (LOW, HIGH, BANK)
*
* EXIT CONDITIONS:
* CARRY: CLEAR
* A, X, Y: UNDEFINED
*
* REP 60
*
QUEEVENT		.eq *
				clc 
				php 
				sei 
				lda E.REG
				sta QEVTEMP
				ora #BITON2 ;FORCE PRIMARY STACK

				and #BITOFF3 ; AND WRITE ENABLE
				sta E.REG
				lda QEVTEMP
				pha 
				lda Z.REG
				pha 
				lda #0
				sta Z.REG ;SET ZERO PAGE := 0
*
				stx QEVARGS
				sty QEVARGS+1 ;SET ARGUMENT POINTER
				ldy #0
				lda (QEVARGS),Y ;GET PRIORITY
				beq Q.EXIT ; IGNORE IF ZERO
*
				ldx EVQ.FREE
				beq Q.FULL
				stx QEV.THIS ;GET FIRST FREE ENTRY
				lda EVQ.LINK,X ; AND DELINK IT
				sta EVQ.FREE
*
				ldy #EVQ.SIZ-2
QEV010			lda (QEVARGS),Y ;COPY ARGUMENTS
				sta EVQ.BANK,X ; INTO NEW ENTRY
				dex 
				dey 
				bpl QEV010
*
				ldx QEV.THIS
				ldy #0
QEV020			sty QEV.LAST
				lda EVQ.LINK,Y
				tay 
				lda EVQ.PRI,Y ;SCAN EVENT QUEUE
				cmp EVQ.PRI,X ; FOR PROPER POSITION
				bcs QEV020
*
				tya 
				sta EVQ.LINK,X ;RELINK EVENT INTO QUEUE
				txa 
				ldy QEV.LAST
				sta EVQ.LINK,Y
*
Q.EXIT			pla
				sta Z.REG ;RESTORE Z REGISTER
				pla 
				sta E.REG ;RESTORE E REGISTER
				plp 
				rts 
*
Q.FULL			lda #EVQOVFL ;EVENT QUEUE OVERFLOW
				jsr SYSDEATH
LST ON

ZZEND			.eq *
ZZLEN			.eq ZZEND-ZZORG
IFNE ZZLEN-LENIPL
FAIL 2,"SOSORG FILE IS INCORRECT FOR IPL"
				.fin

*************************************************************************
* END OF APPLE /// SOS 1.3 SOURCE CODE FILE: IPL.SRC2
*************************************************************************





*--------------------------------------
MAN
SAVE /A3OSX.BUILD/SOS.ORIG/SOS.S.IPL.SRC2
LOAD /A3OSX.BUILD/SOS.ORIG/SOS.S
ASM
