NEW
  AUTO 3,1
*--------------------------------------

*************************************************************************
* APPLE /// SOS 1.3 SOURCE CODE FILE: INIT.SRC
*************************************************************************
* ASSEMBLER: APPLE ][ 6502 ASSEMBLER from APPLE COMPUTER TOOLKIT

*				.TI "SOS 1.1 INITIALIZATION"
* REL
* INCLUDE SOSORG,6,1,254
				.or ORGINIT
ZZORG			.eq *
* FIXME - MSB OFF
* REP 100
* COPYRIGHT (C) APPLE COMPUTER INC. 1981
* ALL RIGHTS RESERVED
* REP 100
*
* SOS INIT MODULE (VERSION = 1.1O )
* (DATE = 8/04/81)
*
* REP 100
*
* ENTRY INT.INIT
* ENTRY EVQ.INIT
* ENTRY CLK.INIT
* ENTRY MMGR.INIT
* ENTRY BMGR.INIT
* ENTRY DMGR.INIT
* ENTRY CFMGR.INIT
* ENTRY BFM.INIT
*
* EXTERNAL SUBROUTINES & DATA
*
* EXTRN SXPAGE
* EXTRN SYSDEATH
*
* INTERRUPT SYSTEM INITIALIZATION
*
* EXTRN COLDSTRT
* EXTRN IRQ.RCVR
* EXTRN NMI.RCVR
* EXTRN NMIFLAG
* EXTRN SIRTABLE
* EXTRN SIRTBLSIZ
* EXTRN ZPGSTACK
* EXTRN ZPGSTART
*
* EVENT QUEUE INITIALIZATION
*
* EXTRN EV.QUEUE
* EXTRN EVQ.LEN
* EXTRN EVQ.CNT
* EXTRN EVQ.SIZ
* EXTRN EVQ.FREE
* EXTRN EVQ.LINK
*
* CLOCK INITIALIZATION
*
* EXTRN PCLOCK
*
* CHARACTER FILE MANAGER INITIALIZATION
*
* EXTRN CFCB.MAX
* EXTRN CFCB.DEV
*
* DEVICE MANAGER INITIALIZATION
*
* EXTRN DMGR
* EXTRN MAX.DNUM
*
* BUFFER MANAGER INITIALIZATION
*
* EXTRN BUF.CNT
* EXTRN PGCT.T
* EXTRN XBYTE.T
* EXTRN BUFREF
*

* MEMORY MANAGER INITIALIZATION
*
* EXTRN ST.CNT
* EXTRN ST.ENTRY
* EXTRN ST.FREE
* EXTRN ST.FLINK
* EXTRN VRT.LIM
* EXTRN MEMSIZE
* EXTRN MEM2SML
*
* BLOCK FILE MANAGER INITIALIZATION
*
* EXTRN FCBZPP
* EXTRN PATHBUF
* EXTRN VCB
* EXTRN WORKSPC
* EXTRN PFIXPTR
* EXTRN FCBADDRH
* EXTRN BMAPAGE
* EXTRN BMBPAGE
* EXTRN BMAMADR
* EXTRN BMBMADR
* EXTRN BFMFCB1
* EXTRN BFMFCB2
*
* CONSTANT DECLARATIONS
*
TRUE			.eq $80
FALSE			.eq $00
BITON6			.eq $40
BITON7			.eq $80
*
* SYSTEM CONTROL REGISTERS
*
E.REG			.eq $FFDF ;ENVIRONMENT REGISTER
Z.REG			.eq $FFD0 ;ZERO PAGE REGISTER
*				.TI "INTERRUPT SYSTEM INITIALIZATION"
*
* 6522 REGISTERS
*
D.DDRB			.eq $FFD2
D.DDRA			.eq $FFD3
D.ACR			.eq $FFDB
D.PCR			.eq $FFDC
D.IFR			.eq $FFDD
D.IER			.eq $FFDE
E.IORB			.eq $FFE0
E.DDRB			.eq $FFE2
E.DDRA			.eq $FFE3
E.ACR			.eq $FFEB
E.PCR			.eq $FFEC
E.IFR			.eq $FFED
E.IER			.eq $FFEE
ACIASTAT		.eq $C0F1
*
*
* REP 60
*
* THIS SUBROUTINE INITIALIZES THE INTERRUPT SYSTEM.
* ALL HARDWARE INTERRUPTS ARE MASKED AND THE
* INTERRUPT ALLOCATION TABLE IS CLEARED.
*
* REP 60
*
*
INT.INIT		.eq *
				sei ;DISABLE INTERRUPTS
				lda #ZPGSTART ;SET UP MIH
				sta ZPGSTACK ; ZERO PAGE STACK POINTER
*
				lda E.REG ;SELECT $C000 I/O SPACE
				pha ; AND SET 1 MHZ
				ora #BITON7+BITON6
				sta E.REG
*
				sta ACIASTAT ;RESET ACIA
*
				lda #$FF ;SET UP 6522 D
				sta D.DDRB
				sta D.DDRA
				lda #$00

				sta D.ACR
				lda #$76
				sta D.PCR
				lda #$7F
				sta D.IFR
				sta D.IER
				lda #$82
				sta D.IER
*
				lda #$3F ;SET UP 6522 E
				sta E.DDRB
				lda #$0F
				sta E.DDRA
				lda #$00
				sta E.ACR
				lda #$63
				sta E.PCR
				lda #$7F
				sta E.IFR
				sta E.IER
*
				lda #$FF
				sta E.IORB ;SOUND PORT
				bit $C0D8 ;DISABLE GRAPHICS SCROLL
				bit $C0DA ;DISABLE CHARACTER DOWNLOAD
				bit $C0DC ;DISABLE ENSEL
				bit $C0DE ;SET ENSIO FOR INPUT
*
				pla ;RESTORE E REGISTER
				sta E.REG
*
				lda #FALSE
				sta NMIFLAG ;CLEAR NMI WAIT FLAG
				ldy #SIRTBLSIZ-1
INTI010			sta SIRTABLE,Y ; ALLOCATION TABLE
				dey 
				bpl INTI010
				lda #TRUE
				sta SIRTABLE+$0A ;LOCK DOWN ANY SLOT SIR
*
				ldx #$05
INTI020			lda RAMVECT,X ;SET UP VECTORS
				sta $FFFA,X ; AT $FFFA - $FFFF
				lda RAMJMPS,X ;SET UP JMP INSTRUCTIONS
				sta $FFCA,X ; AT $FFCA - $FFCF
				dex 
				bpl INTI020
				rts 
*
RAMVECT			.da NMI.RCVR
				.da COLDSTRT
				.da IRQ.RCVR
RAMJMPS			jmp NMI.RCVR
				jmp IRQ.RCVR
*				.TI "EVENT QUEUE INITIALIZATION"
* REP 60
*
* THIS SUBROUTINE INITIALIZES THE EVENT QUEUE. ALL ENTRIES
* ARE CLEARED AND LINKED INTO THE FREE LIST. THE ACTIVE
* LIST IS EMPTY.
*
* REP 60
*
*
EVQ.INIT		.eq *
*
* CLEAR ALL ENTRIES
*
				ldy #EVQ.LEN
				lda #0
EVQI010			sta EV.QUEUE-1,Y
				dey 
				bne EVQI010
*
* SET UP FREE LIST
*
				ldx #EVQ.CNT-2
				lda #EVQ.SIZ
				sta EVQ.FREE
EVQI020			tay
				clc 

				adc #EVQ.SIZ
				sta EVQ.LINK,Y
				dex 
				bne EVQI020
				rts 
*				.TI "PSEUDO CLOCK INITIALIZATION"
* REP 60
*
* THIS SUBROUTINE INITIALIZES THE PSEUDO CLOCK. IF THE
* RAM BEHIND THE "D" 6522 HAS THE PROPER CHECKSUM, IT
* IS USED TO INITIALIZE THE PSEUDO CLOCK. OTHERWISE,
* THE PSEUDO CLOCK IS SET TO ZERO.
*
* (ADDED 23 OCT 81)
* BOTH THE CLOCK AND PSEUDO CLOCK ARE
* ARE NOW INITIALIZED
*
* REP 60
*
PCLK			.eq $F0
CKSUM			.eq $F2
CLKICR			.eq $11 ; CLOCK INTERRUPT CONTROL REG
CLKSTBY			.eq $16 ; CLOCK STANDBY INTERRUPT
CLOCK			.eq $C070
*
CLK.INIT		.eq *
				lda #$D0
				sta PCLK ;POINT (PCLK) TO 8F:FFD0
				lda #$FF
				sta PCLK+1
				lda #$8F
				sta SXPAGE+PCLK+1
				lda #$A5
				sta CKSUM ;INITIALIZE CHECKSUM
*
				ldy #$00
CLK010			lda (PCLK),Y ;COPY SAVED CLOCK DATA
				sta PCLOCK,Y ; TO PSEUDO CLOCK
				eor CKSUM
				sta CKSUM ;UPDATE CHECKSUM
				iny 
				cpy #$0A
				bcc CLK010
*
				cmp (PCLK),Y ;TEST CHECKSUM
				beq CLK030
*
				lda #$00
CLK020			dey
				sta PCLOCK,Y ;ZERO PSEUDO CLOCK
				bne CLK020
CLK030			lda E.REG
				pha 
				ora #$80 ; SET 1 MHZ
				sta E.REG
				lda #$00
				ldy Z.REG
				ldx #CLKICR
				stx Z.REG
				sta CLOCK ; DISABLE CLOCK INTERRUPTS
				ldx #CLKSTBY
				stx Z.REG
				sta CLOCK ; DISABLE STANDBY INTERRUPT
				sty Z.REG
				pla 
				sta E.REG
				rts 
*				.TI "CHARACTER FILE MANAGER INITIALIZATION"
* REP 60
*
* CHAR FILE MANAGER INITIALIZATION ROUTINE
*
* CFMGR.INIT INITIALIZES ALL ENTRIES IN THE CFCB TABLE TO
* THE "FREE" STATE.
*
* REP 60
*
CFMGR.INIT		.eq *
				lda #$80
				ldx #CFCB.MAX-1
CFINIT010		sta CFCB.DEV,X

				dex 
				bpl CFINIT010
				rts 
*				.TI "DEVICE MANAGER INITIALIZATION"
* REP 60
*
* DEVICE MANAGER INITIALIZATION ROUTINE
*
* INITIALIZES THE SYSTEM DEVICE TABLE (SDT) BY WALKING THE
* DEVICE INFORMATION BLOCK (DIB) LINKS. CALLED BY SYSLDR.
*
* REP 60
*
D.TPARMX		.eq $C0
REQCODE			.eq D.TPARMX+$00
DNUM			.eq D.TPARMX+$01
DNUM.TEMP		.bs 1
*
*
DMGR.INIT		.eq *
				ldx MAX.DNUM
				inc MAX.DNUM ; MAX.DNUM:=MAX DEV NUMBER IN SYSTEM+1
				stx DNUM.TEMP
DMI110			lda #8 ; INITIALIZE ALL DEVICES IN SYSTEM (D.INIT)
				sta REQCODE
				lda DNUM.TEMP
				sta DNUM
				jsr DMGR
				dec DNUM.TEMP
				bne DMI110
				rts ; NORMAL EXIT
*				.TI "BUFFER MANAGER INITIALIZATION"
* REP 60
*
* BMGR.INIT
*
* THIS ROUTINE INITIALIZES THE BUFFER TABLE'S ENTRIES TO "FREE".
* CALLED DURING SYSTEM BOOT.
*
* REP 60
*
BMGR.INIT		.eq *
				lda #$FF ; USED WHEN FINDING LOWEST BUFFER IN TBL (BUFCOMPACT)
				sta XBYTE.T
*
				ldx #BUF.CNT-1
				lda #$80
BUFI010			sta PGCT.T,X ;SET ALL ENTRIES "FREE"
				dex 
				bne BUFI010
*
				stx BUFREF ;ZERO COUNT BYTE IN BUFFER REFERENCE TABLE
*
				clc 
				rts 
*				.TI "MEMORY MANAGER INITIALIZATION"
* REP 60
*
* MMGR.INIT
*
* THIS ROUTINE INITIALIZES THE MEMORY MANAGER'S SEGMENT TABLE
* TO FREE ENTRIES, AND DETERMINES THE MEMORY SIZE OF THE
* MACHINE (96K,128K,160K,192K,224K,256K,..,512K IN 32K STEPS).
*
* REP 60
*
MMGR.INIT		.eq *
*
* INIT SEGMENT TABLE
*
				lda #0
				sta ST.ENTRY
				lda #$81
				sta ST.FREE
*
				ldy #ST.CNT-1
				lda #$80 ; SET LAST LINK TO NULL
				sta ST.FLINK,Y
MEMI010			tya
				ora #$80
				dey 

				sta ST.FLINK,Y
				bne MEMI010
*
* COMPUTE VIRTUAL LIMIT FROM MEMORY SIZE
* VRT.LIM := NUMBER OF PAGES IN BANK SWITCHED MEMORY - 1
* := (MEMSIZ-2)*64 - 1
* := (MEMSIZ-4)*64 + 127
*
				sec 
				lda MEMSIZE
				sbc #4
				bcc MEMI.ERR
				lsr A
				lsr A
				sta VRT.LIM+1
				lda #$FE
				ror A
				sta VRT.LIM
				clc 
				rts ; NORMAL EXIT
*
MEMI.ERR		lda #MEM2SML ; FATAL ERR - MEM < 64K
				jsr SYSDEATH
* PAGE
* REP 60
*
* BLOCK FILE MANAGER INITIALIZATION
*
* REP 60
*
SISTER			.eq $1400 ;BFM XPAGE
BFM.INIT		.eq *
				lda #BFMFCB1 ; ADDRESS OF PAGE 1 OF FCB
				sta >FCBZPP+1
				lda #BFMFCB2 ; AND PAGE 2
				sta >FCBZPP+3
				lda #0
				sta >FCBZPP ; FCB PAGE ALIGNED
				sta >FCBZPP+2
				sta SISTER+FCBZPP+1 ; PREPARE PART OF EXTEND BYTE
				sta SISTER+FCBZPP+3
				tay ; MAKE ZERO INTO INDEX
CLRBUFFS		.eq *
				sta PATHBUF,Y ; PATHNAME BUFFER PAGE
				sta VCB,Y ; VOLUME CONTROL BLOCK PAGE
				sta (>FCBZPP),Y ; BOTH FILE CONTROL BLOCK PAGES
				sta (>FCBZPP+2),Y
				iny 
				bne CLRBUFFS
				ldx #$3F ; SIZE OF MY ZERO PAGE STUFF
CLRZWRK			sta 0,X ; ZERO PAGE ZEROED
				sta WORKSPC,X
				dex 
				bpl CLRZWRK
				lda /PATHBUF
				sta PFIXPTR+1
				lda #BFMFCB1
				sta FCBADDRH
				lda #BMAPAGE ; BIT MAP A PAGE NUMBER
				sta BMAMADR
				lda #BMBPAGE ; BIT MAP B PAGE NUMBER
				sta BMBMADR
				clc 
				rts 
*
LST ON
ZZEND			.eq *
ZZLEN			.eq ZZEND-ZZORG
IFNE ZZLEN-LENINIT
FAIL 2,"SOSORG FILE IS INCORRECT FOR INIT"
				.fin

*************************************************************************
* END OF APPLE /// SOS 1.3 SOURCE CODE FILE: INIT.SRC
*************************************************************************




*--------------------------------------
MAN
SAVE /A3OSX.BUILD/SOS.ORIG/SOS.S.INIT
LOAD /A3OSX.BUILD/SOS.ORIG/SOS.S
ASM
