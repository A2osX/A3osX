NEW
AUTO 3,1
*--------------------------------------

*************************************************************************
* APPLE /// SOS 1.3 SOURCE CODE FILE: SWAPOUT.IN
*************************************************************************
* ASSEMBLER: APPLE ][ 6502 ASSEMBLER from APPLE COMPUTER TOOLKIT

SWAPOUT			.eq *
*
* SWAP OUT A VOLUME LOGGED ON A DEVICE
* INPUT ARGUMENT: DEVICE NUMBER "A"
* (STORED AS "DEVNUM")
* OUTPUT ARGUMENT: NONE
* CONDITION CODE: CARRY SET USER DID NOT COMPLY WITH REQUEST
*
* SAVE VCBPTR, FCBPTR, DEVNUM ON STACK
* 1) FIND UNSWAPPED VOLUME IN VCB
* 2) IF DIRTY BIT MAP FOR THIS VOLUME THEN DO
* IF NOT ONLINE, REQUEST USER TO INSERT
* IF REQUEST DENIED, UNCONDITIONALLY CLOSE ALL FILES ON THIS VOLUME AND RTS
* IF ONLINE, UPDATE AND RELEASE BIT MAP
* DOEND
* 3) SWAP IT (MARK VCBSWAP FIELD $80, MARK ALL FILES ON THIS VOLUME WITH SWAP MARK $8X WHERE X=VCB ENTRY)
* "VCB ENTRY" DEFINED AS: HIGH ORDER NIBBLE OF LOW ORDER BYTE OF ENTRIES VCB ADDRESS
* RESTORE VCBPTR, FCBPTR
* RTS
*
				tax ; SAVE DEVICE NUMBER
				jsr SAVECBS
				stx DEVNUM ; PERMANENTLY
SWAPOUTX		jsr DEVVCB ; FIND MATCHING UNSWAPPED ACTIVE VCB ENTRY (BY DEVNUM)
				bcs SORTS ; NO FIND--RETURN WITHOUT ERROR
				ldy #VCBSTAT
				lda (VCBPTR),Y ; GET STATUS OF FILES ON THIS VOLUME
				bpl UNLOG ; IF NO OPEN FILES, JUST THROW VOLUME AWAY
				lda DEVNUM ; DIRTY BM EXIST ON THIS VOLUME?
				ldx #0
				cmp BMADEV,X ; IN BIT MAP "A"?
				beq FDIRBM ; BRANCH IF YES
				ldx #6 ; BIT MAP HEADER TABLE SIZE
				cmp BMADEV,X ; IN BIT MAP "B"?
				beq FDIRBM ; BRANCH IF YES
				jmp MARKSWAP ; NO NEED TO WRITE BIT MAP
FDIRBM			lda BMASTAT,X ; IS BIT MAP DIRTY?
				bpl MARKSWAP ; BRANCH IF NOT
GETVOL			jsr VERFYVOL ; IS THE CORRECT VOLUME ON LINE NOW?
				bcc VONLINE ; BRANCH IF YES
				jsr USRREQ ; OTHERWISE, REQUEST USER INSERTION
				bcc GETVOL ; AND VERIFY IT AGAIN
				jsr CLOSEU ; USER SAID "NO": UNCONDITIONALLY CLOSE VOLUME
				jsr RESTCBS
				sec 
				rts ; ERROR RETURN TO CALLER
VONLINE			ldx DEVNUM ; UPDATE THE
				jsr UPBMAP ; DIRTY BIT MAP
MARKSWAP		lda VCBPTR ; CALCULATE
				lsr
				lsr
				lsr
				lsr
				sec ; AS SWAPPED OUT
				ora #$80
				pha ; SAVE SWAP BYTE
				jsr FCBSCAN
				pla ; MARK VCBSWAP
				ldy #VCBSWAP ; BYTE
				sta (VCBPTR),Y
SORTS			jsr RESTCBS ; RESTORE FCBPTR, VCBPTR, DEVNUM
				clc 
				rts ; SUCCESSFUL SWAP OUT
UNLOG			lda #0
				sta VCB,X ; UNLOG VOLUME
				beq SORTS ; SWAP THE EASY WAY! (BRANCH ALWAYS)
*
*
*
SWAPIN			.eq *
*

* UNSWAP A VOLUME AND ALL ITS FILES
*
* INPUT ARGUMENT: VOLUME NAME (VCBPTR)
* OUTPUT ARGUMENT: NONE
* CONDITION CODE: CARRY SET : USER DID NOT COMPLY WITH REQUEST
*
* SAVE VCBPTR, FCBPTR ON STACK
* 1) FIND SWAPPED VOLUME IN VCB, IF NOT FOUND, THEN RTS.
* 2) IF ANOTHER UNSWAPPED VOLUME ON DEVICE, THEN SWAP IT
* 3) VERIFY UNSWAPPED VOLUME, IF NOT OK THEN REQUEST INSERTION
* 4) UNMARK VCB'S AND FCB'S
* RTS
				jsr SAVECBS ; SAVE FCB, VCB POINTERS, DEVNUM
				ldy #VCBNML ; MAKE SURE VOLUME
				lda (VCBPTR),Y ; IS AT LEAST OPEN
				beq USRTS ; BRANCH IF NOT RIGHT BACK TO CALLER
				ldy #VCBSWAP ; SEE IF
				lda (VCBPTR),Y ; CURRENTLY SWAPPED
				beq USRTS ; IF NOT, RETURN IMMEDIATELY TO CALLER
				ldy #VCBDEV ; SAVE DEVICE NUMBER
				lda (VCBPTR),Y
				sta DEVNUM
				pha ; SAVE DEVNUM AGAIN (SWAPOUTX TRASHES DEVNUM ON RETURN)
				jsr SWAPOUTX ; AND MAKE SURE ANY CURRENT ACTIVE VOLUME IS SWAPPED OUT (NOTICE ENTRY
POINT)
				pla ; RECALL CURRENT DEVICE NUMBER
				sta DEVNUM ; AND SAVE IT TO ITS PROPER PLACE
SI1			jsr VERFYVOL ; VERIFY THE CURRENT VOLUME MOUNTED
				bcc UNMARK ; IF THE RIGHT ONE, GO MARK IT AS UNSWAPPED
				jsr USRREQ ; ELSE REQUEST USER TO INSERT
				bcc SI1 ; USER SAID 'OK'
				jsr CLOSEU ; OTHERWISE UNCONDITIONALLY CLOSE
				jsr RESTCBS
				sec 
				rts 
UNMARK			ldy #VCBSWAP ; FETCH
				lda (VCBPTR),Y ; VOLUME
				pha ; SWAP BYTE
				lda #0 ; BUT CLEAR
				sta (VCBPTR),Y ; VOLUME SWAP
				pla 
				clc ; "UNSWAPPED"
				jsr FCBSCAN
				lda DEVNUM ; MAKE SURE BIT MAPS
				jsr CLEARBMS ; ARE MARKED AS INVALID ON THIS DEVICE
USRTS			jsr RESTCBS ; RESTORE VCB, FCB PTRS
				clc ; NO ERRORS
				rts 
*
SAVEPTRS		.bs 5 ; A RARE EMBEDDED TEMP SAVE AREA, USED ONLY BY ...
*
*
SAVECBS			.eq * ; SAVE FCBPTR, VCBPTR IN A TEMP SAVE AREA
				lda VCBPTR
				sta SAVEPTRS
				lda VCBPTR+1
				sta SAVEPTRS+1
				lda FCBPTR
				sta SAVEPTRS+2
				lda FCBPTR+1
				sta SAVEPTRS+3
				lda DEVNUM
				sta SAVEPTRS+4
				rts 
*
RESTCBS			.eq * ; RESTORE FCBPTR, VCBPTR
* NOTICE THERE EXISTS A SEQUENCE OF CALLS (SWAPIN, WHICH MAY CALL SWAPOUT) THAT JSR'S TO SAVECBS ONCE BUT JSR'S RESTCBS
TWICE.
				lda SAVEPTRS
				sta VCBPTR
				lda SAVEPTRS+1
				sta VCBPTR+1
				lda SAVEPTRS+2
				sta FCBPTR
				lda SAVEPTRS+3
				sta FCBPTR+1
				lda SAVEPTRS+4
				sta DEVNUM
				rts 
*
*

* MARK ALL FILES BELONGING TO A VOLUME
* AS SWAPPED-IN OR SWAPPED-OUT.
*
* INPUT ARGS: DEVNUM -- DEVICE NUMBER OF MOUNTED VOLUME
* A REGISTER - SWAP BYTE
* CARRY -- CARRY FLAG SET MEANS SWAP OUT; ELSE SWAP IN
*
* OUTPUT ARGS: NONE
* GLOBALS AFFECTED: FCB, FCBPTR
* REGISTER STATUS: SCRAMBLED
*
FCBSCAN			.eq * ; MARK FILES BELONGING TO VOLUME AS SWAPPED OR UNSWAPPED
*
				tax ; SAVE SWAP BYTE
				ldy FCBADDRH ; POINT TO
				sty FCBPTR+1 ; BEGINNING TO FCB
				ldy #0
				sty FCBPTR
				bcs FCBOUT ; SWAP OUT A VOLUMES FILES
FCBIN			.eq * ; SWAPIN A VOLUMES FILES
				jsr FCBFETCH ; GET NEXT ACTIVE FCB CANDIDATE
				bcs FCBRTS ; NO MORE FILES TO PROCESS
				ldy #FCBSWAP
				txa 
				cmp (FCBPTR),Y ; SWAP BYTES MATCH?
				bne FCBIN1 ; BRANCH IF NOT
				lda #0
				sta (FCBPTR),Y ; MARK FILE AS SWAPPED IN
FCBIN1			jsr NEXTFCB ; ADVANCE FCB POINTER
				bcs FCBRTS ; NO MORE TO LOOK AT
				jmp FCBIN ; AND LOOK AT NEXT FILE
*
FCBOUT			.eq * ; SWAPPED OUT A VOLUMES FILES
				jsr FCBFETCH ; GET NEXT ACTIVE FILE IN FCB
				bcs FCBRTS ; NO MORE FILES -- RETURN TO USER
				ldy #FCBSWAP ; COMPARE
				lda (FCBPTR),Y
				bne FCBOUT1 ; ALREADY SWAPPED OUT
				txa 
				sta (FCBPTR),Y ; MARK AS SWAPPED
FCBOUT1			jsr NEXTFCB ; ADVANCE FCB POINTER
				bcs FCBRTS
				jmp FCBOUT ; SWAP OUT NEXT FILE
*
FCBRTS			rts
FCBFETCH		.eq * ; GET NEXT ACTIVE FILE FROM FCB
* X REGISTER MUST NOT BE DISTURBED
* USES FCBPTR
				ldy #FCBDEVN ; MAKE
				lda (FCBPTR),Y ; SURE DEVICE
				cmp DEVNUM ; MATCHES
				bne NEXTFCB
				ldy #FCBREFN ; MAKE SURE FILE IS ACTIVE
				lda (FCBPTR),Y
				beq NEXTFCB ; BRANCH IF NOT
				clc 
				rts ; RETURN WITH CARRY CLEAR SHOWING AN ACTIVE FILE
NEXTFCB			lda FCBPTR
				clc 
				adc #$20 ; FCB ENTRY SIZE
				sta FCBPTR
				bcc FCBFETCH ; BRANCH IF NO PAGE CROSS
				lda FCBPTR+1
				inc FCBPTR+1 ; SECOND PAGE
				cmp FCBADDRH
				beq FCBFETCH ; LOOK AT PAGE TWO
NEXTEND			sec
				rts ; SHOW NO MORE FILES TO LOOK AT
USRREQ			.eq * ; OPERATOR CONSOLE MESSAGE INTERFACE
* PRODUCES A MESSAGE REQUESTING
* THE SYSTEM OPERATOR TO MOUNT THE VOLUME
* SPECIFIED BY "VCBPTR" ON DEVICE SPECIFIED
* BY DEVNUM. THIS MODULE INSISTS
* UPON THE CORRECT OPERATOR ACTION
* UPON THREE FAILURES TO COMPLY,
* THE MODULE WILL SIGNIFY FAILURE WITH
* CARRY SET. IF THE CORRECT ACTION IS TAKEN,
* CARRY WILL BE RETURNED CLEAR
*
* INPUT ARGS: VOLUME NAME (VCBPTR)
* DEVICE NUMBER (DEVNUM)

*
* OUTPUT ARGS: CC = OPERATOR COMPLIED WITH REQUESTED ACTION
* CS = OPERATOR COULDN'T/DIDN'T COMPLY
*
* GLOBALS AFFECTED: NONE
*
* STATUS OF REGISTERS: UNCERTAIN
*
VNML			.eq ZPGTEMP ; VOLUME NAME LENGTH
				ldy #VCBNML ; IF ILLEGAL VCB
				lda (VCBPTR),Y ; GET OUT QUICK
				beq NEXTEND ; BRANCH TO SEC RTS
				ldx #$E ; LENGTH OF NAMED AREA-1
				lda #$0 ; NULLS
UR1			sta MDEV,X ; BOTH CLEAR
				sta MVOL,X ; IN ONE LOOP
				dex 
				bpl UR1
*
* DO A D-INFO TO FETCH THE DEVICE NAME
*
				lda #5 ; DO ALL
				sta $C0 ; NECESSARY
				lda DEVNUM ; HOUSKEEPING
				sta $C1 ; TO SET UP
				lda #MDEV-1 ; A DEVICE MANAGER CALL
				sta $C2
				lda /MDEV-1
				sta $C3
				lda #$8F ; EXTEND BYTE
				sta $14C3
				lda #0
				sta $14C2
				sta $C4
				sta $C5
				sta $C6 ; ZERO SUPERFLUOUS PARMS
				sta URDERR ; RESET FAILURE COUNT
				jsr RPEATIO0 ; GET INFO FROM BOBS CODE
				lda #$20 ; "SPACE" RESTORED
				sta MDEV-1 ; RESTORED
				ldy #VCBNML
				lda (VCBPTR),Y ; LENGTH OF VOLUME NAME
				sta VNML ; SAVED FOR WORK
				lda #0
				tax 
				ldy #VCBNAM ; POINT TO BEGINNING OF VOLUME NAME
UR2			lda (VCBPTR),Y
				sta MVOL,X
				inx 
				iny ; VOLUME NAME MOVED
				dec VNML ; TO MESSAGE BUFFER
				bne UR2 ; CHARACTER BY CHARACTER
URDU			ldx #UMB ; PASS THE AREA'S ADDR
				ldy /UMB ; IN X AND Y REGS,LOW, HIGH)
				jsr OPMSGRPLY ; HAVE MESSAGE SYSTEM PRINT IT
				jsr VERFYVOL ; DID THE USER COMPLY?
				bcs URDU1 ; BRANCH IF NOT
				rts ; EXIT--CARRY IS CLEAR
URDU1			inc URDERR ; COLLECT USER ERRORS
				lda URDERR
				cmp #3 ; ONLY THREE TRIES ALLOWED
				bcc URDU ; RETRY MESSAGE IF LESS THAN THREE TRIES
				rts ; OTHERWISE RETURN WITH CARRY SET
*
*
*
*
*
* CLOSE UNCONDITIONAL
*
* (USER HAS REPLIED 'N' TO A VOLUME MOUNT REQUEST
* CLOSE ALL FILES ON VOLUME/UNLOG VOLUME
*
* INPUT ARGUMENT: (VCBPTR)
* OUTPUT ARGUMENT: NONE
*
CLOSEU			.eq *
VSWA			.eq ZPGTEMP ; THE 'SWAP BYTE' STORED HERE
				ldy #VCBDEV ; FETCH
				lda (VCBPTR),Y ; THE DEVICE NUMBER
				sta DEVNUM ; OF THIS VOLUME & SAVE IT

				ldy #VCBSWAP ; FETCH THE
				lda (VCBPTR),Y ; SWAP BYTE
				sta VSWA ; SAVE FOR REFERENCE, TOO
				lda #0
				ldy #VCBNML ; UNLOG THE VOLUME
				sta (VCBPTR),Y ; BY SETTING LEN OF VOL NAME TO ZERO
				ldy #VCBSWAP
				sta (VCBPTR),Y ; TURN OFF SWAP FLAG
				ldy FCBADDRH ; SET UP FCB SCAN FROM BEGINNING OF FCB
				sty FCBPTR+1
				ldy #0
				sty FCBPTR
VFCBLOP			ldy #FCBDEVN ; FETCH
				lda (FCBPTR),Y ; THE DEVICE
				cmp DEVNUM ; NUMBER AND SEE IF A MATCH
				bne VFCBNXT ; BRANCH IF NO MATCH
				ldy #FCBREFN ; SEE EVEN IF FILE OPEN
				lda (FCBPTR),Y
				beq VFCBNXT ; BRANCH IF NOT
				ldy #FCBSWAP ; CHECK TO SEE IF ATTACHED
				lda (FCBPTR),Y ; TO SAME VOLUME
				cmp VSWA
				bne VFCBNXT ; BRANCH IF NOT
				ldy #FCBBUFN ; RELEASE
				lda (FCBPTR),Y ; ANY
				jsr RELBUF ; BUFFERS ASSOCIATED
				ldy #FCBSWAP ; AND CLEAR
				lda #0 ; THE SWAP BYTE
				sta (FCBPTR),Y
				ldy #FCBREFN ; AND FINALLY
				sta (FCBPTR),Y ; SAY 'CLOSED'
VFCBNXT			lda FCBPTR
				clc 
				adc #$20 ; FCB ENTRY SIZE
				sta FCBPTR
				bcc VFCBLOP
				lda FCBPTR+1
				inc FCBPTR+1 ; LOOK AT SECOND PAGE
				cmp FCBADDRH
				beq VFCBLOP ; CHECK PAGE TWO OF FCB
				rts ; RETURN TO USER W/O ERROR
*
FCBUSED			.eq * ; MARK AS FCB AS DIRTY SO
* THE DIRECTORY WILL BE FLUSHED ON 'FLUSH'
				sty ZPGTEMP
				pha ; SAVE REGS
				ldy #FCBDIRTY
				lda (FCBPTR),Y ; FETCH CURRENT FCBDIRTY BYTE
				ora #FCBMOD ; MARK FCB AS DIRTY
				sta (FCBPTR),Y ; SAVE IT BACK
				pla 
				ldy ZPGTEMP ; AND RESTORE REGS
				rts 
*
URDERR			.bs 1 ; ERROR COUNT FOR USRREQ
*
*
UMB			.eq *
				.da 49,6E,73,65,72,74,20
				.da 76,6F,6C,75,6D,65
				.da 3A,20 ; "INSERT VOLUME: "
MVOL			.bs 15
				.da 0D ; CR LINE TERMINATOR
				.da 20,20,20,20,69,6E,20
				.da 64,65,76,69,63,65
				.da 3A,20 ; " IN DEVICE: "
MDEV			.bs 15
				.da 0D ; CR LINE TERMINATOR
				.da 74,68,65,6E,20,70,72
				.da 65,73,73,20,74,68,65,20
				.da 41,4C,50,48,41,20,4C
				.da 4F,43,4B,20,6B,65,79
				.da 20,74,77,69,63,65
* "THEN PRESS THE ALPHA LOCK KEY TWICE"
* FOLLOWED WITH $FF MESSAGE TERMINATOR (HIGH BIT SIGNIFICANT)
				.da FF ; MESSAGE TERMINATOR (HIGH BIT)
*
ZZLEN			.eq *-ZZORG
ZZEND			.eq *
IFNE ZZLEN-LENBFM
FAIL 2,"SOSORG FILE IS INCORRECT FORMBFM"

				.fin

*************************************************************************
* END OF APPLE /// SOS 1.3 SOURCE CODE FILE: SWAPOUT.IN
*************************************************************************




*--------------------------------------
MAN
SAVE /A3OSX.BUILD/SOS.ORIG/SOS.S.SWAPOUT.IN
LOAD /A3OSX.BUILD/SOS.ORIG/SOS.S
ASM
