NEW
AUTO 3,1
*--------------------------------------

*************************************************************************
* APPLE /// SOS 1.3 SOURCE CODE FILE: MEMMGR.A.SRC
*************************************************************************
* ASSEMBLER: APPLE ][ 6502 ASSEMBLER from APPLE COMPUTER TOOLKIT

*				.TI "SOS 1.1 MEMORY MANAGER"
* REL
* INCLUDE SOSORG,6,1,254
				.ph ORGMEMMG FIXME: check if we need this
ZZORG			.eq *
* FIXME - MSB OFF
* REP 60
* COPYRIGHT (C) APPLE COMPUTER INC. 1980
* ALL RIGHTS RESERVED
* REP 60
*
* MEMORY MANAGER (VERSION = 1.1O )
* (DATE = 8/04/81)
*
* THIS MODULE CONTAINS ALL OF THE MEMORY MANAGEMENT SYSTEM
* CALLS SUPPORTED BY THE SARA OPERATING SYSTEM. IT IS
* ALSO CALLED BY THE BUFFER MANAGER.
*
* REP 60
*
* ENTRY MMGR
*
* ENTRY ST.CNT
* ENTRY ST.ENTRY
* ENTRY ST.FREE
* ENTRY ST.FLINK
* ENTRY VRT.LIM
*
* EXTRN SYSERR
* EXTRN BADSCNUM
* EXTRN BADBKPG
* EXTRN SEGRQDN
* EXTRN SEGTBLFULL
* EXTRN BADSEGNUM
* EXTRN SEGNOTFND
* EXTRN BADSRCHMODE
* EXTRN BADCHGMODE
* EXTRN BADPGCNT
* PAGE
* REP 60
*
* SEGMENT TABLE
* (NOTE: ENTRY 0 IS NOT USED)
*
* REP 60
*
ST.FREE			.bs 1 ; PTR TO FIRST FREE SEG TABLE ENTRY
ST.ENTRY		.bs 1 ; PTR TO HIGHEST ALLOC SEG TABLE ENTRY
ST.SIZ			.eq 7
ST.CNT			.eq 32
ST.TBL			.bs ST.SIZ*ST.CNT
ST.BLINK		.eq ST.TBL ; BACK LINK TO PREV ALLOC SEG ENTRY
ST.FLINK		.eq ST.BLINK+ST.CNT ; FORWARD LINK "
ST.BASEL		.eq ST.FLINK+ST.CNT ; BASE BANK/PAGE
ST.BASEH		.eq ST.BASEL+ST.CNT
ST.LIML			.eq ST.BASEH+ST.CNT ; LIMIT BANK/PAGE
ST.LIMH			.eq ST.LIML+ST.CNT
ST.ID			.eq ST.LIMH+ST.CNT ; SEG ID
* PAGE
* REP 60
*
* DATA DECLARATIONS
*
* REP 60
*
ZPAGE			.eq $40 ; BEGINNING OF ZPAGE TEMP SPACE FOR MEMORY MANAGER
VRT.BASE		.eq $0 ; INTERNAL BK/PG PTR TO LOWEST VIRT PAGE
VRT.LIM			.eq ZPAGE+$0 ; &$1, INTERNAL BK/PG PTR TO HIGHEST VIRT PAGE
PHY1BASE		.eq $0780 ; BANK "F",PAGE "0"
PHY1LIM			.eq $079F ; BANK "F",PAGE "1F"
PHY2BASE		.eq $0820 ; BANK "10",PAGE "A0"

PHY2LIM			.eq $087F ; BANK "10",PAGE "FF"
*
* REQUEST.SEG DATA DECLARATIONS
*
M.TPARMX		.eq $60 ; BEGINNING ADDRESS OF MMGR SOS CALL PARMS
M.RQCODE		.eq M.TPARMX
RQ.BASE			.eq M.TPARMX+1 ; BASE.BANK/PAGE
RQ.LIM			.eq M.TPARMX+3 ; LIMIT.BANK/PAGE
RQ.ID			.eq M.TPARMX+5
RQ.NUM			.eq M.TPARMX+6
*
RQ.REGION		.eq ZPAGE+$2 ;VRT(0),PHY0(1),PHY1(2)
*
* FIND.SEG DATA DECLARATIONS
*
SRCHMODE		.eq M.TPARMX+1 ; SEARCH MODE (0,1,2)
F.ID			.eq M.TPARMX+2 ; SEG ID
F.PGCT			.eq M.TPARMX+3 ; PAGE COUNT (LO
FX.PGCT			.eq ZPAGE+$3 ; &$4, INTERNAL PAGE COUNT
F.BASE			.eq M.TPARMX+5 ; BASE.BANK/PAGE
F.LIM			.eq M.TPARMX+7 ; LIMIT.BANK/PAGE
F.NUM			.eq M.TPARMX+9 ; SEG NUM
F.ERR			.eq ZPAGE+$5 ; ERROR FLAG
TRUE			.eq $80
FALSE			.eq $0
CFS.PGCT		.eq ZPAGE+$6 ; &7, CURRENT FREE SEGMENT'S PAGE COUNT
CFS.BASE		.eq ZPAGE+$8 ; &9, " BASE.BANK/PAGE
CFS.LIM			.eq ZPAGE+$A ; &$B, " LIMIT.BANK/PAGE
CFS.BLINK		.eq ZPAGE+$C ; " BACK LINK
CFS.BASE0		.eq ZPAGE+$D ; &$E, " BASE (SMODE=0)
CFS.BASE1		.eq ZPAGE+$F ; &$10, " BASE (SMODE=1)
CFS.NEXT		.eq ZPAGE+$11 ; " NEXT ENTRY
CFS.PREV		.eq ZPAGE+$12 ; " PREV ENTRY
CFS.PTR			.eq ZPAGE+$13 ; &$14 " POINTER TO NXT FREE PG
BFS.PGCT		.eq ZPAGE+$15 ; &$16, BIGGEST FREE SEGMENT'S PAGE COUNT
BFS.BASE		.eq ZPAGE+$17 ; &$18 " BASE.BANK/PAGE
BFS.LIM			.eq ZPAGE+$19 ; &$1A " LIMIT.BANK/PAGE
BFS.BLINK		.eq ZPAGE+$1B ; " BACK LINK
*
* CHANGE.SEG DATA DECLARATIONS
*
CHG.NUM			.eq M.TPARMX+1 ; SEGNUM PARM
CHG.MODE		.eq M.TPARMX+2 ; CHANGE MODE PARM
CHG.PGCT		.eq M.TPARMX+3 ; PAGE COUNT PARM
CHG.PGCTX		.eq ZPAGE+$1C ; &$1D, INTERNAL STORE FOR PGCT
CHG.NEW			.eq ZPAGE+$1E ; &$1F, BANK/PAGE OF SEG'S NEW LIMIT OR BASE
*
* GET.SEG.INFO DATA DECLARATIONS
*
GSI.NUM			.eq M.TPARMX+1
GSI.BASE		.eq M.TPARMX+2
GSI.LIM			.eq M.TPARMX+4
GSI.PGCT		.eq M.TPARMX+6
GSI.ID			.eq M.TPARMX+8
*
* GET.SEG.NUM DATA DECLARATIONS
*
GSN.BKPG		.eq M.TPARMX+1
GSN.NUM			.eq M.TPARMX+3
*
* RELEASE.SEG DATA DECLARATIONS
*
RLS.NUM			.eq M.TPARMX+1 ; SEG NUM
*
* REGION - DATA DECLARATIONS
*
RGN.BKPG		.bs 2 ; TEMP CONTAINER FOR BANK/PAGE
* PAGE
* REP 60
*
* MMGR
*
* THIS ROUTINE IS THE MAIN ENTRANCE TO THE MEMORY MANAGER
* MODULE. IT FUNCTIONS AS A SWITCH, BASED UPON THE RECEIVED
* REQUEST CODE, TO TRANSFER CONTROL TO THE ROUTINE THAT
* HANDLES THE SPECIFIC SYSTEM CALL.
*
* REP 60
*
MMGR			.eq *
				lda M.RQCODE

				beq MMGR010 ; "REQ.SEG"
				cmp #1
				beq MMGR020 ; "FIND.SEG"
				cmp #2
				beq MMGR030 ; "CHANGE.SEG"
				cmp #3
				beq MMGR040 ; "GET.SEG.INFO"
				cmp #4
				beq MMGR050 ; "GET.SEG.NUM"
				cmp #5
				beq MMGR060 ; "RELEASE.SEG"
*
				lda #BADSCNUM
				jsr SYSERR
*
MMGR010			jmp REQ.SEG
MMGR020			jmp FIND.SEG
MMGR030			jmp CHG.SEG
MMGR040			jmp GET.SEG.INFO
MMGR050			jmp GET.SEG.NUM
MMGR060			jmp RELEASE.SEG
* PAGE
* REP 60
*
* REQUEST.SEG(IN.BASE.BANKPAGE,LIMIT.BANKPAGE,SEGID; OUT.SEGNUM)
*
* REP 60
*
REQ.SEG			.eq *
*
* CONVERT CALLER'S BASE.BANK/PAGE TO INTERNAL FMT
*
				ldx RQ.BASE
				ldy RQ.BASE+1
				jsr CNVRT.IBP
				bcc RQ005
*
RQ.ERR			rts ; ERR EXIT - INVALID BANK/PAGE
*
RQ005			stx RQ.BASE
				sty RQ.BASE+1
				sta RQ.REGION
*
* CONVERT CALLER'S LIMIT.BANK/PAGE TO INTERNAL FMT
*
				ldx RQ.LIM
				ldy RQ.LIM+1
				jsr CNVRT.IBP
				bcs RQ.ERR ; ERR - INVALID BANK/PAGE
				stx RQ.LIM
				sty RQ.LIM+1
*
* IF BASE AND LIMIT ARE IN DIFFERENT REGIONS THEN ERR
*
				cmp RQ.REGION
				bne RQ.ERR1 ; ERR - INVALID BANK/PAGE PAIR
* IF CALLER'S BASE > LIMIT THEN ERR
*
				lda RQ.LIM
				cmp RQ.BASE
				lda RQ.LIM+1
				sbc RQ.BASE+1
				bcc RQ.ERR1 ; ERR - INVALID BANK/PAGE PAIR
*
* PREV SEGNUM:=NULL; NEXT SEGNUM:=FIRST ENTRY
*
				ldx #0
				ldy ST.ENTRY ; NOTE: PREV/NEXT CARRIED IN X & Y REGISTERS
*
* IF NO SEGS IN SEG TABLE THEN ALLOCATE REQUESTED SEG
*
				beq RQ030
*
* IF FIRST SEG IN SEG TABLE BELOW REQUESTED SEG
* THEN ALLOCATE SEG
*
				lda ST.LIML,Y
				cmp RQ.BASE
				lda ST.LIMH,Y
				sbc RQ.BASE+1
				bcc RQ030

*
* ADVANCE TO NEXT SEG ENTRY
*
RQ010			tya
				tax 
				lda ST.FLINK,Y
				tay 
*
* IF THERE IS NO NEXT SEG ENTRY
* IF REQUESTED SEG IS BELOW PREV SEG
* THEN ALLOCATE REQ SEG
* ELSE ERR
*
				bne RQ020
				lda RQ.LIM
				cmp ST.BASEL,X
				lda RQ.LIM+1
				sbc ST.BASEH,X
				bcc RQ030
*
				bcs RQ.ERR2 ; ERR - SEGMENT REQUEST DENIED
*
* IF REQUESTED LIMIT >= PREV SEG'S BASE THEN ERR
*
RQ020			lda RQ.LIM
				cmp ST.BASEL,X
				lda RQ.LIM+1
				sbc ST.BASEH,X
				bcs RQ.ERR2 ; ERR - SEGMENT REQUEST DENIED
*
* IF REQUESTED BASE > NEXT SEG'S LIMIT
* THEN ALLOCATE REQUESTED SEGMENT
*
				lda ST.LIML,Y
				cmp RQ.BASE
				lda ST.LIMH,Y
				sbc RQ.BASE+1
				bcs RQ010 ; NO, ADVANCE TO NEXT SEGMENT
*
RQ030			txa ; ALLOCATE REQUESTED SEGMENT
				jsr GET.FREE
				bcs RQ.ERR3 ; ERR - SEG TABLE FULL
*
* ENTER BASE,LIMIT AND ID IN NEW SEG ENTRY
*
				tax 
				lda RQ.BASE
				sta ST.BASEL,X
				lda RQ.BASE+1
				sta ST.BASEH,X
*
				lda RQ.LIM
				sta ST.LIML,X
				lda RQ.LIM+1
				sta ST.LIMH,X
*
				lda RQ.ID
				sta ST.ID,X
*
* RETURN NEW SEG NUM TO CALLER AND RETURN
*
				ldy #0
				txa 
				sta (RQ.NUM),Y
*
				clc 
				rts ; NORMAL EXIT
*
RQ.ERR1			lda #BADBKPG
				jsr SYSERR ; ERR EXIT
RQ.ERR2			lda #SEGRQDN
				jsr SYSERR ; ERR EXIT
*
RQ.ERR3			lda #SEGTBLFULL
				jsr SYSERR ; ERR EXIT
* PAGE
* REP 60
*
* FIND.SEG(IN.SRCHMODE,SEGID; INOUT.PAGECT;
* OUT.BASE.BKPG,LIMIT.BKPG,SEGNUM)
*

* REP 60
*
FIND.SEG		.eq *
*
* RETRIEVE PAGE COUNT PARAMETER AND CLEAR ERR FLAG
*
				ldy #0
				lda (F.PGCT),Y
				sta FX.PGCT
				iny 
				lda (F.PGCT),Y
				sta FX.PGCT+1
*
				bne FIND001
				lda FX.PGCT
				bne FIND001
				lda #BADPGCNT ; ERR, PAGECT=0, EXIT
				jsr SYSERR
*
FIND001			lda #FALSE
				sta F.ERR
*
* IF SEARCH MODE>2 THEN ERR
*
				lda SRCHMODE
				cmp #3
				bcc FIND005
				lda #BADSRCHMODE
				jsr SYSERR ; ERR EXIT
*
* INITIALIZE NEXT FREE SEGMENT SUBROUTINE,
* AND BIGGEST FREE SEGMENT PAGE COUNT
*
FIND005			jsr NXTFRSEG.I
				lda #0
				sta BFS.PGCT
				sta BFS.PGCT+1
*
* GET NEXT FREE SEGMENT
*
FIND010			jsr NXTFRSEG
				bcc FIND015 ; PROCESS FREE SEGMENT
*
* NO MORE FREE SEGMENTS LEFT
* RETURN BIGGEST FREE SEGMENT FOUND
* ALONG WITH ERR
*
				lda #TRUE
				sta F.ERR
				ldx #0 ; SEG#:=0
				jmp FIND070
*
* FREE SEGMENT FOUND.
* IF FREE SEGMENT > BIGGEST FREE SEGMENT THEN BFS:=CFS
*
FIND015			lda BFS.PGCT
				cmp CFS.PGCT
				lda BFS.PGCT+1
				sbc CFS.PGCT+1
				bcs FIND030
*
				ldx #6
FIND020			lda CFS.PGCT,X
				sta BFS.PGCT,X
				dex 
				bpl FIND020
*
* IF BFS.PGCT<F.PGCT THEN GET NEXT FREE SEGMENT
*
FIND030			lda BFS.PGCT
				cmp FX.PGCT
				lda BFS.PGCT+1
				sbc FX.PGCT+1
				bcc FIND010
*
* BFS.BASE:=BFS.LIM-FX.PGCT+1
* BFS.PGCT:=FX.PGCT
*
				lda BFS.LIM
				sbc FX.PGCT
				sta BFS.BASE

				lda BFS.LIM+1
				sbc FX.PGCT+1
				sta BFS.BASE+1
				inc BFS.BASE
				bne FIND050
				inc BFS.BASE+1
*
FIND050			lda FX.PGCT
				sta BFS.PGCT
				lda FX.PGCT+1
				sta BFS.PGCT+1
*
* DELINK ENTRY FROM FREE LIST, AND LINK
* IT INTO SEGMENT LIST
*
				lda BFS.BLINK
				jsr GET.FREE
				bcc FIND060
				rts ; ERR - SEG TABLE FULL
*
* ST.ID(NEW):=F.ID
* ST.BASE(NEW):=BFS.BASE
* ST.LIM(NEW):=BFS.LIM
*
FIND060			tax
				lda F.ID
				sta ST.ID,X
*
				lda BFS.BASE
				sta ST.BASEL,X
				lda BFS.BASE+1
				sta ST.BASEH,X
*
				lda BFS.LIM
				sta ST.LIML,X
				lda BFS.LIM+1
				sta ST.LIMH,X
*
* RETURN SEGNUM, PAGE COUNT, BASE BANK/PAGE, AND LIMIT BANK/PAGE
* TO CALLER
FIND070			ldy #0
				txa 
				sta (F.NUM),Y
*
				lda BFS.PGCT
				sta (F.PGCT),Y
				iny 
				lda BFS.PGCT+1
				sta (F.PGCT),Y
*
				ldx BFS.BASE
				ldy BFS.BASE+1
				jsr CNVRT.XBP
				tya 
				ldy #1
				sta (F.BASE),Y
				dey 
				txa 
				sta (F.BASE),Y
*
				ldx BFS.LIM
				ldy BFS.LIM+1
				jsr CNVRT.XBP
				tya 
				ldy #1
				sta (F.LIM),Y
				dey 
				txa 
				sta (F.LIM),Y
*
				lda F.ERR ; IF ERR FLAG TRUE THEN REPORT IT.
				bne FIND.ERR
*
				clc 
				rts ; NORMAL EXIT
*
FIND.ERR		lda #SEGRQDN
				jsr SYSERR ; ERR EXIT

* CHN MEMMGR.B.SRC


*************************************************************************
* END OF APPLE /// SOS 1.3 SOURCE CODE FILE: MEMMGR.A.SRC
*************************************************************************





*--------------------------------------
MAN
SAVE /A3OSX.BUILD/SOS.ORIG/SOS.S.MEMMGR.A
LOAD /A3OSX.BUILD/SOS.ORIG/SOS.S
ASM
