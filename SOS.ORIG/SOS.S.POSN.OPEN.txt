NEW
AUTO 3,1
*--------------------------------------

*************************************************************************
* APPLE /// SOS 1.3 SOURCE CODE FILE: POSN.OPEN
*************************************************************************
* ASSEMBLER: APPLE ][ 6502 ASSEMBLER from APPLE COMPUTER TOOLKIT

* PAGE
GETMARK			ldy #FCBMARK ; MOVE CURRENT POSITION MARKER TO
GMARK1			lda (FCBPTR),Y ; USER'S 4 BYTE BUFFER POINTED TO BY
				pha ; C.MRKPTR IN SOS ZPAGE
				iny 
				cpy #FCBMARK+3 ; USE STACK AS TEMPORARY STORAGE FOR THREE BYTE
				bne GMARK1 ; POSITION VALUE.
				lda #0 ; THE FOURTH (HIGHEST ORDER) BYTE IS ALWAYS ZERO.
				ldy #3
				pha 
MOVMRK			pla
				sta (C.MRKPTR),Y ; MOVE TO USER'S SPACE
				dey ; IS THERE ANOTHER TO PULL FROM STACK?
				bpl MOVMRK ; YES, GET NEXT LOWER BYTE FROM STACK.
				clc ; INDICATE NO ERROR.
				rts 
*
SETMARK			jsr ADJMARK ; MAKE ADJUSTMENTS TO REQUESTED MARK ACCORDING TO BASE.
				bcc SMARK1 ; BRANCH IF ADJUSTMENT WAS VALID.
				rts 
SMARK1			ldx #2 ; NOW COMPARE END OF FILE WITH NEW
				ldy #FCBEOF+2 ; POSITION TO BE SURE IT'S WITHIN
CMPEOF			lda TPOSLL,X ; THE BOUNDS OF CURRENTLY DEFINED
				cmp (FCBPTR),Y ; LIMITS.
				bcc CKSAMBLK ; BRANCH IF MARK<EOF
				bne ERRMEOF ; RETURN ERROR IF MARK>= EOF
				dey 
				dex 
				bpl CMPEOF
				bmi CKSAMBLK ; BRANCH ALWAYS
ERRMEOF			lda #POSNERR ; TELL USER MARK IS OUT OF RANGE.
				rts ; (CARRY IS SET TO INDICATE ERROR)
*
ADJMARK			lda C.MARK+3 ; MAKE SURE FOURTH BYTE OF DISPLACE IS ZIP
				bne ERRPOSN ; BRANCH TO ERR IF NOT
				ldx #$FD ; ANTICIPATE OTHER THAN BASE OF ZERO
				ldy #FCBMARK ; FURTHER ASSUME IT'S A BASE OFFSET FROM CURRENT POSITION
				lda C.BASE ; NOW FIND OUT WHAT IT REALLY IS.
				lsr
				bcs SUBMARK
				beq ADJMRK ; BRANCH IF MARK IS FROM BEGINNING OF FILE
ADDPOSN			lda (FCBPTR),Y ; ADD USER QUANTITY TO CURRENT
				adc C.MARK+3,X ; POSITION TO FORM NEW POSITION.
				sta >TPOSLL-$FD,X ; (NOTE: ZERO PAGE REFERENCE WRAPS AROUND IN Z-PAGE)
				iny 
				inx 
				bne ADDPOSN ; ADD ALL THREE BYTES
				bcs ERRPOSN ; BRANCH IF OVERFLOW
				beq ADJMRK1 ; BRANCH ALWAYS
*
* PAGE
SUBMARK			bne SUBPOSN ; BRANCH IF IT'S AN OFFSET FROM CURRENT POSITION
				ldy #FCBEOF ; OTHERWISE ASSUME OFFSET FROM END OF FILE.
SUBPOSN			lda (FCBPTR),Y ; SUBTRACT USER QUANTITY TO FORM
				sbc C.MARK+3,X ; NEW POSITION. IF FINAL
				sta >TPOSLL-$FD,X ; RESULT IS L.T. ZERO, THEN REPORT
				iny ; POSITION ERROR...
				inx 
				bne SUBPOSN
				bcs ADJMRK1 ; BRANCH IF LEGAL POSITION CALCULATED.
ERRPOSN			lda #POSNERR
				sec ; INDICATE ERROR
				rts 
*
ADJMRK			ldx #2 ; FIRST SET UP POSITION TEMPS USED
ADJMRK0			lda C.MARK,X ; BY BOTH POSITION ROUTINES
				sta TPOSLL,X
				dex 
				bpl ADJMRK0
ADJMRK1			clc ; NO ERRORS
				rts 

*
*
RDPOSN			.eq *
CKSAMBLK		.eq *
				ldy #FCBMARK+1 ; FIRST TEST TO SEE IF NEW POSITION IS
				lda (FCBPTR),Y ; WITHIN THE SAME (CURRENT) DATA BLOCK.
				and #$FE
				sta SCRTCH
				iny ; BUMP TO ACCESS HIGHEST ORDER ADDRESS BYTE
				lda TPOSLH ; GET MIDDLE BYTE OF NEW POSITION
				sec 
				sbc SCRTCH
				sta SCRTCH
				bcc TYPMARK ; BRANCH IF POSSIBLY L.T. CURRENT POSITION
				cmp #2 ; MUST BE WITHIN 512 BYTES OF BEGINNING OF CURRENT
				bcs TYPMARK
				lda TPOSHI ; NOW MAKE SURE WERE TALKIN ABOUT
				cmp (FCBPTR),Y ; THE SAME 64K CHUNK!
				bne TYPMARK ; BRANCH IF WE AREN'T.
				jmp SVMARK ; IF WE IS, ADJUST FCB AND POSPTR AND RETURN.
*
TYPMARK			ldy #FCBSTYP ; NOW FIND OUT WHICH TYPE
				lda (FCBPTR),Y ; OF FILE WE'RE POSITIONING ON.
				beq FERRTYP ; THERE IS NO SUCH TYPE AS ZERO, BRANCH NEVER!
				cmp #4 ; IS IT A TREE CLASS FILE?
				bcc CHKDSKSW ; YES, GO POSITION
				jmp DIRMARK ; NO, TEST FOR DIRECTORY TYPE.
*
CHKDSKSW		.eq * ; MAKE SURE S/HE HASN'T MOVED THE VOLUME
				ldy #FCBDEVN
				lda (FCBPTR),Y
				sta DEVNUM ; MAKE SURE DEVICE NUMBER PARM IS CURRENT
				jsr TWRPROT1 ; PASSES DEVNUM (CHECK DISK SWITCH)
				lda DSWGLOB ; DISK SWITCH GLOBAL
				beq TREPOS ; BRANCH IF NONE DETECTED
CHKDSKS1		jsr VERFYVOL ; MATCHES VCBPTR VS. DEVNUM
				bcc TREPOS ; BRANCH IF DISK HASN'T SWITCHED
				jsr USRREQ ; POLITELY ASK USER TO MOUNT
				bcc CHKDSKS1 ; SAID HE DID, CHECK AGAIN
				lda #VNFERR ; REFUSES TO MOUNT
				rts 
*
FERRTYP			ldy #FCBREFN ; CLEAR ILLEGALLY TYPED FCB ENTRY
				sta (FCBPTR),Y
				lda #BADREFNUM ; TELL EM THERE IS NO SUCH FILE
				sec 
				rts 
*
* PAGE
TREPOS			ldy #FCBSTYP ; USE STORAGE TYPE AS NUMBER
				lda (FCBPTR),Y ; OF LEVELS (SINCE 1=SEED, 2=SAPLING, AND 3=TREE)
				sta LEVELS
				ldy #FCBSTAT ; SINCE IT'S A DIFFERENT DATA
				lda (FCBPTR),Y ; BLOCK, MUST NOT FORGET PREVIOUS DATA.
				and #DATMOD ; THEREFORE, SEE IF PREVIOUS DATA WAS MODIFIED
				beq POSNEW1 ; THEN DISK MUST BE UPDATED.
				jsr WFCBDAT ; GO WRITE CURRENT DATA BLOCK.
				bcs POSERR ; RETURN ANY ERROR ENCOUNTERED.
*
POSNEW1			ldy #FCBMARK+2 ; TEST TO SEE IF CURRENT
				lda (FCBPTR),Y ; INDEX BLOCK IS GOING TO BE USABLE...
				and #$FE ; OR IN OTHER WORDS-
				sta SCRTCH ; IS NEW POSITION WITHIN 128K OF THE BEGINNING
				lda TPOSHI ; OF CURRENT SAPLING LEVEL CHUNK.
				sec 
				sbc SCRTCH
				bcc POSNEW2 ; BRANCH IF A NEW INDEX BLOCK IS ALSO NEEDED
				cmp #2 ; NEW POSITION IS > THAN BEGINING OF OLD. IS IT WITHIN 128K?
				bcs POSNEW2 ; BRANCH IF NOT.
				ldx LEVELS ; IS THE FILE WE'RE DEALING WITH A SEED?
				dex 
				bne DATLEVEL ; NO, USE CURRENT INDEXES.
TSTINY			lda TPOSLH ; IS NEW POSITION UNDER 512?
				lsr
				ora TPOSHI
				bne NOIDXDAT ; NO, MARK BOTH DATA AND INDEX BLOCK AS UN-ALLOCATED.
				ldy #FCBFRST
				lda (FCBPTR),Y ; FIRST BLOCK IS ONLY BLOCK AND IT'S DATA!
				sta BLOKNML
				iny 
				lda (FCBPTR),Y ; (HIGH BLOCK ADDRESS)

				jmp RNEWPOS ; GO READ IN BLOCK AND SET APPROPRIATE STATUSES.
*
* PAGE
POSNEW2			ldy #FCBSTAT ; GOTA CHECK TO SEE IF PREVIOUS
				lda (FCBPTR),Y ; INDEX BLOCK WAS MODIFIED.
				and #IDXMOD
				beq POSNIDX ; READ IN OVER IT IF CURRENT IS UP TO DATE.
				jsr WFCBIDX ; GO UPDATE INDEX ON DISK (BLOCK ADDR IN FCB)
				bcs POSERR
POSNIDX			ldx LEVELS ; BEFORE READING IN TOP INDEX, CHECK TO BE SURE
				cpx #3 ; THAT THERE IS A TOP INDEX...
				beq POSINDEX ; BRANCH IF FILE IS FULL BLOWN TREE.
				lda TPOSHI ; IS NEW POSITION WITHIN RANGE OF A
				lsr
				php ; ANTICIPATE NO GOOD.
				lda #TOPALC+IDXALC+DATALC ; (TO INDICATE NO LEVEL IS ALLOCATED FOR NEW POSITION.)
				plp ; Z FLAG TELLS ALL...
				bne NODATA ; GO MARK 'EM ALL DUMMY.
				jsr CLRSTATS ; GO CLEAR STATUS BITS 0,1,2 (INDEX/DATA ALLOC STATUS).
				dex ; (UNAFFECTED SINCE LOADED ABOVE) CHECK FOR SEED
				beq TSTINY ; IF SEED, CHECK FOR POSITION L.T. 512...
				jsr RFCBFST ; GO GET ONLY INDEX BLOCK
				bcs POSERR ; BRANCH IF ERROR
				ldy #FCBIDXB ; SAVE NEWLY LOADED INDEX BLOCK'S ADDRESS
				lda BLOKNML
				sta (FCBPTR),Y
				iny 
				lda BLOKNMH
				sta (FCBPTR),Y
				bcc DATLEVEL ; BRANCH ALWAYS...
POSERR			sec
				rts 
*
POSINDEX		jsr CLRSTATS ; CLEAR ALL ALLOCATION REQUIREMENTS FOR PREVIOUS POSITION
				jsr RFCBFST ; GET HIGHEST LEVEL INDEX BLOCK.
				bcs POSERR
				lda TPOSHI ; THEN TEST FOR A SAP LEVEL INDEX BLOCK
				lsr
				tay 
				lda (TINDX),Y
				inc TINDX+1
				cmp (TINDX),Y ; (BOTH HI AND LO WILL BE ZERO IF NO INDEX EXISTS)
				bne SAPLEVEL
				cmp #0 ; ARE BOTH BYTES ZERO?
				bne SAPLEVEL
				dec TINDX+1 ; DON'T LEAVE WRONG POINTERS LAYING AROUND!
NOIDXDAT		lda #IDXALC+DATALC ; SHOW NEITHER INDEX OR DATA BLOCK ALLOCATED.
				jmp NODATA
*
* PAGE
SAPLEVEL		sta BLOKNML ; READ IN NEXT LOWER INDEX BLOCK
				lda (TINDX),Y ; (HI ADDRESS)
				sta BLOKNMH
				dec TINDX+1
				jsr RFCBIDX ; READ IN SAPLING LEVEL
				bcs POSERR
DATLEVEL		lda TPOSHI ; NOW GET BLOCK ADDRESS OF DATA BLOCK
				lsr
				lda TPOSLH ; ( IF THERE IS ONE )
				ror
				tay 
				lda (TINDX),Y ; DATA BLOCK ADDRESS LOW
				inc TINDX+1
				cmp (TINDX),Y
				bne POSNEW3
				cmp #0
				bne POSNEW3
				lda #DATALC ; SHOW DATA BLOCK AS NEVER BEEN ALLOCATED
				dec TINDX+1
*
NODATA			ldy #FCBSTAT
				ora (FCBPTR),Y ; SET STATUS TO SHOW WHATS MISSIN'
				sta (FCBPTR),Y
				lsr
				lsr
				jsr ZIPDATA ; ALSO IS INVALID AND NEEDS TO BE ZEROED (CARRY UNDISTURBED)
				bcc SVMARK ; BRANCH IF INDEX BLOCK DOESN'T NEED ZIPPIN.
ZIPIDX			sta (TINDX),Y
				iny 
				bne ZIPIDX
				inc TINDX+1

ZPIDX1			sta (TINDX),Y
				iny 
				bne ZPIDX1
				dec TINDX+1 ; RESTORE PROPER ADDRESS
				jmp SVMARK
*
ZIPDATA			lda #0 ; ALSO IS INVALID AND NEEDS TO BE ZEROED.
				tay 
ZIPDAT0			sta (DATPTR),Y ; ZERO OUT DATA AREA
				iny 
				bne ZIPDAT0
				inc DATPTR+1
ZPDAT1			sta (DATPTR),Y
				iny 
				bne ZPDAT1
				dec DATPTR+1
				rts 
*
* PAGE
*
POSNEW3			sta BLOKNML ; GET DATA BLOCK OF NEW POSITION
				lda (TINDX),Y ; (HI ADDRESS)
				dec TINDX+1
RNEWPOS			sta BLOKNMH
				jsr RFCBDAT
				bcs PRITZ ; RETURN ANY ERROR
				jsr CLRSTATS ; SHOW WHOLE CHAIN IS ALLOCATED
SVMARK			ldy #FCBMARK+2 ; UPDATE POSITION IN FILE CONTROL BLOCK
				ldx #2
SVMRK1			lda (FCBPTR),Y ; REMEMBER OLDMARK IN CASE
				sta OLDMARK-FCBMARK,Y ; CALLING ROUTINE FAILS LATER
				lda TPOSLL,X
				sta (FCBPTR),Y
				dey 
				dex ; MOVE 3 BYTE POSITION MARKER
				bpl SVMRK1
*
				clc ; LAST, BUT NOT LEAST, SET UP
				lda DATPTR ; INDIRECT ADDRESS TO BUFFER PAGE POINTED
				sta POSPTR ; TO BY THE CURRENT POSITION MARKER.
				lda TPOSLH
				and #1
				adc DATPTR+1
				sta POSPTR+1
				lda SISDATP
				sta SISPOSP ; SISTER PAGE BYTE ALSO.
				rts ; CARRY SHOULD ALWAYS BE CLEAR
PRITZ			sec ; RANDOM ERROR
				rts ; RETURN
*
*
CLRSTATS		ldy #FCBSTAT ; CLEAR ALLOCATION STATES FOR DATA BLOCK
				lda (FCBPTR),Y ; AND BOTH LEVELS OF INDEXES.
				and #$FF-TOPALC-IDXALC-DATALC
				sta (FCBPTR),Y ; THIS SAYS THAT EITHER THEY EXIST CURRENTLY
				rts ; OR THAT THEY'RE UNNECESSARY FOR CURRENT POSITION.
*
* PAGE
*
DIRMARK			cmp #DIRTYP ; IS IT A DIRECTORY?
				beq DIRPOS ; YES...
				lda #CPTERR ; NO, THERE IS A COMPATABLITY PROBLEM-
				jsr SYSERR ; THE DAMN THING SHOULD OF NEVER BEEN OPENED!
*
DIRPOS			lda SCRTCH ; RECOVER RESULTS OF PREVIOUS SUBTRACTION.
				lsr
				sta CNTENT ; BLOCKS MUST BE READ TO GET TO NEW POSITION.
				ldy #FCBMARK+1 ; TEST FOR POSITION DIRECTION.
				lda (FCBPTR),Y
				cmp TPOSLH ; CARRY INDICATES DIRECTION...
				bcc DIRFWRD ; IF SET, POSITION FORWARD.
DIRVRSE			ldy #0 ; OTHERWISE, READ DIRECTORY FILE IN REVERSE ORDER.
				jsr DIRPOS1 ; READ PREVIOUS BLOCK.
				bcs DRPOSERR ; BRANCH IF ANYTHING GOES WRONG.
				inc CNTENT ; COUNT UP TO 128
				bpl DIRVRSE ; LOOP IF THERE IS MORE BLOCKS TO PASS OVER.
				bmi SVMARK ; BRANCH ALWAYS.
*
DIRFWRD			ldy #2 ; POSITION IS FORWARD FROM CURRENT POSITION.
				jsr DIRPOS1 ; READ NEXT DIRECTORY BLOCK.
				bcs DRPOSERR

				dec CNTENT
				bne DIRFWRD ; LOOP IF POSITION NOT FOUND IN THIS BLOCK.
				beq SVMARK ; BRANCH ALWAYS.
*
DIRPOS1			lda (DATPTR),Y ; GET LINK ADDRESS OF PREVIOUS OR
				sta BLOKNML ; NEXT DIRECTORY BLOCK.
				iny ; BUT FIRST BE SURE THERE IS A LINK.
				cmp (DATPTR),Y
				bne DIRPOS2 ; BRANCH IF CERTAIN LINK EXISTS
				cmp #0 ; ARE BOTHE LINK BYTES 0?
				bne DIRPOS2 ; NOPE, JUST HAPPEN TO BE THE SAME VALUE.
				lda #EOFERR ; SOMETHING IS WRONG WITH THIS DIRECTORY FILE!
DRPOSERR		sec ; INDICATE ERROR
				rts 
*
DIRPOS2			lda (DATPTR),Y ; (HIGH ORDER BLOCK ADDRESS)
				sta BLOKNMH
* DROP INTO 'RFCBDAT' (READ FILE'S DATA BLOCK)
*
* NOTE: FOR DIRECTORY POSITIONING NO OPTIMIZATION HAS BEEN
* DONE SINCE DIRECTORY FILES WILL ALMOST ALWAYS BE LESS
* THAN 6 BLOCKS. IF MORE SPEED IS REQUIRED OR DIRECTORY
* TYPE FILES ARE TO BE USED FOR OTHER PURPOSES REQUIRING
* MORE BLOCKS, THEN THE RECOMMENDED METHOD IS TO CALL
* 'RFCBDAT' FOR THE FIRST BLOCK AND GO DIRECTLY TO
* DEVICE (VIA JMP (IOUNITL)) HANDLER FOR SUBSEQUENT
* ACCESSES.
* ALSO NOTE THAT NO CHECKING IS DONE FOR READ/WRITE
* ENABLE SINCE A DIRECTORY FILE CAN ONLY BE OPENED
* FOR READ ACCESS.
*
* PAGE
*
RFCBDAT			lda #RDCMD ; SET READ COMMAND.
				sta DHPCMD
				ldx #DATPTR ; USE X TO POINT AT ADDRESS OF DATA BUFFER
				jsr FILEIO1 ; GO DO FILE INPUT.
				ldy #FCBDATB ; SAVE BLOCK NUMBER JUST READ IN FCB.
				bcc FCBLOKNM ; BRANCH IF NO ERRORS HAPPENED.
				rts ; RETURN ERROR
*
RFCBIDX			lda #RDCMD ; PREPARE TO READ IN INDEX BLOCK.
				sta DHPCMD
				ldx #TINDX ; POINT AT ADDRESS OF CURRENT INDEX BUFFER
				jsr FILEIO1 ; GO READ INDEX BLOCK.
				bcs RDFCBERR ; REPORT ERROR
				ldy #FCBIDXB ; SAVE BLOCK ADDRESS OF THIS INDEX IN FCB.
FCBLOKNM		lda BLOKNML
				sta (FCBPTR),Y
				iny 
				lda BLOKNMH
				sta (FCBPTR),Y
				clc 
RDFCBERR		rts
*
RFCBFST			ldx #TINDX ; POINT AT ADDRESS OF INDEX BUFFER
				ldy #FCBFRST ; AND BLOCK ADDRESS OF FIRST FILE BLOCK IN FCB
				lda #RDCMD ; AND LASTLY, MAKE IT A READ!
* DROP INTO DOFILEIO
*
DOFILEIO		sta DHPCMD ; SAVE COMMAND.
				lda (FCBPTR),Y ; GET DISK BLOCK ADDRESS FROM FCB.
				sta BLOKNML
				iny ; BLOCK ZERO NOT LEGAL.
				cmp (FCBPTR),Y
				bne FILEIO
				cmp #0 ; ARE BOTH BYTES ZERO?
				bne FILEIO ; NO, CONTINUE WITH REQUEST.
				lda #ALCERR ; OTHERWISE REPORT ALLOCATION ERROR.
				jsr SYSDEATH ; NEVER RETURNS...
*
* PAGE
FILEIO			lda (FCBPTR),Y ; GET HIGH ADDRESS OF DISK BLOCK
				sta BLOKNMH
FILEIO1			lda 0,X ; GET MEMORY ADDRESS OF BUFFER FROM
				sta DBUFPL ; S.O.S. ZERO PAGE POINTED TO BY
				jsr WRAPADJ ;GO ADJUST FOR BANK CROSSING <SRS 82.162>
				lda 1,X
				sta DBUFPH ; SET HI BYTE
				lda SISTER+1,X ; AND BANK PAIR BYTE. <SRS 82.162>
				sta SISBPH

				ldy #FCBDEVN
				lda (FCBPTR),Y ; OF COURSE HAVING THE DEVICE NUMBER
				sta DEVNUM ; WOULD MAKE THE WHOLE OPERATION MORE MEANINGFUL...
FILEIO2			lda #2 ; ALSO, SET UP BYTE COUNT TO 512 AND
				sta RQCNTH ; SET 'BYTES READ' POINTER TO
				sta IOACCESS ; (INTERUPT! SET TO INDICATE REG CALL MADE TO DEV HANDLER. RETURN
INTERUPT!)
				lda #TRASH ; A PLACE TO THROW BYTES READ AWAY
				sta BRDPTR
				lda /TRASH ; LOCALLY DEFINED
				sta BRDPTR+1
				lda #0 ; SO THAT IT DOESN'T MESS UP ANY OTHER DATA.
				sta RQCNTL
				sta SSBRDPH ; ('BYTES READ' IS THROWN AWAY)
RPEATIO1		lda DEVNUM ; TRANSFER THE DEVICE NUMBER FOR DISPATCHER TO CONVERT TO UNIT NUMBER.
				sta UNITNUM
RPEATIO0		ldy #$9 ; PREPARE TO SAVE DEVICE PARMS
SAVPRMS			lda DEVICE,Y ; MOVE FROM Z PAGE
				sta RPTBLOK,Y ; TO MY OWN SPACE
				dey ; FROM $C9 THROUGH $C0
				bpl SAVPRMS
DMGRGO			.eq * ; CALL EXTERNAL DEVICE MANAGER
				lda #0
				sta SERR ; CLEAR GLOBAL ERROR VALUE
				jsr DMGR ; CALL THE DRIVER
				bcc RRITZ ; RTS IF NO ERRORS
				cmp #XDISKSW ; DISKSWITCH ITERATES
				beq RPEATIO2 ; BRANCH IF DISK SWITCH AND REPEAT I/O REQUEST
				sec ; REPORT ERROR
RRITZ			rts
RPEATIO2		ldy #$9 ; LENGTH OF PARM BLOCK
GETPRMS			lda RPTBLOK,Y
				sta DEVICE,Y ; RESTORE POSSIBLY DISTURBED PARM BLOCK
				dey 
				bpl GETPRMS
				jmp DMGRGO ; AND TRY THE I/O AGAIN
*
*
TRASH			.bs 2 ; ONLY USED TO PUT BYTES READ TO SLEEP
RPTBLOK			.bs 10 ; DMGR PARM SAVE BLOCK
*
*
WFCBFST			ldy #FCBDEVN ; FETCH THE
				lda (FCBPTR),Y ; DEVICE NUMBER
				tax ; AND UPDATE
				jsr UPBMAP ; ITS BITMAP
				ldx #TINDX ; POINT AT ADDRESS OF INDEX BLOCK
				ldy #FCBFRST ; AND THE DISK ADDRESS OF FILE'S FIRST BLOCK IN FCB
				lda #WRTCMD ; LASTLY, MAKE IT A WRITE REQUEST.
				jmp DOFILEIO ; AND GO DO IT!
*
WFCBDAT			ldx #DATPTR
				ldy #FCBDATB ; POINT AT MEMORY ADDRESS WITH X AND DISK ADDRESS WITH Y.
				lda #WRTCMD ; WRITE DATA BLOCK.
				jsr DOFILEIO
				bcs FILIOERR ; REPORT ANY ERRORS
				lda #$FF-DATMOD ; MARK DATA STATUS AS CURRENT.
				jmp FCBUPDAT
*
WFCBIDX			ldy #FCBDEVN ; MAKE SURE
				lda (FCBPTR),Y ; THE BITMAP
				tax ; FOR THIS DEVICE ("X")
				jsr UPBMAP ; IS UPDATED
				ldx #TINDX ; POINT AT ADDRESS OF INDEX BUFFER
				ldy #FCBIDXB ; AND BLOCK ADDRESS OF THAT INDEX BLOCK.
				lda #WRTCMD
				jsr DOFILEIO ; GO WRITE OUT INDEX BLOCK.
				bcs FILIOERR ; REPORT ANY ERRORS
				lda #$FF-IDXMOD ; MARK INDEX STATUS AS CURRENT.
FCBUPDAT		ldy #FCBSTAT ; CHANGE STATUS BYTE TO
				and (FCBPTR),Y ; REFLECT SUCCESSFUL DISK FILE UPDATE.
				sta (FCBPTR),Y ; (CARRY IS UNAFFECTED)
FILIOERR		rts
*
*
* PAGE
OPEN			jsr FINDFILE ; FIRST OF ALL LOOK UP THE FILE...
				bcc OPEN0
				cmp #BADPATH ; IS AN ATTEMPT TO OPEN A ROOT DIRECTORY?
				bne ERROPN ; NO, PASS BACK ERROR
*

OPEN0			jsr TSTOPEN ; FIND OUT IF ANY OTHER FILES ARE WRITING
				bcc OPEN1 ; TO THIS SAME FILE. (BRANCH IF NOT)
ERRBUSY			lda #FILBUSY ; REPORT SHARED ACCESS NOT ALLOWED.
ERROPN			sec
				rts ; RETURN ERROR.
*
OPEN1			lda DATPTR ; GET ADDRESS OF FIRST FREE FCB FOUND
				sta FCBPTR ; DURING TEST OPEN SEQUENCE AND USE
				lda DATPTR+1 ; IT AS FILE CONTROL AREA. IF HIGH BYTE OF
				sta FCBPTR+1 ; POINTER IS ZERO, THEN NO FCB
				bne ASGNFCB ; IS AVAILABLE FOR USE.
				lda #FCBFULL ; REPORT FCB FULL ERROR.
				sec 
				rts 
*
ASGNFCB			ldy #$1F ; ASSIGN FCB, BUT FIRST
				lda #0 ; CLEAN OUT ANY OLD RUBBISH LEFT AROUND...
CLRFCB			sta (FCBPTR),Y
				dey 
				bpl CLRFCB
				ldy #FCBENTN ; NOW BEGIN CLAIM BY MOVING IN FILE
FCBOWNR			lda D.DEV-1,Y ; OWNERSHIP INFORMATION.
				sta (FCBPTR),Y ; NOTE: THIS CODE DEPENDS UPON THE DEFINED
				dey ; ORDER OF BOTH THE FCB AND DIRECTORY ENTRY
				bne FCBOWNR ; BUFFER (D.). BEWARE OF CHANGES!!! *************
				lda DFIL+D.STOR ; GET STORAGE TYPE.
				lsr
				lsr
				lsr
				lsr
				tax ; SAVE IN X FOR LATER TYPE COMPARISON
				ldy #FCBSTYP
				sta (FCBPTR),Y ; SAVE STORAGE TYPE.
				lda C.OPLSTLN ; IS THERE AN OPEN LIST?
				beq DEFOPEN ; NO, USE DEFAULT REQUST ACCESS...
				ldy #0 ; YES, FIND OUT WHAT ACCESS IS REQUESTED.
				lda (C.OPLIST),Y ; IF REQ-ACCESS IS ZERO, THEN
				beq DEFOPEN ; USE DEFAULTS...
				and DFIL+D.ATTR ; CHECK REQUEST AGAINST ATTRIBUTES.
				cmp (C.OPLIST),Y ; WERE ALL ACCESS REQUESTS SATISFIED?
				beq SVATTRB ; YES, SAVE ATTRIBUTES.
				lda #ACCSERR ; REPORT ACCESS REQUEST CAN'T BE MET.
				sec 
				rts 
* PAGE
DEFOPEN			lda DFIL+D.ATTR ; GET FILES ATTRIBUTES AND
				and #READEN+WRITEN ; USE IT AS A DEFAULT ACCESS REQUEST.
SVATTRB			ldy #FCBATTR
				cpx #DIRTYP ; IF DIRECTORY, DON'T ALLOW WRITE ENABLE
				bne SVATTR1
				and #READEN
SVATTR1			sta (FCBPTR),Y
				and #WRITEN ; CHECK FOR WRITE ENABLED REQUESTED.
				beq OPEN2 ; BRANCH IF READ ONLY OPEN.
				lda TOTENT ; OTHERWISE, BE SURE NO ONE ELSE IS READING SAME
				bne ERRBUSY ; FILE (SET UP BY TSTOPEN).
OPEN2			lda DFIL+D.COMP ; OH, BY THE WAY... IS THIS FILE
				beq OPEN3 ; COMPATABLE WITH VERSION 0000? ***************
ERRCMPAT		lda #CPTERR ; REPORT FILE IS INCOMPATABLE!
				sec 
				rts 
*
OPEN3			cpx #TRETYP+1 ; IS IT A TREE TYPE FILE?
				bcc OPEN4 ; TEST FOR FURTHER COMPATABLITY. IT MUST
				cpx #DIRTYP ; BE EITHER A TREE OR A DIRECTORY.
				bne ERRCMPAT ; REPORT INCOMPATABLE.
OPEN4			ldy #FCBFRST ; MOVE ADDRESS OF FIRST BLOCK OF FILE
				lda DFIL+D.FRST ; INTO FCB. NO CHECKING IS DONE FOR VALIDITY.
				sta (FCBPTR),Y
				sta BLOKNML
				iny 
				lda DFIL+D.FRST+1
				sta (FCBPTR),Y ; NOTE: THE FCB HAS NOT BEEN OFFICIALLY
				sta BLOKNMH ; CLAIMED YET. TO DO THIS, THE FIRST BYTE
				ldy #FCBEOF ; MUST CONTAIN A VALID REFERENCE NUMBER.
EOFCBMV			lda DFIL+D.EOF-FCBEOF,Y ; MOVE CURRENT END OF FILE
				sta (FCBPTR),Y ; TO FCB.
				iny 
				cpy #FCBEOF+3
				bne EOFCBMV
				lda DFIL+D.USAGE

				sta (FCBPTR),Y ; AND CURRENT BLOCK COUNT OF FILE.
				iny 
				lda DFIL+D.USAGE+1
				sta (FCBPTR),Y
				lda C.OPLSTLN ; NOW THAT WE'VE COME THIS FAR, FIND
				beq DEFBUFR ; OUT WHICH TYPE OF BUFFER AND ALLOCATE IT!
				cmp #1 ; WAS IT ONLY TO SET ATTRIBUTES?
				beq DEFBUFR
				cmp #4 ; IS A FULL ADDRESS INCLUDED?
				beq UBUFSPEC
				lda #BADLSTCNT
				sec 
				rts 
*
* PAGE
UBUFSPEC		ldy #1 ; (INDEX TO 'PAGECNT' OF OPEN LIST)
				lda (C.OPLIST),Y ; IS USER SPECIFING THE BUFFER?
				beq DEFBUFR ; NO, USE DEFAULT BUFFER (DYNAMIC)
				cpx #TRETYP+1 ; IF TREE TYPE FILE, THEN AT LEAS 4 PAGES ARE NEEDED.
				bcc ONEKTST ; BRANCH IF TREE TYPE.
				cmp #2 ; DID USER GIVE AT LEAST 2 PAGES FOR DIRECTORY TYPE?
				bcs FIXDBUF ; YES, LOG IT WITH BUFFER MANAGER
ERRBTS			lda #BTSERR ; REPORT NOT ENOUGH BUFFER SPACE.
				sec 
				rts 
*
ONEKTST			cmp #4 ; IS THERE AT LEAST ONE KILOBYTE BUFFER FOR TREES?
				bcc ERRBTS ; NO, THEN TO HELL WITH IT!.
FIXDBUF			jsr REQFXBUF ; CALL BOB AND ASK FOR HIM TO FIX IT...
				bcc FCBUFFER ; GO SAVE BUFFER NUMBER.
ERROPN1			rts ; RETURN ANY ERROR ENCOUNTERED.
*
DEFBUFR			lda #4 ; ASSUME TREE FILE (4 PAGES REQUIRED)
				cpx #TRETYP+1
				bcc BUFREQST ; BRANCH IF IT IS A TREE.
				lda #2 ; OTHERWIZE, WE JUST NEED TWO PAGES.
BUFREQST		jsr REQBUF ; CALL BOB TO ALLOCATE A DYNAMIC BUFFER.
				bcs ERROPN1 ; REPORT ANY ERRORS.
FCBUFFER		ldy #FCBBUFN ; SAVE BUFFER NUMBER AND THEN
				sta (FCBPTR),Y ; FIND OUT WHERE IT IS.
				jsr GTBUFFRS ; HAVE BOB RETURN ADDRESS IN DATA & INDEX POINTERS.
				bcs ERROPEN2 ; IF ERROR, FREE BUFFER BEFOR RETURNING.
				ldy #FCBREFN ; NOW CLAIM FCB FOR THIS FILE.
				lda CNTENT ; THIS WAS SET UP BY 'TSTOPEN'.............
				sta (FCBPTR),Y
				ldy #FCBLEVL ; MARK LEVEL
				lda LEVEL ; AT WHICH
				sta (FCBPTR),Y ; FILE WAS OPENED
				ldy #FCBSTYP ; GET STORAGE TYPE AGAIN.
				lda (FCBPTR),Y ; FILE MUST BE POSITIONED TO BEGINNING.
				cmp #TRETYP+1 ; IS IT A TREE FILE?
				bcs OPNDIR ; NO, ASSUME IT'S A DIRECTORY.
				lda #$FF ; FOOL THE POSITION ROUTINE INTO GIVING
				ldy #FCBMARK ; A VALID POSITION WITH PRELOADED DATA, ETC.
OPNPOS			sta (FCBPTR),Y
				iny 
				cpy #FCBMARK+3
				bne OPNPOS
				ldy #2 ; SET DESIRED POSITION TO ZERO.
				lda #0
OPNPOS1			sta TPOSLL,Y
				dey 
				bpl OPNPOS1
				jsr RDPOSN ; LET TREE POSITION ROUTINE DO THE REST.
				bcc OPENDONE ; BRANCH IF SUCCESSFUL.
*
* PAGE
ERROPEN2		pha ; SAVE ERROR CODE.
				ldy #FCBBUFN ; SINCE ERROR WAS ENCOUNTERED BEFORE FILE
				lda (FCBPTR),Y ; WAS SUCCESSFULLY OPENED, THEN
				jsr RELBUF ; IT'S NECESSARY TO FREE THE BUFFER AND
				ldy #FCBREFN ; FILE CONTROL BLOCK.
				lda #0
				sta (FCBPTR),Y
				pla 
				sec 
				rts 
*
OPNDIR			jsr RFCBDAT ; READ IN FIRST BLOCK OF DIRECTORY FILE.
				bcs ERROPEN2 ; RETURN ANY ERROR AFTER FREEING BUFFER & FCB
OPENDONE		ldy #VCBOPNC ; INCREMENT OPEN COUNT FOR THIS

				lda (VCBPTR),Y ; VOLUME. ALSO MARK STATUS.
				clc 
				adc #1
				sta (VCBPTR),Y
				ldy #VCBSTAT ; HI BIT INDICATES VOLUME BUSY
				lda (VCBPTR),Y
				ora #$80
				sta (VCBPTR),Y ; DOESN'T MATTER HOW MANY, JUST BE SURE IT'S SET.
				ldy #FCBREFN ; PASS USER HIS REFERENCE NUMBER
				lda (FCBPTR),Y
				ldy #0
				sta (C.OUTREF),Y
				clc 
				rts 
*
* PAGE
*
TSTOPEN			lda FCBADDRH ; TEST FOR SHARED ACCESS FILES WITH WRITE ENABLED.
				sta FCBPTR+1
				lda FCBANKNM
				sta SISFCBP
				lda #0
				sta DATPTR+1 ; MARK AS NO FREE FOUND.
				sta CNTENT
				sta TOTENT ; ALSO, INIT COUNT OF MATCHING FILES
TSTOPN1			sta FCBPTR ; SAVE NEW LOW ORDER ADDRESS
				ldx DATPTR+1 ; FIND OUT IF A FREE SPOT HAS BEEN FOUND YET.
				bne TSTOPN2 ; YES, DON'T INCREMENT REFNUM (CNTENT).
				inc CNTENT ; BUMP REFNUM
TSTOPN2			ldy #FCBREFN ; TEST FOR IN USE FCB
				lda (FCBPTR),Y ; (NON ZERO)
				bne CHKACTV ; THIS FCB IS IN USE, COPARE OWNERSHIP.
				txa ; TEST AGAIN FOR FREE FCB
				bne TSNXFCB ; BRANCH IF A FREE SPOT HAS ALREADY BEEN FOUND.
				lda FCBPTR ; TRANSFER CURRENT POINTER SO IT MAY BE
				sta DATPTR ; USED AS A FREE FCB BY OPEN.
				lda FCBPTR+1 ; HIGH BYTE ALWAYS NON ZERO.
				sta DATPTR+1
				jmp TSNXFCB
*
CHKACTV			.eq * ; IF MATCHING FILE IS SWAPPED, IT DOESNT COUNT
				ldy #FCBSWAP
				lda (FCBPTR),Y
				bne TSNXFCB ; BRANCH IF SWAPPED
				ldy #FCBENTN ; NOTE: THIS CODE DEPENDS ON THE
WHOWNS			lda (FCBPTR),Y ; DEFINED ORDER OF FCB AND DIRECTORY
				cmp D.DEV-1,Y ; *****************************
				bne TSNXFCB ; BRANCH IF THIS ONE HAS A DIFFERENT OWNER.
				dey 
				bne WHOWNS
				inc TOTENT ; REPORT THIS ONE AS A CO-OWNER.
				ldy #FCBATTR ; NOW FIND OUT IF THIS ONE WANTS TO WRITE.
				lda (FCBPTR),Y
				and #WRITEN ; IF WRITE IS NOT ENABLED THEN CONTINUE.
				beq TSNXFCB
				sec ; OTHERWISE, JUST SET THE CARRY TO SHOW
				rts ; THAT THE FILE CAN'T BE SHARED.
*
TSNXFCB			lda FCBPTR ; CALCULATE NEXT FCB AREA (+$20)
				clc 
				adc #$20
				bcc TSTOPN1 ; LOOP IF NO PAGE CROSS.
				ldx FCBPTR+1
				inc FCBPTR+1
				cpx FCBADDRH ; HAVE WE LOOKED AT BOTH PAGES?
				beq TSTOPN1 ; NOPE, LOOK AT PAGE TWO.
				clc ; INDICATE NO FILES THAT SHARE HAVE WRITE ENABLED,
				rts 
*
* CHN READ/WRITE,4,2

*************************************************************************
* END OF APPLE /// SOS 1.3 SOURCE CODE FILE: POSN.OPEN
*************************************************************************





*--------------------------------------
MAN
SAVE /A3OSX.BUILD/SOS.ORIG/SOS.S.POSN.OPEN
LOAD /A3OSX.BUILD/SOS.ORIG/SOS.S
ASM
