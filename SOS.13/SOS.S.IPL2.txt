NEW
  AUTO 3,1
*--------------------------------------
*************************************************************************  
* APPLE /// SOS 1.3 SOURCE CODE FILE: IPL.SRC2  
*************************************************************************  
* ASSEMBLER: APPLE ][ 6502 ASSEMBLER from APPLE COMPUTER TOOLKIT  
				 
SBTL			 "SYSTEM INTERNAL RESOURCES"  
REP				 60  
*  
* SYSTEM INTERNAL RESOURCE NUMBERS  
*  
*  
* SIR RESOURCE  
*  
* 0 SOUND PORT / I/O NMI  
* 1 ACIA  
* 2 E.CA2 -- KEYBOARD  
* 3 E.CA1 -- CLOCK  
* 4 E.SR  
* 5 E.CB2 -- VBL +  
* 6 E.CB1 -- VBL -  
* 7 E.T2  
* 8 E.T1  
* 9 D.CA2 -- CSP INPUT FLAG / INPUT SWITCH 1  
* A D.CA1 -- ANY SLOT (RESERVED FOR SOS)  
* B D.SR -- CSP DATA REGISTER  
* C D.CB2 -- CSP DATA I/O / ENSIO  
* D D.CB1 -- CSP CLOCK / ENSEL / A/D SELECT / INPUT SW3  
* E D.T2  
* F D.T1  
* 10 DISK STEPPER / GRAPHICS SCROLL / CHARACTER DOWNLOAD  
* 11 SLOT 1  
* 12 SLOT 2  
* 13 SLOT 3  
* 14 SLOT 4  
* 15 (UNASSIGNED)  
* 16 (UNASSIGNED)  
* 17 (UNASSIGNED)  
*  
REP				 60  
SBTL			 "RESOURCE ALLOCATION & DEALLOCATION"  
REP				 60  
*  
* RESOURCE ALLOCATION AND DEALLOCATION  
*  
* SIRS ARE ALLOCATED AND DEALLOCATED BY THE SUBROUTINES  
* 'ALLOCSIR' AND 'DEALCSIR'. THE RESOURCE PARAMETERS ARE  
* PASSED IN A TABLE THAT CONTAINS ONE FIVE-BYTE ENTRY FOR  
* EACH SIR THAT IS TO BE ALLOCATED OR DEALLOCATED. THE  
* TABLE ENTRY FORMAT IS SHOWN BELOW:  
*  
* 0 1 2 3 4  
* +-------+-------+-------+-------+-------+  
* | SIR # | ID | ADR.L | ADR.H | ADR.B |  
* +-------+-------+-------+-------+-------+  
*  
* SIR # -- SYSTEM INTERNAL RESOURCE NUMBER  
* ID -- IDENTIFICATION BYTE  
* SUPPLIED BY ALLOCSIR, CHECKED BY DEALCSIR  
* ADR -- INTERRUPT ADDRESS (LOW, HIGH, BANK)  
* ZERO IF NO INTERRUPT HANDLER  
*  
*  
* ALLOCSIR -- ALLOCATE SYSTEM INTERNAL RESOURCES  
*  
* PARAMETERS:  
* A: NUMBER OF BYTES IN TABLE  
* X: TABLE ADDRESS (LOW BYTE)  
* Y: TABLE ADDRESS (HIGH BYTE)  
*  
* NORMAL EXIT -- SIRS ALLOCATED  
* CARRY: CLEAR  
* A, X, Y: UNDEFINED  
*  
* ERROR EXIT -- SIRS NOT ALLOCATED  
*CARRY: SET
*X: SIR NUMBER
* A, Y: UNDEFINED  
*  
*  
* DEALCSIR -- DEALLOCATE SYSTEM INTERNAL RESOURCES  
*  
* PARAMETERS:  
* A: NUMBER OF BYTES IN TABLE  
* X: TABLE ADDRESS (LOW BYTE)  
* Y: TABLE ADDRESS (HIGH BYTE)  
*  
* NORMAL EXIT -- SIRS DEALLOCATED  
* CARRY: CLEAR  
* A, X, Y: UNDEFINED  
*  
* ERROR EXIT -- SIRS NOT DEALLOCATED  
* CARRY: SET  
* X: SIR NUMBER  
* A, Y: UNDEFINED    
*     
				REP 60   
				PAGE    
*     
IDBYTE			 DFB $81   
*     
ALLOCSIR		 EQU *   
				CLC    
				PHP    
				SEI    
				STA SIRARGSIZ ;SAVE TABLE SIZE  
				LDA E.REG   
				STA SIRTEMP   
				ORA #BITON2 ;FORCE PRIMARY STACK  
				AND #BITOFF3 ; AND WRITE ENABLE  
				STA E.REG   
				LDA SIRTEMP   
				PHA    
				LDA Z.REG   
				PHA    
				LDA #$00   
				STA Z.REG ;SET ZERO PAGE := $00  
				STX SIRARGS   
				STY SIRARGS+1 ;SET POINTER TO TABLE  
*     
				LDY #$00   
ASIR010			 LDA (SIRARGS),Y ;GET SIR NUMBER  
				CMP #SIRTBLSIZ   
				TAX    
				BCS ASIR020   
				LDA SIRTABLE,X ;CHECK ALLOCATION  
				BMI ASIR020   
				LDA IDBYTE   
				STA SIRTABLE,X ;ALLOCATE SIR  
				INY    
				STA (SIRARGS),Y ;RETURN ID BYTE  
				INY    
				LDA (SIRARGS),Y   
				STA SIRADR.L,X ;SAVE INTERRUPT ADDRESS  
				INY    
				LDA (SIRARGS),Y   
				STA SIRADR.H,X   
				INY    
				LDA (SIRARGS),Y   
				STA SIRADR.B,X   
				INY    
				CPY SIRARGSIZ   
				BCC ASIR010   
*     
				CLC    
				INC IDBYTE ;BUMP ID BYTE  
				BMI SIREXIT   
				LDA #$81   
				STA IDBYTE   
				BMI SIREXIT   
*     
ASIR020			 STX SIRTEMP ;SAVE BAD SIR NUMBER  
ASIR030			 SEC    
				TYA    
				SBC #5   
				TAY    
				BCC ASIR040   
				LDA (SIRARGS),Y ;GET SIR NUMBER  
				TAX    
				LDA #FALSE   
				STA SIRTABLE,X ;RELEASE ALLOCATED SIRS  
				BEQ ASIR030   
*     
ASIR040			 LDX SIRTEMP ;RETURN BAD SIR  
				SEC    
*     
*     
*     
SIREXIT			 PLA    
				STA Z.REG ;RESTORE Z REGISTER  
				PLA    
				STA E.REG ;RESTORE E REGISTER  
				BCC SIREXIT1   
				PLA    
				ORA #BITON0   
				PHA    
SIREXIT1		 PLP    
				RTS    
*     
*     
*     
DEALCSIR		 EQU *   
				CLC    
				PHP    
				SEI    
				STA SIRARGSIZ ;SAVE TABLE SIZE  
				LDA E.REG   
				STA SIRTEMP   
				ORA #BITON2 ;FORCE PRIMARY STACK  
				AND #BITOFF3 ; AND WRITE ENABLE  
				STA E.REG   
				LDA SIRTEMP   
				PHA    
				LDA Z.REG   
				PHA    
				LDA #$00   
				STA Z.REG ;SET ZERO PAGE := $00  
				STX SIRARGS   
				STY SIRARGS+1 ;SET POINTER TO TABLE  
*     
				LDY #$00   
DSIR010			 LDA (SIRARGS),Y ;GET SIR NUMBER  
				TAX    
				CPX #SIRTBLSIZ   
				BCS DSIR030   
				INY    
				LDA SIRTABLE,X   
				BPL DSIR030 ;VERIFY ALLOCATION  
				CMP (SIRARGS),Y   
				BNE DSIR030   
				INY    
				INY    
				INY    
				INY    
				CPY SIRARGSIZ   
				BCC DSIR010   
*     
				LDY SIRARGSIZ   
DSIR020			 SEC    
				TYA    
				SBC #5   
				TAY    
				BCC SIREXIT   
				LDA (SIRARGS),Y ;GET SIR NUMBER  
				TAX    
				LDA #FALSE   
				STA SIRTABLE,X   
				BEQ DSIR020   
*     
DSIR030			 SEC    
				BCS SIREXIT  
				SBTL "SELECT I/O EXPANSION ROM"  
				REP 60  
*  
* SUBROUTINE 'SELC800' IS CALLED TO SELECT THE C800 I/O EX-  
* PANSION ADDRESS SPACE FOR A PERIPHERAL SLOT. ON ENTRY,  
* THE SLOT NUMBER IS PASSED IN THE ACCUMULATOR. IF NO  
* ERROR OCCURS, CARRY IS CLEARED; OTHERWISE, CARRY IS SET  
* AND THE PREVIOUS SLOT REMAINS SELECTED.  
*  
* PARAMETERS:  
* A: SLOT NUMBER  
*  
* NORMAL EXIT -- NEW SLOT SELECTED  
* CARRY: CLEAR  
* A: UNDEFINED  
* X, Y: UNCHANGED  
*  
* ERROR EXIT -- SLOT NOT CHANGED  
* CARRY: SET  
* A, X, Y: UNCHANGED  
*  
* WARNING !!!  
* 'SELC800' USES SELF-MODIFYING CODE!  
*  
REP				 60  
*  
SELC800			 EQU *  
CMP				 #$05 ;CHECK SLOT NUMBER  
BCS				 SC8EXIT ; INVALID  
PHP				  
SEI				  
STA				 EXPNSLOT  
ORA				 #$C0 ;MAKE SLOT INTO $CN00  
STA				 CNADDR+2 ; AND MODIFY BIT ADDRESS  
BIT				 $C020  
BIT				 $CFFF ;DESELECT PREVIOUS SLOT  
CNADDR			 BIT $C0FF ; AND SELECT CURRENT SLOT  
PLP				  
SC8EXIT			 RTS  
SBTL			 "NMI DISABLE / ENABLE"  
REP				 60  
*  
* THE SUBROUTINES NMIDSBL AND NMIENBL ARE CALLED TO  
* DISABLE AND ENABLE NMI, RESPECTIVELY. THERE ARE NO  
* INPUT PARAMETERS. ON EXIT, THE REGISTERS ARE UN-  
* DEFINED. NMIDSBL CLEARS THE CARRY FLAG IF NMI WAS  
* SUCCESSFULLY DISABLED; OTHERWISE, CARRY IS SET.  
*  
REP				 60  
*  
NMIDSBL			 EQU *  
LDX				 E.REG  
BIT				 NMIFLAG  
BPL				 NDS020  
TXA				  
ORA				 #BITON7  
STA				 E.REG ;SET 1MHZ  
LDA				 #$00  
STA				 NMICNTR  
STA				 NMICNTR+1  
NDS010			 BIT NMIFLAG ;NMI PENDING?  
BPL				 NDS020 ; NO  
INC				 NMICNTR ;BUMP NMI COUNTER  
BNE				 NDS010 ; AND RECHECK NMI FLAG  
INC				 NMICNTR+1  
BNE				 NDS010  
LDA				 #>NMIHANG ;CAN'T LOCK NMI  
JSR				 SYSDEATH  
NDS020			 TXA ;GET E.REG  
AND				 #BITOFF4 ;DISABLE NMI  
STA				 E.REG  
RTS				  
*  
*  
*  
NMIENBL			 EQU *  
LDA				 E.REG  
ORA				 #BITON4 ;ENABLE NMI  
STA				 E.REG  
RTS				  
SBTL			 "KEYBOARD NMI HANDLER"  
REP				 60  
*  
* BY DEFAULT, KEYBOARD NMI IS IGNORED. THE USER MAY  
* PROCESS NMI BY CHANGING THE ADDRESS IN SYSTEM GLOBAL.  
*  
REP				 60  
*  
NMIDBUG			 EQU *  
				TSX  ;SAVE THE STACK POINTER  
				STX NMISPSV   
				LDA #$03 ;SELECT MONITOR'S ZERO PAGE  
				STA Z.REG   
				LDA E.REG   
				ORA #$03 ;SELECT MONITOR ROM  
				STA E.REG   
				JSR $F901 ;CALL THE MONITOR  
*     
NMICONT			 EQU *   
				LDA E.REG   
				ORA #BITON2 ;FORCE PRIMARY STACK  
				STA E.REG   
				LDX NMISPSV   
				TXS  ;RESTORE STACK POINTER  
				RTS    
				SBTL "EVENT QUEUE MANAGER"   
				REP 60   
*     
* THE EVENT QUEUE IS USED TO HOLD THE PARAMETERS OF EVENTS  
* THAT HAVE BEEN DETECTED BUT NOT YET RECOGNIZED. EVENT  
* QUEUE ENTRIES ARE ORGANIZED INTO TWO LINKED LISTS; A FREE  
* LIST AND AN ACTIVE LIST. EACH ENTRY IS SIX BYTES LONG,  
* WITH THE FIRST BYTE (BYTE 0) USED AS A LINK. THE LINK  
* BYTE CONTAINS THE TABLE INDEX OF THE NEXT ENTRY IN THE  
* LIST. BECAUSE OF THE INDEXING METHOD, THE EVENT QUEUE  
* MUST NOT EXCEED 256 BYTES.  
*  
* ENTRY ZERO IS A SPECIAL ENTRY. BYTE 0 IS THE INDEX OF  
* THE FIRST ACTIVE ENTRY; BYTE 1 CONTAINS A ZERO, ALLOWING  
* ENTRY 0 TO BE USED AS THE ACTIVE EVENT LIST TERMINATER;  
* BYTE 2 CONTAINS THE INDEX OF THE FIRST FREE ENTRY; AND  
* BYTES 4 THROUGH 6 ARE UNUSED.  
*  
* THE FREE LIST IS LINKED LIFO. THE ONLY VALID BYTE IN A  
* FREE ENTRY IS THE LINK BYTE; THE REMAINING BYTES ARE  
* UNDEFINED. THE FREE LIST IS TERMINATED BY A LINK BYTE  
* CONTAINING A ZERO.  
*  
* THE ACTIVE LIST IS LINKED IN DECREASING PRIORITY ORDER  
* WITH ENTRIES OF EQUAL PRIORITY LINKED FIFO. BYTES 1  
* THROUGH 5 CONTAIN THE EVENT PRIORITY, EVENT ID, LOW BYTE  
* OF THE EVENT ADDRESS, HIGH BYTE OF THE EVENT ADDRESS, AND  
* THE ADDRESS BANK. THE ACTIVE LIST IS TERMINATED BY AN  
* ENTRY WITH AN EVENT PRIORITY OF ZERO.  
*  
REP				 60  
PAGE			  
REP				 60  
*  
* SUBROUTINE 'QUEEVENT' IS USED TO ENTER AN EVENT INTO THE  
* EVENT QUEUE. ACTIVE EVENTS ARE LINKED IN DECREASING  
* PRIORITY ORDER WITH EVENTS OF EQUAL PRIORITY LINKED FIFO.  
* EVENTS ARE REMOVED FROM THE QUEUE AS THEY ARE RECOGNIZED  
* BY THE DISPATCHER.  
*  
* PARAMETERS:  
* X: EVENT PARAMETER ADDRESS (LOW BYTE)  
* Y: EVENT PARAMETER ADDRESS (HIGH BYTE)  
*  
* EVENT 0 1 2 3 4  
* PARMS: +-------+-------+-------+-------+ +  
* | PRI | ID | ADR.L | ADR.H | ADR.B |  
* +-------+-------+-------+-------+-------+  
* PRI: EVENT PRIORITY  
* ID: EVENT ID BYTE  
* ADR: EVENT ADDRESS (LOW, HIGH, BANK)  
*  
* EXIT CONDITIONS:  
* CARRY: CLEAR  
* A, X, Y: UNDEFINED  
*  
REP				 60  
*  
QUEEVENT		 EQU *  
CLC				  
PHP				  
SEI				  
LDA				 E.REG  
STA				 QEVTEMP  
ORA				 #BITON2 ;FORCE PRIMARY STACK  
				AND #BITOFF3 ; AND WRITE ENABLE  
				STA E.REG   
				LDA QEVTEMP   
				PHA    
				LDA Z.REG   
				PHA    
				LDA #0   
				STA Z.REG ;SET ZERO PAGE := 0  
*     
				STX QEVARGS   
				STY QEVARGS+1 ;SET ARGUMENT POINTER  
				LDY #0   
				LDA (QEVARGS),Y ;GET PRIORITY  
				BEQ Q.EXIT ; IGNORE IF ZERO  
*     
				LDX EVQ.FREE   
				BEQ Q.FULL   
				STX QEV.THIS ;GET FIRST FREE ENTRY  
				LDA EVQ.LINK,X ; AND DELINK IT  
				STA EVQ.FREE   
*     
				LDY #EVQ.SIZ-2   
QEV010			 LDA (QEVARGS),Y ;COPY ARGUMENTS  
				STA EVQ.BANK,X ; INTO NEW ENTRY  
				DEX    
				DEY    
				BPL QEV010   
*     
				LDX QEV.THIS   
				LDY #0   
QEV020			 STY QEV.LAST   
				LDA EVQ.LINK,Y   
				TAY    
				LDA EVQ.PRI,Y ;SCAN EVENT QUEUE  
				CMP EVQ.PRI,X ; FOR PROPER POSITION  
				BCS QEV020   
*     
				TYA    
				STA EVQ.LINK,X ;RELINK EVENT INTO QUEUE  
				TXA    
				LDY QEV.LAST   
				STA EVQ.LINK,Y   
*     
Q.EXIT			 PLA    
				STA Z.REG ;RESTORE Z REGISTER  
				PLA    
				STA E.REG ;RESTORE E REGISTER  
				PLP    
				RTS    
*     
Q.FULL			 LDA #>EVQOVFL ;EVENT QUEUE OVERFLOW  
				JSR SYSDEATH   
				LST ON   
				    
ZZEND			 EQU *   
ZZLEN			 EQU ZZEND-ZZORG   
				IFNE ZZLEN-LENIPL   
				FAIL 2,"SOSORG FILE IS INCORRECT FOR IPL"  
				FIN    
				    
*************************************************************************  
* END OF APPLE /// SOS 1.3 SOURCE CODE FILE: IPL.SRC2  
*************************************************************************  
				 
				 
*--------------------------------------
MAN
SAVE /A3OSX.BUILD/SOS.13\sos.s.ipl2.txt
LOAD /A3OSX.BUILD/SOS.13/sos.s
ASM
