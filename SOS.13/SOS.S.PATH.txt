NEW
  AUTO 3,1
*--------------------------------------
*************************************************************************  
* APPLE /// SOS 1.3 SOURCE CODE FILE: PATH  
*************************************************************************  
* ASSEMBLER: APPLE ][ 6502 ASSEMBLER from APPLE COMPUTER TOOLKIT  
				 
PAGE			  
*  
*  
*  
BFMGR			 LDX COMMAND ; WHAT CALL?  
*  
*  
*  
LDA				 DISPTCH,X ; TRANSLATE INTO COMMAND ADDRESS  
ASL				 A ; (BIT 7 INDICATES IT'S GOT A PATHNAME TO PREPROCESS)  
STA				 CMDTEMP  
AND				 #$3F ; (BIT 6 IS REFNUM PREPROCESS, 5 IS FOR TIME, SO STRIP EM.)  
TAX				  
LDA				 CMDTABLE,X ; MOVE ADDRESS FOR INDIRECT JUMP.  
STA				 CMDADR  
LDA				 CMDTABLE+1,X ; (HIGH BYTE)  
STA				 CMDADR+1  
LDA				 #<VCB  
STA				 VCBPTR+1 ; INSURE DEFAULT HI ADDRESS TO VCB BEFORE CALLS  
LDA				 #BKBITVAL ; INIT "BACKUP BIT FLAG"  
STA				 BKBITFLG ; TO SAY "FILE MODIFIED"  
LDY				 #MAXTEMPS ; ZERO OUT SISTER PAGE FOR TEMPS  
LDA				 #0  
STA				 SERR ; MAKE GLOBAL ERROR SAY "NONE"  
STA				 DSWGLOB ; "DISK SWITCH GLOBAL"  
STA				 DUPLFLAG ; "DUPLICATE VOLUME ON LINE"  
STA				 CFLAG ; SET "CREATE" TO NO  
STA				 BLOKSAVE  
STA				 BLOKSAVE+1 ; SET PARENT DIRECTORY TO NULL  
CLRSIS			 STA SISTEMPS,Y  
DEY				  
BPL				 CLRSIS ; CARRY IS UNDISTURBED BY THIS LOOP  
BCC				 NOPATH  
JSR				 SETPATH ; GO PROCESS PATHNAME BEFORE CALLING COMMAND  
BCS				 ERRORSYS ; BRANCH IF BAD NAME.  
NOPATH			 ASL CMDTEMP ; TEST FOR REFNUM PREPROCESSING  
BCC				 NOPREREF  
JSR				 FINDFCB ; GO SET UP POINTERS TO FCB AND VCB OF THIS FILE.  
BCS				 ERRORSYS ; BRANCH IF ANY ERRORS ARE ENCOUNTERED.  
NOPREREF		 ASL CMDTEMP ; LASTLY CHECK FOR NECESSITY OF TIME STAMP.  
BCC				 TSWVRFY  
LDX				 #DATELO ; PASS Z PAGE ADDRESS OF WHERE TO RETURN DATE/TIME  
JSR				 DATETIME ; (NO ERROR POSIBLE)  
TSWVRFY			 LDX COMMAND ; TEST FOR NECESSITY OF VOLUME VERIFICATION  
LDA				 #PREPATH+PREREF+PRETIME ; TO ENSURE VCB IS SET  
AND				 DISPTCH,X  
BEQ				 EXECUTE  
LDY				 #VCBSTAT  
LDA				 (VCBPTR),Y  
AND				 #DSWITCH ; WAS THE VOLUME PREVIOUSLY SWITCHED?  
BEQ				 EXECUTE  
DEY				 ; GET DEVICE NUMBER  
LDA				 (VCBPTR),Y  
STA				 DEVNUM  
DVERIFY			 JSR VERFYVOL ; SEE IF PROPER VOLUME NOW ON LINE  
BCC				 CLRDSWT ; BRANCH IF YES  
JSR				 USRREQ ; OTHERWISE REQUEST IT BE PUT ON LINE  
BCC				 DVERIFY ; USER SEZ S/HE DID: CHECK IT OUT  
LDA				 #VNFERR ; VOLUME NOT FOUND IF USER REFUSES  
BNE				 ERRORSYS ; REPORT ERROR (BRANCH ALWAYS)  
CLRDSWT			 LDY #VCBSTAT ; GET VOLUME  
LDA				 (VCBPTR),Y ; STATUS  
AND				 #$FF-DSWITCH ; TURN OFF DISK SWITCH  
STA				 (VCBPTR),Y ; SO WE WON'T VERIFY NEXT TIME  
EXECUTE			 JSR GOCMD ; EXECUTE COMMAND  
BCC				 GOODOP ; BRANCH IF SUCCESSFUL  
CMP				 #XDISKSW ; DISK SWITCH?  
BNE				 ERRORSYS ; NO, REPORT SOME OTHER  
LDY				 #VCBSTAT ; MARK VCB WITH SWITCH  
LDA				 (VCBPTR),Y  
AND				 #$FF-DSWITCH ; TO ENSURE VOLUME VERIFIED  
				BPL ERRCMD ; NO FILES OPEN SO DSWITCH CANT APPLY  
				ORA #DSWITCH   
ERRCMD			 STA (VCBPTR),Y   
				JMP BFMGR ; TRY THE COMMAND AGAIN  
*     
ERRORSYS		 JSR SYSERR   
GOODOP			 RTS  ; GOOD RETURN  
*     
GOCMD			 JMP (CMDADR)   
*     
				PAGE    
*     
CMDTABLE		 EQU *   
				DW CREATE   
				DW DESTROY   
				DW RENAME   
				DW SETINFO   
				DW GETINFO   
				DW VOLUME   
				DW SETPREFX   
				DW GETPREFX   
				DW OPEN   
				DW NEWLINE   
				DW READ   
				DW WRITE   
				DW CLOSE   
				DW FLUSH   
				DW SETMARK   
				DW GETMARK   
				DW SETEOF   
				DW GETEOF   
*     
DISPTCH			 EQU *   
				DFB PREPATH+PRETIME+0 ; CREATE  
				DFB PREPATH+PRETIME+1 ; DESTROY  
				DFB PREPATH+PRETIME+2 ; RENAME  
				DFB PREPATH+PRETIME+3 ; SETINFO  
				DFB PREPATH+4 ; GETINFO  
				DFB 5 ; VOLUME  
				DFB 6 ; SETPREFIX, PATHNAME MOVED TO PREFIX BUFFER  
				DFB 7 ; GETPREFIX  
				DFB PREPATH+8 ; OPEN  
				DFB PREREF+$9 ; NEWLINE  
				DFB PREREF+$A ; READ  
				DFB PREREF+$B ; WRITE  
				DFB PRETIME+$C ; CLOSE  
				DFB PRETIME+$D ; FLUSH, REFNUM MAY BE ZERO TO FLUSH ALL.  
				DFB PREREF+$E ; SETMARK  
				DFB PREREF+$F ; GETMARK  
				DFB PREREF+$10 ; SET EOF  
				DFB PREREF+$11 ; GET EOF  
*     
				PAGE    
*     
SETPATH			 LDA C.PATH ; FOR A REGULAR PATHNAME,  
				STA TPATH ; SET UP TEMP POINTER TO PROCESS  
				LDA C.PATH+1 ; PATHNAME AND CHECK FOR SYNTAX ERRORS  
				STA TPATH+1   
				LDA SISPATH   
				STA SISTPATH ; (LEAVE CALL PARAMETERS ALONE!)  
* DROP INTO 'SYNPATH'  
*  
SYNPATH			 LDA #>PATHBUF ; SET UP DEFAULT ADDRESS FOR  
				STA PATHNML ; SYNTAXED PATHNAME -  
				STA WRKPATH ; LENGTH, NAME, LENGTH, NAME, ETC...  
				LDA #<PATHBUF   
				STA PATHNMH   
				STA WRKPATH+1 ; (ASSUMES FULL PATHNAME, NO PREFIX).  
				LDX #0 ; USE INDEXED INDIRECT FOR SOURCE PATHNAME  
				TXA  ; SET BEGINNING OF PATH  
				STA (PATHNML,X) ; TO ZERO TO INDICATE NOTHING PROCESSED.  
				TAY    
				LDA (TPATH,X) ; GET TOTAL LENGTH OF SOURCE PATHNAME  
				BMI ERRSYN   
				BEQ ERRSYN   
				STA PATHCNT ; (THIS IS USED AS A 'COUNT-DOWN')  
				JSR INCTPTH ; INCREMENT SOURCE POINTER  
				LDA (TPATH,X) ; GET FIRST CHARACTER OF PATHNAME  
				CMP #DLIMIT ; IS IT A FULL PATHNAME (NO PREFIX)?  
				BEQ BUMPATH ; YES, WE'RE READY TO DO IT.  
				CMP #$2E ; IS IT A DRIVE NAME '.'?  
				BNE ADPREFIX ; NO, ADD PREFIX TO BEGINNING  
DRIVENAM		 LDA (TPATH,X) ; MOVE DRIVE NAME FOR VOLUME CALL  
				CMP #DLIMIT ; HAVE WE MOVED ENTIRE NAME?  
				BEQ PREVOLM ; YES, PROCESS IT.  
				INY  ; (IF THIS IS THE FIRST, MAKE ROOM FOR LENGTH OF NAME)  
				STA (WRKPATH),Y   
				JSR INCTPTH ; BUMP POINTER TO GIVEN NAME.  
				DEC PATHCNT   
				BNE DRIVENAM   
				BEQ PREVOLM1   
*     
				PAGE    
PREVOLM			 JSR INCTPTH ; MAKE IT SO POINTING PAST DELIMITER.  
				DEC PATHCNT   
PREVOLM1		 TYA  ; SAVE LENGTH OF DRIVE NAME.  
				STA (WRKPATH,X)   
				LDA #>PATHBUF ; POINT AT PATHNAME BUFFER FOR DEVICE ID CALL.  
				STA DVNAMP   
				LDA #<PATHBUF   
				STA DVNAMP+1   
				LDA #0 ; MAKE VIRTUAL POINT AT SWITCHED IN BANK.  
				STA SISTER+DVNAMP+1   
				JSR SRCHDEV ; GO IDENTIFY WHICH VOLUME  
				BCC PREVOLM2 ; BRANCH IF NO ERROR  
				CMP #VNFERR ; WAS IT REPORTED AS 'VOLUME NOT FOUND'?  
				BNE SPTHERR ; NO SOME OTHER ERROR WAS ENCOUNTERED.  
				LDX DUPLFLAG ; YES, WAS IT NOT FOUND BECAUSE SOME OTHER 'OPEN' VOLUME HAS SAME NAME?  
				BEQ SPTHERR ; NO, IT SIMPLY WASN'T FOUND.  
				LDA #DUPVOL ; (CARRY IS SET)  
				RTS    
*     
PREVOLM2		 LDY #0 ; (X CONTAINS AN INDEX TO VCB)  
				LDA VCB,X ; GET VOLUME NAME LENGTH.  
				STA PATHBUF,Y   
SPATH2			 INX  ; MOVE VOLUME NAME INTO PATH NAME BUFFER IN  
				INY  ; PLACE OF DISK DEVICE NAME ('.D1' OR SIMULAR)  
				LDA VCB,X   
				STA PATHBUF,Y   
				CPY PATHBUF ; HAVE ALL CHARACTERS BEEN MOVED?  
				BNE SPATH2   
				LDX #0 ; RESET X FOR INDEXING  
				STX PATHNML   
				LDA #<PATHBUF   
				STA PATHNMH   
				LDA PATHCNT ; IS THAT ALL THERE IS?  
				BNE SPATH3 ; NO, MORE TO COME...  
				CLC    
				JMP ENDPATH   
*     
SPATH3			 INY  ; BUMP TO END OF NAME+1  
				STY WRKPATH ; RESET WORKPATH POINTER TO CURRENT.  
				LDA #0 ; RESET PATHNAME BUFFER POINTER.  
				LDY #<PATHBUF   
				BNE NOPREFX ; BRANCH ALWAYS...  
*     
ERRSYN			 LDA #BADPATH ; RETURN SYNTAX ERROR  
SPTHERR			 SEC    
				RTS    
*     
ADPREFIX		 LDA PFIXPTR ; GET POINTER TO BEGINNING OF THE  
				LDY PFIXPTR+1 ; PREFIX.  
NOPREFX			 STA PATHNML   
				STY PATHNMH ; IF NO PRESET PREFIX, THIS IS THE SAME AS  
				BNE FRSTCHAR ; PATHBUF ADDRESS. (BRANCH ALWAYS TAKEN)  
*     
				PAGE    
*     
BUMPATH			 DEC PATHCNT ; FIRST ADJUST COUNT  
				CLC  ; (JUST IN CASE OF LAST CHARACTER)  
				BEQ ENDPATH ; (MUST OF HAD TRAILING SPACES)  
				JSR INCTPTH   
FRSTCHAR		 LDY #0 ; INIT COUNT FOR THIS PORTION OF THE  
				TYA  ; PATHNAME. ALSO PRESET LENGTH TO ZERO IN  
				STA (WRKPATH,X) ; CASE OF TRAILING SPACES.  
				LDA (TPATH,X) ; GET CHARACTER.  
				AND #$7F ; IGNORE HIGH BIT.  
				CMP #$20 ; IS IT A LEADING SPACE?  
				BEQ BUMPATH ; IF SO, IGNORE IT.  
				CMP #$5B ; IS IT GREATER THAN (UPPER CASE) A 'Z'?  
				BCC ALFA1 ; NO, MAKE SURE IT'S AN ALPHA CHARACTER  
				AND #$5F ; YES, ASSUME IT'S LOWER CASE, AND UPSHIFT  
				CMP #$5B ; WAS IT TRULY LOWER CASE?  
				BCS ERRSYN ; NO, GIVE ERROR.  
*     
ALFA1			 CMP #$41 ; IS IT LESS THAN 'A'?  
				BCC ERRSYN ; YES! IT'S CRAP...  
				BCS SAVPATH ; NO, IT'S GOOD. SAVE IT.  
*     
NXTCHAR			 LDA (TPATH,X) ; GET THE NEXT CHARACTER.  
				AND #$7F ; THESE CHARACTERS MAY BE ALPHA, NUMERIC,  
				CMP #$5B ; OR A PERIOD - ONLY THE FIRST HAD TO BE ALPHA  
				BCC ALFA2 ; BRANCH IF LESS THAN 'Z'  
				AND #$5F ; UPSHIFT LOWER CASE.  
				CMP #$5B ; NOW IS IT VALID?  
				BCS ERRSYN ; NOPE.  
*     
ALFA2			 CMP #$41 ; IS IT GREATER THAN 'A'?  
				BCS SAVPATH ; YUP, IT IS WORTH SAVIN.  
				CMP #$3A ; >9?  
				BCS TSTDLIM ; YES  
				CMP #$30 ; NO, <0?  
				BCS SAVPATH ; NO, IT'S VALID NUMERIC.  
TSTDLIM			 CMP #DLIMIT ; IS IT THE DELIMITER?  
				BEQ ENDPATH ; YES. CARRY SET INDICATES MORE TO COME.  
				CMP #$2E ; IS IT A '.' (PERIOD)?  
				BNE ERRSYN ; NO, IT'S AN ERROR (#@&##@!)  
SAVPATH			 CLC    
				INY  ; BUMP NAME LENGTH  
				STA (WRKPATH),Y   
				DEC PATHCNT ; IF ZERO, THAT WAS THE LAST CHARACTER  
				BEQ ENDPATH ; (CARRY CLEAR INDICATES END OF PATH)  
				INC TPATH ; BUMP POINTER TO SOURCE PATHNAME.  
				BNE NXTCHAR   
				INC TPATH+1 ; HIGH ORDER, WHEN NECESSARY.  
				BNE NXTCHAR ; BRANCH ALWAYS.  
				PAGE    
*     
ENDPATH			 TYA  ; GET CURRENT NAME LENGTH  
				STA (WRKPATH,X) ; AND PUT IT IN FRONT OF NAME  
				BCC LSTNAME ; BRANCH IF THAT WAS THE LAST OF PATH  
				CMP #$10 ; WAS THE NAME ILLEGALLY LONG?  
				BCS ERRSYN1 ; YES, REPORT IT.  
				LDY #0   
				SEC  ; ADJUST WORK POINTER TO END OF PREVIOUS NAME.  
				ADC WRKPATH   
				STA WRKPATH ; REPLACE OLD POINTER.  
				BCC BUMPATH ; DO NEXT NAME.  
				LDA #TOOLONG ; THIS IS A NEVER ERROR!  
				JSR SYSDEATH ; (NEVER RETURNS).  
*     
LSTNAME			 BEQ TSTVALD   
				CMP #$10 ; MAKE SURE LAST ISN'T TOO LONG  
				BCS ERRSYN1   
				INY  ; PUT A ZERO AT END OF PROCESSED PATHNAME  
				LDA #0   
TSTVALD			 STA (WRKPATH),Y   
				LDA (PATHNML,X) ; SURE THERE IS A PATHNAME  
				BEQ ERRSYN1 ; IF NOT, REPORT ERROR.  
				CLC  ; INDICATE NO ERROR.  
				RTS    
*     
ERRSYN1			 JMP ERRSYN   
*     
INCTPTH			 INC TPATH ; POINT AT NEXT CHARACTER  
				BNE INCPTH1   
				INC TPATH+1   
INCPTH1			 RTS    
*     
				PAGE    
SETPREFX		 JSR SETPATH ; CALL IS MADE HERE SO A 'NUL' PATH MAY BE DETECTED.  
				BCC SETPRFX1 ; BRANCH IF PATHNAME OK  
				TAX  ; SAVE ERROR CODE  
				LDY #0   
				LDA (C.PATH),Y ; TEST FOR A NUL PATHNAME  
				BEQ RESETPFX ; BRANCH IF PREFIX TO BE RESET.  
				TXA  ; RESTORE ERROR CODE  
				RTS    
RESETPFX		 STA PFIXPTR   
				CLC    
				RTS    
SETPRFX1		 LDA PATHNML ; MAKE SURE NAME STARTED WITH A '/' DELIMITER.  
				BNE ERRSYN1 ; BRANCH IF IT DID.  
				LDY WRKPATH ; FIND THE END OF THE INPUT PREFIX  
				CLC  ; ADD LAST LOCAL NAME LENGTH TO FIND TRUE END.  
				LDA (PATHNML),Y   
				BNE SETPRFX3   
				DEY    
				TYA    
				BNE SETPRFX4   
SETPRFX3		 ADC WRKPATH   
				TAY    
SETPRFX4		 EOR #$FF ; GET COMPLIMENT TO FIND BEGINNING ADDRESS.  
				STA PFIXPTR ; OF NEW PREFIX IN THE PREFIX BUFFER  
				STA WRKPATH ; (PREFIX ALWAYS ENDS AT THE LAST BYTE OF BUFFER)  
MOVPRFX			 LDA (PATHNML),Y   
				STA (WRKPATH),Y ; MOVE IN NEW PREFIX  
				DEY    
				BPL MOVPRFX   
				CLC  ; AND WE'RE FINISHED!  
				RTS  ; NO ERRORS POSIBLE FROM THIS ROUTINE.  
*     
				PAGE    
*     
GETPREFX		 CLC  ; CALCULATE HOW BIG A BUFFER IS NEEDED TO  
				LDA PFIXPTR ; PASS THE PREFIX BACK TO THE USER.  
				EOR #$FF ; (EVEN IF NO PREFIX, 1 BYTE IS NEEDED TO SHOW 0 LENGTH)  
				ADC #2 ; ADD 2 FOR LEADING AND ENDING "/".  
				CMP C.MAXPTH ; IS THERE ENOUGH SPACE IN USER'S BUFFER?  
				BCC SENDPRFX ; BRANCH IF YES  
				LDA #BTSERR ; TELL USER BUFFER IS TOO SMALL.  
				RTS  ; (CARRY IS SET TO INDICATE ERROR.)  
*     
SENDPRFX		 LDY #0 ; SAVE TOTAL LENGTH OF STRING TO BE RETURNED  
				STA (C.PATH),Y   
				TAY    
				DEY  ; DISCOUNT TRAILING DELIMITER.  
				BEQ NULPREFX ; BRANCH IF PREFIX IS SET TO NUL.  
				INY    
				LDX PFIXPTR ; GET BEGINNING ADDRESS OF PREFIX AGAIN  
				DEX    
				STX WRKPATH   
				LDA #<PATHBUF   
				STA WRKPATH+1   
SNDLMIT			 LDA #DLIMIT ; PLACE DELIMITER BEFORE, BETWEEN, AND AFTER LOCAL NAMES.  
				STA (C.PATH),Y   
SNDPRFX1		 DEY    
				BEQ GOTPRFX ; BRANCH IF ALL OF PREFIX IS TRANSFERED.  
				LDA (WRKPATH),Y   
				STA (C.PATH),Y ; ASSUME IT'S A CHARACTER.  
				AND #$F0 ; NOW TEST TO SEE IF IT WAS A LOCAL LENGTH.  
				BEQ SNDLMIT ; BRANCH IF IT WAS.  
				BNE SNDPRFX1 ; GO MOVE NEXT CHAR IF IT WASN'T (ALWAYS TAKEN).  
NULPREFX		 TYA  ; RETURN NUL STRING.  
				STA (C.PATH),Y   
GOTPRFX			 CLC  ; INDICATE NO ERROR.  
				RTS    
				PAGE    
*     
FINDFCB			 LDA FCBADDRH ; INITIALIZE INDIRECT POINTER TO  
				STA FCBPTR+1 ; FILE CONTROL BLOCK (ALLOCATED WHEN SYSTEM  
				LDA #0 ; WAS FIRST BOOTED).  
				STA FCBPTR ; NOTE: ALWAYS STARTS ON PAGE BOUNDARY.  
				LDA FCBANKNM ; SET SISTE PAGE BYTE TOO...  
				STA SISFCBP   
				LDY C.REFNUM ; GET REQUESTED REFERENCE  
				BMI ERRNOTBLK ; BRANCH IF IT'S NOT A BLOCK DEVICE REFERENCE  
				DEY  ; (SHOULD BE IN THE RANGE OF 1-16 BEFORE DECREMENT)  
				CPY #$10 ; IS IT A VALID REFNUM?  
				BCS REEFER ; NO, THE USER'S SMOKIN DOPE!  
				TYA  ; TO FIND ASSOCIATED FILE CONTROL STUFF,  
				ASL A ; MULTIPLY (REFNUM-1) BY 32.  
				ASL A   
				ASL A   
				ASL A   
				ASL A   
				BCC SVFCBLO ; BRANCH IF IT'S WITHIN FIRST HALF OF FCB  
				INC FCBPTR+1 ; BUMP TO SECOND HAVE (REFNUM>8)  
SVFCBLO			 STA FCBPTR ; SAVE LOW ADDRESS OF REFERENCED FCB  
				LDA C.REFNUM ; NOW VERIFY THAT FILE IS OPEN.  
				LDY #FCBREFN   
				CMP (FCBPTR),Y ; SHOULD BE EQUAL!  
				BNE ERRNOREF ; BRANCH IF THEY'RE NOT  
FNDFCBUF		 LDY #FCBBUFN ; IT'S A LEGAL FILE, NOW SET UP  
				LDA (FCBPTR),Y ; INDIRECT POINTERS TO DATA  
GTBUFFRS		 LDX #DATPTR ; (AND INDEX) BUFFER(S) IN ZERO PAGE  
				JSR GETBUFADR ; GET BUFFER ADDRESS UNLESS  
				BCS REEFER1 ; BOB HAS BEEN SMOKIN DOPE...  
				LDA #2 ; (ASSUME AN INDEX BLOCK BUFFER IS ALSO PRESENT)  
				ADC DATPTR+1   
				STA TINDX+1   
				LDA DATPTR   
				STA TINDX   
				LDA SISDATP   
				STA SSTIDXH   
				LDY #FCBDEVN   
				LDA (FCBPTR),Y ; MAKE SURE DEVICE  
				STA D.DEV ; NUMBER TEMPS MATCH  
				STA DEVNUM ; CURRENT FILE'S DEVICE  
				LDA #0 ; LOOK AT ALL VOLUMES LOGGED IN  
FNDFVOL			 TAX    
				LDA VCB+VCBDEV,X ; GET VOLUMES DEVICE NUMBER  
				CMP (FCBPTR),Y ; HVE WE FOUND A MATCH.  
				BNE FNDFV1   
				LDY #FCBSWAP ; SWAP BYTES  
				LDA VCB+VCBSWAP,X ; MISMATCH  
				CMP (FCBPTR),Y ; MEANS FILE BELONGS  
				BNE FNDFV.1 ; TO ANOTHER VOLUME  
				LDA VCB,X ; IS THIS AN OPEN DEVICE?  
				BEQ FNDFV.1 ; NO, TRY ANOTHER VOLUME  
				JSR FVOLFOUND ; YES, SAVE VCB ADDRESS  
				LDA VCB+VCBSWAP,X ; SWAPPED?  
				BEQ REEFER1 ; NO, RETURN CALMLY TO USER  
				JSR SWAPIN ; YES, SWAP ME IN  
				BCC REEFER1 ; RETURN WITHOUT ERROR  
				LDA #XIOERROR ; USER REFUSED TO MOUNT PROPER VOLUME  
				RTS    
*     
FNDFV.1			 LDY #FCBDEVN ; RELOAD Y WITH DEVICE INDEX  
FNDFV1			 TXA    
				CLC    
				ADC #VCBSIZE   
				BCC FNDFVOL ; LOOP UNTIL FOUND  
				LDA #VCBERR ; OTHERWISE DIE A SYSTEM DEATH!  
				JSR SYSDEATH   
				PAGE    
*     
ERRNOREF		 LDA #0 ; DROP A ZERO INTO THIS FCB TO  
				STA (FCBPTR),Y ; SHOW FREE FCB  
*     
REEFER			 LDA #BADREFNUM ; TELL USER THAT REQUESTED REFNUM  
				SEC  ; IS ILLEGAL (OUT OF RANGE) FOR THIS CALL.  
REEFER1			 RTS    
*     
ERRNOTBLK		 LDA #NOTBLKDEV ; TELL USER THAT SPECIFIED DEVICE IS NOT A BLOCK DEVICE  
				SEC    
				RTS    
*     
SVCBADR			 EQU *   
FVOLFOUND		 STX VCBPTR   
				LDA #VCB/256   
				STA VCBPTR+1   
				CLC  ; INDICATE LEGAL REFNUM  
				RTS    
				PAGE    
* NAME : GETDNUM    
* FUNCTION: GET DEVICE NUMBER  
* INPUT : DVNAMP SETUP  
* OUTPUT : DEVNUM IN 'SCRTCH'  
* : 'BPL' IF NOT BLOCK DEV  
* : 'BCS' IF NO DEVICE  
* VOLATILE: ALL REGS  
*  
GETDNUM			 EQU *   
				LDA #>SCRTCH+1 ; SET UP POINTER TO SCRATCH AREA  
				STA DVDNUM ; TO RECIEVE DEVICE NUMBER.  
				LDA #SCRHIGH   
				STA DVDNUM+1   
				LDA #0 ; PLACE A ZERO IN BANK BYTE SINCE  
				STA SISTER+DVDNUM+1 ; IT'S NOT IN A BANK.  
				STA VCBPTR+1   
				LDA #4 ; THE 'GET.DNUM' COMMAND.  
				STA DHPCMD   
				JSR RPEATIO0 ; CALL BOB FOR THE INFO.  
				RTS  ; RETURN WITH DEVMGR CC'S  
				PAGE  
*   
* NAME : SRCHDEV  
* FUNCTION: SEARCH FOR A VOLUME  
*  
SRCHDEV			 EQU *   
				JSR GETDNUM ; GET DEVNUM  
				BCS VOLERR1 ; BRANCH IF ANY ERROR OTHER THAN NOTBLOCKDEV  
				BPL ERRNOTBLK ; BRANCH IF NOT A BLOCK DEVICE  
				LDA #0 ; NOW SEARCH FOR A VOL WITH THE  
				STA NFOPEN ; INIT TEMP VCB POINTER  
VOLOOK			 TAX  ; SAME DEVNUM AS SCRTCH  
				LDA VCB+VCBSTAT,X ; ANY FILES OPEN?  
				BNE VLOOK00 ; BRANCH IF SOME FILE OPEN  
				STX NFOPEN ; ELSE SAVE THE VCB ENTRY PTR  
VLOOK00			 EQU *   
				LDA VCB+VCBSWAP,X ; VOLUME SWAPPED OUT?  
				BNE VNOTEQ ; YES, CANT BE THE ACTIVE VOL  
				LDA VCB+VCBDEV,X   
				EOR SCRTCH+1   
				BEQ VLOOK0 ; BRANCH IF MATCH.  
VNOTEQ			 LDA VCB,X ; IS THIS A FREE VCB?  
				BNE VLOOK2 ; BRANCH IF NOT FREE, OTHEWISE TAKE NEXT BRANCH.  
VLOOK0			 EOR VCB,X ; TEST FOR A VOLUME NAME LENGTH  
				BEQ VLOOK1 ; BRANCH IF VCB FREE  
				JSR SVCBADR ; SAVE CURRENT ADDRESS OF VCB.  
				LDA VCB+VCBSTAT,X ; TEST FOR ANY OPEN FILES.  
				BPL VLOOK3 ; LOG THE VOLUME IN JUST TO BE SURE  
				LDA SCRTCH+1 ; SET UP  
				STA DEVNUM ; DEVICE NUMBER ARGUMENT  
				TXA  ; SAVE PTR TO VCB  
				PHA  ; ON STACK  
				JSR VERFYVOL ; COMPARES VCBPTR TO DEVNUM CONTENTS  
				BCC VNOSWIT   
				CMP #VNFERR ; SEE IF NOTHING IN DRIVE  
				BEQ VLOOK7 ; BRANCH IF NOTHING IN DRIVE  
				JSR TSTSOS ; IS THE VOLUME AN UNRECOGNIZED SOS OR (UCSD OR DOS)?  
				BCS KNOTSOS ; DEFINITELY NOT SOS FORMAT  
				LDX #0 ; START VCB SCAN AT BEGINNING  
				JSR SNSWIT1 ; FIND A FREE VCB AND LOG IN THE NEW GUY  
				BCS VNOSWIT1 ; CAN'T LOG IN NEW GUY--KEEP OLD  
				PLA    
				LDX VCBPTR ; PASS BACK X AS NEW VCB  
				RTS    
*     
NFOPEN			 DS 1 ; TEMP VCB PTR FOR VCB W/ NO FILES OPEN  
*     
VNOSWIT			 CLC  ; RETURN IT TO USER  
				PLA  ; REMEMBER OLD VCB PTR  
				TAX  ; AND PASS BACK TO USER  
				RTS    
;				 RETURN TO CALLER X=POINTER TO VCB.  
*  
VOLERR1			 SEC  ; RETURN SOME VOLUME ERROR  
				RTS    
VNOSWIT1		 CMP #DUPVOL   
				BNE VLOOK7 ; REPORT OTHER ERROR FROM LOGGING IN NEW VOL AS VNF  
				TAX    
				PLA  ; MAKE STACK CORRECT  
				TXA  ; RESTORE ERROR CODE  
				SEC    
				RTS  ; IF DUPLICATE VOLUME ERROR, RETURN FACT TO USER  
KNOTSOS			 PLA  ; MAKE STACK CORRECT  
				LDA #NOTSOS ; FOR THE PASCAL FOLK  
				RTS  ; NOTSOS MEANS UCSD OR DOS OR BAD SOS VOLUME  
*     
VLOOK7			 PLA  ; THROW AWAY OLD VCB PTR  
				JMP NOVOLM ; AND REPORT VOLUME NOT FOUND  
*     
VLOOK1			 JSR SVCBADR ; SAVE ADDRESS OF FREE VCB.  
VLOOK2			 TXA  ; BUMP TO NEXT VOLUME ENTRY.  
				CLC    
				ADC #VCBSIZE   
				BCC VOLOOK ; BRANCH IF MORE TO CHECK.  
				LDX VCBPTR+1 ; FREE VCB YET FOUND?  
				BNE VLOOK3 ; BRANCH IF YES  
				LDX NFOPEN ; SAVE POSSIBLE FREE VCB  
				JSR SVCBADR ; AND SAVE PTR PERMANENTLY  
VLOOK3			 LDA VCBPTR+1 ; WAS A FREE VCB FOUND?  
				BEQ NOVOLM ; BRANCH IF VOLUME CAN'T BE LOGGED IN.  
				LDA SCRTCH+1 ; GET DEVICE NUMBER  
				STA DEVNUM ; SAVE DEVICE NUMBER.  
				LDA #1 ; FAKE OUT 'LOKVOL'  
				STA SCRTCH ; TO THINK TO LOOK ONLY ONCE.  
				STA TOTDEVS   
				LDA #<VCB   
				STA VCBPTR+1   
				STA PATHNMH ; (TO MAKE HARMLESS)  
				LDA #0   
				STA SISTER+PATHNMH   
				LDX VCBPTR   
				STX PATHNML   
				STA VCB,X ; FORCE CURRENT VOLUME OFF LINE, THEN LOG WHATS THERE.  
				JSR FREEVCB ; GO READ ROOT DIRECTORY.  
				BCS RTVOLNAM ; RETURN ANY ERRORS  
				LDX VCBPTR ; MAKE SURE VOLUME WAS LOGGED IN  
				LDA VCB,X   
				BEQ NOVOLM ; RETURN ERROR  
				RTS  ; ELSE RETURN NORMALLY  
NOVOLM			 LDA #VNFERR ; TELL USER 'NO VOLUME'  
				SEC    
RTVOLNAM		 TAX  ; SAVE REAL ERROR WHILE DUPLICATE IS CHECKED  
				LDA DUPLFLAG   
				BEQ RTV1 ; BRANCH IF NOT DUPLICATE  
				LDX #DUPVOL   
RTV1			 TXA  ; RECALL ERROR  
				RTS    
				    
				CHN VOLUME,4,1   
				    
*************************************************************************  
* END OF APPLE /// SOS 1.3 SOURCE CODE FILE: PATH  
*************************************************************************  
				 
				 
*--------------------------------------
MAN
SAVE /A3OSX.BUILD/SOS.13\sos.s.path.txt
LOAD /A3OSX.BUILD/SOS.13/sos.s
ASM
