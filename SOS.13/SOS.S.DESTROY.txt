NEW
  AUTO 3,1
*--------------------------------------
*************************************************************************  
* APPLE /// SOS 1.3 SOURCE CODE FILE: DESTROY  
*************************************************************************  
* ASSEMBLER: APPLE ][ 6502 ASSEMBLER from APPLE COMPUTER TOOLKIT  
				 
PAGE			  
*  
NEWLINE			 LDY #FCBATTR ; ADJUST NEWLINE STATUS FOR OPEN FILE.  
LDA				 C.ISNEWL ; ON OR OFF?  
BPL				 OFFNEWL ; BRANCH IF NEW LINE IS TO BE CLEARED.  
LDA				 #NLINEN  
ORA				 (FCBPTR),Y ; SET NEW LINE BIT IN ATTRIBUTES  
STA				 (FCBPTR),Y  
LDY				 #FCBNEWL ; AND MOVE IN NEW 'NEW-LINE' BYTE.  
LDA				 C.NEWL  
STA				 (FCBPTR),Y  
CLC				  
RTS				 ; NO ERROR POSSIBLE.  
*  
OFFNEWL			 LDA #$FF-NLINEN  
AND				 (FCBPTR),Y  
STA				 (FCBPTR),Y ; CLEAR NEW-LINE BIT.  
OFFRTS			 CLC ; THE NEW LINE CHARACTER DOES'T MATTER...  
RTS				  
PAGE			  
*  
GETINFO			 JSR FINDFILE ; LOOK FOR FILE THEY WANT OT KNOW ABOUT.  
BCC				 GTINFO1 ; BRANCH IF NO ERRORS.  
CMP				 #BADPATH ; WAS IT A ROOT DIRECTORY FILE?  
SEC				 ; (IN CASE OF NO MATCH)  
BNE				 GINFOERR  
LDA				 #$F0  
STA				 DFIL+D.STOR ; FOR GET INFO, REPORT PROPER STORAGE TYPE  
LDA				 #0 ; FORCE A COUNT OF FREE BLOCKS.  
STA				 REQL  
STA				 REQH  
JSR				 TSFRBLK ; (RETURNS IF IMMEDIATELY IF COUNT HAS PREVIOUSLY BEEN TAKEN)  
LDY				 #VCBTFRE+1  
LDA				 (VCBPTR),Y ; RETURN TOTAL BLOCKS AND TOTAL IN USE.  
STA				 REQH ; FIRST TRANSFER 'FREE' BLOCKS TO ZPAGE FOR LATER SUBTRACT  
DEY				  
LDA				 (VCBPTR),Y ; TO DETERMINE THE 'USED' COUNT  
STA				 REQL  
DEY				  
LDA				 (VCBPTR),Y ; TRANSFER TO 'D.' TABLE AS AUX I.D.  
STA				 DFIL+D.AUXID+1 ; (TOTAL BLOCK COUNT IS CONSIDERED AUX I.D. FOR THE VOLUME)  
TAX				  
DEY				  
LDA				 (VCBPTR),Y  
STA				 DFIL+D.AUXID  
SEC				 ; NOW SUBTRACT AND REPORT THE NUMBER OF BLOCKS 'IN USE'  
SBC				 REQL  
STA				 DFIL+D.USAGE  
TXA				  
SBC				 REQH  
STA				 DFIL+D.USAGE+1  
GTINFO1			 LDY #0 ; TRANSFER BYTES FROM THERE INTERNAL ORDER TO CALL SPEC VIA 'INFTABL'  
TION			 000058 GTINFO2  LDA  INFTABL,Y   
				BPL GTINFO3 ; BRANCH IF THIS IS DATA IS VALID AS IS.  
				AND #$7F ; IS THIS THE 4TH BYTE OF THE EOF PARAMETER?  
				BEQ GTINFO4 ; YES, AND IT'S ALWAYS A ZERO.  
				CMP #D.STOR+1 ; IS THIS THE STORAGE TYPE BYTE?  
				BNE GINFOEND ; NO, IT'S THE END OF INFO THAT CAN BE RETURNED.  
				LDA DFIL+D.STOR ; GET STORAGE TYPE  
				LSR A   
				LSR A   
				LSR A   
				LSR A ; MAKE IT A VALUE 1-$F BY SHIFTING OUT FILE NAME LENGTH.  
				BPL GTINFO4 ; BRANCH ALWAYS  
*     
GTINFO3			 TAX  ; USE AS OFFSET INTO 'D.' TABLE.  
				LDA DFIL,X   
GTINFO4			 STA (C.FILIST),Y ; PASS TO USER'S BUFFER  
				INY    
				CPY C.FILSTLN ; HAS REQUEST BEEN FILLED?  
				BNE GTINFO2 ; NO, PASS NEXT  
GINFOEND		 CLC  ; INDICATE NO ERRORS  
GINFOERR		 RTS    
*     
*     
				PAGE    
*     
SETINFO			 JSR FINDFILE ; FIND WHAT USER WANTS...  
				BCS SINFOERR ; RETURN ANY FAILURE.  
				LDA C.FILSTLN ; TEST FOR NUL CHANGE  
				BEQ SINFEND ; BRANCH IF NOTHING TO CHANGE.  
				LDY #0 ; INIT POINTER TO USER SUPPLIED LIST.  
				LDA (C.FILIST),Y ; FETCH FILE ATTRIBUTES  
				AND #$1C ; FORBIDDEN BITS? <SRS 82.162>  
				BEQ SETINF1 ; NO  
				LDA #ACCSERR ; YES  
				SEC    
				RTS  ; RETURN AN ERROR  
SETINF1			 LDA BACKMASK ; GET CURRENT BACKMASK <SRS 82.162>  
* BACKUP KNOWS HOW TO RESET THIS BIT. <SRS 82.162>  
				STA BKBITFLG ; BIT (USED BY DREVISE)  
SETINF1X		 LDX INFTABL,Y ; GET INDEX INTO CORESPONDING 'D.' TABLE  
				BMI SETINF2 ; BRANCH IF WE'VE REACHED STORAGE TYPE PARAMETER  
				LDA (C.FILIST),Y   
				STA DFIL,X   
				INY  ; HAS USER'S REQUEST BEEN SATISFIED?  
				CPY C.FILSTLN   
				BNE SETINF1X ; NO, MOVE NEXT BYTE.  
SINFEND			 JMP DREVISE ; GO UPDATE DIRECTORY WITH CURRENT TIME.  
*     
SETINF2			 LDY C.FILSTLN ; TEST TO SEE IF USER WANTS HIS TIME STAMP ADDED  
				CPY #$F ; (LIST MUST BE AT LEAST $F BYTES LONG)  
				BCC SINFEND ; NO PUT CURRENT TIME INSTEAD.  
				LDY #$B ; MOVE IN THE NEXT GROUP OF BYTES  
SETINF3			 LDX INFTABL,Y   
				BMI SINFEND1   
				LDA (C.FILIST),Y   
				STA DFIL,X   
				INY    
				CPY C.FILSTLN ; SATISFACTION YET?  
				BNE SETINF3 ; NOPE, KEEP EM PUMPIN'  
SINFEND1		 JMP DREVISE1   
*     
BKBITFLG		 DS 1 ; FOR TURNING OFF BACKUP BIT  
*     
*     
INFTABL			 DFB D.ATTR,D.FILID,D.AUXID,D.AUXID+1  
				DFB D.STOR+1+$80,D.EOF,D.EOF+1,D.EOF+2 ; (D.STOR=0 THUS D.STOR+1 WAS NECESSARY)  
				DFB $80,D.USAGE,D.USAGE+1,D.MODDT ; (THE $80 IS FOR THE FOURTH BYTE OF EOF)  
				DFB D.MODDT+1,D.MODTM,D.MODTM+1,$FF ; TABLE ALWAYS ENDS IN $FF  
				PAGE   
*    
RENAME			 JSR LOOKFILE ; LOOK FOR SOURCE (ORIGINAL) FILE.  
				BCC RNAME0 ; BRANCH IF FOUND.  
				CMP #BADPATH ; TRYING TO RENAME A VOLUME?  
				BNE RNAMERR ; NO, RETURN OTHER ERROR.  
				JSR RENPATH ; SYNTAX NEW NAME.  
				BCS RNAMERR  
				LDA WRKPATH ; FIND OUT IF ONLY ROOTNAME FOR NEW NAME  
				CMP PATHNML  
				BNE RNBADPTH ; NOT SINGLE NAME, RETURN ERROR!  
				LDY #VCBSTAT ; TEST FOR OPEN FILES BEFORE CHANGING  
				LDA (VCBPTR),Y  
				BPL RNAMEVOL ; BRANCH IF VOLUME NOT BUSY  
				LDA #FILBUSY  
SINFOERR		 EQU *  
				RTS ; (CARRY IS SET)  
RNAMEVOL		 LDY #0 ; GET NEWNAME'S LENGTH.  
				LDA (WRKPATH),Y  
				TAY   
				ORA #$F0 ; (ROOT FILE STORAGE TYPE)  
				JSR MVROTNAM ; UPDATE ROOT DIRECTORY.  
				BCS RNAMERR  
				LDY #0  
				LDA (WRKPATH),Y ; UPDATE VCB ALSO.  
				TAY   
RNMEVOL			 LDA (WRKPATH),Y  
				STA (VCBPTR),Y  
				DEY   
				BPL RNMEVOL  
				CLC   
				RTS   
*    
RNAME0			 JSR RENPATH ; SET UP AND SYNTAX NEW NAME.  
				BCS RNAMERR   
				LDY #0 ; VERIFY THAT BOTH NAMES HAVE SAME ROOT.  
				LDA (PATHNML),Y   
				TAY    
TSTSMROT		 LDA (PATHNML),Y ; COMPARE NEWNAME'S ROOT NAME WITH  
				CMP (VCBPTR),Y ; OLD NAME'S VOLUME NAME.  
				BNE RNBADPTH ; RETURN 'BADPATH' IF NOT SAME VOLUME.  
				DEY    
				BPL TSTSMROT ; (TEST SAME 'ROT')  
				JSR LOOKFILE ; TEST FOR DUPLICATE FILE NAME.  
				BCS TSTFNF1 ; BRANCH IF ERROR TO TEST FOR FILE NOT FOUND.  
				LDA #DUPERR ; TELL USER THAT NEW NAME ALREADY EXISTS.  
RNAMERR			 SEC    
				RTS    
				PAGE    
TSTFNF1			 CMP #FNFERR ; WAS IT A VALID FILE NOT FOUND?  
				BNE RNAMERR ; NO, RETURN OTHER ERROR CODE.  
				LDX #2 ; NOW MOVE NEW NAME'S OWNERSHIP (DIRECTORY HEADER) I.D.  
SVENEWID		 LDA D.DEV,X ; THIS CONSISTS OF THE UNIT NUMBER,  
				STA NPATHDEV,X ; AND THE ADDRESS OF THE DIRECTORY THE FILE  
				DEX  ; WASN'T FOUND IN. LOGIC BY NEGATION...  
				BPL SVENEWID   
				JSR SETPATH ; NOW SYNTAX THE PATHNAME OF THE FILE TO BE CHANGED.  
				BCS RNAMERR   
				JSR FINDFILE ; GET ALL THE INFO ON THIS ONE.  
				BCS RNAMERR   
				JSR TSTOPEN ; DON'T ALLOW RENAME TO OCCUR IF FILE IS IN USE.  
				LDA #FILBUSY ; ANTICIPATE ERROR  
				BCS RNAMERR   
				LDA DFIL+D.ATTR ; TEST BIT THAT SAYS IT'S OK TO RENAME  
				AND #RENAMEN   
				BNE RNAME1 ; BRANCH IF IT'S ALRIGHT TO RENAME.  
				LDA #ACCSERR ; OTHERWISE REPORT ILLEGAL ACCESS.  
				SEC    
				RTS    
*     
RNAME1			 LDX #2 ; NOW TEST TO SEE IF NEW PATHNAME FITS IN THE  
SAMOWNR			 LDA D.DEV,X ; SAME DIRECTORY FILE.  
				CMP NPATHDEV,X   
				BEQ RNAME2   
RNBADPTH		 LDA #BADPATH ; TELL USER THAT PATHNAMES INCOMPATABLE.  
				SEC    
				RTS    
*     
RNAME2			 DEX  ; TEST ALL THREE BYTES.  
				BPL SAMOWNR   
				JSR RENPATH ; WELL... SINCE BOTH NAMES WOULD GO INTO THE  
				BCS RNAMERR ; DIRECTORY, RE-SYNTAX THE NEW NAME TO GET LOCAL NAME ADDRESS.  
				TYA  ; (Y CONTAINS THE LOCAL NAME LENGTH+1)  
				BEQ RNBADPTH ; REPORT ERROR IF LENGTH INFO NOT IMMEDIATELY AVAILABLE.  
				DEY  ; (REMOVE THE +1)  
RNAME3			 LDA (WRKPATH),Y ; MOVE LOCAL NAME TO DIR ENTRY WORKSPACE.  
				STA DFIL+D.STOR,Y   
				DEY    
				BNE RNAME3   
				LDA DFIL+D.STOR ; PRESERVE FILE STORAGE TYPE.  
				AND #$F0 ; STRIP OFF OLD NAME LENGTH.  
				TAX    
				ORA (WRKPATH),Y ; ADD IN NEW NAME'S LENGTH  
				STA DFIL+D.STOR   
				CPX #DIRTYP*16 ; THAT FILE MUST BE CHANGED ALSO.  
				BNE RNAMDONE ; BRANCH IF NOT DIRECTORY TYPE.  
				PAGE    
				LDA DFIL+D.FRST ; READ IN FIRST (HEADER) BLOCK OF SUB DIRECTORY  
				STA BLOKNML   
				LDA DFIL+D.FRST+1   
				STA BLOKNMH   
				JSR RDGBUF   
				BCS RNAMERR ; REPORT ERRORS  
				LDY #0 ; CHANGE THE HEADER'S NAME TO MATCH THE OWNER'S NEW NAME.  
				LDA (WRKPATH),Y ; GET LOCAL NAME LENGTH AGAIN  
				TAY    
				ORA #HEDTYP*16 ; ASSUME IT'S A HEADER.  
				JSR MVROTNAM   
				BCS RNAMERR   
RNAMDONE		 JMP DREVISE1 ; END BY UPDATING ALL PATH DIRECTORIES  
*     
*     
MVROTNAM		 STA GBUF+4   
MVHEDNAM		 LDA (WRKPATH),Y   
				STA GBUF+4,Y   
				DEY    
				BNE MVHEDNAM   
				JMP WRTGBUF ; WRITE CHANGED HEADER BLOCK.  
*     
*     
RENPATH			 LDA C.NWPATH ; GET ADDRESS TO NEW PATHNAME.  
				STA TPATH   
				LDA C.NWPATH+1 ; SET UP FOR SYNTAXING ROUTINE (SYNPATH).  
				STA TPATH+1   
				LDA SSNWPATH ; (MOVE BYTE FOR SISTER PAGE, TOO.)  
				STA SISTPATH   
				JMP SYNPATH ; GO SYNTAX IT. (RETURNS LAST LOCAL NAME LENGTH IN Y).  
*     
*     
DEALBLK			 LDY #0 ; BEGIN AT THE BEGINNING.  
DALBLK1			 STY SAPTR ; SAVE CURRENT INDEX.  
				LDA GBUF,Y ; GET ADDRESS (LOW) OF BLOCK TO BE DEALLOCATED.  
				CMP GBUF+$100,Y ; TEST FOR NUL BLOCK.  
				BNE DALBLK2 ; BRANCH IF NOT NUL.  
				CMP #0   
				BEQ DALBLK3 ; SKIP IT IF NUL.  
DALBLK2			 LDX GBUF+$100,Y ; GET THE REST OF THE BLOCK ADDRESS.  
				JSR DEALLOC ; FREE IT UP ON VOLUME BIT MAP.  
				BCS DALBLKERR ; RETURN ANY ERROR.  
				LDY SAPTR ; GET INDEX TO SAPLING LEVEL INDEX BLOCK AGAIN.  
DALBLK3			 INY  ; POINT AT NEXT BLOCK ADDRESS.  
				BNE DALBLK1 ; BRANCH IF MORE TO DEALLOCATE (OR TEST).  
				CLC  ; INDICATE NO ERROR.  
DALBLKERR		 RTS    
*     
*     
				PAGE    
*     
DESTROY			 JSR FINDFILE ; LOOK FOR FILE TO BE WIPED OUT.  
				BCS DESTERR ; PASS BACK ANY ERROR.  
				JSR TSTOPEN ; IS THIS FILE OPEN?  
				LDA TOTENT   
				BEQ DSTROY1 ; BRANCH IF FILE NOT OPEN.  
				LDA #FILBUSY   
				SEC  ; INFORM USER THAT FILE CAN'T BE DESTORYED AT THIS TIME.  
				RTS    
*     
DSTROY1			 LDA #0 ; FORCE PROPER FREE COUNT IN VOLUME.  
				STA REQL ; (NO DISK ACCESS OCCURS IF ALREADY PROPER)  
				STA REQH   
				JSR TSFRBLK   
				BCC DSTROY2   
				CMP #OVRERR ; WAS IT JUST A FULL DISK?  
				SEC    
				BNE DESTERR ; NOPE, REPORT ERROR.  
*     
DSTROY2			 LDA DFIL+D.ATTR ; MAKE SURE IT'S OK TO DESTROY THIS FILE.  
				AND #DSTROYEN   
				BNE DSTROY3 ; BRANCH IF OK.  
				LDA #ACCSERR ; TELL USER IT'S NOT KOSHER.  
				JSR SYSERR ; (RETURNS TO CALLER OF DESTORY)  
*     
DSTROY3			 JSR TWRPROT1 ; BEFORE GOING THRU DEALLOCATION,  
				BCS DESTERR ; TEST FOR WRITE PROTECTED HARDWARE.  
				LDA DFIL+D.STOR ; FIND OUT WHICH STORAGE TYPE.  
				AND #$F0 ; STRIP OFF NAME LENGTH.  
				CMP #TRETYP+1*$10 ; IS IT A SEED, SAPLING, OR TREE?  
				BCC DSTREE ; BRANCH IF IT IS.  
				JMP DSTDIR ; OTHERWISE TEST FOR DIRECTORY DESTROY.  
*     
DSTREE			 JSR GTTINDX ; GET A BIT MAP BUFFER AND TEMPORARY INDEX BUFFER.  
				BCS DESTERR   
				LDA DFIL+D.STOR ; GET STORAGE TYPE AGAIN  
				AND #$F0   
				CMP #TRETYP*$10 ; IS THIS A TREE (FULL 2-LEVEL)?  
				BNE DSTSAP ; NO, TEST FOR SAPLING.  
				JSR RDFRST ; READ IN ROOT INDEX FOR THIS FILE.  
				BCC DSTRE2 ; BRANCH IF ALL IS WELL.  
DESTERR			 RTS  ; OTHERWISE RETURN ERROR.  
*     
DSTSAP			 CMP #SAPTYP*$10 ; IS IT A SAPLING  
				BNE DSTLAST ; NO, JUST DEALLOCATE FIRST (AND ONLY) BLOCK.  
				JSR ZTMPIDX ; CLEAR OUT TEMPORARY INDEX BUFFER.  
				LDA DFIL+D.FRST ; MAKE THIS SAP LOOK LIKE A TREE...  
				LDY #0 ; THIS IS DONE BY PLACING THE FIRST BLOCK ADDRESS  
				STA (TINDX),Y ; IN THE TEMP (TOP) INDEX BUFFER AS  
				INC TINDX+1   
				LDA DFIL+D.FRST+1 ; A SUB INDEX WOULD APPEAR.  
				STA (TINDX),Y   
				DEC TINDX+1   
DSTRE2			 LDY #0 ; BEGIN SCAN OF TOP LEVEL INDEX AT ZERO.  
DSTNXT			 STY TREPTR ; SAVE POINTER TO TREE LEVEL.  
				LDA (TINDX),Y ; GET BLOCK ADDRESS OF A SUB INDEX BLOCK  
				INC TINDX+1 ; (TEST FOR NUL BLOCK)  
				CMP (TINDX),Y   
				BNE DSTRE3 ; BRANCH IF WE'VE GOT AN BLOCK TO DEALLOCATE.  
				CMP #0 ; IS ENTIRE ADDRESS ZERO?  
				BEQ DSTRE4 ; YES, DO NEXT. (CARRY SET)  
DSTRE3			 CLC  ; INDICATE THERE IS A BLOCK OF INDEXES TO FREE UP.  
				STA BLOKNML   
				LDA (TINDX),Y ; GET HI ADDRESS TOO.  
				STA BLOKNMH   
DSTRE4			 DEC TINDX+1 ; (RESTORE PROPER ADDRESS FOR BUFFER)  
				BCS DSTNXT1 ; BRANCH IF NO SUB INDEX.  
				JSR RDGBUF ; USE GENERAL BUFFER FOR SUB INDEX BUFFER.  
				BCS DESTERR   
				JSR DEALBLK ; GO FREE UP BLOCKS IN SUB INDEX  
				BCS DESTERR   
				LDY TREPTR ; AND FREE UP SUB INDEX BLOCK TOO.  
				INC TINDX+1   
				LDA (TINDX),Y   
				TAX    
				DEC TINDX+1   
				LDA (TINDX),Y   
				JSR DEALLOC   
				BCS DESTERR   
				LDY TREPTR   
DSTNXT1			 INY  ; HAVE ALL SUB INDEXES BEEN LOCATED?  
				BNE DSTNXT ; NO, DO NEXT...  
DSTLAST			 LDA DFIL+D.FRST ; DEALLOCATE FIRST BLCOK OF FILE.  
				LDX DFIL+D.FRST+1   
				JSR DEALLOC   
				BCS DESTERR   
				LDA #0 ; UPDATE DIRECTORY TO FREE ENTRY SPACE.  
				STA DFIL+D.STOR   
				CMP H.FCNT ; FILE ENTRY WRAP?  
				BNE DST1 ; BRANCH IF NO CARRY ADJUSTMENT  
				DEC H.FCNT+1 ; TAKE CARRY FROM HIGH BYTE OF FILE ENTRIES  
DST1			 DEC H.FCNT ; MARK HEADER WITH ONE LESS FILE  
				LDX BMTAB ; UPDATE (LAST) BITMAP.  
				JSR BMAPUP   
				BCS DESTERR   
				LDY #VCBTFRE   
				LDA DFIL+D.USAGE   
				ADC (VCBPTR),Y   
				STA (VCBPTR),Y ; UPDATE CURRENT FREE BLOCK COUNT.  
				INY    
				LDA DFIL+D.USAGE+1   
				ADC (VCBPTR),Y   
				STA (VCBPTR),Y   
				LDA #0 ; FORCE RESCAN FROM FIRST BITMAP  
				LDY #VCBCMAP   
				STA (VCBPTR),Y   
				JMP DREVISE ; UPDATE DIRECTORY LAST...  
*     
				PAGE    
*     
DSTDIR			 CMP #DIRTYP*16 ; IS THIS A DIRECTORY FILE?  
				BEQ DSDIR1 ; YES, PROCEED.  
				LDA #CPTERR ; FILE IS NOT COMPATABLE.  
				JSR SYSERR ; GIVE UP.  
*     
DSDIR1			 JSR FNDBMAP ; MAKE SURE A BUFFER IS AVAILABLE FOR THE BITMAP.  
				BCS DSDIRERR   
				LDA DFIL+D.FRST ; READ IN FIRST BLOCK OF DIRECTORY INTO GBUF.  
				STA BLOKNML   
				LDA DFIL+D.FRST+1   
				STA BLOKNMH   
				JSR RDGBUF   
				BCS DSDIRERR   
				LDA GBUF+HCENT+4 ; FIND OUT IF ANY FILES EXIST ON THIS DIRECTORY.  
				BNE DSDIRACC ; BRANCH IF ANY EXIST.  
				LDA GBUF+HCENT+5   
				BEQ DSDIR2   
DSDIRACC		 LDA #ACCSERR   
				JSR SYSERR   
*     
DSDIR2			 LDA GBUF+2 ; GET FORWARD LINK.  
				CMP GBUF+3 ; TEST FOR NO LINK.  
				BNE DSDIR3   
				CMP #0   
				BEQ DSTLAST ; IF NO LINK, THEN FINISHED.  
DSDIR3			 LDX GBUF+3   
				JSR DEALLOC ; FREE THIS BLOCK.  
				BCS DSDIRERR   
				LDA GBUF+2   
				STA BLOKNML   
				LDA GBUF+3   
				STA BLOKNMH ; READ IN LINKED BLOCK.  
				JSR RDGBUF   
				BCC DSDIR2 ; LOOP UNTIL ALL ARE FREED.  
DSDIRERR		 RTS    
*     
*     
				PAGE    
WORKSPC			 EQU *   
V.STATUS		 DS 1 ; VOLUME STATUS, INCLUDES 'ACTIVE' IN BIT 7  
H.CREDT			 DS 2 ; DIRECTORY CREATION DATE  
				DS 2 ; DIRECTORY CREATION TIME  
				DS 1 ; VERSION UNDER WHICH THIS DIRECTORY WAS CREATED  
				DS 1 ; EARLIEST VERSION THAT IT'S COMPATABLE WITH  
H.ATTR			 DS 1 ; ATTRIBUTES (PROTECT BIT, ETC.)  
H.ENTLN			 DS 1 ; LENGTH OF EACH ENTRY IN THIS DIRECTORY.  
H.MAXENT		 DS 1 ; MAXIMUM NUMBER OF ENTRIES PER BLOCK  
H.FCNT			 DS 2 ; CURRENT NUMBER OF FILES IN THIS DIRECTORY  
				DS 2 ; ADDRESS OF FIRST ALLOCATION BIT MAP  
				DS 2 ; TOTAL NUMBER OF BLOCKS ON THIS UNIT  
				DS 5 ; (FOR FUTURE EXPANSION)  
*     
D.DEV			 DS 1 ; DEVICE NUMBER OF THIS DIRECTORY ENTRY  
D.HEAD			 DS 2 ; ADDRESS OF <SUB> DIRECTORY HEADER  
D.ENTBLK		 DS 2 ; ADDRESS OF BLOCK WHICH CONTAINS THIS ENTRY  
D.ENTNUM		 DS 1 ; ENTRY NUMBER WITHIN BLOCK.  
DFIL			 EQU *   
D.STOR			 EQU *-DFIL ; STORAGE TYPE * 16 + FILE NAME LENGTH  
				DS 1   
;				 *-DFIL ; FILE NAME    
				DS 15   
D.FILID			 EQU *-DFIL ; USER'S IDENTIFICATION BYTE  
				DS 1   
D.FRST			 EQU *-DFIL ; FIRST BLOCK OF FILE  
				DS 2   
D.USAGE			 EQU *-DFIL ; NUMBER OF BLOCKS CURRENTLY ALLOCATED TO THIS FILE  
				DS 2   
D.EOF			 EQU *-DFIL ; CURRENT END OF FILE MARKER  
				DS 3   
D.CREDT			 EQU *-DFIL ; DATE OF FILE'S CREATION  
				DS 2   
;				 *-DFIL ; TIME OF FILE'S CREATION  
DS				 2  
;				 EQU *-DFIL ; SOS VERSION THAT CREATED THIS FILE  
				DS 1   
D.COMP			 EQU *-DFIL ; BACKWARD VERSION COMPATABILTY  
				DS 1   
D.ATTR			 EQU *-DFIL ; 'PROTECT', READ/WRITE 'ENABLE' ETC.  
				DS 1   
D.AUXID			 EQU *-DFIL ; USER AUXILLARY IDENTIFACATION  
				DS 2   
D.MODDT			 EQU *-DFIL ; FILE'S LAST MODIFICATION DATE  
				DS 2   
D.MODTM			 EQU *-DFIL ; FILE'S LAST MODIFICATION TIME  
				DS 2   
D.DHDR			 EQU *-DFIL ; HEADER BLOCK ADDRESS OF FILE'S DIRECTORY  
				DS 2   
*     
CMDADR			 DS 2   
SCRTCH			 DS 13 ; SCRATCH AREA FOR ALLOCATION ADDRESS CONVERSION  
OLDEOF			 DS 3 ; TEMP USED IN W/R  
OLDMARK			 DS 3 ; USED BY 'RDPOSN' AND 'WRITE'  
SCRHIGH			 EQU <SCRTCH ; AND DEVICE NUMBERS FROM BOB'S CODE.  
*     
				CHN SWAPOUT/IN,4,2   
				    
*************************************************************************  
* END OF APPLE /// SOS 1.3 SOURCE CODE FILE: DESTROY  
*************************************************************************

*--------------------------------------
MAN
SAVE /A3OSX.BUILD/SOS.13\sos.s.destroy.txt
LOAD /A3OSX.BUILD/SOS.13/sos.s
ASM
