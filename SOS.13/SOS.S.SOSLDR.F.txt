NEW
  AUTO 3,1
*--------------------------------------
*************************************************************************  
* APPLE /// SOS 1.3 SOURCE CODE FILE: SOSLDR.F.SRC  
*************************************************************************  
* ASSEMBLER: APPLE ][ 6502 ASSEMBLER from APPLE COMPUTER TOOLKIT  
				 
PAGE			  
REP				 100  
*  
* GETMEM ( IN: PG.ALIGN  
* IN: CNT  
* I/O: DST.P  
* I/O: DSTBANK  
* I/O: DSEGLIST  
* OUT: PREVBANK )  
*  
* LOCAL: PREVDST  
* (COMPUTES # OF PAGES TO ADD TO DRIVER SEGMENT AND WHETHER TO BEGIN A NEW SEGMENT)  
REP				 100  
GETMEM			 EQU *  
LDA				 DSTBANK ; PREVBANK:=DSTBANK  
STA				 PREVBANK  
LDA				 DST.P ; PREVDST:=DST.P  
STA				 PREVDST  
LDA				 DST.P+1  
STA				 PREVDST+1  
JSR				 NEWDST ; NEWDST(PG.ALIGN.IN, PREVDST.IN, CNT.IN, DST.P.OUT)  
*  
LDA				 DST.P+1 ; IF DST.P >= $2000  
CMP				 #$20  
BCC				 GETM010  
				SEC  ; THEN  
				LDA PREVDST+1 ; A=PAGES:=PREVDST-DST.P  
				SBC DST.P+1    
				CLC     
				JSR BUILD.DSEG ; BUILD.DSEG(C="NEXT BANK".IN, A=PAGES.IN, DSEGLIST.IO)  
				JMP GETM.EXIT    
*   ELSE   
GETM010			 DEC DSTBANK ; DSTBANK:=DSTBANK-1  
				LDA #>$A000 ; PREVDST:=$A000  
				STA PREVDST    
				LDA #<$A000    
				STA PREVDST+1    
				JSR NEWDST ; NEWDST(PG.ALIGN.IN, PREVDST.IN, CNT.IN, DST.P.OUT)  
				SEC  ; A="PAGES":=PREVDST-DST.P  
				LDA PREVDST+1    
				SBC DST.P+1    
				SEC     
				JSR BUILD.DSEG ; BUILD.DSEG(C="NEXTBANK".IN, A="PAGES".IN, DSEGLIST.IO)  
*      
GETM.EXIT		 RTS ; RETURN  
PAGE			  
REP				 100  
*  
* NEWDST ( IN: PG.ALIGN  
* IN: PREVDST  
* IN: CNT  
* I/O: DST.P )  
* (COMPUTES DESTINATION BASE ADDRESS, ALIGNING ON PAGE BOUNDARY IF REQUESTED)  
				REP 100   
NEWDST			 EQU *   
				SEC  ; IF (PREVDST-$2000) < CNT  
				LDA PREVDST   
				SBC #>$2000   
				TAX    
				LDA PREVDST+1   
				SBC #<$2000   
				CPX CNT   
				SBC CNT+1   
				BCS NEWD010   
				LDA #0 ; THEN  
				STA DST.P ; DST.P:=0  
				STA DST.P+1   
				BEQ NEWD.EXIT   
NEWD010			 SEC  ; ELSE  
				LDA PREVDST ; DST.P:=PREVDST-CNT  
				SBC CNT   
				STA DST.P   
				LDA PREVDST+1   
				SBC CNT+1   
				STA DST.P+1   
				LDA PG.ALIGN ; IF PG.ALIGN <> 0  
				ORA PG.ALIGN+1 ; THEN  
				BEQ NEWD.EXIT    
				SEC  ; DST.P:=(DST.P/256*256)-PG.ALIGN  
				LDA #0    
				SBC PG.ALIGN    
				STA DST.P    
				LDA DST.P+1    
				SBC PG.ALIGN+1    
				STA DST.P+1    
NEWD.EXIT		 RTS  ; RETURN   
				PAGE     
				REP 100    
*
* BUILD.DSEG ( IN:C="NEXTBANK"
*IN:A="PAGES"
*I/O: DSEGLIST)
* (COMPUTES # OF PAGES TO ADD TO DRIVER SEGMENT AND WHETHER TO BEGIN A NEW SEGMENT)
				REP 100   
BUILD.DSEG		 EQU *   
				PHA    
				BCS BLDS010 ; IF ("NEXTBANK"=TRUE OR DSEGX=$FF)  
				LDA DSEGX ; THEN  
				BPL BLDS020   
BLDS010			 INC DSEGX ; DSEGX:=DSEGX+1  
BLDS020			 LDX DSEGX   
				CLC  ; DSEGLIST(DSEGX):=DSEGLIST(DSEGX)+"PAGES"  
				PLA    
				ADC DSEGLIST,X   
				STA DSEGLIST,X   
				RTS  ; RETURN  
*     
*     
*     
DSEGX			 DFB $FF ; DRIVER SEGMENT LIST TABLE  
DSEGLIST		 DFB $0 ; # PAGES FOR 1ST DRIVER SEGMENT (BANK N )  
DFB				 $0 ; " 2ND " (BANK N-1)  
DFB				 $0 ; " 3RD " (BANK N-2)  
DFB				 $0 ; " 4TH " (BANK N-3)  
PAGE			       
REP				 100       
*       
* RELOC ( IN: SRC.P       
* IN: REL.P       
* IN: DST.P       
* OUT: RELOCATED DRIVER MODULE )       
*       
*LOCAL: REL.END, CODE.P
* (RELOCATES DRIVER MODULE'S CODE FIELD USING RELOCATION FIELD)
				REP 100   
RELOC			 EQU *   
				SEC  ; REL.END:=REL.P-(REL.P)  
				LDY #0   
				LDA REL.P   
				SBC (REL.P),Y   
				STA REL.END   
				INY    
				LDA REL.P+1   
				SBC (REL.P),Y   
				STA REL.END+1   
REL.LOOP		 SEC  ; REL.P:=REL.P-2  
				LDA REL.P   
				SBC #2   
				STA REL.P   
				LDA REL.P+1   
				SBC #0   
				STA REL.P+1   
				LDA REL.P ; IF REL.P < REL.END THEN EXIT  
				CMP REL.END   
				LDA REL.P+1   
				SBC REL.END+1   
				BCC REL.EXIT   
				LDY #0 ; CODE.P:=X:SRC.P+(REL.P)  
				CLC    
				LDA SRC.P   
				ADC (REL.P),Y   
				STA CODE.P   
				INY    
				LDA SRC.P+1   
				ADC (REL.P),Y   
				STA CODE.P+1   
				LDA CXPAGE+SRC.P+1   
				STA CXPAGE+CODE.P+1   
				LDY #0 ; (CODE.P):=(CODE.P)+DST.P  
				CLC    
				LDA (CODE.P),Y   
				ADC DST.P   
				STA (CODE.P),Y   
				INY    
				LDA (CODE.P),Y   
				ADC DST.P+1   
				STA (CODE.P),Y   
				JMP REL.LOOP ; GOTO REL.LOOP  
*     
REL.EXIT		 RTS  ; RETURN  
				PAGE    
				REP 100   
* 000179 * ALLOC.SEG ( IN: K.BASE  
* IN: I.BASE.P  
* IN: SYSBANK )  
* I.BASE.P  
* D.BASE.PG  
* (ALLOCATES SEGMENTS FOR KERNEL, INTERPRETER AND SYSTEM WORK AREA)  
				REP 100   
ALLOC.SEG		 EQU *   
				BRK  ; REQ.SEG(BASE=(F,0), LIMIT=(F,1D), SEGID=0, SEGNUM)  
				DFB REQSEG   
				DW SEGMENT   
*     
				LDA #$10 ; SET BASE/LIMIT BANKS  
				STA SEGBASE   
				STA SEGLIM   
				LDA #0 ; AND INIT BASE PAGE  
				STA SEGBASE+1   
*     
				LDX K.BASE+1 ; KERNEL SEGMENT, ID=1  
				JSR RSEG   
*     
				LDX I.BASE.P+1 ; INTERPRETER SEGMENT, ID=2  
				JSR RSEG   
				RTS    
				PAGE    
				REP 100   
*     
* RSEG ( IN: X=BASE.PAGE OF SEGMENT )  
*   
				REP 100    
RSEG			 EQU *    
				INC SEGID ; SEGID:=SEGID+1  
				LDY SEGBASE+1 ; LIMIT.PAGE:=BASE.PAGE-1  
				DEY     
				STY SEGLIM+1    
				STX SEGBASE+1 ; BASE.PAGE:=X  
*      
				CPX #$A0 ; IF BASE>=$A0 OR LIMIT<$A0 THEN  
				BCS RSEG010 ; THEN  
				LDA SEGLIM+1 ; REQUEST ONLY ONE SEGMENT  
				CMP #$A0    
				BCC RSEG010    
*      
				TXA  ; ELSE  
				PHA  ; REQUEST TWO SEGMENTS  
				LDX #$A0    
				STX SEGBASE+1    
*      
				BRK  ; REQ.SEG(BASE, LIMIT, SEGID, SEGNUM)  
				DFB REQSEG    
				DW SEGMENT    
*      
				PLA     
				STA SEGBASE+1    
				LDA #$9F    
				STA SEGLIM+1    
				LDA SYSBANK    
				STA SEGBASE    
				STA SEGLIM    
*      

ALDS.EXITRTS;	 RETURN
AGE
EP100
*
* ERROR (IN: X=MESSAGE INDEX
*IN: Y=MESSAGE LENGTH
* (DISPLAYS ERROR MESSAGE, SOUNDS BELL AND LOOPS UNTIL CONTROL/RESET PRESSED)
				REP 100   
ERROR			 EQU *   
				STY ETEMP ; CENTER MSG (Y:=LEN/2+LEN)  
				SEC    
				LDA #40   
				SBC ETEMP   
				LSR A   
				CLC    
				ADC ETEMP   
				TAY    
*     
PRNT010			 LDA ERR,X ; MOVE MESSAGE TO SCREEN MEMORY  
				STA EMSGADR-1,Y   
				DEX    
				DEY    
				DEC ETEMP   
				BNE PRNT010   
*     
				LDA #$73 ; E:=( 0.1.1.1:0.0.1.1 )  
				STA E.REG ; ( 1.I.S.R:W.P.R.S )  
				LDA $C040 ; SOUND BELL  
				JMP * ; LOOP UNTIL REBOOT (CTRL/RESET)  
				PAGE    
				REP 100  
*    
* ERROR MESSAGES   
*    
				REP 100  
EMSGADR			 EQU $7A8  
*    
ERR				 EQU *  
ERR0			 ASC "I/O ERROR"  
ERR0L			 EQU *-ERR0  
ERR0X			 EQU *-ERR-1  
ERR1			 ASC "INTERPRETER FILE NOT FOUND"  
ERR1L			 EQU *-ERR1  
ERR1X			 EQU *-ERR-1  
ERR2			 ASC "INVALID INTERPRETER FILE"  
ERR2L			 EQU *-ERR2  
ERR2X			 EQU *-ERR-1  
ERR3			 ASC "INCOMPATIBLE INTERPRETER"  
ERR3L			 EQU *-ERR3  
ERR3X			 EQU *-ERR-1  
ERR4			 ASC "DRIVER FILE NOT FOUND"  
ERR4L			 EQU *-ERR4  
ERR4X			 EQU *-ERR-1  
ERR5			 ASC "INVALID DRIVER FILE"  
ERR5L			 EQU *-ERR5  
*   
RSEG010			 BRK  ; REQ.SEG(BASE, LIMIT, SEGID, SEGNUM)  
				DFB REQSEG   
				DW SEGMENT   
*     
				RTS  ; RETURN  
				PAGE    
				REP 100   
*   
* ALLOC.DSEG ( IN: DSEGLIST )   
*   
* (ALLOCATES SEGMENTS FOR DRIVER MODULES"   
REP				 100   
ALLOC.DSEG		 EQU *   
INC				 DSEGX ; DSEGX:=DSEGX+1  
BNE				 ALDS010 ; IF DSEGX=0  
LDX				 #ERR5X ; THEN ERROR("INVALID DRIVER FILE")  
LDY				 #ERR5L   
JSR				 ERROR   
*   
ALDS010			 LDY #$FF ; Y:=-1  
ALDS020			 INY ; WHILE (Y:=Y+1) < DSEGX  
CPY				 DSEGX ; DO  
BCS				 ALDS.EXIT    
LDA				 DSEGLIST,Y ; PAGECT:=DSEGLIST(Y)  
STA				 SEGPGCNT    
BRK				  ; FINDSEG (SRCHMODE=0.IN, SEGID=3  
DFB				 FINDSEG ; PAGECT=DSEGLIST(Y)  
DW				 SEGMENT1 ; BASE.OUT, LIMIT.OUT)  
JMP				 ALDS020    
*     
ERR5X			 EQU *-ERR-1  
ERR6			 ASC "DRIVER FILE TOO LARGE"  
ERR6L			 EQU *-ERR6  
ERR6X			 EQU *-ERR-1  
ERR7			 ASC "ROM ERROR: PLEASE NOTIFY YOUR DEALER"  
ERR7L			 EQU *-ERR7  
ERR7X			 EQU *-ERR-1  
ERR8			 ASC "TOO MANY DEVICES"  
ERR8L			 EQU *-ERR8  
ERR8X			 EQU *-ERR-1  
ERR9			 ASC "TOO MANY BLOCK DEVICES"  
ERR9L			 EQU *-ERR9  
ERR9X			 EQU *-ERR-1  
ERR10			 ASC "EMPTY DRIVER FILE"  
ERR10L			 EQU *-ERR10  
ERR10X			 EQU *-ERR-1  
				PAGE   
				REP 100  
*  
* WELCOME ()  
*  
* (PRINTS WELCOME MESSAGE - "APPLE ///", VERSION, DATE/TIME, COPYRIGHT)  
REP				 100  
WELCOME			 EQU *  
*  
* PRINT "APPLE III" MESSAGE  
*  
LDY				 #AMSGL  
WAM010			 LDA AMSG-1,Y  
STA				 AMSGADR-1,Y  
DEY				  
BNE				 WAM010  
*  
* PRINT SOS VERSION MESSAGE  
*  
CLC				  
LDA				 #40  
ADC				 #>SOSVERL  
LSR				 A  
TAX				  
LDY				 #>SOSVERL  
WSM010			 LDA SOSVER-1,Y  
ORA				 #$80  
STA				 SMSGADR-1,X  
DEX				  
DEY				  
BNE				 WSM010  
*  
* PRINT DATE AND TIME MESSAGE  
*  
				BRK  ; GET.TIME(TIME.OUT)  
				DFB GETTIME   
				DW DTPARMS   
*     
				LDA DATETIME+8 ;SET UP WEEKDAY  
				AND #$0F   
				BEQ WDM040 ;NO CLOCK  
				STA WTEMP   
				ASL A   
				ADC WTEMP   
				TAX    
				LDY #3   
WDM010			 LDA DAYNAME-1,X   
				STA DMSG-1,Y   
				DEX    
				DEY    
				BNE WDM010   
*     
				LDA DATETIME+7 ;SET UP DATE  
				LDX DATETIME+6   
				STA DMSG+6   
				STX DMSG+5   
*     
				LDA DATETIME+5 ;SET UP MONTH  
				AND #$0F   
				LDX DATETIME+4   
				CPX #$31   
				BCC WDM020   
				ADC #9   
WDM020			 STA WTEMP   
				ASL A   
				ADC WTEMP   
				TAX    
				LDY #3   
WDM030			 LDA MONNAME-1,X   
				STA DMSG+7,Y   
				DEX    
				DEY    
				BNE WDM030   
*     
				LDA DATETIME+3 ;SET UP YEAR  
				LDX DATETIME+2   
				STA DMSG+13   
				STX DMSG+12   
*     
				LDA DATETIME+10 ;SET UP HOUR  
				LDX DATETIME+09   
				STA DMSG+17   
				STX DMSG+16   
*     
				LDA DATETIME+12 ;SET UP MINUTE  
				LDX DATETIME+11   
				STA DMSG+20   
				STX DMSG+19   
*     
				LDY #DMSGL ;PRINT DATE & TIME  
WDM050			 LDA DMSG-1,Y   
				ORA #$80   
				STA DMSGADR-1,Y   
				DEY    
				BNE WDM050   
*     
* PRINT COPYRIGHT MESSAGE    
*     
WDM040			 LDY #CMSGL   
WCM010			 LDA CMSG-1,Y   
				STA CMSGADR-1,Y   
				DEY    
				BNE WCM010   
				RTS    
				PAGE    
				REP 100   
*  
* WELCOME () - DATA DECLARATIONS  
*  
				REP 100  
				MSB ON  
AMSG			 ASC "APPLE ///"  
AMSGL			 EQU *-AMSG  
AMSGADR			 EQU 40-AMSGL/2+$4A8  
				MSB OFF  
SMSGADR			 EQU $5A8  
DMSG			 ASC "DAY, DD-MON-YY HH:MM"  
DMSGL			 EQU *-DMSG  
DMSGADR			 EQU 40-DMSGL/2+$6A8  
DAYNAME			 ASC "SUNMONTUEWEDTHUFRISAT"  
MONNAME			 ASC "JANFEBMARAPRMAYJUN"  
				ASC "JULAUGSEPOCTNOVDEC"  
				MSB ON  
CMSG			 ASC "(C)1980,1981,1982 BY APPLE COMPUTER INC."  
CMSGL			 EQU *-CMSG  
CMSGADR			 EQU 40-CMSGL/2+$7D0  
				MSB OFF  
				PAGE   
				REP 100  
*   
* SOS SYSTEM CALLS (1)   
*   
REP				 100  
* OPEN (PATHNAME.IN, REFNUM.OUT, OPENLIST.IN, OPENCNT.IN) ** (ACCESS.IN, PAGES.IN, SYSBUF.IN)
				REP 100  
OPEN			 EQU $C8  
*    
OPEN.PARMS		 DFB $4  
				DW PATH  
OPEN.REF		 DFB $0  
				DW OPEN.LIST  
				DFB $4   
OPEN.LIST		 DFB $0,$4 ; PAGES:=4  
				DW SYSBUF.P   
PATH			 DS $40 ; PATHNAME BUFFER  
I.LABEL			 ASC "SOS NTRP" ; FILE LABELS  
D.LABEL			 ASC "SOS DRVR"   
				REP 100   
* READ (REFNUM.IN, BUFFER.IN, BYTES.IN, BYTESREAD.OUT)  
REP				 100  
READ			 EQU $CA  
*  
READ.PARMS		 DFB $4  
READ.REF		 DFB $0  
READ.BUF		 DW RDBUF.P  
READ.BYT		 DW $FFFF-FILE+1  
READ.BYTRD		 DW $0  
REP				 100  
* CLOSE (REFNUM.IN)  
REP				 100  
CLOSE			 EQU $CC  
*  
CLOSE.PARMS		 DFB $1  
CLOSE.REF		 DFB $0  
REP				 100  
* FIND.SEG (SRCHMODE.IN, PAGES.IN, SEGID.IN, BASE.OUT, LIMIT.OUT, SEGNUM.OUT)  
				REP 100   
FINDSEG			 EQU $41   
*     
SEGMENT1		 DFB $6 ; FIND.SEG(SRCHMODE, SEGID, PAGECT, BASE, LIMIT, SEGNUM)  
SEGSRCH			 DFB $0,$3   
SEGPGCNT		 DW $0000   
				DW $0   
				DW $0   
				DFB $0   
				PAGE    
				REP 100   
*   
* SOS SYSTEM CALLS (2)   
*   
REP				 100  
REP				 100  
* REQUEST.SEG (BASE.IN, LIMIT.IN, SEGID.IN, SEGNUM.OUT)  
				REP 100   
REQSEG			 EQU $40   
*     
SEGMENT			 DFB $4 ; REQUEST SEG PARM LIST  
SEGBASE			 DFB $F,$0   
SEGLIM			 DFB $F,$1D   
SEGID			 DFB $0,$0   
				REP 100   
* SET.PREFIX (PREFIXPATH.IN)   
REP				 100   
SETPREFIX		 EQU $C6   
PREFX.PARMS		 DFB $1   
DW				 PREFX.PATH   
PREFX.PATH		 DFB $3   
ASC				 '.D1'   
REP				 100   
* GETTIME (TIME.OUT)   
REP				 100   
GETTIME			 EQU $63   
*   
DTPARMS			 DFB 1   
DW				 DATETIME   
DATETIME		 ASC "YYYYMMDDWHHMMSSMMM"   
PAGE			   
REP				 100   
*   
* END OF SOSLDR CODE   
*   
REP				 100   
SLOP			 EQU >$F8-*   
DS				 SLOP ; +-----------------------------------+  
INITMODULE		 DS $200 ; ! KERNEL'S INIT MODULE RESIDES HERE !  
LDREND			 EQU * ; +-----------------------------------+  
FILE			 EQU *-$2000+$400   
REP				 100   
* SOS INTERPRETER FILE   
REP				 100   
I.FILE			 EQU FILE   
I.HDR.CNT		 EQU I.FILE+$8   
				REP 100  
* SOS DRIVER FILE   
				REP 100  
D.FILE			 EQU FILE  
D.HDR.CNT		 EQU D.FILE+$8  
D.DRIVES		 EQU D.HDR.CNT+$2  
D.CHRSET		 EQU D.DRIVES+$2+$10  
D.KYBD			 EQU D.CHRSET+$10+$400  
				REP 100  
				   
				LST ON  
ZZEND			 EQU *  
ZZLEN			 EQU ZZEND-ZZORG  
*    
NE				 ZZLEN-LENLODR   
FAIL			 2,"SOSORG FILE IS INCORRECT FOR SOS LOADER"  
FIN				   
*   
				  
*************************************************************************  
* END OF APPLE /// SOS 1.3 SOURCE CODE FILE: SOSLDR.F.SRC  
*************************************************************************  
				 
*--------------------------------------
MAN
SAVE /A3OSX.BUILD/SOS.13\sos.s.sosldr.f.txt
LOAD /A3OSX.BUILD/SOS.13/sos.s
ASM
