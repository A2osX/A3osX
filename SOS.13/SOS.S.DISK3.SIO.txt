NEW
  AUTO 3,1
*--------------------------------------
*************************************************************************  
* APPLE /// SOS 1.3 SOURCE CODE FILE: DISK3.SIO.SRC  
*************************************************************************  
* ASSEMBLER: APPLE ][ 6502 ASSEMBLER from APPLE COMPUTER TOOLKIT  
				 
PAGE			  
REP				 40  
* NAME : SECTORIO  
* FUNCTION: READ OR WRITE A SECTOR  
* INPUT : IBSTRK, IBSECT, MONTIME,  
* RETURNS : CARRY CLEAR IF OK (AC=00)  
* : CARRY SET IF ERROR (AC=ERRCODE)  
* : SEEKWAIT ALL SETUP  
* DESTROYS: ALL REGISTERS  
REP				 40  
*  
SECTORIO		 EQU *  
LDA				 #R.RECAL ;SETUP THE  
* R.RECAL MUST BE NON-ZERO!! (SEE BELOW)  
STA				 RECALCNT ; RECAL TRIES  
NOP				 ; PAD ONE BYTE  
STA				 E1908 ; A-REG MUST BE NON-ZERO !!!  
* E1908 = NON-ZERO LOCKOUT MOUSE  
*  
LDY				 D.UNITNUM ;ARE WE ON-TRACK?  
LDA				 TRACK  
CMP				 DRVTRACK,Y  
BEQ				 SOUGHT ;=>IF SO, FORGET SEEK & DELAY!  
*  
* WAIT BEFORE STEPPING:  
*  
LDA				 SEEKWAIT ;SEEK DELAY NEEDED?  
BEQ				 GOSEEK ;=>NAW...  
LDA				 #0  
STA				 SEEKWAIT ;CLEAR THE FLAG  
LDA				 #4 ;ADD SEEKDELAY TO  
JSR				 ADDTIME ; THE TOTAL UPTIME(S)  
TAY				 ;4*25 MS DELAY  
SEEKDEL			 EQU *  
LDA				 #0  
JSR				 MSWAIT  
DEY				  
BNE				 SEEKDEL  
*  
* ISSUE THE SEEK:  
*  
GOSEEK			 EQU *  
LDA				 TRACK ;GET DESTINATION TRACK  
JSR				 MYSEEK ;=>..AND YOU SHALL FIND...  
*  
SOUGHT			 EQU *  
LDA				 IRQMASK ;SET IRQ MASK FOR  
STA				 IMASK ; CORE ROUTINES  
LDA				 #R.IRQ ;SETUP IRQ RETRIES  
STA				 INTRTRY  
LDA				 #R.IOERR ; AND ERROR RETRIES  
STA				 RETRYCNT  
*  
* DELAY FOR ANY REMAINING MOTOR-UP TIME:  
*  
MDELAY			 EQU *  
LDA				 MONTIMEH ;ANY TIME REMAINING?  
BPL				 FINDIT ;=>NO, WE'RE UP TO SPEED.  
LDA				 #1 ;YES, SO BUMP A SLICE OF  
JSR				 ADDTIME ; UPTIME WHILE WE WAIT  
LDA				 #0  
JSR				 MSWAIT  
JMP				 MDELAY ;=>GO TILL ENOUGH  
*  
* FIND THE DESIRED SECTOR:  
*  
* NOTE: FINDSECT RETURNS WITH  
000074			 * IRQ * INHIBITED!   
FINDIT			 EQU *  
				PHP ;INHIBIT IRQ WHILE  
				SEI  ; MESSING WITH VBL FLAGS  
				LDA E.IER ;DISABLE VBL IRQ  
				AND #$18 ; DURING SECTOR I/O  
				STA E.IER   
				ORA #$80 ;FOR 'SET' LATER  
				STA VBLSAVE   
				PLP  ;RESTORE IRQ STATUS  
				JSR FINDSECT ;FIND ME PLEASE  
				BCS TRYRECAL ;=>NO? RECAL OR GIVE UP!  
				LDX #$60 ;SET UP SLOT FOR CORE RTNS  
				LDA D.COMMAND ;WHAT'S YOUR PLEASURE?  
				BNE SIOWRITE ;=>WRITE  
*     
				REP 40   
* READ A SECTOR:     
*     
				JSR READ ;READ THAT SECTOR  
				JSR FIXIRQ ;ENABLE IRQ IF OK  
				LDA VBLSAVE ;ALLOW VBL DURING  
				STA E.IER ; POSTNIB  
				BCS BADIO ;=>I/O ERR OR IRQ  
				LDA E.REG ;SET 2MHZ FOR POSTNIB  
				AND #$7F   
				STA E.REG   
				JSR POSTNIB ;POSTNIB/CHECKSUM  
				BCS IORETRY ;=>I/O ERR:BAD CHKSUM  
				JMP SIOGOOD ;=>GOOD READ  
*     
				REP 40   
* WRITE A SECTOR:  
*  
SIOWRITE		 EQU *   
				JSR WRITE ;WRITE THE DATA  
				JSR FIXIRQ ;RE-ENABLE IRQ IF OK  
				LDA VBLSAVE ;RESTORE  
				STA E.IER ; VBL IRQ  
				BCC SIOGOOD ;=>GOOD WRITE  
				BVC SIOWPROT ;=>WRITE PROTECTED  
*     
				REP 40   
* IT DIDN'T GO WELL FOR US:  
*  
BADIO			 EQU *   
				DO 1-REV0ROM ;FOR REV1  
				BVS FINDIT ;=>IRQ. JUST RETRY IT.  
				ELSE  ;FOR REV0  
*   
* THE REV1 ROM TAKES CARE OF THE   
* IRQ RETRY COUNT, BUT REV0 DOESN'T:   
*   
BVC				 IORETRY ;=>I/O ERROR. RETRY IT  
LDA				 ROMREV ;WHICH ROM?  
BNE				 FINDIT ;=>REV1. HE DOES IT.  
LDA				 INTRTRY ;REV0. OUT OF RETRIES?  
BPL				 BADIO2 ;=>NO.  
STA				 IMASK ;SET HI BIT FOR IRQ MASK  
BADIO2			 EQU *   
DEC				 INTRTRY ;ONE LESS RETRY  
JMP				 FINDIT ;=>RETRY AFTER IRQ  
FIN				   
*   
* RETRY AFTER AN I/O ERROR:   
*   
IORETRY			 EQU *   
DEC				 RETRYCNT ;ANY RETRIES LEFT?  
BNE				 FINDIT ;=>YEAH, RETRY AFTER ERROR  
*   
* RETRIES EXHAUSTED. RECALIBRATE:   
*   
TRYRECAL		 EQU *   
LDA				 VBLSAVE ;ALLOW VBL IF RECAL  
STA				 E.IER ; OR UNRECOVERABLE ERROR  
DEC				 RECALCNT ;HAVE WE RECALIBRATED YET?  
BMI				 SIOERR ;=>YUP. WE'RE DEAD.  
JSR				 RECAL ;NO, TRY OUR LUCK  
LDY				 D.UNITNUM ;ARE WE ON-TRACK?  
LDA				 TRACK   
CMP				 DRVTRACK,Y   
BNE				 NOTSAME   
JMP				 SOUGHT ;=>IF SO, FORGET RESEEK  
NOTSAME			 EQU *   
				JMP GOSEEK ;TRY AGAIN ON TARGET TRACK  
*     
				REP 40   
SIOERR			 EQU *   
				LDA #XIOERROR ;RETURN CODE  
				SEC  ;INDICATE HARD ERROR  
				BCS SIORET   
SIOWPROT		 EQU *   
				LDA #XNOWRITE ;RETURN CODE  
				SEC  ;INDICATE HARD ERROR  
				BCS SIORET   
SIOGOOD			 EQU *   
				LDA #0   
				CLC  ;INDICATE GOOD COMPLETION  
SIORET			 LDX #0 ; SAY OK TO MOUSE  
				STX E1908 ; WITH THIS GLOBAL $1908  
				RTS    
				PAGE    
				REP 40   
* NAME : FINDSECT    
* FUNCTION: LOCATE A DESIRED SECTOR  
* INPUT : IBTRK, IBSECT SETUP  
* RETURNS : CARRY CLEAR IF OK,  
* : CARRY SET IF ERROR.  
* DESTROYS: ALL REGISTERS & 'TEMP'  
* NOTE : RETURNS WITH IRQ DISABLED IF NO ERROR!  
				REP 40   
*     
FINDSECT		 EQU *   
				LDA #R.FIND*16 ;SETUP NUMBER OF REVS  
				STA RETRYADR ; ALLOWED TO FIND SECTOR  
				LSR TEMP ;COMPUTE LATENCY FIRST TIME THRU  
FINDSEC2		 EQU *   
				LDX #$60 ;FAKE SLOT FOR CORE ROUTINES  
				JSR RDADR ;GET NEXT ADDRESS FIELD  
				BCS RDADERR ;=>UGH! AN ERROR!  
*  
* MAKE SURE WE'RE ON THE CORRECT TRACK:  
*  
LDA				 TRACK ;IS IT  
CMP				 CSSTV+2 ; CORRECT TRACK?  
BNE				 FINDERR ;=>NO?!? IT'S USELESS!  
LDA				 SECTOR ;IS IT  
CMP				 CSSTV+1 ; DESIRED SECTOR?  
BEQ				 FINDGOOD ;=>YEAH. GOT IT!  
*  
* COMPUTE LATENCY. EACH TWO-SECTOR  
* DISTANCE IS 25 MS OF UPTIME.  
*  
LDA				 TEMP ;LATENCY ALREADY COMPUTED?  
BMI				 RDADERR ;=>YES.  
LDA				 SECTOR ;HOW FAR AWAY IS OUR  
SEC				  ; DESIRED SECTOR?  
ROR				 TEMP ;PREVENT RECOMPUTATION  
SBC				 CSSTV+1   
AND				 #$0F   
LSR				 A ;EACH 2-SECTORS IS 25 MS  
JSR				 ADDTIME   
*  
* KEEP LOOKING TILL WE FIND IT:  
*  
RDADERR			 EQU *   
				JSR FIXIRQ ;ENABLE IRQ IF APPROPRIATE  
				DEC RETRYADR ;ANY RETRIES LEFT?  
				BEQ FINDERR ;=>NO, WE CAN'T FIND IT.  
*   
* COMPENSATE FOR A BUG IN RDADR: IF WE TRY   
* TO CALL RDADR AGAIN BEFORE THE DATA MARK   
* GOES BY, THEN RDADR WILL ACCIDENTALLY CALL   
* THAT AN ERROR. WE CAN AVOID THIS 'FAKE'   
* ERROR BY DELAYING PAST THE DATA MARK.   
LDY				 #200 ;1 MS IS PLENTY  
ADRDELAY		 EQU *   
DEY				   
BNE				 ADRDELAY   
JMP				 FINDSEC2 ;=>NOW TRY LOOKING AGAIN  
*   
REP				 40   
FINDGOOD		 EQU *   
LDA				 #0 ;CLEAR VOLNUM OUT OF  
STA				 MONTIMEH ; MOTORTIME!  
				CLC  ;INDICATE NO ERROR  
				RTS    
*     
FINDERR			 EQU *   
				JSR FIXIRQ ;ENABLE IRQ IF APPROPRIATE  
				LDA #0 ;CLEAR VOLNUM OUT OF  
				STA MONTIMEH ; MOTORTIME!  
				SEC  ;INDICATE THE ERROR  
				RTS    
				    
				CHN DISK3.USEL.SRC   
				    
*************************************************************************  
* END OF APPLE /// SOS 1.3 SOURCE CODE FILE: DISK3.SIO.SRC  
*************************************************************************  
				 
				 
*--------------------------------------
MAN
SAVE /A3OSX.BUILD/SOS.13\sos.s.disk3.sio.txt
LOAD /A3OSX.BUILD/SOS.13/sos.s
ASM
