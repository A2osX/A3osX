NEW
  AUTO 3,1
*--------------------------------------
*************************************************************************  
* APPLE /// SOS 1.3 SOURCE CODE FILE: ALLOC  
*************************************************************************  
* ASSEMBLER: APPLE ][ 6502 ASSEMBLER from APPLE COMPUTER TOOLKIT  
				 
*  
DEALLOC			 STX BMCNT ; SAVE HIGH ORDER ADDRESS OF BLOCK TO BE FREED.  
				PHA ; SAVE IT  
				LDX VCBPTR ; WHILE THE BITMAP  
				LDA VCB+VCBTBLK+1,X ; DISK ADDRESS IS CHECKED  
				CMP BMCNT ; TO SEE IF IT MAKES SENSE  
				PLA ; RESTORE  
				BCC DEALERR1 ; BRANCH IF IMPOSSIBLE  
				TAX  
				AND #$7 ; GET THE BIT TO BE OR-ED IN.  
				TAY  
				LDA WHICHBIT,Y ; (SHIFTING TAKES 7 BYTES, BUT IS SLOWER)  
				STA NOFREE ; SAVE BIT PATTERN  
				TXA ; GET LOW BLOCK ADDRESS AGAIN.  
				LSR BMCNT  
				ROR A ; GET POINTER TO BYTE IN BITMAP THAT REPRESENTS  
				LSR BMCNT ; THE BLOCK ADDRESS.  
				ROR A  
				LSR BMCNT  
				ROR A  
STA				 BMPTR ; SAVE POINTER.  
LSR				 BMCNT ; NOW TRANSFER BIT WHICH SPECIFIES WHICH PAGE OF BITMAP.  
				ROL HALF  
				LDX BMTAB ; (THIS POINTS TO THE TABLE FOR THE BITMAP BUFFER USED).  
				LDA BMACMAP,X ; WHAT IS THE CURRENT MAP  
				CMP BMCNT ; IS IN CORE BIT MAP THE ONE WE WANT?  
				BEQ DEALL1 ; BRANCH IF IN-CORE IS CORRECT.  
				JSR BMAPUP ; PUT CURRENT MAP AWAY.  
				BCS DEALERR ; PASS BACK ANY ERROR.  
				LDA BMCNT ; GET DESIRED MAP NUMBER.  
				LDY #VCBCMAP  
				STA (VCBPTR),Y ; AND MAKE IT CURRENT.  
				LDX BMTAB  
				LDA BMADEV,X  
				JSR GTBMAP ; READ IT INTO THE BUFFER,  
				BCS DEALERR  
DEALL1			 LDY BMPTR ; INDEX TO BYTE.  
				LSR HALF  
				BCC DEALL2 ; BRANCH IF ON PAGE ONE OF BITMAP.  
				INC BMADR+1  
DEALL2			 LDA NOFREE ; THE INDIVIDUAL BIT.  
				ORA (BMADR),Y  
				STA (BMADR),Y  
				BCC DEALL3 ; BRANCH IF ADDRESS IS PROPER  
				DEC BMADR+1  
DEALL3			 LDX BMTAB ; MARK BITMAP AS MODIFIED.  
				LDA #$80  
				ORA BMASTAT,X  
				STA BMASTAT,X  
				CLC  
DEALERR			 RTS  
DEALERR1		 LDA #BITMAPADR ; BIT MAP BLOCK NUMBER IMPOSSIBLE  
				SEC ; SAY BIT MAP DISK ADDRESS WRONG  
				RTS ; (PROBABLY DATA MASQUERADING AS INDEX BLOCK)  
*  
WHICHBIT		 DFB $80,$40,$20,$10  
				DFB 8,4,2,1  
*  
*  
				PAGE  
*  
ALCIDXS			 LDA #0 ; ALLOCATION OF THE INDEXES ALWAYS FILLS IN  
				STA SAPTR ; STARTING AT THE BEGINNING OF THE BLOCK.  
				JSR ALC1BLK ; THIS GETS FIRST INDEX AND SETS UP A  
				BCS ERRALC1 ; POINTER TO THE FREE BLOCKS (TO AVOID  
ALIDX1			 LDY SAPTR ; SCANNING THE WHOLE BLOCK EVERY TIME).  
				STA (TINDX),Y ; SAVE INDEX BLOCK ADDRESS (LOW)  
				INC TINDX+1  
				LDA SCRTCH+1 ; GET HIGH BYTE OF ADDRESS  
				STA (TINDX),Y ; (AND SAVE IT)  
				DEC TINDX+1   
				DEC REQL ; HAS REQUEST BEEN SATIFIED?  
				BEQ ALDXEND ; (CARRY IS CLEAR)  
				INC SAPTR ; BUMP INDEX POINTER  
				LDY BMPTR ; GET INDEX POINTER TO LAST ACCESSED BIT GROUP  
				LDA HALF ; WHICH HALF OF MAP? (BOTH BMPTR & HALF SET UP BY 'ALC1BLK')  
				BNE SECNDHAF   
				JSR GETBITS1 ; GET NEXT FREE BLOCK ADDRESS.  
				BCC ALIDX1 ; BRANCH IF NO ERROR  
ERRALC1			 RTS    
*     
SECNDHAF		 JSR GETBITS2 ; GET NEXT FREE BLOCK ADDRESS FROM SECOND HALF OF BIT MAP  
				BCC ALIDX1 ; BRANCH IF NO ERROR.  
ALDXEND			 RTS  ; RETURN STATUS (CARRY SET INDICATES ERROR)  
*     
*     
ALC1BLK			 JSR FNDBMAP ; GET ADDRESS OF BIT MAP IN 'BMADR'  
				BCS ERRALC1 ; BRANCH IF ERROR ENCOUNTERED  
SRCHFRE			 LDY #0 ; START SEARCH AT BEGINNING OF BIT MAP BLOCK  
				STY HALF ; INDICATE WHICH HALF (PAGE) WE'RE SEARCHING.  
GETBITS1		 LDA (BMADR),Y   
				BNE BITFOUND ; FREE BLOCKS ARE INDICATED BY 'ON' BITS  
				INY    
				BNE GETBITS1 ; CHECK ALL OF 'EM IN FIRST PAGE.  
				INC BMADR+1 ; BUMP HIGH ADDRESS OF CURRENT BITMAP  
				INC HALF ; INDICATE SEARCH HAS PROGRESSED TO PAGE 2  
				INC BASVAL ; BASE VALUE= BASE ADDRESS/2048  
GETBITS2		 LDA (BMADR),Y ; SEARCH SECOND HALF FOR FREE BLOCK  
				BNE BITFOUND   
				INY    
				BNE GETBITS2   
				DEC BMADR+1 ; RESET BIT MAP ADDRESS TO BEGINNING.  
				INC BASVAL ; ADD 2048 OFFSET FOR NEXT PAGE  
				JSR NXTBMAP ; GET NEXT BITMAP (IF IT EXISTS) AND UPDATE VCB.  
				BCC SRCHFRE ; BRANCH IF NO ERROR ENCOUNTERED.  
				RTS  ; RETURN ERROR.  
				PAGE    
*     
BITFOUND		 STY BMPTR ; SAVE INDX POINTER TO VALID BIT GROUP  
				LDA BASVAL ; SET UP FOR BLOCK ADDRESS CALCULATION  
				STA SCRTCH+1   
				TYA  ; GET ADDRESS OF BIT PATTERN  
				ASL A ; MULTIPLY THIS AND BASVAL BY 8  
				ROL SCRTCH+1   
				ASL A   
				ROL SCRTCH+1   
				ASL A   
				ROL SCRTCH+1   
				TAX  ; NOW X= LOW ADDRESS WITHIN 7 OF ACTUAL ADDRESS.  
				LDA (BMADR),Y ; GET BIT PATTERN AGAIN  
				SEC  ; MARK RIGHT END OF BYTE.  
ADCALC			 ROL A ; FIND LEFT MOST 'ON' BIT  
				BCS BOUNCE ; BRANCH IF FOUND.  
				INX  ; ADJUST LOW ADDRESS  
				BNE ADCALC ; BRANCH ALWAYS  
BOUNCE			 LSR A ; RESTORE ALL BUT LEFT MOST BIT TO ORIGINAL POSITION  
				BCC BOUNCE ; LOOP UNTIL MARK (SET ABOVE) MOVES INTO CARRY  
				STA (BMADR),Y ; UPDATE BITMAP TO SHOW ALLOCATED BLOCK IN USE.  
				STX SCRTCH ; SAVE LOW ADDRESS.  
				LDX BMTAB ; UPDATE BIT MAP BUFFER STATUS  
				LDA #$80 ; INDICATE MAP HAS BEEN MODIFIED  
				ORA BMASTAT,X ; (X IS EITHER 0 OR 6 FOR  
				STA BMASTAT,X ; BUFFER 'A' OR 'B' RESPECTIVELY.)  
				LDY #VCBTFRE ; SUBTRACT 1 FROM TOTAL FREE  
				LDA (VCBPTR),Y ; BLOCKS IN VCB TO ACCOUNT FOR NEWLY  
				SBC #1 ; ALLOCATED BLOCK (CARRY IS SET FROM 'BOUNCE')  
				STA (VCBPTR),Y   
				BCS RET1BLK ; BRANCH IF HI FREE COUNT DOESN'T NEED ADJUSTMENT.  
				INY    
				LDA (VCBPTR),Y ; ADJUST HIGH COUNT.  
				SBC #0 ; (CARRY IS CLEAR, SO ACC=ACC-1)  
				STA (VCBPTR),Y   
RET1BLK			 CLC  ; INDICATE NO ERROR ENCOUNTERED  
				LDA SCRTCH ; GET ADDRESS LOW IN ACC.  
				LDY SCRTCH+1 ; AND HIGH ADDRESS IN Y  
				RTS  ; RETURN ADDRESS OF NEWLY ALLOCATED BLOCK.  
*     
				PAGE    
*     
GTTINDX			 LDY #VCBDEV ; GET DEVICE NUMBER SO WE DON'T  
				LDX #0 ; ANTICPATE USING BUFFER 'A'.  
				LDA (VCBPTR),Y ; USE THE BUFFER USED BY IT!  
				CMP BMADEV ; IS IT IN BUFFER 'A'?  
				BEQ FREEBE ; IF SO, FREE 'B'!  
				CMP BMBDEV ; IF NOT, IS IT IN 'B'?  
				BEQ FREEA ; IF SO, FREE UP BUFFER 'A'  
				JSR FNDBMAP ; OTHERWISE, FORCE ALLOCATION FOR ONE OF THE BUFFERS  
				BCC GTTINDX ; NOW TRY AGAIN.  
				RTS  ; RETURN ERROR.  
*     
FREEBE			 LDX #BMTABSZ ; DE-ALLOCATE BUFFER IF NECESSARY  
FREEA			 STX NOFREE ; SAVE WHICH BUFFER WE'RE LOOKIN AT.  
				LDY BMASTAT,X ; DO WE NEED TO WRITE BUFFER TO FREE IT?  
				BPL USEBUF ; NO, THEN USE IT.  
				STX ZPGTEMP ; SAVE BM BUFFER ID FOR A BIT  
				JSR WRTBMAP ; WRITE BM TO OWNING UNIT  
				BCS SOMERR1 ; RETURN ANY ERROR (W/O RELEASING BM)  
				LDX ZPGTEMP ; FETCH THE BM BUFFER ID  
				LDA #0   
				STA BMASTAT,X ; AND MARK BM BUFFER AS FREE  
USEBUF			 LDX NOFREE ; GET INDEX TO BUFFER INFO  
				LDA #0 ; MARK STATUS OF BUFFER AS FREE.  
				STA BMADEV,X ; (DEVICE 0 IS NOT ANY DEVICE)  
				STA TINDX   
				STA BMADR   
				LDA BMAMADR,X ; GET MEMORY ADDRESS OF FREE BUFFER.  
				STA TINDX+1   
				TXA  ; SET UP PROPER HI ADDRESS OF BIT MAP TOO...  
				EOR #BMTABSZ ; SELECT ALTERNATE BIT MAP TABLE.  
				STA BMTAB ; (TO INDICATE WHICH IS BITMAP)  
				TAX    
				LDA BMAMADR,X ; GET HIGH ADDRESS OF BIT MAP.  
				STA BMADR+1   
				LDA BMBUFBNK ; AND BANK PAIR NUMBER.  
				STA SSTIDXH   
				STA SISBMADR   
				CLC  ; INDICATE NO ERRORS  
SOMERR1			 RTS    
*     
				PAGE    
NXTBMAP			 LDY #VCBTBLK+1 ; BEFORE BUMPING TO NEXT MAP,  
				LDA (VCBPTR),Y ; CHECK TO BE SURE THERE IS  
				LSR A ; INDEED A NEXT MAP!  
				LSR A   
				LSR A   
				LSR A   
				LDY #VCBCMAP   
				CMP (VCBPTR),Y ; ARE THERE MORE MAPS?  
				BEQ NOMORBIT ; BRANCH IF NO MORE TO LOOK AT.  
				LDA (VCBPTR),Y ; ADD 1 TO CURRENT MAP  
				CLC    
				ADC #1   
				STA (VCBPTR),Y   
				LDY #VCBDEV   
				LDA (VCBPTR),Y   
				TAX  ; GO WRITE OUT LAST MAP IF NECESSARY  
				JSR UPBMAP   
				JMP FNDBMAP ; READ NEXT BIT MAP INTO BUFFER  
*     
GETA.BUF		 LDX #0   
				BEQ FRESHMAP   
*     
GETB.BUF		 LDX #BMTABSZ   
				BNE FRESHMAP ; BRANCH ALWAYS  
*     
*     
FNDBMAP			 LDY #VCBDEV ; GET DEVICE NUMBER  
				LDA (VCBPTR),Y   
				LDX #0 ; START WITH MAP 'A'  
FNDMAP1			 CMP BMADEV,X   
				BNE TRYMAP2   
FRESHMAP		 STX BMTAB ; SAVE POINTER TO BIT MAP INFO TABLE  
				LDY BMASTAT,X ; IS THIS ONE ALREADY MODIFIED?  
				BMI BMFOUND ; YES, RETURN POINTER IN 'BMADR'  
				JSR GTBMAP ; OTHERWISE READ IN FRESH BIT MAP  
				BCC BMFOUND ; BRANCH IF SUCCESSFUL.  
				RTS  ; OTHERWISE, RETURN ERROR.  
*     
TRYMAP2			 DEX  ; WAS LAST FAILURE MAP 'A'  
				BPL FRBMBUF ; NO, MUST FREE UP ONE OF THE BUFFERS  
				LDX #BMTABSZ ; TRY BIT MAP BUFFER 'B'.  
				JMP FNDMAP1   
				PAGE    
*     
BMFOUND			 LDX BMTAB ; WHICH TABLE?  
				LDY #VCBCMAP   
				LDA (VCBPTR),Y   
				ASL A   
				STA BASVAL   
				LDA BMAMADR,X ; GET HIGH ADDRESS  
				STA BMADR+1   
				LDA BMBUFBNK ; GET BANK NUMBER OF BUFFER BIT MAP BUFFERS  
				STA SISBMADR   
				LDA #0 ; BUFFERS ALWAYS FALL ON A PAGE BOUNDARY  
				STA BMADR   
				CLC  ; INDICATE ALL IS VALID AND GOOD!  
				RTS    
*     
NOMORBIT		 LDA #OVRERR ; INDICATE REQUEST CAN'T BE FILLED.  
				SEC  ; INDICATE ERROR  
				RTS    
*     
FRBMBUF			 SEC    
				LDX BMTAB ; FIND OUT WHICH WAS LAST USED.  
				BEQ CHKBMB ; IF 'A' WAS USED CHECK 'B' FIRST  
				CLC  ; INDICATE 'A' IS CHECKED FIRST  
				BIT BMASTAT ; IS BUFFER 'A' FREE (UNMODIFIED)?  
				BPL GETA.BUF ; YES, USE IT.  
CHKBMB			 BIT BMBSTAT ; IS BUFFER 'B' FREE?  
				BCC FREBUF1 ; BRANCH IF BOTH ARE USED  
				BPL GETB.BUF ; YES...  
				BIT BMASTAT ; (CHECK 'A')  
				BPL GETA.BUF   
FREBUF1			 LDX #0   
				BCC FREBUFA ; BRANCH IF BUFFER 'A' HAS LEAST PRIORITY.  
				LDX #BMTABSZ   
FREBUFA			 STX ZPGTEMP ; SAVE BM BUFF ID FOR A BIT  
				JSR WRTBMAP ; XREG PASSES BM BUFF ID  
				BCS NOGO ; ERROR ENCOUNTERED ON WRITING  
				LDX ZPGTEMP ; FETCH BM BUFF ID  
				LDA #0   
				STA BMASTAT,X ; AND MARK BM BUFFER AS FREE  
				BCC FNDBMAP ; LOOK AGAIN FOR FRRE BIT MAP BUFFER SPACE  
NOGO			 RTS  ; RETURN ERROR ON WRITING BM  
*     
UPBMAP			 CPX BMADEV ; UPDATE BIT MAP OF DEVICE X  
				BNE UPBM1   
				CLC  ; FREE BUFFER 'A' IF NEEDED.  
				BIT BMASTAT   
				BMI FREBUF1 ; (CARRY CLEAR FOR BUFFER 'A')  
				RTS    
				PAGE    
*     
UPBM1			 CPX BMBDEV   
				BNE NOUPDAT ; DON'T UPDATE IF NOT NECESSARY.  
				BIT BMBSTAT   
				BMI FREBUF1 ; (CARRY IS SET)  
NOUPDAT			 CLC    
				RTS  ; RETURN 'NO ERROR'  
*     
CLEARBMS		 EQU * ; MAKE SURE ALL BIT MAPS ASSOCIATED  
* WITH A DEVICE ARE MARKED INVALID   
* IF A NEW VOLUME IS LOGGED IN ON IT.   
* INPUT ARG: A REG = DEVNUM   
* X REG PRESERVED   
LDY				 #0   
CMP				 BMADEV   
BNE				 CLRBM1 ; BRANCH IF BIT MAP A NOT OWNED  
BIT				 BMASTAT   
BMI				 CLRBM2 ; BRANCH IF BITMAP A BUSY  
STY				 BMADEV ; ELSE, CLEAR IT  
CLRBM2			 RTS ; NEED ONLY CLEAR ONE  
CLRBM1			 CMP BMBDEV ; BIT MAP B?  
BNE				 CLRBM2 ; BRANCH IF BIT MAP B NOT OWNED BY DEVNUM  
BIT				 BMBSTAT   
BMI				 CLRBM2 ; BRANCH IF BITMAP B BUSY  
STY				 BMBDEV ; ELSE CLEAR IT  
RTS				 ; AND RETURN TO CALLER (NO ERRORS)  
*   
GTBMAP			 STA BMADEV,X ; SAVE ACC AS CURRENT DEVICE FOR BUFFER  
LDA				 BMAMADR,X ; GET HIGH ORDER ADDRESS OF BUFFER  
STA				 BMADR+1 ; SELECTED BY X  
LDA				 BMBUFBNK ; AND GET BANK PAIR NUMBER  
STA				 SISBMADR ; OF BOTH BIT MAP BUFFERS 'A' AND 'B'  
LDY				 #VCBCMAP ; GET LOWEST MAP NUMBER WITH FREE BLOCKS IN IT.  
LDA				 (VCBPTR),Y   
STA				 BMACMAP,X ; ASSOCIATE THE OFFSET WITH THE BITMAP CONTROL BLOCK  
CLC				    
LDY				 #VCBDMAP ; ADD THIS NUMBER TO THE BASE  
ADC				 (VCBPTR),Y ; ADDRESS OF FIRST BIT MAP  
STA				 BMADADR,X ; SAVE LOW ADDRESS OF BIT MAP TO BE USED.  
INY				  ; NOW GET HIGH DISK ADDRESS OF MAP  
LDA				 (VCBPTR),Y ; ADD TO THIS THE STATE OF THE CARRY  
ADC				 #0   
STA				 BMADADR+1,X ; SAVE HIGH DISK ADDRESS TOO.  
;				 DROP INTO 'RDBMAP'    
*    
PAGE			    
*    
LDA				 #RDCMD ; (X CONTAINS AN INDEX TO DETERMINE WHICH BUFFER)  
DOBMAP			 STA DHPCMD ; SAVE DEVICE COMMAND  
				LDA DEVNUM ; FIX THE 'BIT MAP TRASH BUG'  
				PHA  ; BY NOT MUNGING DEVNUM  
				LDA BMADEV,X ; GET DEVICE NUMBER.  
				STA DEVNUM   
				LDA BMADADR,X ; AND MAP'S DISK ADDRESS  
				STA BLOKNML   
				LDA BMADADR+1,X   
				STA BLOKNMH   
				LDA BMAMADR,X ; LASTLY GET THE ADDRESS OF THE BUFFER  
				LDX BMBUFBNK ; AND BANK NUMBER.  
				JSR DOBITMAP ; (NOTE: LOW ADDRESS IS FIXED TO ZERO AS THIS IS A BUFFER)  
				PLA  ; RESTORE  
				STA DEVNUM ; THE DEVNUM WE CAME IN WITH!  
				RTS    
*     
WRTBMAP			 LDA #WRTCMD ; WRITE BIT MAP POINTED TO BY X  
				JMP DOBMAP   
*     
WRTGBUF			 LDA #WRTCMD ; SET CALL FOR WRITE.  
				BNE SVGCMD ; BRANCH ALWAYS.  
RDGBUF			 LDA #RDCMD ; SET CALL FOR READ.  
SVGCMD			 STA DHPCMD ; PASSED TO DEVICE HANDLER.  
				LDA BLOKNML ; SAVE CURRENT  
				STA TTLINK ; GBUF BLOCK  
				LDA BLOKNMH ; ADDRESS  
				STA TTLINK+1 ; FOR DIRECTORY EXTEND  
				LDA #GBUF/256 ; GET HIGH ADDRESS OF GENERAL BUFFER  
				LDX #0 ; TO FORCE ACCESS TO NON BANK MEMORY.  
DOBITMAP		 EQU *   
DOIDX			 STA DBUFPH   
				STX SISBPH ; SELECT BANK  
				LDA #0 ; GENERAL PURPOSE BUFFERS ALWAYS  
				STA DBUFPL ; START ON A PAGE BOUNDARY.  
				JMP FILEIO2 ; END VIA DEVICE DISPATCHER.  
*     
TTLINK			 DS 2 ; GBUF CURRENT ADDRESS  
*     
WRTINDX			 LDA #WRTCMD   
				LDX IDXADRL ; GET BLOCK ADDRESS OF INDEX BLOCK  
				LDY IDXADRH   
DOFRST			 STA DHPCMD ; (ENTRY USED BY RD/WRTDFRST)  
				STX BLOKNML   
				STY BLOKNMH   
				LDA TINDX+1 ; HIGH RAM ADDRESS OF INDEX BLOCK  
				LDX SSTIDXH ; AND BANK NUMBER.  
				JMP DOIDX ; AND GO DO REQUESTED OPERATION.  
*     
WRTDFRST		 LDA #WRTCMD ; WRITE FILE'S FIRST BLOCK (USED  
				BNE FADDR ; BY CREATE, SO ADDRESS IN 'D.' STUFF).  
RDFRST			 LDA #RDCMD   
FADDR			 LDX DFIL+D.FRST ; (BUFFER ADDRESS IS IN 'TINDX')  
				LDY DFIL+D.FRST+1   
				JMP DOFRST   
*     
*     
				CHN POSN/OPEN,4,2   
				    
*************************************************************************  
* END OF APPLE /// SOS 1.3 SOURCE CODE FILE: ALLOC  
*************************************************************************  
				 
*--------------------------------------
MAN
SAVE /A3OSX.BUILD/SOS.13/sos.s.bfm.a
LOAD /A3OSX.BUILD/SOS.13/sos.s
ASM
