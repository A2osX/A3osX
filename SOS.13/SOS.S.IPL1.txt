NEW
  AUTO 3,1
*--------------------------------------
*************************************************************************  
* APPLE /// SOS 1.3 SOURCE CODE FILE: IPL.SRC1  
*************************************************************************  
* ASSEMBLER: APPLE ][ 6502 ASSEMBLER from APPLE COMPUTER TOOLKIT  
				 
SBTL			 "SOS 1.1 INTRPTS. & PROC. LAUNCH"  
REL				  
INCLUDE			 SOSORG,6,1,254  
ORG				 ORGIPL  
ZZORG			 EQU *  
MSB				 OFF  
REP				 60  
* COPYRIGHT (C) APPLE COMPUTER INC. 1980  
* ALL RIGHTS RESERVED  
REP				 60  
*  
* THIS MODULE IS RESPONSIBLE FOR FIELDING ALL INTERRUPTS  
* AND RELAUNCHING THE INTERRUPTED CODE AFTER THE INTERRUPTS  
* HAVE BEEN PROCESSED. THE MAJOR FUNCTIONAL AREAS ARE:  
*  
* GENERAL INTERRUPT RECEIVER  
* NMI INTERRUPT RECEIVER  
* DISPATCHER  
* INTERRUPT ALLOCATION & DEALLOCATION  
* EVENT QUEUE MANAGER  
* TABLE INITIALIZATION  
*  
REP				 60  
*  
* SUBROUTINE ENTRY POINTS  
*  
ENTRY			 IRQ.RCVR ;GENERAL INTERRUPT RECEIVER  
ENTRY			 NMI.RCVR ;NON-MASKABLE INTRPT RCVR  
ENTRY			 DISPATCH ;DISPATCHER  
ENTRY			 ALLOCSIR ;SIR ALLOCATION  
ENTRY			 DEALCSIR ;SIR DEALLOCATION  
ENTRY			 SELC800 ;SELECT I/O EXPANSION ROM  
ENTRY			 NMIDSBL ;DISABLE NMI  
ENTRY			 NMIENBL ;ENABLE NMI  
ENTRY			 NMIDBUG ;NMI DEBUG ENTRY  
ENTRY			 NMICONT ;NMI DEBUG CONTINUATION  
ENTRY			 QUEEVENT ;QUEUE AN EVENT  
*  
* EXTERNAL SUBROUTINES & DATA  
*  
EXTRN			 SCMGR  
EXTRN			 CHKBUF  
*  
* SYSTEM DEATH ERRORS  
*  
EXTRN			 SYSDEATH  
EXTRN			 BADBRK  
EXTRN			 BADINT1  
EXTRN			 BADINT2  
EXTRN			 NMIHANG  
EXTRN			 EVQOVFL  
EXTRN			 STKOVFL  
*  
* LINKAGE DATA FOR INITIALIZATION ROUTINES  
*  
				ENTRY EV.QUEUE   
				ENTRY EVQ.CNT   
				ENTRY EVQ.SIZ   
				ENTRY EVQ.LEN   
				ENTRY EVQ.FREE   
				ENTRY EVQ.LINK   
				ENTRY SIRTABLE   
				ENTRY SIRTBLSIZ   
				ENTRY ZPGSTACK   
				ENTRY ZPGSTART   
*     
* SYSGLOB DATA     
*     
				EXTRN SERR   
				EXTRN CEVPRI ;CALLER'S EVENT PRIORITY  
				EXTRN SYSBANK ;SYSTEM BANK  
EXTRN			 KYBDNMI   
EXTRN			 NMISPSV   
EXTRN			 NMIFLAG ;NMI PENDING FLAG  
EXTRN			 SCRNMODE ;CURRENT SCREEN MODE  
EXTRN			 SIRTEMP ;FOR ALLOCSIR & DEALCSIR  
EXTRN			 SIRARGSIZ   
EXTRN			 IRQCNTR ;FLASE IRQ COUNTER  
EXTRN			 NMICNTR ;TWO BYTE COUNTER  
EXTRN			 QEVTEMP   
EXTRN			 QEV.THIS   
EXTRN			 QEV.LAST   
EXTRN			 BACKMASK   
*    
* CONSTANT DECLARATIONS    
*    
FALSE			 EQU $00   
BITON0			 EQU $01   
BITON1			 EQU $02   
BITON2			 EQU $04   
BITON4			 EQU $10   
BITON5			 EQU $20   
BITON6			 EQU $40   
BITON7			 EQU $80   
BITOFF3			 EQU $F7   
BITOFF4			 EQU $EF   
BITOFF5			 EQU $DF   
BITOFF6			 EQU $BF   
BITOFF7			 EQU $7F   
BACKBIT			 EQU $20 ; BACKUP BIT MASK  
*    
* SYSTEM CONTROL REGISTERS    
*    
B.REG			 EQU $FFEF ;BANK REGISTER  
E.REG			 EQU $FFDF ;ENVIRONMENT REGISTER  
Z.REG			 EQU $FFD0 ;ZERO PAGE REGISTER  
*    
* 6522 REGISTERS    
*    
D.IFR			 EQU $FFDD   
D.IER			 EQU $FFDE   
E.IORB			 EQU $FFE0   
E.IFR			 EQU $FFED   
E.IER			 EQU $FFEE   
E.IORA			 EQU $FFEF   
PAGE			    
*   
* REGISTER PRESERVATION EQUATES   
* FOR USE DURING INTERRUPT PROCESSING   
*   
A.SAVE			 EQU $103   
S.SAVE			 EQU $104   
SP.SAVE			 EQU $1FF   
E.SAVE			 EQU $1FE   
Z.SAVE			 EQU $1FD   
B.SAVE			 EQU $1FC   
EXPNSLOT		 DFB $00 ;CURRENT I/O EXPANSION SLOT  
*   
* STATUS LOCATIONS FOR INTERRUPT POLLING   
*   
ACIASTAT		 EQU $C0F1   
ANYSLOT			 DFB BITON1   
SLOT1			 EQU $C065   
SLOT2			 EQU $C064   
SLOT3			 DFB BITON5   
SLOT4			 DFB BITON4   
*   
* INTERRUPT ZERO PAGE STORAGE & EQUATES   
*   
SIRARGS			 EQU $F9 ;AND $FA  
QEVARGS			 EQU $FB ;AND $FC  
IRQADDR			 EQU $FD ;AND $FE  
ZPGSP			 EQU $FF   
ZPGSTART		 EQU $F8   
ZPGSTOP			 EQU $28   
ZPGSPACE		 EQU $20   
ZPGSTACK		 DFB ZPGSTART   
*   
* SYSTEM INTERNAL RESOURCE   
* TABLE STORAGE AND EQUATES   
*   
SIRTBLSIZ		 EQU $18   
SIRTABLE		 DS SIRTBLSIZ   
SIRADR.L		 DS SIRTBLSIZ   
NMIADR.L		 DS 1 ;MUST PRECEED SIRADR.H  
SIRADR.H		 DS SIRTBLSIZ   
SIRADR.B		 DS SIRTBLSIZ   
*     
* EVENT QUEUE STORAGE AND EQUATES  
*  
EVQ.SIZ			 EQU 6 ;ENTRY SIZE  
EVQ.CNT			 EQU $07 ;ENTRY COUNT  
EVQ.LEN			 EQU $2A ;(EVQ.SIZ*EVQ.CNT)  
EV.QUEUE		 DS EVQ.LEN   
EVQ.FREE		 EQU EV.QUEUE+2 ;FIRST FREE ENTRY INDEX  
EVQ.LINK		 EQU EV.QUEUE+0 ;NEXT ACTIVE ENTRY INDEX  
EVQ.PRI			 EQU EV.QUEUE+1 ;EVENT PRIORITY  
EVQ.ID			 EQU EV.QUEUE+2 ;EVENT IDENTIFICATION  
EVQ.ADRL		 EQU EV.QUEUE+3 ;EVENT ADDRESS: LOW BYTE  
EVQ.ADRH		 EQU EV.QUEUE+4 ;EVENT ADDRESS: HIGH BYTE  
EVQ.BANK		 EQU EV.QUEUE+5 ;EVENT ADDRESS: BANK  
SBTL			 "GENERAL INTERRUPT RECEIVER"  
REP				 60  
*  
* THIS IS THE GENERAL INTERRUPT RECEIVER. WHEN AN  
* INTERRUPT OCCURS, THE CPU PASSES CONTROL TO THE GIR  
* THROUGH THE IRQ VECTOR. THE GIR IS RESPONSIBLE FOR  
* SAVING THE CURRENT ENVIRONMENT, SETTING UP THE SOS  
* ENVIRONMENT, AND CALLING THE APPROPRIATE CODE MODULE.  
* IF THE INTERRUPT WAS CAUSED BY A BRK, THE GIR CALLS  
* THE SYSTEM CALL MANAGER. OTHERWISE, THE GIR POLLS THE  
* I/O DEVICES AND CALLS THE APPROPRIATE MASTER INTERRUPT  
* HANDLER. WHEN THE SCM OR MIH RETURNS, THE GIR PASSES  
* CONTROL TO THE DISPATCHER.  
*  
REP				 60  
*  
IRQ.RCVR		 EQU *  
*  
* SAVE CPU REGISTERS A, X, & Y ON CURRENT STACK  
*  
PHA				  
TXA				  
PHA				  
TYA				  
PHA				  
*  
* CHECK FOR STACK OVERFLOW AND  
* SAVE INTERRUPTED STATUS IN Y REGISTER.  
*  
				TSX   
				CPX #$FA  
				BCC GIR005  
				LDA #>STKOVFL  
				JSR SYSDEATH  
GIR005			 LDY S.SAVE,X  
*    
* SET UP INTERRUPT ENVIRONMENT:  
* BINARY ARITHMETIC, 2 MHZ, I/O ENABLED,  
* RAM WRITE ENABLED, PRIMARY STACK,  
* AND $F000 RAM SELECTED. PRESERVE  
* USER STATE OF SCREEN AND RESET LOCK.  
*  
CLD				  
LDA				 E.REG  
TAX				  
AND				 #BITON5+BITON4  
ORA				 #BITON6+BITON2  
STA				 E.REG  
*  
* IF NOT ALREADY ON PRIMARY STACK, SAVE USER'S STACK  
* POINTER AND SET UP SOS STACK POINTER.  
*  
TXA				   
AND				 #BITON2  
BNE				 GIR010  
TXA				   
TSX				   
STX				 SP.SAVE  
LDX				 #>E.SAVE  
TXS				   
TAX				   
*   
* SAVE E, Z, B, & I/O EXPANSION SLOT ON SOS STACK  
* IF BRK THEN CALL SCMGR ELSE POLL I/O DEVICES  
*  
GIR010			 TXA  
PHA				  
LDA				 Z.REG  
PHA				  
LDA				 B.REG  
PHA				  
LDA				 EXPNSLOT  
PHA				  
BIT				 $CFFF  
BIT				 $C020 ;RESET I/O SPACE  
LDA				 #$00  
STA				 EXPNSLOT  
TYA				  
AND				 #BITON4  
BEQ				 POLL.IO  
*  
* CALL SYSTEM CALL MANAGER; ON RETURN, PUT ERROR CODE IN  
* USER'S A REGISTER AND SET RETURN STATUS, THEN DISPATCH.  
*  
TSX				 ;CHECK FOR  
CPX				 #>B.SAVE-2 ; REENTRANT  
BEQ				 GIR020 ; SYSTEM CALL  
LDA				 #>BADBRK  
JSR				 SYSDEATH  
GIR020			 LDA E.REG ;SELECT $C000 RAM  
AND				 #BITOFF6  
STA				 E.REG  
CLI				 ;ENABLE INTERRUPTS  
JSR				 SCMGR ;CALL THE SYSTEM CALL MGR  
LDA				 #BACKBIT ; GET THE MASK  
STA				 BACKMASK ; SET IT IN SYSGLOB  
JSR				 CHKBUF  
SEI				  
LDX				 SP.SAVE  
LDA				 Z.SAVE  
EOR				 #BITON0 ;SET ZERO PAGE TO  
STA				 Z.REG ; CALLER'S STACK  
LDA				 SERR  
STA				 >A.SAVE,X  
PHP				  
LDA				 >S.SAVE,X  
AND				 #$7D  
STA				 >S.SAVE,X  
PLA				  
AND				 #$82  
ORA				 >S.SAVE,X  
STA				 >S.SAVE,X  
JMP				 DISPATCH  
PAGE			  
*  
* SET INTERRUPT ZERO PAGE AND SOS BANK  
* THEN POLL I/O DEVICES  
*  
POLL.IO			 BIT E.IORA ;VERIFY THAT 'IRQ IS LOW  
BPL				 PIO006  
INC				 IRQCNTR ;BUMP FALSE IRQ COUNTER  
BNE				 PIO004  
INC				 IRQCNTR+1  
PIO004			 JMP DISPATCH  
PIO006			 LDA #0 ;SET INTERRUPT ZERO PAGE  
STA				 Z.REG  
LDA				 E.REG  
ORA				 #BITON7 ;FORCE 1 MHZ FOR  
STA				 E.REG ; READING ACIA STATUS  
AND				 #BITOFF7  
LDX				 #$01  
LDY				 ACIASTAT ;ANY INTERRUPT ON ACIA?  
STA				 E.REG  
BMI				 PIO070  
LDA				 E.IFR ;ANY INTERRUPT ON E-6522?  
BPL				 PIO020 ; NO  
AND				 E.IER  
LDY				 #7  
LDX				 #$02  
PIO010			 LSR A ;CHECK FLAG BITS  
BCS				 PIO070  
INX				  
DEY				  
				BNE PIO010   
				BEQ PIO035   
PIO020			 LDA D.IFR ;ANY INTERRUPT ON D-6522?  
				BPL PIO035   
				AND D.IER   
				BIT ANYSLOT ;ANY SLOT INTERRUPT?  
				BNE PIO040 ; YES  
				LDY #7   
				LDX #$09   
PIO030			 LSR A ;CHECK FLAG BITS  
				BCS PIO070   
				INX    
				DEY    
				BNE PIO030   
PIO035			 LDX #$10 ;INTERRUPT NOT FOUND  
				BNE PIO050   
PIO040			 LDX #$11   
				BIT SLOT1 ;SLOT 1?  
				BPL PIO070   
				INX    
				BIT SLOT2 ;SLOT 2?  
				BPL PIO070   
				LDA E.IORA   
				INX    
				BIT SLOT3 ;SLOT 3?  
				BEQ PIO070   
				INX    
				BIT SLOT4 ;SLOT 4?  
				BEQ PIO070   
				LDX #$0A   
*  
* BAD INTERRUPT -- SYSTEM DEATH  
*  
PIO050			 LDA #>BADINT1 ;INTERRUPT NOT FOUND  
				JSR SYSDEATH   
PIO060			 LDA #>BADINT2 ;BAD ZERO PAGE ALLOCATION  
				JSR SYSDEATH   
*     
* INTERRUPTING DEVICE FOUND  
* ALLOCATE ZERO PAGE AND CALL MASTER INTERRUPT HANDLER  
*  
* NOTE:  
* SINCE READING THE ACIA'S STATUS REGISTER RESETS THE  
* DSR AND DCD BITS, THE STATUS READ BY THE POLLING  
* ROUTINE MUST BE PASSED TO THE INTERRUPT HANDLER;  
* THE Y REGISTER HAS BEEN SELECTED FOR THIS PURPOSE.  
* THE CURRENT IMPLEMENTATION DOES NOT USE Y IN CALLING  
* THE INTERRUPT HANDLER. IF SUBSEQUENT REVISIONS  
* NEED TO USE Y, THE STATUS MUST BE PRESERVED AND  
* RESTORED BEFORE CALLING THE INTERRUPT HANDLER.  
*  
CALLMIH			 JMP (IRQADDR)  
*  
PIO070			 LDA SIRTABLE,X ;INTERRUPT ALLOCATED?  
BPL				 PIO050 ; NO  
LDA				 SIRADR.L,X ;GET INTERRUPT ADDRESS  
STA				 IRQADDR  
ORA				 SIRADR.H,X ;CHECK FOR ADDRESS = $00  
BEQ				 PIO050 ; BAD ADDRESS  
LDA				 SIRADR.H,X  
STA				 IRQADDR+1  
LDA				 SIRADR.B,X  
STA				 B.REG  
LDA				 ZPGSTACK ;ALLOCATE MIH ZERO PAGE  
CMP				 #ZPGSTOP+ZPGSPACE  
BCC				 PIO060 ;TOO MANY NESTED INTERRUPTS  
SBC				 #ZPGSPACE  
STA				 ZPGSTACK  
STA				 ZPGSP  
TAX				  
JSR				 CALLMIH ;CALL INTERRUPT HANDLER  
SEI				  
LDA				 #$00  
STA				 Z.REG  
CLC				  
LDA				 ZPGSTACK ;DEALLOCATE MIH ZERO PAGE  
ADC				 #ZPGSPACE  
STA				 ZPGSTACK  
STA				 ZPGSP  
LDA				 #BITON1  
STA				 D.IFR ;CLEAR ANY SLOT INTERRUPT  
JMP				 DISPATCH  
SBTL			 "NON-MASKABLE INTERRUPT RECEIVER"  
REP				 60  
*   
* THIS IS THE NON-MASKABLE INTERRUPT RECEIVER. WHEN AN  
* NMI OCCURS, THE CPU PASSES CONTROL TO THE NMI RECEIVER  
* THROUGH THE NMI VECTOR. THE OPERATION OF THE NMI  
* RECEIVER IS ESSENTIALLY THE SAME AS THE GIR EXCEPT  
* THAT IT IS NOT CONCERNED WITH BRK, AND THE ONLY VALID  
* SOURCE OF AN NMI IS THE KEYBOARD OR THE I/O DEVICE THAT  
* HAS ALLOCATED THE NMI RESOURCE.  
*  
REP				 60  
*  
*  
NMI.RCVR		 EQU *  
*  
* SAVE CPU REGISTERS A, X, & Y ON CURRENT STACK  
*  
PHA				  
TXA				  
PHA				  
TYA				  
PHA				  
*  
* CHECK FOR STACK OVERFLOW  
*   
TSX				   
CPX				 #$FA  
BCC				 NMI005  
LDA				 #>STKOVFL  
JSR				 SYSDEATH  
*   
* SET UP INTERRUPT ENVIRONMENT:  
* BINARY ARITHMETIC, 2 MHZ, I/O ENABLED,  
* RAM WRITE ENABLED, PRIMARY STACK,  
* AND $F000 RAM SELECTED. PRESERVE  
* USER STATE OF SCREEN AND RESET LOCK.  
*  
NMI005			 CLD  
LDA				 E.REG  
TAX				  
AND				 #BITON5+BITON4  
ORA				 #BITON6+BITON2  
STA				 E.REG  
*  
* IF NOT ALREADY ON PRIMARY STACK, SAVE USER'S  
* STACK POINTER AND SET UP SOS STACK POINTER.  
*  
TXA				  
AND				 #BITON2  
BNE				 NMI010  
TXA				  
TSX				  
STX				 SP.SAVE  
LDX				 #>E.SAVE  
TXS				  
TAX				  
*  
* SAVE SYSTEM CONTROL REGISTERS E, Z, & B ON SOS STACK  
*  
NMI010			 TXA    
				PHA    
				LDA Z.REG   
				PHA    
				LDA B.REG   
				PHA    
				LDA EXPNSLOT   
				PHA    
				BIT $CFFF   
				BIT $C020 ;RESET I/O SPACE  
				LDA #$00   
				STA EXPNSLOT   
*     
000476			 * SET INTERRUPT ZERO PAGE *  
LDA				 #0  
STA				 Z.REG  
*   
* SEE IF NMI IS FROM KEYBOARD OR I/O DEVICE  
*  
LDA				 E.IORB   
BMI				 NMI030   
*    
* NMI IS FROM I/O DEVICE    
*    
LDA				 SIRTABLE ;NMI ALLOCATED?  
BPL				 NMI020   
JSR				 CALLNMI   
SEI				    
JMP				 DISPATCH   
CALLNMI			 LDA SIRADR.L   
STA				 NMIADR.L   
LDA				 SIRADR.B   
STA				 B.REG   
JMP				 (NMIADR.L)   
*    
* BAD INTERRUPT -- SYSTEM DEATH   
*    
NMI020			 LDA #>BADINT1 ;NMI NOT ALLOCATED  
JSR				 SYSDEATH   
*    
* NMI IS FROM THE KEYBOARD    
*    
NMI030			 LDA SYSBANK   
STA				 B.REG   
JSR				 KYBDNMI   
SEI				    
JMP				 DISPATCH   
SBTL			 "DISPATCHER"   
REP				 60   
*    
* THIS IS THE DISPATCHER. UPON COMPLETION, ALL SOS CALLS  
* AND INTERRUPT HANDLERS RETURN CONTROL TO THE DISPATCHER.  
* ITS PURPOSE IS TO SET UP THE APPROPRIATE ENVIRONMENT AND  
* PASS CONTROL TO WHATEVER CODE SHOULD RUN NEXT.  
*  
* WHEN SOS IS INTERRUPTED, CONTROL ALWAYS RETURNS TO THE  
* INTERRUPTED CODE. HOWEVER, WHEN THE USER IS INTERRUPTED,  
* BY EITHER A SOS CALL OR AN INTERRUPT, THE DISPATCHER  
* MUST CHECK THE EVENT QUEUE. IF THERE IS AN ACTIVE EVENT  
* WITH A PRIORITY HIGHER THAN THE CURRENT EVENT FENCE,  
* CONTROL IS PASSED TO THE EVENT CODE. OTHERWISE, CONTROL  
* RETURNS TO THE INTERRUPTED CODE.  
*  
REP				 60  
*  
DISPATCH		 EQU *  
*  
* DISABLE INTERRUPTS AND RESTORE  
* SYSTEM CONTROL REGISTERS B & Z  
*  
SEI				  
LDA				 E.REG  
ORA				 #BITON6 ;ENABLE I/O  
STA				 E.REG  
PLA				  
JSR				 SELC800 ;RESTORE I/O SPACE  
PLA				  
STA				 B.REG  
PLA				  
STA				 Z.REG  
*  
* CHECK SAVED ENVIRONMENT REGISTER  
* IF RETURNING TO PRIMARY STACK  
* THEN RESTORE E REG AND RELAUNCH SOS  
* ELSE RESET STACK POINTER & RESTORE E REG  
*  
PLA				  
ORA				 #BITON5 ;SET SCREEN STATE TO  
BIT				 SCRNMODE ; CURRENT SCREEN MODE  
BMI				 DSP005  
AND				 #BITOFF5  
DSP005			 TAY  
AND				 #BITON2  
BEQ				 DSP010  
STY				 E.REG  
BNE				 DSP030  
DSP010			 PLA  
TAX				  
TXS				  
STY				 E.REG  
*  
* CHECK FOR ACTIVE EVENT WITH PRIORITY > FENCE  
*  
DSP020			 LDA CEVPRI  
				LDX EVQ.LINK  
				CMP EVQ.PRI,X  
				BCS DSP030  
*  
* PROCESS ACTIVE EVENT TRAP  
* SAVE E, Z, B, & CALLER'S PRIORITY ON STACK THEN CALL  
* EVENT. UPON RETURN, RESTORE PRIORITY, B, Z, & E THEN  
* CHECK FOR MORE EVENTS.  
*  
LDA				 E.REG  
PHA				  
LDA				 Z.REG  
PHA				  
LDA				 B.REG  
PHA				  
LDA				 CEVPRI  
PHA				  
JSR				 DO.EVENT  
SEI				  
PLA				  
STA				 CEVPRI  
PLA				  
STA				 B.REG  
PLA				  
STA				 Z.REG  
PLA				  
ORA				 #BITON5 ;SET SCREEN STATE TO  
BIT				 SCRNMODE ; CURRENT SCREEN MODE  
BMI				 DSP025  
AND				 #BITOFF5  
DSP025			 STA E.REG  
JMP				 DSP020  
*  
* RESTORE CPU REGISTERS Y, X, & A AND LAUNCH  
*  
DSP030			 PLA  
TAY				  
PLA				  
TAX				  
PLA				  
RTI				  
PAGE			  
REP				 60  
*  
* THIS SUBROUTINE CALLS THE HIGHEST PRIORITY ACTIVE EVENT.  
* FIRST, IT DELINKS THE FIRST ENTRY ON THE ACTIVE LIST AND  
* LINKS IT TO THE FREE LIST. THEN, IT SETS UP THE BANK,  
* ADDRESS, ID, & STATUS AND CALLS THE EVENT VIA AN RTI.  
*  
REP				 60  
*  
DO.EVENT		 EQU *  
*  
* WRITE ENABLE RAM  
*  
LDY				 E.REG  
TYA				  
AND				 #BITOFF3  
STA				 E.REG  
*  
* DELINK ENTRY FROM ACTIVE LIST AND RELINK IT TO FREE LIST  
*  
LDX				 EVQ.LINK  
LDA				 EVQ.LINK,X  
STA				 EVQ.LINK  
LDA				 EVQ.FREE  
STA				 EVQ.LINK,X  
STX				 EVQ.FREE  
*  
* SET FENCE TO EVENT PRIORITY THEN RESTORE E REG  
*  
LDA				 EVQ.PRI,X  
STA				 CEVPRI  
STY				 E.REG  
*  
* SET UP B, Z, E, ADDRESS, ID, & STATUS  
*  
LDA				 EVQ.BANK,X  
STA				 B.REG  
LDA				 EVQ.ADRH,X  
PHA				   
LDA				 EVQ.ADRL,X  
PHA				   
LDY				 EVQ.ID,X  
PHP				   
PLA				   
AND				 #$82  
PHA				   
TYA				   
RTI				   
				  
CHN				 IPL.SRC2  
				  
*************************************************************************
* END OF APPLE /// SOS 1.3 SOURCE CODE FILE: IPL.SRC1
*************************************************************************


*--------------------------------------
MAN
SAVE /A3OSX.BUILD/SOS.13\sos.s.ipl1.txt
LOAD /A3OSX.BUILD/SOS.13/sos.s
ASM
