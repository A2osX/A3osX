NEW
  AUTO 3,1
*--------------------------------------
BFM.READ		clc 					; FIRST DETERMINE IF REQESTED
				ldy	#FCBATTR 			; READ IS LEGAL
				lda	(FCBPTR),Y
				and	#READEN 			; IS READ ENABLED?
				bne	READ1 				; YES, CONTINUE...
				lda	#ACCSERR 			; REPORT ILLEGAL ACCESS.
				sec
				rts
*
READ1			ldy #FCBMARK 			; GET CURRENT MARK INTO 'TPOS' AND
				lda	(FCBPTR),Y 			; DETERMINE IF RESULTING POSITION
				sta	TPOSLL 				; EXCEEDS CURRENT END OF FILE.
				adc	C.BYTES
				sta	SCRTCH
				iny
				lda	(FCBPTR),Y
				sta	TPOSLH
				adc	C.BYTES+1 			; (THIS WAS DONE STRAIT-LINE SINCE
				sta	SCRTCH+1 			; WE'RE ADDING A TWO BYTE TO A THREE
				iny						; BYTE QUANTITY)
				lda	(FCBPTR),Y
				sta	TPOSHI
				adc	#0 					; ADD IN REMAINING CARRY.
				sta	SCRTCH+2
				ldy	#FCBEOF+2 			; NOW TEST EOF AGAINST POSITION GENERATED

EOFTEST			lda SCRTCH-FCBEOF,Y
				cmp	(FCBPTR),Y 			; IS NEW POSITION > EOF?
				bcc	READ2				; NO, PROCEED.
				bne	ADJSTCNT 			; YES, ADJUST 'C.BYTES' REQUEST
				dey
				cpy	#FCBEOF-1 			; HAVE WE COMPARED ALL TREE BYTES?
				bne	EOFTEST 			; NO, TEST NEXT LOWEST.

ADJSTCNT		.EQ * 					; ADJUST REQUEST TO READ UP TO (BUT
				ldy	#FCBEOF 			; NOT INCLUDING) END OF FILE.
				lda	(FCBPTR),Y 			; RESULT= (EOF-1)-POSITION
				sbc	TPOSLL
				sta	C.BYTES
				iny
				lda	(FCBPTR),Y
				sbc	TPOSLH
				sta	C.BYTES+1
				ora	C.BYTES 			; IF BOTH BYTES ARE ZERO, REPORT EOF ERROR.
				bne	READ2
				lda	#EOFERR
				jsr	SYSERR
READ2			lda C.BYTES
				sta	RWREQL
				bne	READ3 				; BRANCH IF READ REQUEST DEFINITELY NON-ZERO.
				cmp	C.BYTES+1
				bne	READ3 				; BRANCH IF READ REQUEST<>ZERO
				sta	RWREQH
GORDDNE			jmp READONE 			; DO NOTHING.

*
READ3			lda C.BYTES+1
				sta	RWREQH
				lda	C.OUTBUF 			; MOVE POINTER TO USERS BUFFER TO BFM
				sta	USRBUF 				; Z-PAGE AREA.
				ldx	#C.OUTBUF			; <SRS 82.162>
				jsr	WRAPADJ 			; ADJUST FOR BANK CROSSING. <SRS 82.162>
				sta	USRBUF+1
				sty	SISUSRBF 			; SAVE VALID USER BUFFER ADDRESS (THAT WILL NOT CROSS BANKS)
				ldy	#FCBSTYP 			; NOW FIND OUT IF IT'S A TREE READ OR OTHER.
				lda	(FCBPTR),Y
				cmp	#TRETYP+1
				bcc	TREAD 				; BRANCH IF A TREE FILE.
				jmp	BFM.RW.DREAD 		; OTHEWISE ASSUME IT'S A DIRECTORY.
*
TREAD			jsr RDPOSN 				; GET DATA POINTER SET UP.
				bcc	TREAD0 				; REPORT ANY ERRORS
				jmp ERRFIX1
TREAD0			jsr PREPRW 				; TEST FOR NEWLINE, SETS UP FOR PARTIAL READ.
				jsr READPART 			; MOVE CURRENT DATA BUFFER CONTENTS TO USER AREA
				bvs GORDDNE 			; BRANCH IF REQUEST IS SATISFIED.
				bcs TREAD 				; CARRY SET INDICATES NEWLINE IS SET.
				lda RWREQH 				; FIND OUT HOW MANY BLOCKS ARE TO BE READ
				lsr 					; IF LESS THAN TWO, THEN DO IT THE SLOW WAY.
				beq TREAD
				sta BULKCNT 			; SAVE BULK BLOCK COUNT.
				ldy #FCBSTAT 			; MAKE SURE CURRENT DATA AREA
				lda (FCBPTR),Y 			; DOESN'T NEED TO BE WRITTEN BEFORE
				and #DATMOD 			; RESETTING POINTER TO READ DIRECTLY INTO
				bne TREAD 				; USER'S AREA. BRANCH IF DATA NEED TO BE WRITTEN
				sta IOACCESS 			; TO FORCE FIRST CALL THRU ALL DEVICE HANDLER CHECKING.
				lda USRBUF 				; MAKE THE DATA BUFFER THE USER'S SPACE.
				sta DATPTR
				lda USRBUF+1
				sta DATPTR+1
				lda SISUSRBF
				sta SISDATP
*

RDFAST			jsr RDPOSN 				; GET NEXT BLOCK DIRECTLY INTO USER SPACE.
				bcs ERRFIX 				; BRANCH ON ANY ERROR.

RDFAST0			inc DATPTR+1 			; BUMP ALL POINTERS BY 512 (ONE BLOCK)
				inc DATPTR+1
				dec RWREQH
				dec RWREQH
				inc TPOSLH
				inc TPOSLH
				bne RDFAST1 			; BRANCH IF POSITION DOES NOT GET TO A 64K BOUNDARY.
				inc TPOSHI 				; OTHERWISE, MUST CHECK FOR A 128K BOUNDARY
				lda TPOSHI 				; SET CARRY IF MOD 128K HAS BEEN REACHED
				eor #1
				lsr

RDFAST1			dec BULKCNT 			; HAVE WE READ ALL WE CAN FAST?
				bne RDFAST2 			; BRANCH IF MORE TO READ.
				jsr FXDATPTR 			; GO FIX UP DATA POINTER TO SOS BUFFER.
				lda RWREQL 				; TEST FOR END OF READ.
				ora RWREQH 				; ARE BOTH ZERO?
				beq READONE
				bne TREAD 				; NO, READ LAST PARTIAL BLOCK.
*
RDFAST2			bcs RDFAST
				lda TPOSHI 				; GET INDEX TO NEXT BLOCK ADDRESS
				lsr
				lda TPOSLH
				ror
				tay  					; INDEX TO ADDRESS IS INT(POS/512)
				lda (TINDX),Y 			; GET LOW ADDRESS
				sta BLOKNML
				inc TINDX+1
				cmp (TINDX),Y 			; ARE BOTH HI AND LOW ADDRESS THE SAME?
				bne REALRD 				; NO, IT'S A REAL BLOCK ADDRESS.
				cmp #0 					; ARE BOTH BYTES ZERO?
				bne REALRD 				; NOPE -- MUST BE REAL DATA
				sta IOACCESS 			; DON'T DO REPEATIO JUST AFTER SPARSE
				beq NOSTUF 				; BRANCH ALWAYS (CARRY SET)

REALRD			lda (TINDX),Y 			; GET HIGH ADDRESS BYTE
				clc

NOSTUF			dec TINDX+1
				bcs RDFAST 				; BRANCH IF NO BLOCK TO READ
				sta BLOKNMH
				lda IOACCESS 			; HAS FIRST CALL GONE TO DEVICE YET?
				beq RDFAST 				; NOPE, GO THRU NORMAL ROUTE...
				lda DATPTR+1 			; RESET HI BUFFER ADDRESS FOR DEVICE HANDLER
				sta DBUFPH
				jsr REPEATIO
				bcc RDFAST0 			; BRANCH IF NO ERRORS.

ERRFIX			pha  					; SAVE ERROR CODE
				jsr FXDATPTR 			; GO RESTORE DATA POINTERS, ETC...
				pla
ERRFIX1			pha  					; SAVE ERROR CODE
				jsr READONE 			; PASS BACK NUMBER OF BYTES ACTUALLY READ.
				pla
				sec  					; REPORT ERROR
				rts
*
READONE			ldy #0 					; RETURN TOTAL NUMBER OF BYTES ACTUALLY READ
				sec  					; THIS IS DERIVED FROM C.BYTES-RWREQ
				lda C.BYTES
				sbc RWREQL
				sta (C.OUTCNT),Y
				iny
				lda C.BYTES+1
				sbc RWREQH
				sta (C.OUTCNT),Y
				jmp RDPOSN 				; LEAVE WITH VALID POSITION IN FCB.
*
PREPRW			sec  					; ADJUST POINTER TO USER'S BUFFER TO
				lda USRBUF 				; MAKE THE TRANSFER
				sbc TPOSLL
				sta USRBUF
				bcs PREPRW1 			; BRANCH IF NO ADJUSTMENT TO HI ADDR. NEEDED.
				dec USRBUF+1 			; NOTE: SARA ALLOWS INDIRECT FROM $101 UP

PREPRW1			ldy #FCBATTR 			; AS LONG AS ACTUAL RESULTING ADDRESS IS >=$200
				lda (FCBPTR),Y 			; TEST FOR NEW LINE ENABLED
				and #NLINEN 			; SET CARRY IF IT IS.
				clc
				beq NONEWLIN 			; BRANCH IF NEWLINE IS NOT ENABLED
				sec
				ldy #FCBNEWL
				lda (FCBPTR),Y 			; MOVE NEWLINE CHARACTER TO MORE
				sta NLCHAR 				; ACCESSABLE SPOT.

NONEWLIN		ldy TPOSLL 				; GET INDEX TO FIRST DATA
				lda DATPTR 				; RESET LOW ORDER OF POSPTR TO BEGINNING OF PAGE.
				sta POSPTR
				ldx RWREQL 				; AND LASTLY GET LOW ORDER COUNT OF REQUESTED BYTES.
				rts  					; RETURN STATUSES...
*
READPART		txa
				bne RDPART0 			; BRANCH IF REQUEST IS NOT A EVEN PAGES
				lda RWREQH 				; A CALL OF ZERO BYTES SHOULD NEVER GET HERE!
				beq SETRDNE 			; BRANCH IF NOTHIN' TO DO.
				dec RWREQH
RDPART0			dex
RDPART			lda (POSPTR),Y 			; MOVE DATA TO USER'S BUFFER
				sta (USRBUF),Y 			; ONE BYTE AT A TIME.
				txa  					; NOTE: THIS ROUTINE IS CODED TO BE
				beq ENDRQCHK			; FASTEST WHEN NEWLINE IS DISABLED.
RDPART1			bcs TSTNEWL 			; BRANCH IF NEW LINE NEEDS TO BE TESTED.
RDPART2			dex
				iny  					; PAGE CROSSED?
				bne RDPART 				; NO. MOVE NEXT BYTE.
				lda POSPTR+1 			; TEST FOR END OF BUFFER
				inc USRBUF+1 			; BUT FIRST ADJUST USER BUFFER POINTER
				inc TPOSLH 				; AND POSITION.
				bne RDPART3
				inc TPOSHI
RDPART3			inc POSPTR+1 			; AND SOS BUFFER HIGH ADDRESS.
				eor DATPTR+1 			; (CARRY HAS BEEN CLEVERLY UNDISTURBED.)
				beq RDPART 				; BRANCH IF MORE TO READ IN BUFFER.
				clv  					; INDICATE NOT FINISHED.
				bvc RDPRTDNE 			; BRANCH ALWAYS.
*
ENDRQCHK		lda RWREQH
				beq RDRQDNE 			; BRANCH IF REQEST SATISFIED.
				iny  					; DONE WITH THIS BLOCK OF DATA?
				bne ENDRCHK1 			; NO, ADJUST HIGH BYTE OF REQUEST.
				lda POSPTR+1 			; MAYBE- CHECK FOR END OF BLOCK BUFFER.
				eor DATPTR+1 			; (DON'T DISTURB CARRY)
				bne ENDRCHK2 			; BRANCH IF HI COUNT CAN BE DEALT WITH NEXT TIME.
ENDRCHK1		dec RWREQH
ENDRCHK2		dey  					; RESTORE PROPER VALUE TO 'Y'
				jmp RDPART1
*
TSTNEWL			lda (POSPTR),Y 			; GET LAST BYTE TRANSFERED AGAIN.
				eor NLCHAR 				; HAVE WE MATCHED NEWLINE CHARACTER?
				bne RDPART2 			; NO, READ NEXT.
RDRQDNE			iny  					; ADJUST POSITION.
				bne SETRDNE
				inc USRBUF+1 			; BUMP POINTERS.
				inc TPOSLH
				bne SETRDNE
				inc TPOSHI
SETRDNE			bit SETVFLG 			; (SET V FLAG)
RDPRTDNE		sty TPOSLL 				; SAVE LOW POSITION
				bvs RDONE1
				inx  					; LEAVE REQUEST AS +1 FOR NEXT CALL
RDONE1			stx RWREQL 				; AND REMAINDER OF REQUEST COUNT.
				php  					; SAVE STATUSES
				clc  					; ADJUST USER'S LOW BUFFER ADDRESS
				tya
				adc USRBUF
				sta USRBUF
				bcc RDPART4
				inc USRBUF+1 			; ADJUST HI ADDRESS AS NEEDED.
RDPART4			plp  					; RESTORE RETURN STATUSES
SETVFLG			rts  					; (THIS BYTE <$60> IS USED TO SET V FLAG)
*
FXDATPTR		lda DATPTR 				; PUT CURRENT USER BUFFER
				sta USRBUF 				; ADDRESS BACK TO NORMAL
				lda DATPTR+1
				sta USRBUF+1 			; BANK PAIR BYTE SHOULD BE MOVED ALSO.
				lda SISDATP
				sta SISUSRBF
				ldy #FCBBUFN 			; RESTORE BUFFER ADDRESS
				lda (FCBPTR),Y
				ldx #DATPTR
				jmp GETBUFADR 			; END VIA CALL TO BOB'S CODE.
*

*
* READ DIRECTORY FILE...
*
BFM.RW.DREAD	jsr RDPOSN
				bcs	ERRDRD 				; PASS BACK ANY ERRORS
				jsr	PREPRW 				; PREPARE FOR TRANSFER.
				jsr	READPART 			; MOVE DATA TO USER'S BUFFER
				bvc	BFM.RW.DREAD 		; REPEAT UNTIL REQUEST IS SATISFIED.
				jsr	READONE 			; UPDATE FCB AS TO NEW POSITION.
				bcc	DREDONE 			; BRANCH IF ALL IS WELL.
				cmp	#EOFERR 			; WAS LAST READ TO END OF FILE?
				sec	 					; ANTICIPATE SOME OTHER PROBLEM
				bne	DREDERR 			; BRANCH IF NOT EOF ERROR.
				jsr	SVMARK
				jsr	ZIPDATA 			; CLEAR OUT DATA BLOCK.
				ldy	#FCBDATB+1 			; PROVIDE DUMMY BACK POINTER FOR FUTURE RE-POSITION
				lda	(FCBPTR),Y 			; GET HI BYTE OF LAST BLOCK.
				pha
				dey
				lda	(FCBPTR),Y 			; AND LOW BYTE.
				pha
				lda	#0 					; NOW MARK CURRENT BLOCK AS IMPOSIBLE.
				sta	(FCBPTR),Y
				iny
				sta	(FCBPTR),Y
				tay	 					; NOW MOVE LAST BLOCK ADDRESS TO DATA BUFFER AS BACK POINTER.
				pla
				sta	(DATPTR),Y
				pla
				iny
				sta	(DATPTR),Y
DREDONE			clc  					; INDICATE NO ERROR
DREDERR			rts
*
ERRDRD			jmp ERRFIX1 			; REPORT HOW MUCH WE COULD TRANSFER BEFORE ERROR.
*

WRITE			clc  					; FIRST DETERMINE IF REQESTED
				ldy	#FCBATTR 			; WRITE IS LEGAL
				lda	(FCBPTR),Y
				and	#WRITEN 			; IS WRITE ENABLED?
				bne	WRITE1 				; YES, CONTINUE...
ERRACCS			lda #ACCSERR 			; REPORT ILLEGAL ACCESS.
				sec
WPERROR			rts
*
WRITE1			jsr TSTWPROT 			; OTHERWISE, MAKE SURE DEVICE IS NOT WRITE PROTECTED.
				bcs	WPERROR 			; REPORT WRITE PROTECTED AND ABORT OPERATION.
*
				ldy	#FCBMARK 			; GET CURRENT MARK INTO 'TPOS' AND
				lda	(FCBPTR),Y 			; DETERMINE IF RESULTING POSITION
				sta	TPOSLL 				; EXCEEDS CURRENT END OF FILE.
				adc	C.BYTES
				sta	SCRTCH
				iny
				lda	(FCBPTR),Y
				sta	TPOSLH
				adc	C.BYTES+1 			; (THIS WAS DONE STRAIGHT-LINE SINCE
				sta	SCRTCH+1 			; WE'RE ADDING A TWO BYTE TO A THREE
				iny				  		; BYTE QUANTITY)
				lda (FCBPTR),Y
				sta TPOSHI
				adc #0 					; ADD IN REMAINING CARRY.
				sta SCRTCH+2
				ldy #FCBEOF+2 			; NOW TEST EOF AGAINST POSITION GENERATED

WEOFTST			lda SCRTCH-FCBEOF,Y
				cmp (FCBPTR),Y 			; IS NEW POSITION > EOF?
				bcc WRITE2 				; NO, PROCEED.
				bne WADJEOF 			; YES, ADJUST END OF FILE
				dey
				cpy #FCBEOF-1 			; HAVE WE COMPARED ALL TREE BYTES?
				bne WEOFTST 			; NO, TEST NEXT LOWEST.

WADJEOF			clc  					; ADJUST REQUEST TO WRITE UP TO (BUT
				ldy #FCBEOF 			; NOT INCLUDING) END OF FILE.

WRTADJEOF		lda (FCBPTR),Y 			; SAVE OLD EOF IN CASE OF LATER ERROR
				sta OLDEOF-FCBEOF,Y
				lda SCRTCH-FCBEOF,Y 	; RESULT=EOF
*
				sta (FCBPTR),Y
				iny
				cpy #FCBEOF+3
				bne WRTADJEOF

WRITE2			lda C.BYTES
				sta RWREQL
				bne WRITE3 				; BRANCH IF WRITE REQUEST DEFINITELY NON-ZERO.
				cmp C.BYTES+1
				bne WRITE3 				; BRANCH IF WRITE REQUEST<>ZERO
				sta RWREQH
				jmp WRITDONE 			; DO NOTHING.
*

WRITE3			lda C.BYTES+1
				sta RWREQH
				lda C.OUTBUF 			; MOVE POINTER TO USERS BUFFER TO BFM
				sta USRBUF 				; Z-PAGE AREA.
				lda C.OUTBUF+1
				sta USRBUF+1 			; (SO IT MAY BE ADJUSTED WITHOUT LOOSING
				lda SISOUTBF 			; ORIGINAL ADDRESS.)
				sta SISUSRBF
				ldy #FCBSTYP 			; NOW FIND OUT IF IT'S A TREE WRITE OR OTHER.
				lda (FCBPTR),Y
				cmp #TRETYP+1
				bcc TWRITE 				; BRANCH IF A TREE FILE.
				jmp ERRACCS 			; OTHEWISE RETURN AN ACCESS ERROR!

TWRITE			jsr RDPOSN 				; READ BLOCK WE'RE
				bcs WRITERROR
				ldy #FCBSTAT
				lda (FCBPTR),Y
				and #DATALC+IDXALC+TOPALC
				beq TREWRT1
				ldy #0 					; FIND OUT IF ENOUGH DISK SPACE IS AVAILABLE FOR

TWRTALC			iny  					; INDEXES AND DATA BLOCK
				lsr
				bne TWRTALC
				sty REQL
				sta REQH
				jsr TSFRBLK
				bcs WRITERROR 			; PASS BACK ANY ERRORS.
				ldy #FCBSTAT
				lda (FCBPTR),Y 			; NOW GET MORE SPECIFIC.
				and #TOPALC 			; ARE WE LACKING A TREE TOP?
				beq TSTSAPWR 			; NO, TEST FOR LACK OF SAPLING LEVEL INDEX.
				jsr TOPDOWN 			; GO ALLOCATE TREE TOP AND ADJUST FILE TYPE.
				bcc DBLOKALC 			; CONTINUE WITH ALLOCATION OF DATA BLOCK.
WRITERROR		pha  					; SAVE ERROR
				ldy #FCBEOF
WRITERR01		lda OLDEOF-FCBEOF,Y
				sta (FCBPTR),Y 			; RESTORE OLD EOF UPON ERR
				iny
				cpy #FCBEOF+3
				bne WRITERR01
				ldy #FCBMARK
WRITERR02		lda OLDMARK-FCBMARK,Y
				sta (FCBPTR),Y 			; AND RESTORE OLD MARK!
				iny
				cpy #FCBMARK+3
				bne WRITERR02
				pla
				sec
				rts  					; ERROR RETURN
*
TWRITEGO		bvc TWRITE 				; A PIGGY-BACK BACKWARD BRANCH
*

TSTSAPWR		lda (FCBPTR),Y 			; GET STATUS BYTE AGAIN.
				and #IDXALC 			; DO WE NEED A SAPLING LEVEL INDEX BLOCK?
				beq DBLOKALC 			; NO, ASSUME IT'S JUST A DATA BLOCK NEEDED.
				jsr SAPDOWN 			; GO ALLOCATE AN INDEX BLOCK AND UPDATE TREE TOP.
				bcs WRITERROR 			; RETURN ANY ERRORS.
DBLOKALC		jsr ALCWBLK 			; GO ALLOCATE FOR DATA BLOCK.
				bcs WRITERROR
				lda TPOSHI 				; CALCULATE POSITION WITHIN INDEX BLOCK.
				lsr
				lda TPOSLH
				ror
				tay  					; NOW PUT BLOCK ADDRESS INTO INDEX BLOCK
				inc TINDX+1 			; HIGH BYTE FIRST.
				lda SCRTCH+1
				tax
				sta (TINDX),Y
				dec TINDX+1 			; (RESTORE POINTER TO LOWER PAGE OF INDEX BLOCK)
				lda SCRTCH 				; GET LOW BLOCK ADDRESS
				sta (TINDX),Y 			; NOW STORE LOW ADDRESS.
				ldy #FCBDATB 			; ALSO UPDATE FILE CONTROL BLOCK TO INDICATE
				sta (FCBPTR),Y 			; THAT THIS BLOCK IS ALLOCATED.
				iny
				txa  					; GET HIGH ADDRESS AGAIN.
				sta (FCBPTR),Y
				ldy #FCBSTAT
				lda (FCBPTR),Y
				ora #IDXMOD
				and #$FF-DATALC-IDXALC-TOPALC ; CLEAR ALLOCATION REQUIREMENT BITS.
				sta (FCBPTR),Y
TREWRT1			ldx #USRBUF 			; LOCATE POINTER TO ADJUST <SRS 82.162>
				jsr WRAPADJ 			; ADJUST FOR BANK CROSSING <SRS 82.162>
				jsr PREPRW 				; WRITE ON
				jsr WRTPART
				bvc TWRITEGO
WRITDONE		jmp RDPOSN 				; UPDATE FCB WITH NEW POSITION.
*

WRTPART			txa
				bne WRPART 				; BRANCH IF REQUEST IS NOT A EVEN PAGES
				lda RWREQH 				; A CALL OF ZERO BYTES SHOULD NEVER GET HERE!
				beq SETWRDNE 			; DO NOTHING!
*
				dec RWREQH
WRPART			dex
				lda (USRBUF),Y 			; MOVE DATA FROM USER'S BUFFER
				sta (POSPTR),Y 			; ONE BYTE AT A TIME.
				txa
				beq ENDWQCHK
WRPART2			iny 					; PAGE CROSSED?
				bne WRPART 				; NO. MOVE NEXT BYTE.
				lda POSPTR+1 			; TEST FOR END OF BUFFER
				inc USRBUF+1 			; BUT FIRST ADJUST USER BUFFER POINTER
				inc TPOSLH 				; AND POSITION.
				bne WRPART3
				inc TPOSHI
WRPART3			inc POSPTR+1 			; AND SOS BUFFER HIGH ADDRESS.
				eor DATPTR+1 			; (CARRY HAS BEEN CLEVERLY UNDISTURBED.)
				beq WRPART 				; BRANCH IF MORE TO WRITE TO BUFFER.
				clv 					; INDICATE NOT FINISHED.
				bvc WRPRTDNE 			; BRANCH ALWAYS.
*
ENDWQCHK		lda RWREQH
				beq WRTRQDNE			; BRANCH IF REQEST SATISFIED.
				iny 					; ARE WE DONE WITH THIS BLOCK OF DATA?
				bne ENDWCHK1 			; BRANCH IF NOT.
				lda POSPTR+1
				eor DATPTR+1 			; WHILE THIS IS REDUNDANT, IT'S NECESSARY FOR
				bne ENDWCHK2 			; PROPER ADJUSTMENT OF REQUEST COUNT.
ENDWCHK1		dec RWREQH 				; (NOT FINISHED- OK TO ADJUST HI BYTE.)
ENDWCHK2		dey 					; RESET MODIFIED Y
				jmp WRPART2
*
WRTRQDNE		iny 					; AND POSITION.
				bne SETWRDNE
				inc USRBUF+1 			; BUMP POINTERS.
				inc TPOSLH
				bne SETWRDNE
				inc TPOSHI
SETWRDNE		bit SETVFLG 			; (SET V FLAG)
WRPRTDNE		sty TPOSLL 				; SAVE LOW POSITION
				stx RWREQL 				; AND REMAINDER OF REQUEST COUNT.
				php  					; SAVE STATUSES
				ldy #FCBSTAT
				lda (FCBPTR),Y
				ora #DATMOD+USEMOD
				sta (FCBPTR),Y
				clc  					; ADJUST USER'S LOW BUFFER ADDRESS
				lda TPOSLL
				adc USRBUF
				sta USRBUF
				bcc WRPART4
				inc USRBUF+1 			; ADJUST HI ADDRESS AS NEEDED.
WRPART4			jsr FCBUSED 			; SET DIRECTORY FLUSH BIT
				plp  					; RESTORE RETURN STATUSES
				rts

TOPDOWN			jsr SWAPDOWN 			; FIRST MAKE CURRENT 1ST BLOCK AN ENTRY IN NEW TOP.
				bcs TPDWNERR 			; RETURN ANY ERRORS
				ldy #FCBSTYP 			; FIND OUT IF STORAGE TYPE HAS BEEN CHANGED TO 'TREE'.
				lda (FCBPTR),Y 			; (IF NOT, ASSUME IT WAS ORIGINALLY A SEED AND
				cmp #TRETYP 			; BOTH LEVELS NEED TO BE BUILT.
				beq TOPDWN1 			; OTHERWISE, ONLY AN INDEX NEED BE ALLOCATED)
				jsr SWAPDOWN 			; MAKE PREVIOUS SWAP A SAP LEVEL INDEX BLOCK.
				bcs TPDWNERR
TOPDWN1			jsr ALCWBLK 			; GET ANOTHER BLOCK ADDRESS FOR THE SAP LEVEL INDEX.
				bcs TPDWNERR
				lda TPOSHI 				; CALCULATE POSITION OF NEW INDEX BLOCK
				lsr 					; IN THE TOP OF THE TREE.
				tay
				lda SCRTCH 				; GET ADDRESS OF NEWLY ALOCATED INDEX BLOCK AGAIN
				tax
				sta (TINDX),Y
				inc TINDX+1
				lda SCRTCH+1
				sta (TINDX),Y 			; SAVE HI ADDRESS
				dec TINDX+1
				ldy #FCBIDXB+1 			; MAKE NEWLY ALLOCATED BLOCK THE CURRENT INDEX BLOCK.
				sta (FCBPTR),Y
				txa
				dey
				sta (FCBPTR),Y
				jsr WFCBFST 			; SAVE NEW TOP OF TREE.
				bcs TPDWNERR
				jmp ZTMPIDX 			; END BY RE-CLEARING CURRENT (NEW) INDEX BLOCK.
*
SAPDOWN			ldy #FCBSTYP 			; FIND OUT IF WE'RE DEALING WITH A TREE
				lda (FCBPTR),Y 			; OR A SIMPLE SEED.
				cmp #SEEDTYP 			; IF SEED THEN AN ADJUSTMENT TO FILE TYPE IS NECESSARY.
				beq SAPDWN1 			; BRANCH IF SEED.
				jsr RFCBFST 			; OTHERWISE READ IN TOP OF TREE.
				bcc TOPDWN1 			; BRANCH IF NO ERROR.
TPDWNERR		rts  					; RETURN ERRORS
*

SAPDWN1			.EQ * 					; MAKE CURRENT SEED INTO A SAPLING
*
SWAPDOWN		jsr ALCWBLK 			; ALLOCATE A BLOCK BEFORE SWAP
				bcs SWAPERR 			; RETURN ERRORS IMMEDIATELY.
				ldy #FCBFRST 			; GET PREVIOUS FIRST BLOCK
				lda (FCBPTR),Y 			; ADDRESS INTO INDEX BLOCK.
				pha  					; SAVE TEMPORARLY WHILE SWAPPING IN NEW TOP INDEX
				lda SCRTCH 				; GET NEW BLOCK ADDRESS (LOW)
				tax
				sta (FCBPTR),Y
				iny
				lda (FCBPTR),Y
				pha
				lda SCRTCH+1 			; AND HIGH ADDRESS TOO.
				sta (FCBPTR),Y
				ldy #FCBIDXB+1 			; MAKE NEW TOP ALSO THE CURRENT INDEX IN MEMORY.
				sta (FCBPTR),Y
				txa  					; GET LOW ADDRESS AGAIN
				dey
				sta (FCBPTR),Y
				ldy #0 					; MAKE PREVIOUS THE FIRST ENTRY IN SUB INDEX
				inc TINDX+1
				pla
				sta (TINDX),Y
				dec TINDX+1
				pla
				sta (TINDX),Y
				jsr WFCBFST 			; SAVE NEW FILE TOP.
				bcs SWAPERR
				ldy #FCBSTYP 			; NOW ADJUST STORAGE TYPE
				lda #1 					; BY ADDING 1 (THUS SEED BECOMES SAPLING BECOMES TREE)
				adc (FCBPTR),Y
				sta (FCBPTR),Y
				ldy #FCBSTAT
				lda (FCBPTR),Y 			; MARK STORAGE TYPE MODIFIED.
				ora #STPMOD
				sta (FCBPTR),Y
				clc  					; RETURN 'NO ERROR' STATUS.
SWAPERR			rts
*

ALCWBLK			jsr ALC1BLK
				bcs ALUSERR
				ldy #FCBUSE
				lda (FCBPTR),Y 			; BUMP CURRENT USAGE COUNT BY 1.
				clc
				adc #1
				sta (FCBPTR),Y
				bcc INCUSG1
				iny
				lda (FCBPTR),Y
				adc #0
				sta (FCBPTR),Y
INCUSG1			ldy #FCBSTAT 			; MARK USAGE AS MODIFIED.
				lda (FCBPTR),Y
				ora #USEMOD
				sta (FCBPTR),Y
				clc  					; INDICATE NO ERROR
ALUSERR			rts  					; ALL DONE
*
TSTWPROT		ldy #FCBSTAT 			; CHECK FOR A 'NEVER BEEN MODIFIED' CONDITION
				lda (FCBPTR),Y 			; GET STATUS BYTE
				and #USEMOD+DATMOD+IDXMOD+EOFMOD
				clc 					; ANTICIPATE WRITE OK
				bne ALUSERR 			; ORDINARY RTS
				ldy #FCBDEVN 			; GET FILE'S DEVICE NUMBER
				lda (FCBPTR),Y
				sta DEVNUM 				; GET CURRENT STATUS OF BLOCK DEVICE
TWRPROT1		lda #STATCMD
				sta DHPCMD
				lda #STATSUB 			; STORE SUB COMMAND OF STATUS CALL
				sta DSTATREQ
				lda #TWRCODE
				sta DSTATBFL 			; FETCH RETURN CODE IN SCRATCH AREA
				lda /TWRCODE
				sta DSTATBFH
				lda #0 					; MAKE SURE REGULAR RAM IS SELECTED (NO BANKS)
				sta SISDSTAT
				sta SERR 				; CLEAR GLOBAL ERROR FLAG
				lda DEVNUM 				; SET UP LAST PARM
				sta UNITNUM 			; FOR DEVICE CALL
				jsr DMGR 				; MAKE THE EXTERNAL CALL
				bcs WPROTRET 			; RETURN ANY SPECIFIC ERRORS
				lda TWRCODE 			; GET STATUS BYTE
				lsr 					; SHIFT WRITE PROTECT STATE INTO CARRY
				lsr
				lda #XNOWRITE			; ANTICIPATE WRITE PROTECTED.
				rts 					; CARRY IS INDETERMINATE

WPROTRET		cmp #XDISKSW 			; IF EXPLICITLY DISK SWITCH
				bne WPROT1 				; BRANCH IF XNODRIVE OR XNOWRITE
				sta DSWGLOB 			; IF DISKSW, FLAG UNTIL ENTIRE OPERATION IS COMPLETE
				clc
				rts 					; DISKSWITCH DOESNT SET CARRY

WPROT1			sec
				rts

DSWGLOB			.BS 1 ; DISK SWITCH GLOBAL
TWRCODE			.BS 1 ; A RARE EMBEDDED TEMP STORE
*
* MEMORY 'WRAP-AROUND' ADJUST ROUTINE. THIS ROUTINE ADJUSTS
* ADDRESSES THAT CROSS BANK PAIR BOUNDARIES. ON ENTRY, X CONTAINS
* THE OFFSET OF THE ZERO PAGE EXTENDED POINTER TO BE ADJUSTED.
* ON EXIT, THE POINTER WILL HAVE BEEN ADJUSTED, IF NECESSARY,
* AND THE ASSOCIATED X-BYTE WILL ALSO HAVE BEEN ADJUSTED.
* ONLY ADDRESSES IN THE RANGE $8200-$8E00 WILL BE ADJUSTED.
*
* UPON EXIT, A CONTAINS HIGH BYTE OF ADDRESS & Y CONTAINS UPDATED X-BYTE.
* THIS ROUTINE LEAVES X UNCHANGED.
*
WRAPADJ			lda 1,X 				; GET HIGH ADDRESS BYTE <SRS 82.162>
				ldy SISTER+1,X 			; CHECK X-BYTE <SRS 82.162>
				bpl WRAPDNE 			; NOT AN EXTENDED ADDRESS. <SRS 82.162>
				cmp #$82 				; DOES IT NEED UPDATING? <SRS 82.162>
				bcc WRAPDNE 			; NO <SRS 82.162>
				cpy #$8F 				; SPECIAL BANK? <SRS 82.162>
				bcs WRAPDNE 			; NO <SRS 82.162>
				and #$7F				; ADJUST THE ADDRESS <SRS 82.162>
				sta 1,X 				; UPDATE <SRS 82.162>
				inc SISTER+1,X 			; INCREMENT X-BYTE <SRS 82.162>
				iny  					; UPDATE Y ALSO <SRS 82.162>
*
WRAPDNE			rts  					; RETURN VALID HIGH ADDRESS AND BANK BYTE.
*--------------------------------------
MAN
SAVE /A3OSX.BUILD/SOS.13/sos.s.bfm.rw
LOAD /A3OSX.BUILD/SOS.13/sos.s
ASM
