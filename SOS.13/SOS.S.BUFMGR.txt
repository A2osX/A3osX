NEW
  AUTO 3,1
*--------------------------------------
*************************************************************************  
* APPLE /// SOS 1.3 SOURCE CODE FILE: BUFMGR.SRC  
*************************************************************************  
* ASSEMBLER: APPLE ][ 6502 ASSEMBLER from APPLE COMPUTER TOOLKIT  
				 
SBTL			 "SOS 1.1 BUFFER MANAGER"  
REL				  
INCLUDE			 SOSORG,6,1,254  
*ORGBUFMG EQU $F552  
*LENBUFMG EQU $31C  
ORG				 ORGBUFMG  
ZZORG			 EQU *  
MSB				 OFF  
REP				 60  
* COPYRIGHT (C) APPLE COMPUTER INC. 1980  
* ALL RIGHTS RESERVED  
REP				 60  
*  
* BUFFER MANAGER (VERSION = 1.1O )  
* (DATE = 8/04/81)  
*  
* THIS MODULE IS RESPONSIBLE FOR CREATING AND RELEASING BUFFERS  
* FOR BOTH THE BLOCK FILE MANAGER AND, LATER, DEVICE HANDLERS  
* THE BUFFER MANAGER CREATES BUFFERS BY REQUESTING MEMORY  
* SEGMENTS FROM THE MEMORY MANAGER, AND RELEASES THEM VIA SAME.  
* THE PRIMARY DATA STRUCTURE IN THIS MODULE IS THE BUFFER TABLE.  
*  
REP				 60  
*  
ENTRY			 REQBUF  
ENTRY			 REQFXBUF  
ENTRY			 GETBUFADR  
ENTRY			 CHKBUF  
ENTRY			 RELBUF  
*  
EXTRN			 MMGR  
EXTRN			 SXPAGE  
EXTRN			 CZPAGE  
EXTRN			 CXPAGE  
*  
EXTRN			 SYSERR  
EXTRN			 SERR  
EXTRN			 OUTOFMEM  
EXTRN			 BUFTBLFULL  
EXTRN			 BADSYSBUF  
*  
EXTRN			 SYSDEATH  
EXTRN			 BADBUFNUM  
EXTRN			 BADBUFSIZ  
*  
ENTRY			 BUF.CNT  
ENTRY			 PGCT.T  
ENTRY			 XBYTE.T  
ENTRY			 BUFREF  
PAGE			  
REP				 60  
*  
* DATA DECLARATIONS  
*  
REP				 60  
*  
Z.REG			 EQU $FFD0  
*  
* MEMORY MGMT CALL PARM LOCATIONS ON SOS ZPAGE  
*  
M.TPARMX		 EQU $60 ; FIRST ADR OF MEM SYS CALL PARMS ON SOS ZPAGE  
REQCODE			 EQU M.TPARMX+$0  
*  
FINDSEG			 EQU $1  
SRCHMODE		 EQU M.TPARMX+$1  
F.ID			 EQU M.TPARMX+$2  
F.PGCT			 EQU M.TPARMX+$3  
F.PGCTX			 DS 2 ; TEMP LOC FOR F.PGCT PARM  
F.BASE			 EQU M.TPARMX+$5  
F.BASEX			 DS 2 ; TEMP LOC FOR F.BASE PARM  
F.LIM			 EQU M.TPARMX+$7  
F.LIMX			 DS 2 ; TEMP LOC FOR F.LIM PARM  
F.NUM			 EQU M.TPARMX+$9   
F.NUMX			 DS 1 ; TEMP LOC FOR F.NUM PARM  
*     
RELSEG			 EQU $5   
RLS.NUM			 EQU M.TPARMX+$1   
*     
* REQBUF DATA DECLARATIONS 000085 *  
RQB.PGCT		 DS 1 ; REQUESTED PAGE COUNT  
RQB.BNUM		 DS 1 ; BUFFER NUMBER (FM GETFREE CALL)  
*     
* REQFXBUF DATA DECLARATIONS  
*  
RQFB.PGCT		 DS 1 ; REQUESTED PAGE COUNT  
RQFB.BNUM		 DS 1 ; BUFFER NUMBER (FM GETFREE CALL)  
MAXPGCT			 EQU 64 ; MAX BUFSIZE=16K  
F.TPARMX		 EQU $A0 ; FIRST ADR OF FILE SYS CALL PARMS ON SOS ZPAGE  
OPEN.LIST		 EQU F.TPARMX+$5 ; LOC OF OPEN.LIST PARM (OPEN SYS CALL)  
*     
* BUFCOMPACT DATA DECLARATIONS (SOURCE ALSO USED BY CHKBUF)  
*  
BUFC.BNUM		 DS 1 ; BUF# OF LOWEST BUFFER IN BUF.TBL  
SOURCE			 EQU M.TPARMX+$10 ; & $11  
DEST			 EQU M.TPARMX+$12 ; & $13  
				PAGE    
				REP 60   
*  
* BUFFER TABLE  
*  
* THE BUFFER TABLE CONSISTS OF "CNT"-1 ENTRIES (1 TO "CNT"-1).  
* EACH ENTRY IS "SIZ" BYTES IN LENGTH. THE "PGCT" FIELD  
* CONTAINS 3 SUBFIELDS. BIT 7 IS THE "FREE" FLAG (0=ACTIVE,1=FREE)  
* BIT 6 IS THE "FIXED" FLAG (0=FLOATING BUFFER,1=FIXED BUFFER)  
* BITS 5 THRU 0 CONTAIN THE PAGE COUNT OF AN "ACTIVE" ENTRY  
* (0=>1 PAGE,63=>64 PAGES DECIMAL). THE "XBYTE" FIELD CONTAINS  
* THE PROPER XBYTE OF AN "ACTIVE" ENTRY. THE "ADRH" FIELD  
* CONTAINS THE HIGH BYTE OF THE BUFFER ADDRESS. IF THE  
* BUFFER ENTRY IS "FLOATING", THEN THE "SEG" FIELD CONTAINS THE  
* SEGMENT NUMBER AND THE LOW BYTE OF THE BUFFER ADDRESS IS  
* ASSUMMED TO BE ZERO.  
*  
* THUS, THE FOLLOWING RESTRICTIONS APPLY TO BUFFERS:  
*  
* (1) MAXIMUM BUFFER LENGTH IS 64 PAGES (16K)  
* (2) "FLOATING" BUFFERS ALWAYS BEGIN ON A PAGE BOUNDARY  
* "FIXED" BUFFERS DO NOT.  
* (3) BUFFERS ARE ALWAYS AN INTEGRAL NUMBER OF PAGES IN LENGTH  
* (4) BUFFERS ALWAYS RESIDE IN THE 32K BANK MEMORY REGION,  
* A LIMITATION OF FIND.SEG (MEMORY MANAGER)  
* (5) MAXIMUM NUMBER OF BUFFERS = 16; ENTRY 0 IS NOT USED.  
*  
REP				 60  
*  
* BUFFER TABLE  
*  
BUF.SIZ			 EQU 5  
BUF.CNT			 EQU 17  
BUF.TBL			 DS BUF.SIZ*BUF.CNT  
PGCT.T			 EQU BUF.TBL  
XBYTE.T			 EQU PGCT.T+BUF.CNT  
ADRH.T			 EQU XBYTE.T+BUF.CNT  
SEG.T			 EQU ADRH.T+BUF.CNT  
ADRL.T			 EQU SEG.T  
CHK.T			 EQU ADRL.T+BUF.CNT  
ISFIXED			 EQU $40  
ISFREE			 EQU $80  
*  
* BUFFER REFERENCE TABLE  
*  
* FIRST BYTE IS COUNT, FOLLOWED BY "COUNT" BUFFER #S.  
* THIS TABLE IS A LIST OF ALL BUFFERS REFERENCED DURING ONE  
* SOS SYSTEM CALL. BUFFER #S ARE ADDED TO THIS LIST BY  
* GETBUFADR AND REMOVED BY CHKSUM.  
*  
BUFREF.CNT		 EQU 17  
BUFREF			 DS BUFREF.CNT  
ZPAGEX			 DS 1  
PAGE			  
REP				 60  
*  
* REQBUF  
*  
* INPUT: PAGE.CNT (A)  
* OUTPUT: BUFNUM (A)  
* ERROR: "BUFFER TABLE FULL" - SYSERR  
* "OUT OF MEMORY" - SYSERR  
* "BAD BUFFER SIZE" - SYSDEATH  
*  
* THIS ROUTINE FINDS A FREE ENTRY IN THE BUFFER TABLE  
* AND THEN CALLS FIND.SEG (MMGR) TO OBTAIN MEMORY FOR IT.  
* IF MEMORY IS FOUND THEN THE BUFFER ENTRY IS MARKED "ACTIVE"  
* AND THE BUFFER INFO IS INSERTED INTO THE ENTRY  
*  
REP				 60  
*  
REQBUF			 EQU *  
*  
* IF REQUESTED PGCT OUT OF BOUNDS THEN FATAL ERR  
*  
TAY				  
BEQ				 RQB.ERR2 ; FATAL ERR, INVALID BUFFER SIZE  
CPY				 #MAXPGCT+1  
BCS				 RQB.ERR2 ; FATAL ERR, INVALID BUFFER SIZE  
STY				 RQB.PGCT ; SAVE PAGE COUNT  
*  
* FIND FREE ENTRY IN BUF.TBL  
*  
JSR				 GETFREE  
BCS				 RQB.ERR ; ERR, BUFFER TABLE FULL  
STX				 RQB.BNUM  
*  
* FIND PGCT*256 BYTES OF FREE MEMORY  
*  
LDA				 RQB.PGCT  
JSR				 FSEG  
BCS				 RQB.ERR1 ; ERR, OUT OF MEMORY  
*  
* INSERT PGCT, XBYTE, ADRH, SEG#, CHK BYTE IN BUF.TBL(BUF#)  
*  
LDX				 RQB.BNUM  
DEC				 RQB.PGCT ; PAGE COUNT FIELD  
LDA				 RQB.PGCT  
STA				 PGCT.T,X  
*  
LDX				 F.BASEX ; XBYTE & ADRH FIELDS  
LDY				 F.BASEX+1  
JSR				 CNVRT.ADR  
CPX				 #$8F  
BNE				 RQB010  
LDX				 #$7F ; IF XBYTE=$8F THEN XBYTE:=$7F  
RQB010			 TXA  
LDX				 RQB.BNUM  
STA				 XBYTE.T,X  
TYA				  
STA				 ADRH.T,X  
*  
LDA				 F.NUMX ; SEG# FIELD  
STA				 SEG.T,X  
*  
LDA				 #0 ; INIT CHECK BYTE TO NULL  
STA				 CHK.T,X  
*  
TXA				 ; RETURN BUF#  
CLC				  
RTS				 ; NORMAL EXIT  
*  
*  
RQB.ERR			 LDA #BUFTBLFULL  
JSR				 SYSERR  
*  
RQB.ERR1		 LDA #OUTOFMEM  
JSR				 SYSERR  
*  
RQB.ERR2		 LDA #BADBUFSIZ  
JSR				 SYSDEATH  
PAGE			  
REP				 60  
*  
* REQFXBUF  
*  
* INPUT: PAGE.CNT (A)  
* OUTPUT: BUFNUM(A)
* ERROR: "BUFFER TABLE FULL"- SYSERR
* "BAD SYSTEM.BUF PARM ADDRESS" - SYSERR  
* "BAD BUFFER SIZE" - SYSDEATH  
*   
* THIS ROUTINE COMPUTES THE ACTUAL BUFFER ADDRESS IN THE OPEN  
* CALL (PARM "OPEN.LIST"), AND ALLOCATES A BUFFER ENTRY FOR IT.  
* NOTE: THE SYSBUF PARAMETER MUST BE AN EXTENDED INDIRECT PTR!!  
*  
REP				 60  
*  
REQFXBUF		 EQU *  
*  
* IF REQUESTED PGCT OUT OF BOUNDS THEN FATAL ERR  
*  
TAY				  
BEQ				 RQFB.ERR2 ; FATAL ERR, BAD BUFFER SIZE  
CPY				 #MAXPGCT+1  
BCS				 RQFB.ERR2 ; FATAL ERR, BAD BUFFER SIZE  
*  
STY				 RQFB.PGCT ; SAVE PAGE COUNT  
*  
* GET A FREE BUFFER ENTRY  
*  
JSR				 GETFREE  
BCS				 RQFB.ERR ; ERR, BUFFER TABLE FULL  
STX				 RQFB.BNUM ; SAVE BUF#  
*  
* FETCH SYSTEM.BUF PARAMETER IN OPEN SYSTEM CALL  
*  
LDY				 #3  
LDA				 (OPEN.LIST),Y  
BNE				 RQFB.ERR1 ; ERR, SYSBUF ADR  
DEY				  
LDA				 (OPEN.LIST),Y  
TAY				  
LDA				 CXPAGE+1,Y  
BPL				 RQFB.ERR1 ; ERR, SYSBUF ADR  
CMP				 #$8F  
BCS				 RQFB.ERR1 ; ERR, SYSBUF ADR  
*  
* INSERT XBYTE, ADRH, ADRL, PGCT, CHK BYTE INTO BUF.TBL(BUF#)  
*  
LDX				 RQFB.BNUM  
STA				 XBYTE.T,X  
*  
LDA				 CZPAGE+1,Y  
BEQ				 RQFB.ERR1 ; ERR SYSBUF ADR  
CMP				 #$81 ; CHECK FOR ADDRESS COMPENSATION  
BCC				 RQFB010  
INC				 XBYTE.T,X  
AND				 #$7F  
RQFB010			 STA ADRH.T,X  
*  
LDA				 CZPAGE,Y  
STA				 ADRL.T,X  
*  
DEC				 RQFB.PGCT  
LDA				 RQFB.PGCT  
ORA				 #ISFIXED  
STA				 PGCT.T,X ; BUFFER ENTRY NOW "ACTIVE"  
*  
LDA				 #0 ; INIT CHECK BYTE TO NULL  
STA				 CHK.T,X  
*  
TXA				 ; RETURN BUF#  
CLC				  
RTS				 ; NORMAL EXIT  
*  
RQFB.ERR		 LDA #BUFTBLFULL  
JSR				 SYSERR  
*  
RQFB.ERR1		 LDA #BADSYSBUF  
JSR				 SYSERR  
*  
RQFB.ERR2		 LDA #BADBUFSIZ  
JSR				 SYSDEATH  
PAGE			  
REP				 60  
*  
* GETBUFADR  
*   
* INPUT: BUFNUM (A)  
* ZPAGELOC (X)  
* OUTPUT: BUF ADR AT: X,X+1 & SXPAGE+1,X  
* PAGE.CNT (A)  
* BUFNUM (Y)  
*   
* ERROR: "BADBUFNUM" SYSDEATH  
*   
				REP 60  
*   
GETBUFADR		 EQU *  
*   
* IF BUF# OUT OF RANGE OR BUF.TBL(BUF#)=FREE  
* THEN FATAL ERR  
*  
TAY				  
BEQ				 GTBF.ERR ; BUF#=0, FATAL ERR  
CPY				 #BUF.CNT   
BCS				 GTBF.ERR ; BUF# > MAX BUF TABLE ENTRY, FATAL ERR  
LDA				 PGCT.T,Y   
BMI				 GTBF.ERR ; BUF ENTRY MARKED "FREE", FATAL ERR  
*  
* OTHERWISE, CONSTRUCT BUFFER PTR ON SOS ZPAGE  
*  
JSR				 GETBUFADR1  
*  
* IF BUFFER NOT PREVIOUSLY REFERENCED ON THIS SOS CALL AND CHECK BYTE <> 0  
* THEN COMPARE FIRST BYTE OF BUFFER WITH CHECK BYTE IN BUFFER TABLE.  
* IF NO MATCH THEN KILL SYSTEM.  
*  
STX				 ZPAGEX  
TYA				  
LDX				 BUFREF  
BEQ				 GTBF020 ; BUFREF EMPTY  
*  
GTBF010			 CMP BUFREF,X ; SEARCH FOR PREVIOUS REFERENCE  
BEQ				 GTBF030 ; MATCH FOUND  
DEX				  
BNE				 GTBF010  
*  
GTBF020			 INC BUFREF ; LOG BUF # IN BUFREF TABLE  
LDX				 BUFREF  
CPX				 #BUFREF.CNT  
BCS				 GTBF.ERR ; BUFREF TABLE OVFLOW, KILL SYSTEM  
STA				 BUFREF,X  
*  
LDA				 CHK.T,Y  
BEQ				 GTBF030 ; NO CHECK BYTE, SKIP CHECK  
LDX				 ZPAGEX  
LDA				 ($0,X) ; COMPARE FIRST BYTE OF BUFFER  
CMP				 CHK.T,Y ; WITH CHECK BYTE IN BUF TABLE  
BNE				 GTBF.ERR ; NO MATCH, PULL THE PLUG  
*  
* RETURN PAGE.CNT TO CALLER  
*  
GTBF030			 LDA PGCT.T,Y  
AND				 #$3F ; STRIP OFF FREE,FIXED FLAGS  
CLC				  
ADC				 #1  
*  
CLC				  
RTS				  
*  
*  
GTBF.ERR		 LDA #BADBUFNUM  
JSR				 SYSDEATH  
*  
*  
REP				 60  
*  
* GETBUFADR1  
*  
* INPUT: PGCT.T(BUF#) (A)  
* ZPAGELOC (X)  
* BUF# (Y)  
* ERROR: NONE.  
*  
* EXTRACTS THE BUFFER POINTER FROM THE BUFFER TABLE AND  
* PLACES IT ON ZERO PAGE AT X, X+1 & SXPAGE+1,X  
*  
				REP 60   
*     
GETBUFADR1		 EQU *   
				AND #$40   
				BNE GTB1010   
				LDA #0 ; "FIXED" BUFFER  
				BEQ GTB1020 ; ALWAYS TAKEN  
GTB1010			 LDA ADRL.T,Y ; "FLOATING" BUFFER  
GTB1020			 STA 0,X   
				LDA ADRH.T,Y   
				STA 1,X   
				LDA XBYTE.T,Y   
				ORA #$80 ; ENSURE $7F->$8F  
				STA SXPAGE+1,X   
				RTS    
				PAGE    
				REP 60   
*  
* CHKBUF  
*  
* CHECK BUFFER. FETCHES THE FIRST BYTE OF EACH BUFFER  
* REFERENCED DURING THE CURRENT SYSTEM CALL AND PLACES IT  
* IN CHK.T(BUF#).  
*  
* INPUT: BUFREF TABLE  
* BUFFER TABLE  
* OUTPUT: EMPTY BUFREF TABLE  
* BUFFER TABLE'S CHECK BYTES UPDATED  
* Z REG:=$18  
* ERROR: NONE.  
*  
REP				 60  
*  
CHKBUF			 EQU *  
LDY				 BUFREF ; PICK UP COUNT  
BEQ				 CHKB.EXIT ; EXIT IF BUFREF EMPTY  
*  
LDA				 #$18 ; ENSURE SOS ZPAGE SWITCHED IN  
STA				 Z.REG  
*  
* UPDATE THE CHECK BYTE OF EACH BUF# IN THE BUFREF TABLE  
*  
CHKB010			 LDX #>SOURCE  
LDA				 BUFREF,Y  
TAY				  
LDA				 PGCT.T,Y  
JSR				 GETBUFADR1 ; PUT BUF#S ADR ON ZPAGE  
LDA				 ($0,X)  
STA				 CHK.T,Y  
DEC				 BUFREF  
LDY				 BUFREF  
BNE				 CHKB010 ; IF COUNT<>0 THEN PROCESS NEXT BUF# IN BUFREF TABLE  
*  
CHKB.EXIT		 RTS ; BUFREF TABLE IS EMPTY (COUNT=0)  
PAGE			  
REP				 60  
*  
* RELBUF  
*  
* INPUT: BUFNUM (A)  
* OUTPUT: NONE.  
* ERROR: "BADBUFNUM" SYSDEATH  
*  
* THIS ROUTINE RELEASES THE BUFFER ENTRY, CALLS FIND.SEG TO  
* RELEASE THE CORRESPONDING MEMORY SEGMENT, AND CALLS  
* BUFCOMPACT TO PERFORM BUFFER COMPACTION.  
*  
REP				 60  
*  
RELBUF			 EQU *  
*  
* IF BUF# OUT OF RANGE OR BUF.TBL(BUF#)=FREE  
* THEN FATAL ERR  
*  
TAY				  
BEQ				 RLBF.ERR  
CPY				 #BUF.CNT  
BCS				 RLBF.ERR  
LDA				 PGCT.T,Y  
BMI				 RLBF.ERR  
*  
* MARK BUF.TBL(BUF#)=FREE   
*   
ORA				 #ISFREE  
STA				 PGCT.T,Y  
*   
* IF BUF.TBL(BUF#)=FIXED THEN EXIT   
*   
AND				 #ISFIXED   
BNE				 RLBF.EXIT   
*   
* OTHERWISE CALL MEMORY MGR TO RELEASE BUFFER'S MEMORY SEG  
*   
LDA				 #RELSEG   
STA				 REQCODE   
*   
LDA				 SEG.T,Y   
STA				 RLS.NUM   
*   
JSR				 MMGR   
BCS				 RLBF.ERR ; ANY ERR IS FATAL  
*   
* AND COMPACT BUFFERS   
*   
JSR				 BUFCOMPACT   
*   
RLBF.EXIT		 CLC   
RTS				   
*   
RLBF.ERR		 LDA #BADBUFNUM   
JSR				 SYSDEATH   
PAGE			   
REP				 60   
*  
* BUFCOMPACT  
*  
* THIS ROUTINE IS RESPONSIBLE FOR PACKING ALL SOS BUFFERS UP  
* AGAINST THE HIGHEST AVAILABLE FREE MEMORY. COULD IMPROVE THE  
* EFFICIENCY OF THIS COMPACTION CYCLE BY NOT RELEASING THE "RELEASED" BUFFER  
* UNTIL IT IS KNOWN THAT ANOTHER BUFFER WILL NOT BE MOVED INTO ITS LOC.  
*  
REP				 60  
*  
BUFCOMPACT		 EQU *  
*  
* FIND THE FLOATING BUFFER IN BUF.TBL WITH THE LOWEST ADDRESS.  
*  
BUFC010			 LDY #0  
LDX				 #BUF.CNT-1  
*  
BUFC020			 LDA PGCT.T,X  
AND				 #$C0 ; STRIP OUT PAGE COUNT BITS  
BNE				 BUFC030  
*  
LDA				 ADRH.T,X  
CMP				 ADRH.T,Y  
LDA				 XBYTE.T,X  
SBC				 XBYTE.T,Y  
BCS				 BUFC030  
*  
TXA				 ; SMALLER BUFFER FOUND, SAVE IN Y  
TAY				  
*  
BUFC030			 DEX  
BNE				 BUFC020  
*  
* IF NO BUFFER FOUND THEN DONE  
*  
TYA				  
BNE				 BUFC040  
JMP				 BUFC.EXIT  
BUFC040			 STY BUFC.BNUM ; OTHERWISE SAVE BUF# IN Y REG.  
*  
* CALL FIND.SEG: FINDS HIGHEST AVAILABLE FREE MEMORY  
*  
LDA				 PGCT.T,Y  
AND				 #$3F ; STRIP OUT "FREE","FIXED" FLAGS  
CLC				  
ADC				 #1  
JSR				 FSEG  
BCS				 BUFC.EXIT ; DONE IF NO FREE SEG FOUND  
*  
* CONVERT BASE.BKPG TO BUFFER ADR
*
LDX				 F.BASEX ; BASE BANK  
LDY				 F.BASEX+1 ; BASE PAGE  
JSR				 CNVRT.ADR   
STX				 F.BASEX ; XBYTE  
STY				 F.BASEX+1 ; ADRH  
*  
* IF NEW SEG'S BASE < CURRENT BUFFER'S BASE ADR THEN DONE  
*  
LDY				 BUFC.BNUM  
LDA				 ADRH.T,Y  
STA				 SOURCE+1  
CMP				 F.BASEX+1  
LDA				 XBYTE.T,Y  
STA				 SXPAGE+SOURCE+1  
SBC				 F.BASEX  
BCS				 BUFC.EXIT1  
*  
* MOVE DATA FROM CURRENT BUFFER TO NEW BUFFER  
*  
				LDX F.BASEX   
				STX SXPAGE+DEST+1   
				LDY F.BASEX+1   
				STY DEST+1   
				LDA #0   
				STA SOURCE   
				STA DEST   
*     
				TAY    
				LDX F.PGCTX   
BUFC200			 LDA (SOURCE),Y ; MOVE LOOP  
				STA (DEST),Y   
				DEY    
				BNE BUFC200   
				INC SOURCE+1   
				INC DEST+1   
				DEX    
				BNE BUFC200   
*   
* UPDATE BUF.TBL(BUF#)   
*   
LDY				 BUFC.BNUM  
LDA				 F.BASEX  
STA				 XBYTE.T,Y  
LDA				 F.BASEX+1  
STA				 ADRH.T,Y  
*   
LDX				 SEG.T,Y  
LDA				 F.NUMX  
STA				 SEG.T,Y  
*   
* AND RELEASE OLD MEMORY SEGMENT  
*  
				STX RLS.NUM   
				LDA #RELSEG   
				STA REQCODE   
				JSR MMGR   
				BCS BUFC.ERR   
*     
				JMP BUFC010 ; REPEAT COMPACTION CYCLE  
*     
*     
BUFC.EXIT1		 LDX F.NUMX ; DONE,  
				STX RLS.NUM ; RELEASE SEG BEFORE EXIT  
				LDA #RELSEG   
				STA REQCODE   
				JSR MMGR   
				BCS BUFC.ERR   
*     
BUFC.EXIT		 LDA #0   
				STA SERR ; MASK OUT ANY ERROR FROM MEMORY MGR  
				CLC    
				RTS  ; NORMAL EXIT  
*     
*     
BUFC.ERR		 LDA #BADBUFNUM   
				JSR SYSDEATH   
				PAGE    
				REP 60   
*     
* FSEG  
*  
* INPUT: PAGE.CNT (A)  
* OUTPUT: PAGE.CNT (A) UNCHANGED IF FIND.SEG SUCCESSFUL  
* ERROR: CARRY SET "UNABLE TO FIND MEMORY SEG OF PAGE.CNT*256 BYTES"  
*  
* THIS ROUTINE BUILDS THE PARAMETERS FOR A FIND.SEG SYSTEM CALL  
* AND THEN CALLS THE MEMORY MANAGER.  
*  
REP				 60  
*  
FSEG			 EQU *  
*  
* SETUP INPUT PARAMETERS FOR FIND.SEG CALL  
*  
STA				 F.PGCTX  
LDA				 #FINDSEG  
STA				 REQCODE  
LDA				 #2  
STA				 SRCHMODE  
LDA				 #4  
STA				 F.ID  
*  
* SETUP OUTPUT PARAMETER ADRESSES  
*  
LDA				 #>F.PGCTX  
STA				 F.PGCT  
LDA				 #<F.PGCTX  
STA				 F.PGCT+1  
LDA				 #>F.BASEX  
STA				 F.BASE  
LDA				 #<F.BASEX  
STA				 F.BASE+1  
LDA				 #>F.LIMX  
STA				 F.LIM  
LDA				 #<F.LIMX  
STA				 F.LIM+1  
LDA				 #>F.NUMX  
STA				 F.NUM  
LDA				 #<F.NUMX  
STA				 F.NUM+1  
*  
LDA				 #0  
STA				 F.PGCTX+1  
STA				 SXPAGE+F.PGCT+1  
STA				 SXPAGE+F.BASE+1  
STA				 SXPAGE+F.LIM+1  
STA				 SXPAGE+F.NUM+1  
*  
JSR				 MMGR  
LDA				 F.PGCTX  
*  
RTS				 ; EXIT. CARRY SET->ERR  
PAGE			  
REP				 60  
*  
* GETFREE  
*  
* INPUT: NONE  
* OUTPUT: BUF# (X)  
* ERROR: "BUFTBLFULL" SYSERR  
*  
* THIS ROUTINE SEARCHES THE BUFFER TABLE, LOOKING FOR A FREE  
* ENTRY. IF FOUND, IT RETURNS THE BUFFER NUMBER, ELSE ERROR.  
*  
REP				 60  
*  
GETFREE			 EQU *  
LDX				 #BUF.CNT-1  
GFR010			 LDA PGCT.T,X  
BMI				 GFR.EXIT ; FREE ENTRY FOUND  
DEX				  
BNE				 GFR010  
*  
LDA				 #BUFTBLFULL  
JSR				 SYSERR ; ERR EXIT  
*  
GFR.EXIT		 CLC  
RTS				 ; NORMAL EXIT  
PAGE			  
REP				 60  
*
* CNVRT.ADR
*
* INPUT: BANK VALUE (X)
*PAGE VALUE (Y)
* OUTPUT: XBYTE (X)
*ADRH (Y)
* ERROR: NONE.
*
* THIS ROUTINE CONVERTS A BASE.BKPG PARM (MMGR) INTO A
* VIRTUAL POINTER
*
EP60
*
CNVRT.ADREQU*
*
* IF PAGE <> $20 THEN GOTO L2
*
PY#$20
NECNVA020
*
* IF BANK <> 0 THEN GOTO L1
*
XA
NECNVA010
*
* XBYTE=$8F
* ADRH:=PAGE
*
DX#$8F
MICNVA.EXIT
*
* L1: XBYTE:=(BANK-1) ORA #$80
*ADRH:=#$80
*
CNVA010ORA#$80
AX
EX
DY#$80
MICNVA.EXIT
*
* L2: XBYTE:=BANK ORA #$80
*ADRH:=ADRH-#$20
*
CNVA020TXA
RA#$80
AX
EC
YA
BC#$20
AY
*
CNVA.EXITRTS
*
STON
ZZENDEQU*
ZZLENEQUZZEND-ZZORG
FNEZZLEN-LENBUFMG
AIL2,"SOSORGFILE	 IS INCORRECT FOR BUFMGR"
IN

*************************************************************************
* END OF APPLE /// SOS 1.3 SOURCE CODE FILE: BUFMGR.SRC
*************************************************************************

*--------------------------------------
MAN
SAVE /A3OSX.BUILD/SOS.13\sos.s.bufmgr.txt
LOAD /A3OSX.BUILD/SOS.13/sos.s
ASM
