NEW
  AUTO 3,1
*--------------------------------------
* BUFFER MANAGER (VERSION = 1.1O )
* (DATE = 8/04/81)
*
* THIS MODULE IS RESPONSIBLE FOR CREATING AND RELEASING BUFFERS
* FOR BOTH THE BLOCK FILE MANAGER AND, LATER, DEVICE HANDLERS
* THE BUFFER MANAGER CREATES BUFFERS BY REQUESTING MEMORY
* SEGMENTS FROM THE MEMORY MANAGER, AND RELEASES THEM VIA SAME.
* THE PRIMARY DATA STRUCTURE IN THIS MODULE IS THE BUFFER TABLE.
*
*
* MEMORY MGMT CALL PARM LOCATIONS ON SOS ZPAGE
*
*M.TPARMX		.EQ $60 				; FIRST ADR OF MEM SYS CALL PARMS ON SOS ZPAGE
*REQCODE			.EQ M.TPARMX+$0
*
*FINDSEG			.EQ $1
*SRCHMODE		.EQ M.TPARMX+$1
*F.ID			.EQ M.TPARMX+$2
*F.PGCT			.EQ M.TPARMX+$3
F.PGCTX			.BS 2 					; TEMP LOC FOR F.PGCT PARM
*F.BASE			.EQ M.TPARMX+$5
F.BASEX			.BS 2 					; TEMP LOC FOR F.BASE PARM
*F.LIM			.EQ M.TPARMX+$7
F.LIMX			.BS 2 					; TEMP LOC FOR F.LIM PARM
*F.NUM			.EQ M.TPARMX+$9
F.NUMX			.BS 1 					; TEMP LOC FOR F.NUM PARM
*
RELSEG			.EQ $5
*RLS.NUM			.EQ M.TPARMX+$1
*
* REQBUF DATA DECLARATIONS 000085 *
RQB.PGCT		.BS 1 					; REQUESTED PAGE COUNT
RQB.BNUM		.BS 1 					; BUFFER NUMBER (FM GETFREE CALL)
*
* REQFXBUF DATA DECLARATIONS
*
RQFB.PGCT		.BS 1 					; REQUESTED PAGE COUNT
RQFB.BNUM		.BS 1 					; BUFFER NUMBER (FM GETFREE CALL)
MAXPGCT			.EQ 64 					; MAX BUFSIZE=16K
*F.TPARMX		.EQ $A0 				; FIRST ADR OF FILE SYS CALL PARMS ON SOS ZPAGE
BUFMGR.OPEN.LIST		.EQ F.TPARMX+$5 		; LOC OF OPEN.LIST PARM (OPEN SYS CALL)
*
* BUFCOMPACT DATA DECLARATIONS (SOURCE ALSO USED BY CHKBUF)
*
BUFC.BNUM		.BS 1 					; BUF# OF LOWEST BUFFER IN BUF.TBL
SOURCE			.EQ M.TPARMX+$10 		; & $11
DEST			.EQ M.TPARMX+$12 		; & $13

* BUFFER TABLE
*
* THE BUFFER TABLE CONSISTS OF "CNT"-1 ENTRIES (1 TO "CNT"-1).
* EACH ENTRY IS "SIZ" BYTES IN LENGTH. THE "PGCT" FIELD
* CONTAINS 3 SUBFIELDS. BIT 7 IS THE "FREE" FLAG (0=ACTIVE,1=FREE)
* BIT 6 IS THE "FIXED" FLAG (0=FLOATING BUFFER,1=FIXED BUFFER)
* BITS 5 THRU 0 CONTAIN THE PAGE COUNT OF AN "ACTIVE" ENTRY
* (0=>1 PAGE,63=>64 PAGES DECIMAL). THE "XBYTE" FIELD CONTAINS
* THE PROPER XBYTE OF AN "ACTIVE" ENTRY. THE "ADRH" FIELD
* CONTAINS THE HIGH BYTE OF THE BUFFER ADDRESS. IF THE
* BUFFER ENTRY IS "FLOATING", THEN THE "SEG" FIELD CONTAINS THE
* SEGMENT NUMBER AND THE LOW BYTE OF THE BUFFER ADDRESS IS
* ASSUMMED TO BE ZERO.
*
* THUS, THE FOLLOWING RESTRICTIONS APPLY TO BUFFERS:
*
* (1) MAXIMUM BUFFER LENGTH IS 64 PAGES (16K)
* (2) "FLOATING" BUFFERS ALWAYS BEGIN ON A PAGE BOUNDARY
* "FIXED" BUFFERS DO NOT.
* (3) BUFFERS ARE ALWAYS AN INTEGRAL NUMBER OF PAGES IN LENGTH
* (4) BUFFERS ALWAYS RESIDE IN THE 32K BANK MEMORY REGION,
* A LIMITATION OF FIND.SEG (MEMORY MANAGER)
* (5) MAXIMUM NUMBER OF BUFFERS = 16; ENTRY 0 IS NOT USED.
*
* BUFFER TABLE
*
BUF.SIZ			.EQ 5
BUF.CNT			.EQ 17
BUF.TBL			.BS BUF.SIZ*BUF.CNT
PGCT.T			.EQ BUF.TBL
XBYTE.T			.EQ PGCT.T+BUF.CNT
ADRH.T			.EQ XBYTE.T+BUF.CNT
SEG.T			.EQ ADRH.T+BUF.CNT
ADRL.T			.EQ SEG.T
CHK.T			.EQ ADRL.T+BUF.CNT
ISFIXED			.EQ $40
ISFREE			.EQ $80
*
* BUFFER REFERENCE TABLE
*
* FIRST BYTE IS COUNT, FOLLOWED BY "COUNT" BUFFER #S.
* THIS TABLE IS A LIST OF ALL BUFFERS REFERENCED DURING ONE
* SOS SYSTEM CALL. BUFFER #S ARE ADDED TO THIS LIST BY
* GETBUFADR AND REMOVED BY CHKSUM.
*
BUFREF.CNT		.EQ 17
BUFREF			.BS BUFREF.CNT
ZPAGEX			.BS 1
*
* REQBUF
*
* INPUT: PAGE.CNT (A)
* OUTPUT: BUFNUM (A)
* ERROR: "BUFFER TABLE FULL" - SYSERR
* "OUT OF MEMORY" - SYSERR
* "BAD BUFFER SIZE" - SYSDEATH
*
* THIS ROUTINE FINDS A FREE ENTRY IN THE BUFFER TABLE
* AND THEN CALLS FIND.SEG (MMGR) TO OBTAIN MEMORY FOR IT.
* IF MEMORY IS FOUND THEN THE BUFFER ENTRY IS MARKED "ACTIVE"
* AND THE BUFFER INFO IS INSERTED INTO THE ENTRY
*
*
* IF REQUESTED PGCT OUT OF BOUNDS THEN FATAL ERR
*
REQBUF			tay
				beq	RQB.ERR2 			; FATAL ERR, INVALID BUFFER SIZE
				cpy	#MAXPGCT+1
				bcs	RQB.ERR2 			; FATAL ERR, INVALID BUFFER SIZE
				sty	RQB.PGCT 			; SAVE PAGE COUNT
*
* FIND FREE ENTRY IN BUF.TBL
*
				jsr	GETFREE
				bcs	RQB.ERR 			; ERR, BUFFER TABLE FULL
				stx	RQB.BNUM
*
* FIND PGCT*256 BYTES OF FREE MEMORY
*
				lda	RQB.PGCT
				jsr	FSEG
				bcs	RQB.ERR1 			; ERR, OUT OF MEMORY
*
* INSERT PGCT, XBYTE, ADRH, SEG#, CHK BYTE IN BUF.TBL(BUF#)
*
				ldx	RQB.BNUM
				dec	RQB.PGCT 			; PAGE COUNT FIELD
				lda	RQB.PGCT
				sta	PGCT.T,X
*
				ldx	F.BASEX 			; XBYTE & ADRH FIELDS
				ldy	F.BASEX+1
				jsr	CNVRT.ADR
				cpx	#$8F
				bne	RQB010
				ldx	#$7F 				; IF XBYTE=$8F THEN XBYTE:=$7F

RQB010			txa
				ldx	RQB.BNUM
				sta	XBYTE.T,X
				tya
				sta	ADRH.T,X
*
				lda	F.NUMX 				; SEG# FIELD
				sta	SEG.T,X
*
				lda	#0 					; INIT CHECK BYTE TO NULL
				sta	CHK.T,X
*
				txa						; RETURN BUF#
				clc
				rts						; NORMAL EXIT
*
*
RQB.ERR			lda #BUFTBLFULL
				jsr	SYSERR
*
RQB.ERR1		lda #OUTOFMEM
				jsr	SYSERR
*
RQB.ERR2		lda #BADBUFSIZ
				jsr	SYSDEATH
*
* REQFXBUF
*
* INPUT: PAGE.CNT (A)
* OUTPUT: BUFNUM(A)
* ERROR: "BUFFER TABLE FULL"- SYSERR
* "BAD SYSTEM.BUF PARM ADDRESS" - SYSERR
* "BAD BUFFER SIZE" - SYSDEATH
*
* THIS ROUTINE COMPUTES THE ACTUAL BUFFER ADDRESS IN THE OPEN
* CALL (PARM "OPEN.LIST"), AND ALLOCATES A BUFFER ENTRY FOR IT.
* NOTE: THE SYSBUF PARAMETER MUST BE AN EXTENDED INDIRECT PTR!!
*
*
* IF REQUESTED PGCT OUT OF BOUNDS THEN FATAL ERR
*
REQFXBUF		tay
				beq RQFB.ERR2 			; FATAL ERR, BAD BUFFER SIZE
				cpy #MAXPGCT+1
				bcs RQFB.ERR2 			; FATAL ERR, BAD BUFFER SIZE

				sty RQFB.PGCT 			; SAVE PAGE COUNT

* GET A FREE BUFFER ENTRY

				jsr GETFREE
				bcs RQFB.ERR 			; ERR, BUFFER TABLE FULL
				stx RQFB.BNUM 			; SAVE BUF#

* FETCH SYSTEM.BUF PARAMETER IN OPEN SYSTEM CALL

				ldy	#3
				lda	(BUFMGR.OPEN.LIST),Y
				bne	RQFB.ERR1 			; ERR, SYSBUF ADR
				dey
				lda	(BUFMGR.OPEN.LIST),Y
				tay
				lda	CXPAGE+1,Y
				bpl	RQFB.ERR1 			; ERR, SYSBUF ADR
				cmp	#$8F
				bcs	RQFB.ERR1 			; ERR, SYSBUF ADR

* INSERT XBYTE, ADRH, ADRL, PGCT, CHK BYTE INTO BUF.TBL(BUF#)

				ldx	RQFB.BNUM
				sta	XBYTE.T,X

				lda	CZPAGE+1,Y
				beq	RQFB.ERR1 			; ERR SYSBUF ADR
				cmp	#$81 				; CHECK FOR ADDRESS COMPENSATION
				bcc	RQFB010
				inc	XBYTE.T,X
				and	#$7F
RQFB010			sta ADRH.T,X
*
				lda	CZPAGE,Y
				sta	ADRL.T,X
*
				dec	RQFB.PGCT
				lda	RQFB.PGCT
				ora	#ISFIXED
				sta	PGCT.T,X 			; BUFFER ENTRY NOW "ACTIVE"
*
				lda	#0 					; INIT CHECK BYTE TO NULL
				sta	CHK.T,X
*
				txa						; RETURN BUF#
				clc
				rts						; NORMAL EXIT
*
RQFB.ERR		lda #BUFTBLFULL
				jsr	SYSERR
*
RQFB.ERR1		lda #BADSYSBUF
				jsr	SYSERR
*
RQFB.ERR2		lda #BADBUFSIZ
				jsr	SYSDEATH
*
* GETBUFADR
*
* INPUT: BUFNUM (A)
* ZPAGELOC (X)
* OUTPUT: BUF ADR AT: X,X+1 & SXPAGE+1,X
* PAGE.CNT (A)
* BUFNUM (Y)
*
* ERROR: "BADBUFNUM" SYSDEATH
*
*
* IF BUF# OUT OF RANGE OR BUF.TBL(BUF#)=FREE
* THEN FATAL ERR
*
GETBUFADR		tay
				beq	GTBF.ERR 			; BUF#=0, FATAL ERR
				cpy	#BUF.CNT
				bcs	GTBF.ERR 			; BUF# > MAX BUF TABLE ENTRY, FATAL ERR
				lda	PGCT.T,Y
				bmi	GTBF.ERR 			; BUF ENTRY MARKED "FREE", FATAL ERR
*
* OTHERWISE, CONSTRUCT BUFFER PTR ON SOS ZPAGE
*
				jsr	GETBUFADR1
*
* IF BUFFER NOT PREVIOUSLY REFERENCED ON THIS SOS CALL AND CHECK BYTE <> 0
* THEN COMPARE FIRST BYTE OF BUFFER WITH CHECK BYTE IN BUFFER TABLE.
* IF NO MATCH THEN KILL SYSTEM.
*
				stx ZPAGEX
				tya
				ldx BUFREF
				beq GTBF020 			; BUFREF EMPTY
*
GTBF010			cmp BUFREF,X 			; SEARCH FOR PREVIOUS REFERENCE
				beq	GTBF030 			; MATCH FOUND
				dex
				bne	GTBF010
*
GTBF020			inc BUFREF 				; LOG BUF # IN BUFREF TABLE
				ldx	BUFREF
				cpx	#BUFREF.CNT
				bcs	GTBF.ERR 			; BUFREF TABLE OVFLOW, KILL SYSTEM
				sta	BUFREF,X
*
				lda	CHK.T,Y
				beq	GTBF030 			; NO CHECK BYTE, SKIP CHECK
				ldx	ZPAGEX
				lda	($0,X) 				; COMPARE FIRST BYTE OF BUFFER
				cmp	CHK.T,Y 			; WITH CHECK BYTE IN BUF TABLE
				bne	GTBF.ERR 			; NO MATCH, PULL THE PLUG
*
* RETURN PAGE.CNT TO CALLER
*
GTBF030			lda PGCT.T,Y
				and	#$3F 				; STRIP OFF FREE,FIXED FLAGS
				clc
				adc	#1
*
				clc
				rts
*
*
GTBF.ERR		lda #BADBUFNUM
				jsr	SYSDEATH
*
* GETBUFADR1
*
* INPUT: PGCT.T(BUF#) (A)
* ZPAGELOC (X)
* BUF# (Y)
* ERROR: NONE.
*
* EXTRACTS THE BUFFER POINTER FROM THE BUFFER TABLE AND
* PLACES IT ON ZERO PAGE AT X, X+1 & SXPAGE+1,X
*
GETBUFADR1		and #$40
				bne GTB1010
				lda #0 					; "FIXED" BUFFER
				beq GTB1020 ; ALWAYS TAKEN

GTB1010			lda ADRL.T,Y 			; "FLOATING" BUFFER
GTB1020			sta 0,X
				lda ADRH.T,Y
				sta 1,X
				lda XBYTE.T,Y
				ora #$80 				; ENSURE $7F->$8F
				sta SXPAGE+1,X
				rts
*
* CHKBUF
*
* CHECK BUFFER. FETCHES THE FIRST BYTE OF EACH BUFFER
* REFERENCED DURING THE CURRENT SYSTEM CALL AND PLACES IT
* IN CHK.T(BUF#).
*
* INPUT: BUFREF TABLE
* BUFFER TABLE
* OUTPUT: EMPTY BUFREF TABLE
* BUFFER TABLE'S CHECK BYTES UPDATED
* Z REG:=$18
* ERROR: NONE.
*
CHKBUF			ldy	BUFREF 				; PICK UP COUNT
				beq	CHKB.EXIT 			; EXIT IF BUFREF EMPTY
*
				lda	#$18 				; ENSURE SOS ZPAGE SWITCHED IN
				sta	Z.REG
*
* UPDATE THE CHECK BYTE OF EACH BUF# IN THE BUFREF TABLE
*
CHKB010			ldx #SOURCE
				lda	BUFREF,Y
				tay
				lda	PGCT.T,Y
				jsr	GETBUFADR1 			; PUT BUF#S ADR ON ZPAGE
				lda	($0,X)
				sta	CHK.T,Y
				dec	BUFREF
				ldy	BUFREF
				bne	CHKB010 			; IF COUNT<>0 THEN PROCESS NEXT BUF# IN BUFREF TABLE
*
CHKB.EXIT		rts 					; BUFREF TABLE IS EMPTY (COUNT=0)
*
* RELBUF
*
* INPUT: BUFNUM (A)
* OUTPUT: NONE.
* ERROR: "BADBUFNUM" SYSDEATH
*
* THIS ROUTINE RELEASES THE BUFFER ENTRY, CALLS FIND.SEG TO
* RELEASE THE CORRESPONDING MEMORY SEGMENT, AND CALLS
* BUFCOMPACT TO PERFORM BUFFER COMPACTION.
*
*
* IF BUF# OUT OF RANGE OR BUF.TBL(BUF#)=FREE
* THEN FATAL ERR
*
RELBUF			tay
				beq	RLBF.ERR
				cpy	#BUF.CNT
				bcs	RLBF.ERR
				lda	PGCT.T,Y
				bmi	RLBF.ERR
*
* MARK BUF.TBL(BUF#)=FREE
*
				ora	#ISFREE
				sta	PGCT.T,Y
*
* IF BUF.TBL(BUF#)=FIXED THEN EXIT
*
				and #ISFIXED
				bne RLBF.EXIT
*
* OTHERWISE CALL MEMORY MGR TO RELEASE BUFFER'S MEMORY SEG
*
				lda	#RELSEG
				sta	REQCODE
*
				lda	SEG.T,Y
				sta	RLS.NUM
*
				jsr	MMGR
				bcs	RLBF.ERR 			; ANY ERR IS FATAL
*
* AND COMPACT BUFFERS
*
				jsr	BUFCOMPACT
*
RLBF.EXIT		clc
				rts
*
RLBF.ERR		lda #BADBUFNUM
				jsr	SYSDEATH
*
* BUFCOMPACT
*
* THIS ROUTINE IS RESPONSIBLE FOR PACKING ALL SOS BUFFERS UP
* AGAINST THE HIGHEST AVAILABLE FREE MEMORY. COULD IMPROVE THE
* EFFICIENCY OF THIS COMPACTION CYCLE BY NOT RELEASING THE "RELEASED" BUFFER
* UNTIL IT IS KNOWN THAT ANOTHER BUFFER WILL NOT BE MOVED INTO ITS LOC.
*
BUFCOMPACT		.EQ *
*
* FIND THE FLOATING BUFFER IN BUF.TBL WITH THE LOWEST ADDRESS.
*
BUFC010			ldy #0
				ldx	#BUF.CNT-1
*
BUFC020			lda PGCT.T,X
				and	#$C0 				; STRIP OUT PAGE COUNT BITS
				bne	BUFC030
*
				lda	ADRH.T,X
				cmp	ADRH.T,Y
				lda	XBYTE.T,X
				sbc	XBYTE.T,Y
				bcs	BUFC030
*
				txa						; SMALLER BUFFER FOUND, SAVE IN Y
				tay
*
BUFC030			dex
				bne	BUFC020
*
* IF NO BUFFER FOUND THEN DONE
*
				tya
				bne	BUFC040
				jmp	BUFC.EXIT
BUFC040			sty BUFC.BNUM 			; OTHERWISE SAVE BUF# IN Y REG.
*
* CALL FIND.SEG: FINDS HIGHEST AVAILABLE FREE MEMORY
*
				lda	PGCT.T,Y
				and	#$3F 				; STRIP OUT "FREE","FIXED" FLAGS
				clc
				adc	#1
				jsr	FSEG
				bcs	BUFC.EXIT 			; DONE IF NO FREE SEG FOUND
*
* CONVERT BASE.BKPG TO BUFFER ADR
*
				ldx	F.BASEX 			; BASE BANK
				ldy	F.BASEX+1 			; BASE PAGE
				jsr	CNVRT.ADR
				stx	F.BASEX 			; XBYTE
				sty	F.BASEX+1 			; ADRH
*
* IF NEW SEG'S BASE < CURRENT BUFFER'S BASE ADR THEN DONE
*
				ldy	BUFC.BNUM
				lda	ADRH.T,Y
				sta	SOURCE+1
				cmp	F.BASEX+1
				lda	XBYTE.T,Y
				sta	SXPAGE+SOURCE+1
				sbc	F.BASEX
				bcs	BUFC.EXIT1
*
* MOVE DATA FROM CURRENT BUFFER TO NEW BUFFER
*
				ldx F.BASEX
				stx SXPAGE+DEST+1
				ldy F.BASEX+1
				sty DEST+1
				lda #0
				sta SOURCE
				sta DEST
*
				tay
				ldx F.PGCTX
BUFC200			lda (SOURCE),Y 			; MOVE LOOP
				sta (DEST),Y
				dey
				bne BUFC200
				inc SOURCE+1
				inc DEST+1
				dex
				bne BUFC200
*
* UPDATE BUF.TBL(BUF#)
*
				ldy BUFC.BNUM
				lda F.BASEX
				sta XBYTE.T,Y
				lda F.BASEX+1
				sta ADRH.T,Y
*
				ldx SEG.T,Y
				lda F.NUMX
				sta SEG.T,Y
*
* AND RELEASE OLD MEMORY SEGMENT
*
				stx RLS.NUM
				lda #RELSEG
				sta REQCODE
				jsr MMGR
				bcs BUFC.ERR
*
				jmp BUFC010 			; REPEAT COMPACTION CYCLE
*
*
BUFC.EXIT1		ldx F.NUMX 				; DONE,
				stx RLS.NUM 			; RELEASE SEG BEFORE EXIT
				lda #RELSEG
				sta REQCODE
				jsr MMGR
				bcs BUFC.ERR
*
BUFC.EXIT		lda #0
				sta SERR 				; MASK OUT ANY ERROR FROM MEMORY MGR
				clc
				rts  					; NORMAL EXIT
*
*
BUFC.ERR		lda #BADBUFNUM
				jsr SYSDEATH
*
* FSEG
*
* INPUT: PAGE.CNT (A)
* OUTPUT: PAGE.CNT (A) UNCHANGED IF FIND.SEG SUCCESSFUL
* ERROR: CARRY SET "UNABLE TO FIND MEMORY SEG OF PAGE.CNT*256 BYTES"
*
* THIS ROUTINE BUILDS THE PARAMETERS FOR A FIND.SEG SYSTEM CALL
* AND THEN CALLS THE MEMORY MANAGER.
*
*
* SETUP INPUT PARAMETERS FOR FIND.SEG CALL
*
FSEG			sta	F.PGCTX
*				lda	#FINDSEG
				lda #1

				sta	REQCODE
				lda	#2
				sta	SRCHMODE
				lda	#4
				sta	F.ID
*
* SETUP OUTPUT PARAMETER ADRESSES
*
				lda	#F.PGCTX
				sta	F.PGCT
				lda	/F.PGCTX
				sta	F.PGCT+1
				lda	#F.BASEX
				sta	F.BASE
				lda	/F.BASEX
				sta	F.BASE+1
				lda	#F.LIMX
				sta	F.LIM
				lda	/F.LIMX
				sta	F.LIM+1
				lda	#F.NUMX
				sta	F.NUM
				lda	/F.NUMX
				sta	F.NUM+1
*
				lda	#0
				sta	F.PGCTX+1
				sta	SXPAGE+F.PGCT+1
				sta	SXPAGE+F.BASE+1
				sta	SXPAGE+F.LIM+1
				sta	SXPAGE+F.NUM+1
*
				jsr	MMGR
				lda	F.PGCTX
*
				rts						; EXIT. CARRY SET->ERR
*
* GETFREE
*
* INPUT: NONE
* OUTPUT: BUF# (X)
* ERROR: "BUFTBLFULL" SYSERR
*
* THIS ROUTINE SEARCHES THE BUFFER TABLE, LOOKING FOR A FREE
* ENTRY. IF FOUND, IT RETURNS THE BUFFER NUMBER, ELSE ERROR.
*
GETFREE			ldx	#BUF.CNT-1
GFR010			lda PGCT.T,X
				bmi	GFR.EXIT 			; FREE ENTRY FOUND
				dex
				bne	GFR010
*
				lda	#BUFTBLFULL
				jsr	SYSERR 				; ERR EXIT
*
GFR.EXIT		clc
				rts				 		; NORMAL EXIT
*
* CNVRT.ADR
*
* INPUT: BANK VALUE (X)
* PAGE VALUE (Y)
* OUTPUT: XBYTE (X)
* ADRH (Y)
* ERROR: NONE.
*
* THIS ROUTINE CONVERTS A BASE.BKPG PARM (MMGR) INTO A
* VIRTUAL POINTER
*
*
* IF PAGE <> $20 THEN GOTO L2
*
CNVRT.ADR 		cpy #$20
				bne CNVA020
*
* IF BANK <> 0 THEN GOTO L1
*
				txa
				bne CNVA010
*
* XBYTE=$8F
* ADRH:=PAGE
*
				ldx #$8F
				bmi CNVA.EXIT
*
* L1: XBYTE:=(BANK-1) ORA #$80
* ADRH:=#$80
*
CNVA010 		ora #$80
				tax
				dex
				ldy #$80
				bmi CNVA.EXIT
*
* L2: XBYTE:=BANK ORA #$80
* ADRH:=ADRH-#$20
*
CNVA020 		txa
				ora #$80
				tax
				sec
				tya
				sbc #$20
				tay
*
CNVA.EXIT 		rts
*--------------------------------------
MAN
SAVE /A3OSX.BUILD/SOS.13/sos.s.bufmgr
LOAD /A3OSX.BUILD/SOS.13/sos.s
ASM
