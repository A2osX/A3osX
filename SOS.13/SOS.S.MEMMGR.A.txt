NEW
  AUTO 3,1
*--------------------------------------
*************************************************************************  
* APPLE /// SOS 1.3 SOURCE CODE FILE: MEMMGR.A.SRC  
*************************************************************************  
* ASSEMBLER: APPLE ][ 6502 ASSEMBLER from APPLE COMPUTER TOOLKIT  
				 
SBTL			 "SOS 1.1 MEMORY MANAGER"  
REL				  
INCLUDE			 SOSORG,6,1,254  
ORG				 ORGMEMMG  
ZZORG			 EQU *  
MSB				 OFF  
REP				 60  
* COPYRIGHT (C) APPLE COMPUTER INC. 1980  
* ALL RIGHTS RESERVED  
REP				 60  
*  
* MEMORY MANAGER (VERSION = 1.1O )  
* (DATE = 8/04/81)  
*  
* THIS MODULE CONTAINS ALL OF THE MEMORY MANAGEMENT SYSTEM  
* CALLS SUPPORTED BY THE SARA OPERATING SYSTEM. IT IS  
* ALSO CALLED BY THE BUFFER MANAGER.  
*  
REP				 60  
*  
ENTRY			 MMGR  
*  
ENTRY			 ST.CNT  
ENTRY			 ST.ENTRY  
ENTRY			 ST.FREE  
ENTRY			 ST.FLINK  
ENTRY			 VRT.LIM  
*  
EXTRN			 SYSERR  
EXTRN			 BADSCNUM  
EXTRN			 BADBKPG  
EXTRN			 SEGRQDN  
EXTRN			 SEGTBLFULL  
EXTRN			 BADSEGNUM  
EXTRN			 SEGNOTFND  
EXTRN			 BADSRCHMODE  
EXTRN			 BADCHGMODE  
EXTRN			 BADPGCNT  
PAGE			  
REP				 60  
*  
* SEGMENT TABLE  
* (NOTE: ENTRY 0 IS NOT USED)  
*  
REP				 60  
*  
ST.FREE			 DS 1 ; PTR TO FIRST FREE SEG TABLE ENTRY  
ST.ENTRY		 DS 1 ; PTR TO HIGHEST ALLOC SEG TABLE ENTRY  
ST.SIZ			 EQU 7  
ST.CNT			 EQU 32  
ST.TBL			 DS ST.SIZ*ST.CNT  
ST.BLINK		 EQU ST.TBL ; BACK LINK TO PREV ALLOC SEG ENTRY  
ST.FLINK		 EQU ST.BLINK+ST.CNT ; FORWARD LINK "  
ST.BASEL		 EQU ST.FLINK+ST.CNT ; BASE BANK/PAGE  
ST.BASEH		 EQU ST.BASEL+ST.CNT  
ST.LIML			 EQU ST.BASEH+ST.CNT ; LIMIT BANK/PAGE  
ST.LIMH			 EQU ST.LIML+ST.CNT  
ST.ID			 EQU ST.LIMH+ST.CNT ; SEG ID  
PAGE			  
REP				 60  
*  
* DATA DECLARATIONS  
*  
REP				 60  
*  
ZPAGE			 EQU $40 ; BEGINNING OF ZPAGE TEMP SPACE FOR MEMORY MANAGER  
VRT.BASE		 EQU $0 ; INTERNAL BK/PG PTR TO LOWEST VIRT PAGE  
VRT.LIM			 EQU ZPAGE+$0 ; &$1, INTERNAL BK/PG PTR TO HIGHEST VIRT PAGE  
PHY1BASE		 EQU $0780 ; BANK "F",PAGE "0"  
PHY1LIM			 EQU $079F ; BANK "F",PAGE "1F"  
PHY2BASE		 EQU $0820 ; BANK "10",PAGE "A0"  
PHY2LIM			 EQU $087F ; BANK "10",PAGE "FF"  
*     
* REQUEST.SEG DATA DECLARATIONS  
*  
M.TPARMX		 EQU $60 ; BEGINNING ADDRESS OF MMGR SOS CALL PARMS  
M.RQCODE		 EQU M.TPARMX   
RQ.BASE			 EQU M.TPARMX+1 ; BASE.BANK/PAGE  
RQ.LIM			 EQU M.TPARMX+3 ; LIMIT.BANK/PAGE  
RQ.ID			 EQU M.TPARMX+5   
RQ.NUM			 EQU M.TPARMX+6   
*     
RQ.REGION		 EQU ZPAGE+$2 ;VRT(0),PHY0(1),PHY1(2)  
*     
* FIND.SEG DATA DECLARATIONS  
*  
SRCHMODE		 EQU M.TPARMX+1 ; SEARCH MODE (0,1,2)  
F.ID			 EQU M.TPARMX+2 ; SEG ID  
F.PGCT			 EQU M.TPARMX+3 ; PAGE COUNT (LO  
FX.PGCT			 EQU ZPAGE+$3 ; &$4, INTERNAL PAGE COUNT  
F.BASE			 EQU M.TPARMX+5 ; BASE.BANK/PAGE  
F.LIM			 EQU M.TPARMX+7 ; LIMIT.BANK/PAGE  
F.NUM			 EQU M.TPARMX+9 ; SEG NUM  
F.ERR			 EQU ZPAGE+$5 ; ERROR FLAG  
TRUE			 EQU $80   
FALSE			 EQU $0   
CFS.PGCT		 EQU ZPAGE+$6 ; &7, CURRENT FREE SEGMENT'S PAGE COUNT  
CFS.BASE		 EQU ZPAGE+$8 ; &9, " BASE.BANK/PAGE  
CFS.LIM			 EQU ZPAGE+$A ; &$B, " LIMIT.BANK/PAGE  
CFS.BLINK		 EQU ZPAGE+$C ; " BACK LINK  
CFS.BASE0		 EQU ZPAGE+$D ; &$E, " BASE (SMODE=0)  
CFS.BASE1		 EQU ZPAGE+$F ; &$10, " BASE (SMODE=1)  
CFS.NEXT		 EQU ZPAGE+$11 ; " NEXT ENTRY  
CFS.PREV		 EQU ZPAGE+$12 ; " PREV ENTRY  
CFS.PTR			 EQU ZPAGE+$13 ; &$14 " POINTER TO NXT FREE PG  
BFS.PGCT		 EQU ZPAGE+$15 ; &$16, BIGGEST FREE SEGMENT'S PAGE COUNT  
BFS.BASE		 EQU ZPAGE+$17 ; &$18 " BASE.BANK/PAGE  
BFS.LIM			 EQU ZPAGE+$19 ; &$1A " LIMIT.BANK/PAGE  
BFS.BLINK		 EQU ZPAGE+$1B ; " BACK LINK  
*     
* CHANGE.SEG DATA DECLARATIONS  
*  
CHG.NUM			 EQU M.TPARMX+1 ; SEGNUM PARM  
CHG.MODE		 EQU M.TPARMX+2 ; CHANGE MODE PARM  
CHG.PGCT		 EQU M.TPARMX+3 ; PAGE COUNT PARM  
CHG.PGCTX		 EQU ZPAGE+$1C ; &$1D, INTERNAL STORE FOR PGCT  
CHG.NEW			 EQU ZPAGE+$1E ; &$1F, BANK/PAGE OF SEG'S NEW LIMIT OR BASE  
*     
* GET.SEG.INFO DATA DECLARATIONS  
*  
GSI.NUM			 EQU M.TPARMX+1  
GSI.BASE		 EQU M.TPARMX+2  
GSI.LIM			 EQU M.TPARMX+4  
GSI.PGCT		 EQU M.TPARMX+6  
GSI.ID			 EQU M.TPARMX+8  
*    
* GET.SEG.NUM DATA DECLARATIONS 000133 *  
GSN.BKPG		 EQU M.TPARMX+1  
GSN.NUM			 EQU M.TPARMX+3  
*    
* RELEASE.SEG DATA DECLARATIONS   
*   
RLS.NUM			 EQU M.TPARMX+1 ; SEG NUM  
*   
* REGION - DATA DECLARATIONS   
*   
RGN.BKPG		 DS 2 ; TEMP CONTAINER FOR BANK/PAGE  
PAGE			   
REP				 60   
*  
* MMGR  
*  
* THIS ROUTINE IS THE MAIN ENTRANCE TO THE MEMORY MANAGER  
* MODULE. IT FUNCTIONS AS A SWITCH, BASED UPON THE RECEIVED  
* REQUEST CODE, TO TRANSFER CONTROL TO THE ROUTINE THAT  
* HANDLES THE SPECIFIC SYSTEM CALL.  
*  
REP				 60  
*  
MMGR			 EQU *  
LDA				 M.RQCODE  
				BEQ MMGR010 ; "REQ.SEG"  
				CMP #1   
				BEQ MMGR020 ; "FIND.SEG"  
				CMP #2   
				BEQ MMGR030 ; "CHANGE.SEG"  
				CMP #3   
				BEQ MMGR040 ; "GET.SEG.INFO"  
				CMP #4   
				BEQ MMGR050 ; "GET.SEG.NUM"  
				CMP #5   
				BEQ MMGR060 ; "RELEASE.SEG"  
*     
				LDA #BADSCNUM   
				JSR SYSERR   
*     
MMGR010			 JMP REQ.SEG   
MMGR020			 JMP FIND.SEG   
MMGR030			 JMP CHG.SEG   
MMGR040			 JMP GET.SEG.INFO   
MMGR050			 JMP GET.SEG.NUM   
MMGR060			 JMP RELEASE.SEG   
				PAGE    
				REP 60   
*  
* REQUEST.SEG(IN.BASE.BANKPAGE,LIMIT.BANKPAGE,SEGID; OUT.SEGNUM)  
*  
REP				 60  
*  
REQ.SEG			 EQU *  
*  
* CONVERT CALLER'S BASE.BANK/PAGE TO INTERNAL FMT  
*  
LDX				 RQ.BASE  
LDY				 RQ.BASE+1  
JSR				 CNVRT.IBP  
BCC				 RQ005  
*  
RQ.ERR			 RTS ; ERR EXIT - INVALID BANK/PAGE  
*  
RQ005			 STX RQ.BASE  
STY				 RQ.BASE+1  
STA				 RQ.REGION  
*  
* CONVERT CALLER'S LIMIT.BANK/PAGE TO INTERNAL FMT  
*  
LDX				 RQ.LIM  
LDY				 RQ.LIM+1  
JSR				 CNVRT.IBP  
BCS				 RQ.ERR ; ERR - INVALID BANK/PAGE  
STX				 RQ.LIM  
STY				 RQ.LIM+1  
*  
* IF BASE AND LIMIT ARE IN DIFFERENT REGIONS THEN ERR  
*  
CMP				 RQ.REGION  
BNE				 RQ.ERR1 ; ERR - INVALID BANK/PAGE PAIR  
* IF CALLER'S BASE > LIMIT THEN ERR  
*  
LDA				 RQ.LIM  
CMP				 RQ.BASE  
LDA				 RQ.LIM+1  
SBC				 RQ.BASE+1  
BCC				 RQ.ERR1 ; ERR - INVALID BANK/PAGE PAIR  
*  
* PREV SEGNUM:=NULL; NEXT SEGNUM:=FIRST ENTRY  
*  
LDX				 #0  
LDY				 ST.ENTRY ; NOTE: PREV/NEXT CARRIED IN X & Y REGISTERS  
*  
* IF NO SEGS IN SEG TABLE THEN ALLOCATE REQUESTED SEG  
*  
BEQ				 RQ030  
*  
* IF FIRST SEG IN SEG TABLE BELOW REQUESTED SEG  
* THEN ALLOCATE SEG  
*  
LDA				 ST.LIML,Y  
CMP				 RQ.BASE  
LDA				 ST.LIMH,Y  
SBC				 RQ.BASE+1  
BCC				 RQ030  
*  
* ADVANCE TO NEXT SEG ENTRY  
*  
RQ010			 TYA   
				TAX   
				LDA ST.FLINK,Y  
				TAY   
*   
* IF THERE IS NO NEXT SEG ENTRY   
* IF REQUESTED SEG IS BELOW PREV SEG   
* THEN ALLOCATE REQ SEG   
* ELSE ERR   
*   
BNE				 RQ020   
LDA				 RQ.LIM   
CMP				 ST.BASEL,X   
LDA				 RQ.LIM+1   
SBC				 ST.BASEH,X   
BCC				 RQ030   
*   
BCS				 RQ.ERR2 ; ERR - SEGMENT REQUEST DENIED  
*   
* IF REQUESTED LIMIT >= PREV SEG'S BASE THEN ERR   
*   
RQ020			 LDA RQ.LIM   
CMP				 ST.BASEL,X   
LDA				 RQ.LIM+1   
SBC				 ST.BASEH,X   
BCS				 RQ.ERR2 ; ERR - SEGMENT REQUEST DENIED  
*   
* IF REQUESTED BASE > NEXT SEG'S LIMIT   
* THEN ALLOCATE REQUESTED SEGMENT   
*   
LDA				 ST.LIML,Y   
CMP				 RQ.BASE   
LDA				 ST.LIMH,Y   
SBC				 RQ.BASE+1   
BCS				 RQ010 ; NO, ADVANCE TO NEXT SEGMENT  
*   
RQ030			 TXA ; ALLOCATE REQUESTED SEGMENT  
JSR				 GET.FREE   
BCS				 RQ.ERR3 ; ERR - SEG TABLE FULL  
*   
* ENTER BASE,LIMIT AND ID IN NEW SEG ENTRY   
*   
TAX				   
LDA				 RQ.BASE   
STA				 ST.BASEL,X   
LDA				 RQ.BASE+1   
STA				 ST.BASEH,X   
*   
LDA				 RQ.LIM   
STA				 ST.LIML,X   
LDA				 RQ.LIM+1   
STA				 ST.LIMH,X   
*   
LDA				 RQ.ID   
STA				 ST.ID,X   
*   
* RETURN NEW SEG NUM TO CALLER AND RETURN   
*   
LDY				 #0   
TXA				   
STA				 (RQ.NUM),Y   
*   
CLC				   
RTS				 ; NORMAL EXIT  
*   
RQ.ERR1			 LDA #BADBKPG   
JSR				 SYSERR ; ERR EXIT  
RQ.ERR2			 LDA #SEGRQDN   
JSR				 SYSERR ; ERR EXIT  
*   
RQ.ERR3			 LDA #SEGTBLFULL   
JSR				 SYSERR ; ERR EXIT  
PAGE			   
REP				 60   
*   
* FIND.SEG(IN.SRCHMODE,SEGID; INOUT.PAGECT;   
* OUT.BASE.BKPG,LIMIT.BKPG,SEGNUM)   
*   
				REP 60  
*    
FIND.SEG		 EQU *  
*    
* RETRIEVE PAGE COUNT PARAMETER AND CLEAR ERR FLAG  
*  
				LDY #0   
				LDA (F.PGCT),Y   
				STA FX.PGCT   
				INY    
				LDA (F.PGCT),Y   
				STA FX.PGCT+1   
*     
				BNE FIND001   
				LDA FX.PGCT   
				BNE FIND001   
				LDA #BADPGCNT ; ERR, PAGECT=0, EXIT  
				JSR SYSERR   
*     
FIND001			 LDA #FALSE   
				STA F.ERR   
*    
* IF SEARCH MODE>2 THEN ERR    
*    
LDA				 SRCHMODE   
CMP				 #3   
BCC				 FIND005   
LDA				 #BADSRCHMODE   
JSR				 SYSERR ; ERR EXIT  
*    
* INITIALIZE NEXT FREE SEGMENT SUBROUTINE,   
* AND BIGGEST FREE SEGMENT PAGE COUNT   
*   
FIND005			 JSR NXTFRSEG.I   
LDA				 #0   
STA				 BFS.PGCT   
STA				 BFS.PGCT+1   
*   
* GET NEXT FREE SEGMENT   
*   
FIND010			 JSR NXTFRSEG   
BCC				 FIND015 ; PROCESS FREE SEGMENT  
*   
* NO MORE FREE SEGMENTS LEFT   
* RETURN BIGGEST FREE SEGMENT FOUND   
* ALONG WITH ERR   
*   
LDA				 #TRUE   
STA				 F.ERR   
LDX				 #0 ; SEG#:=0  
JMP				 FIND070   
*   
* FREE SEGMENT FOUND.   
* IF FREE SEGMENT > BIGGEST FREE SEGMENT THEN BFS:=CFS  
*   
FIND015			 LDA BFS.PGCT   
CMP				 CFS.PGCT   
LDA				 BFS.PGCT+1   
SBC				 CFS.PGCT+1   
BCS				 FIND030   
*   
LDX				 #6   
FIND020			 LDA CFS.PGCT,X   
STA				 BFS.PGCT,X   
DEX				   
BPL				 FIND020   
*   
* IF BFS.PGCT<F.PGCT THEN GET NEXT FREE SEGMENT   
*   
FIND030			 LDA BFS.PGCT   
CMP				 FX.PGCT   
LDA				 BFS.PGCT+1   
SBC				 FX.PGCT+1   
BCC				 FIND010   
*   
* BFS.BASE:=BFS.LIM-FX.PGCT+1   
* BFS.PGCT:=FX.PGCT   
*   
LDA				 BFS.LIM   
SBC				 FX.PGCT   
STA				 BFS.BASE   
				LDA BFS.LIM+1  
				SBC FX.PGCT+1  
				STA BFS.BASE+1  
				INC BFS.BASE  
				BNE FIND050  
				INC BFS.BASE+1  
*    
FIND050			 LDA FX.PGCT  
				STA BFS.PGCT  
				LDA FX.PGCT+1  
				STA BFS.PGCT+1  
*    
* DELINK ENTRY FROM FREE LIST, AND LINK   
* IT INTO SEGMENT LIST    
*    
LDA				 BFS.BLINK   
JSR				 GET.FREE   
BCC				 FIND060   
RTS				  ; ERR - SEG TABLE FULL  
*    
* ST.ID(NEW):=F.ID    
* ST.BASE(NEW):=BFS.BASE    
* ST.LIM(NEW):=BFS.LIM    
*    
FIND060			 TAX    
LDA				 F.ID   
STA				 ST.ID,X   
*    
LDA				 BFS.BASE   
STA				 ST.BASEL,X   
LDA				 BFS.BASE+1   
STA				 ST.BASEH,X   
*    
LDA				 BFS.LIM   
STA				 ST.LIML,X   
LDA				 BFS.LIM+1   
STA				 ST.LIMH,X   
*  
* RETURN SEGNUM, PAGE COUNT, BASE BANK/PAGE, AND LIMIT BANK/PAGE  
* TO CALLER  
FIND070			 LDY #0   
				TXA    
				STA (F.NUM),Y   
*     
				LDA BFS.PGCT   
				STA (F.PGCT),Y   
				INY    
				LDA BFS.PGCT+1   
				STA (F.PGCT),Y   
*     
				LDX BFS.BASE   
				LDY BFS.BASE+1   
				JSR CNVRT.XBP   
				TYA    
				LDY #1   
				STA (F.BASE),Y   
				DEY    
				TXA    
				STA (F.BASE),Y   
*     
				LDX BFS.LIM   
				LDY BFS.LIM+1   
				JSR CNVRT.XBP   
				TYA    
				LDY #1   
				STA (F.LIM),Y   
				DEY    
				TXA    
				STA (F.LIM),Y   
*     
				LDA F.ERR ; IF ERR FLAG TRUE THEN REPORT IT.  
				BNE FIND.ERR   
*     
				CLC    
				RTS  ; NORMAL EXIT  
*     
FIND.ERR		 LDA #SEGRQDN   
				JSR SYSERR ; ERR EXIT  
				    
				CHN MEMMGR.B.SRC   
				    
*************************************************************************
* END OF APPLE /// SOS 1.3 SOURCE CODE FILE: MEMMGR.A.SRC
*************************************************************************


*--------------------------------------
MAN
SAVE /A3OSX.BUILD/SOS.13\sos.s.memmgr.a.txt
LOAD /A3OSX.BUILD/SOS.13/sos.s
ASM
