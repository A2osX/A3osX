NEW
  AUTO 3,1
*--------------------------------------
BFMGR			ldx COMMAND 			; WHAT CALL?
				lda	DISPTCH,X 			; TRANSLATE INTO COMMAND ADDRESS
				asl	A 					; (BIT 7 INDICATES IT'S GOT A PATHNAME TO PREPROCESS)
				sta	CMDTEMP
				and	#$3F 				; (BIT 6 IS REFNUM PREPROCESS, 5 IS FOR TIME, SO STRIP EM.)
				tax
				lda	CMDTABLE,X 			; MOVE ADDRESS FOR INDIRECT JUMP.
				sta	CMDADR
				lda	CMDTABLE+1,X 		; (HIGH BYTE)
				sta	CMDADR+1
				lda	/VCB
				sta	VCBPTR+1 			; INSURE DEFAULT HI ADDRESS TO VCB BEFORE CALLS
				lda	#BKBITVAL 			; INIT "BACKUP BIT FLAG"
				sta	BKBITFLG 			; TO SAY "FILE MODIFIED"
				ldy	#MAXTEMPS 			; ZERO OUT SISTER PAGE FOR TEMPS
				lda	#0
				sta	SERR 				; MAKE GLOBAL ERROR SAY "NONE"
				sta	DSWGLOB 			; "DISK SWITCH GLOBAL"
				sta	DUPLFLAG 			; "DUPLICATE VOLUME ON LINE"
				sta	CFLAG 				; SET "CREATE" TO NO
				sta	BLOKSAVE
				sta	BLOKSAVE+1 			; SET PARENT DIRECTORY TO NULL

CLRSIS			sta SISTEMPS,Y
				dey
				bpl CLRSIS 				; CARRY IS UNDISTURBED BY THIS LOOP
				bcc NOPATH
				jsr SETPATH 			; GO PROCESS PATHNAME BEFORE CALLING COMMAND
				bcs ERRORSYS 			; BRANCH IF BAD NAME.
NOPATH			asl CMDTEMP 			; TEST FOR REFNUM PREPROCESSING
				bcc	NOPREREF
				jsr	FINDFCB 			; GO SET UP POINTERS TO FCB AND VCB OF THIS FILE.
				bcs	ERRORSYS 			; BRANCH IF ANY ERRORS ARE ENCOUNTERED.

NOPREREF		asl CMDTEMP 			; LASTLY CHECK FOR NECESSITY OF TIME STAMP.
				bcc	TSWVRFY
				ldx	#DATELO				; PASS Z PAGE ADDRESS OF WHERE TO RETURN DATE/TIME
				jsr	DATETIME			; (NO ERROR POSIBLE)

TSWVRFY			ldx COMMAND 			; TEST FOR NECESSITY OF VOLUME VERIFICATION
				lda	#PREPATH+PREREF+PRETIME ; TO ENSURE VCB IS SET
				and	DISPTCH,X
				beq	EXECUTE
				ldy	#VCBSTAT
				lda	(VCBPTR),Y
				and	#DSWITCH 			; WAS THE VOLUME PREVIOUSLY SWITCHED?
				beq	EXECUTE
				dey						; GET DEVICE NUMBER
				lda	(VCBPTR),Y
				sta	DEVNUM

DVERIFY			jsr VERFYVOL			; SEE IF PROPER VOLUME NOW ON LINE
				bcc	CLRDSWT 			; BRANCH IF YES
				jsr	USRREQ 				; OTHERWISE REQUEST IT BE PUT ON LINE
				bcc	DVERIFY 			; USER SEZ S/HE DID: CHECK IT OUT
				lda	#VNFERR 			; VOLUME NOT FOUND IF USER REFUSES
				bne	ERRORSYS 			; REPORT ERROR (BRANCH ALWAYS)

CLRDSWT			ldy #VCBSTAT 			; GET VOLUME
				lda	(VCBPTR),Y 			; STATUS
				and	#$FF-DSWITCH 		; TURN OFF DISK SWITCH
				sta	(VCBPTR),Y 			; SO WE WON'T VERIFY NEXT TIME

EXECUTE			jsr GOCMD 				; EXECUTE COMMAND
				bcc	GOODOP 				; BRANCH IF SUCCESSFUL
				cmp	#XDISKSW 			; DISK SWITCH?
				bne	ERRORSYS 			; NO, REPORT SOME OTHER
				ldy	#VCBSTAT 			; MARK VCB WITH SWITCH
				lda	(VCBPTR),Y
				and	#$FF-DSWITCH 		; TO ENSURE VOLUME VERIFIED
				bpl ERRCMD 				; NO FILES OPEN SO DSWITCH CANT APPLY
				ora #DSWITCH

ERRCMD			sta (VCBPTR),Y
				jmp BFMGR 				; TRY THE COMMAND AGAIN
*
ERRORSYS		jsr SYSERR
GOODOP			rts  					; GOOD RETURN
*
GOCMD			jmp (CMDADR)
*
CMDTABLE		.DA CREATE
				.DA DESTROY
				.DA RENAME
				.DA SETINFO
				.DA GETINFO
				.DA VOLUMEINFO
				.DA SETPREFX
				.DA GETPREFX
				.DA OPEN
				.DA NEWLINE
				.DA READ
				.DA WRITE
				.DA CLOSE
				.DA FLUSH
				.DA SETMARK
				.DA GETMARK
				.DA SETEOF
				.DA GETEOF
*
DISPTCH			.DA #PREPATH+PRETIME+0 	; CREATE
				.DA #PREPATH+PRETIME+1 	; DESTROY
				.DA #PREPATH+PRETIME+2 	; RENAME
				.DA #PREPATH+PRETIME+3 	; SETINFO
				.DA #PREPATH+4 			; GETINFO
				.DA #5 					; VOLUME
				.DA #6 					; SETPREFIX, PATHNAME MOVED TO PREFIX BUFFER
				.DA #7 					; GETPREFIX
				.DA #PREPATH+8 			; OPEN
				.DA #PREREF+$9 			; NEWLINE
				.DA #PREREF+$A 			; READ
				.DA #PREREF+$B 			; WRITE
				.DA #PRETIME+$C 		; CLOSE
				.DA #PRETIME+$D 		; FLUSH, REFNUM MAY BE ZERO TO FLUSH ALL.
				.DA #PREREF+$E 			; SETMARK
				.DA #PREREF+$F 			; GETMARK
				.DA #PREREF+$10 		; SET EOF
				.DA #PREREF+$11 		; GET EOF
*
SETPATH			lda C.PATH 				; FOR A REGULAR PATHNAME,
				sta TPATH 				; SET UP TEMP POINTER TO PROCESS
				lda C.PATH+1 			; PATHNAME AND CHECK FOR SYNTAX ERRORS
				sta TPATH+1
				lda SISPATH
				sta SISTPATH 			; (LEAVE CALL PARAMETERS ALONE!)
* DROP INTO 'SYNPATH'
*
SYNPATH			lda #PATHBUF 			; SET UP DEFAULT ADDRESS FOR
				sta PATHNML 			; SYNTAXED PATHNAME -
				sta WRKPATH 			; LENGTH, NAME, LENGTH, NAME, ETC...
				lda /PATHBUF
				sta PATHNMH
				sta WRKPATH+1 			; (ASSUMES FULL PATHNAME, NO PREFIX).
				ldx #0 					; USE INDEXED INDIRECT FOR SOURCE PATHNAME
				txa  					; SET BEGINNING OF PATH
				sta (PATHNML,X) 		; TO ZERO TO INDICATE NOTHING PROCESSED.
				tay
				lda (TPATH,X) 			; GET TOTAL LENGTH OF SOURCE PATHNAME
				bmi ERRSYN
				beq ERRSYN
				sta PATHCNT 			; (THIS IS USED AS A 'COUNT-DOWN')
				jsr INCTPTH 			; INCREMENT SOURCE POINTER
				lda (TPATH,X) 			; GET FIRST CHARACTER OF PATHNAME
				cmp #DLIMIT 			; IS IT A FULL PATHNAME (NO PREFIX)?
				beq BUMPATH 			; YES, WE'RE READY TO DO IT.
				cmp #$2E 				; IS IT A DRIVE NAME '.'?
				bne ADPREFIX 			; NO, ADD PREFIX TO BEGINNING

DRIVENAM		lda (TPATH,X) 			; MOVE DRIVE NAME FOR VOLUME CALL
				cmp #DLIMIT 			; HAVE WE MOVED ENTIRE NAME?
				beq PREVOLM 			; YES, PROCESS IT.
				iny  					; (IF THIS IS THE FIRST, MAKE ROOM FOR LENGTH OF NAME)
				sta (WRKPATH),Y
				jsr INCTPTH 			; BUMP POINTER TO GIVEN NAME.
				dec PATHCNT
				bne DRIVENAM
				beq PREVOLM1
*
PREVOLM			jsr INCTPTH 			; MAKE IT SO POINTING PAST DELIMITER.
				dec PATHCNT

PREVOLM1		tya  ; SAVE LENGTH OF DRIVE NAME.
				sta (WRKPATH,X)
				lda #PATHBUF 			; POINT AT PATHNAME BUFFER FOR DEVICE ID CALL.
				sta DVNAMP
				lda /PATHBUF
				sta DVNAMP+1
				lda #0 					; MAKE VIRTUAL POINT AT SWITCHED IN BANK.
				sta SISTER+DVNAMP+1
				jsr SRCHDEV 			; GO IDENTIFY WHICH VOLUME
				bcc PREVOLM2 			; BRANCH IF NO ERROR
				cmp #VNFERR 			; WAS IT REPORTED AS 'VOLUME NOT FOUND'?
				bne SPTHERR 			; NO SOME OTHER ERROR WAS ENCOUNTERED.
				ldx DUPLFLAG 			; YES, WAS IT NOT FOUND BECAUSE SOME OTHER 'OPEN' VOLUME HAS SAME NAME?
				beq SPTHERR 			; NO, IT SIMPLY WASN'T FOUND.
				lda #DUPVOL 			; (CARRY IS SET)
				rts
*
PREVOLM2		ldy #0 					; (X CONTAINS AN INDEX TO VCB)
				lda VCB,X 				; GET VOLUME NAME LENGTH.
				sta PATHBUF,Y

SPATH2			inx  					; MOVE VOLUME NAME INTO PATH NAME BUFFER IN
				iny  					; PLACE OF DISK DEVICE NAME ('.D1' OR SIMULAR)
				lda VCB,X
				sta PATHBUF,Y
				cpy PATHBUF 			; HAVE ALL CHARACTERS BEEN MOVED?
				bne SPATH2
				ldx #0 					; RESET X FOR INDEXING
				stx PATHNML
				lda /PATHBUF
				sta PATHNMH
				lda PATHCNT 			; IS THAT ALL THERE IS?
				bne SPATH3 				; NO, MORE TO COME...
				clc
				jmp ENDPATH
*
SPATH3			iny  					; BUMP TO END OF NAME+1
				sty WRKPATH 			; RESET WORKPATH POINTER TO CURRENT.
				lda #0 					; RESET PATHNAME BUFFER POINTER.
				ldy /PATHBUF
				bne NOPREFX 			; BRANCH ALWAYS...
*
ERRSYN			lda #BADPATH 			; RETURN SYNTAX ERROR
SPTHERR			sec
				rts
*
ADPREFIX		lda PFIXPTR 			; GET POINTER TO BEGINNING OF THE
				ldy PFIXPTR+1 			; PREFIX.

NOPREFX			sta PATHNML
				sty PATHNMH 			; IF NO PRESET PREFIX, THIS IS THE SAME AS
				bne FRSTCHAR 			; PATHBUF ADDRESS. (BRANCH ALWAYS TAKEN)
*
BUMPATH			dec PATHCNT 			; FIRST ADJUST COUNT
				clc  					; (JUST IN CASE OF LAST CHARACTER)
				beq ENDPATH 			; (MUST OF HAD TRAILING SPACES)
				jsr INCTPTH

FRSTCHAR		ldy #0 					; INIT COUNT FOR THIS PORTION OF THE
				tya  					; PATHNAME. ALSO PRESET LENGTH TO ZERO IN
				sta (WRKPATH,X) 		; CASE OF TRAILING SPACES.
				lda (TPATH,X) 			; GET CHARACTER.
				and #$7F 				; IGNORE HIGH BIT.
				cmp #$20 				; IS IT A LEADING SPACE?
				beq BUMPATH 			; IF SO, IGNORE IT.
				cmp #$5B 				; IS IT GREATER THAN (UPPER CASE) A 'Z'?
				bcc ALFA1 				; NO, MAKE SURE IT'S AN ALPHA CHARACTER
				and #$5F 				; YES, ASSUME IT'S LOWER CASE, AND UPSHIFT
				cmp #$5B 				; WAS IT TRULY LOWER CASE?
				bcs ERRSYN 				; NO, GIVE ERROR.
*
ALFA1			cmp #$41 				; IS IT LESS THAN 'A'?
				bcc ERRSYN 				; YES! IT'S CRAP...
				bcs SAVPATH 			; NO, IT'S GOOD. SAVE IT.
*
NXTCHAR			lda (TPATH,X) 			; GET THE NEXT CHARACTER.
				and #$7F 				; THESE CHARACTERS MAY BE ALPHA, NUMERIC,
				cmp #$5B 				; OR A PERIOD - ONLY THE FIRST HAD TO BE ALPHA
				bcc ALFA2 				; BRANCH IF LESS THAN 'Z'
				and #$5F 				; UPSHIFT LOWER CASE.
				cmp #$5B 				; NOW IS IT VALID?
				bcs ERRSYN 				; NOPE.
*
ALFA2			cmp #$41 				; IS IT GREATER THAN 'A'?
				bcs SAVPATH 			; YUP, IT IS WORTH SAVIN.
				cmp #$3A 				; >9?
				bcs TSTDLIM 			; YES
				cmp #$30 				; NO, <0?
				bcs SAVPATH 			; NO, IT'S VALID NUMERIC.

TSTDLIM			cmp #DLIMIT 			; IS IT THE DELIMITER?
				beq ENDPATH 			; YES. CARRY SET INDICATES MORE TO COME.
				cmp #$2E 				; IS IT A '.' (PERIOD)?
				bne ERRSYN 				; NO, IT'S AN ERROR (#@&##@!)

SAVPATH			clc
				iny  					; BUMP NAME LENGTH
				sta (WRKPATH),Y
				dec PATHCNT 			; IF ZERO, THAT WAS THE LAST CHARACTER
				beq ENDPATH 			; (CARRY CLEAR INDICATES END OF PATH)
				inc TPATH 				; BUMP POINTER TO SOURCE PATHNAME.
				bne NXTCHAR
				inc TPATH+1 			; HIGH ORDER, WHEN NECESSARY.
				bne NXTCHAR 			; BRANCH ALWAYS.
*
ENDPATH			tya  					; GET CURRENT NAME LENGTH
				sta (WRKPATH,X) 		; AND PUT IT IN FRONT OF NAME
				bcc LSTNAME 			; BRANCH IF THAT WAS THE LAST OF PATH
				cmp #$10 				; WAS THE NAME ILLEGALLY LONG?
				bcs ERRSYN1 			; YES, REPORT IT.
				ldy #0
				sec  					; ADJUST WORK POINTER TO END OF PREVIOUS NAME.
				adc WRKPATH
				sta WRKPATH 			; REPLACE OLD POINTER.
				bcc BUMPATH 			; DO NEXT NAME.
				lda #TOOLONG 			; THIS IS A NEVER ERROR!
				jsr SYSDEATH 			; (NEVER RETURNS).
*
LSTNAME			beq TSTVALD
				cmp #$10 				; MAKE SURE LAST ISN'T TOO LONG
				bcs ERRSYN1
				iny  					; PUT A ZERO AT END OF PROCESSED PATHNAME
				lda #0

TSTVALD			sta (WRKPATH),Y
				lda (PATHNML,X) 		; SURE THERE IS A PATHNAME
				beq ERRSYN1 			; IF NOT, REPORT ERROR.
				clc  					; INDICATE NO ERROR.
				rts
*
ERRSYN1			jmp ERRSYN
*
INCTPTH			inc TPATH 				; POINT AT NEXT CHARACTER
				bne INCPTH1
				inc TPATH+1
INCPTH1			rts
*
SETPREFX		jsr SETPATH 			; CALL IS MADE HERE SO A 'NUL' PATH MAY BE DETECTED.
				bcc SETPRFX1 			; BRANCH IF PATHNAME OK
				tax  					; SAVE ERROR CODE
				ldy #0
				lda (C.PATH),Y 			; TEST FOR A NUL PATHNAME
				beq RESETPFX 			; BRANCH IF PREFIX TO BE RESET.
				txa  					; RESTORE ERROR CODE
				rts

RESETPFX		sta PFIXPTR
				clc
				rts

SETPRFX1		lda PATHNML 			; MAKE SURE NAME STARTED WITH A '/' DELIMITER.
				bne ERRSYN1 			; BRANCH IF IT DID.
				ldy WRKPATH 			; FIND THE END OF THE INPUT PREFIX
				clc  					; ADD LAST LOCAL NAME LENGTH TO FIND TRUE END.
				lda (PATHNML),Y
				bne SETPRFX3
				dey
				tya
				bne SETPRFX4

SETPRFX3		adc WRKPATH
				tay

SETPRFX4		eor #$FF 				; GET COMPLIMENT TO FIND BEGINNING ADDRESS.
				sta PFIXPTR 			; OF NEW PREFIX IN THE PREFIX BUFFER
				sta WRKPATH 			; (PREFIX ALWAYS ENDS AT THE LAST BYTE OF BUFFER)

MOVPRFX			lda (PATHNML),Y
				sta (WRKPATH),Y 		; MOVE IN NEW PREFIX
				dey
				bpl MOVPRFX
				clc  					; AND WE'RE FINISHED!
				rts  					; NO ERRORS POSIBLE FROM THIS ROUTINE.
*
GETPREFX		clc  					; CALCULATE HOW BIG A BUFFER IS NEEDED TO
				lda PFIXPTR 			; PASS THE PREFIX BACK TO THE USER.
				eor #$FF 				; (EVEN IF NO PREFIX, 1 BYTE IS NEEDED TO SHOW 0 LENGTH)
				adc #2 					; ADD 2 FOR LEADING AND ENDING "/".
				cmp C.MAXPTH 			; IS THERE ENOUGH SPACE IN USER'S BUFFER?
				bcc SENDPRFX 			; BRANCH IF YES
				lda #BTSERR 			; TELL USER BUFFER IS TOO SMALL.
				rts  					; (CARRY IS SET TO INDICATE ERROR.)
*
SENDPRFX		ldy #0 					; SAVE TOTAL LENGTH OF STRING TO BE RETURNED
				sta (C.PATH),Y
				tay
				dey  					; DISCOUNT TRAILING DELIMITER.
				beq NULPREFX 			; BRANCH IF PREFIX IS SET TO NUL.
				iny
				ldx PFIXPTR 			; GET BEGINNING ADDRESS OF PREFIX AGAIN
				dex
				stx WRKPATH
				lda /PATHBUF
				sta WRKPATH+1

SNDLMIT			lda #DLIMIT 			; PLACE DELIMITER BEFORE, BETWEEN, AND AFTER LOCAL NAMES.
				sta (C.PATH),Y

SNDPRFX1		dey
				beq GOTPRFX 			; BRANCH IF ALL OF PREFIX IS TRANSFERED.
				lda (WRKPATH),Y
				sta (C.PATH),Y 			; ASSUME IT'S A CHARACTER.
				and #$F0 				; NOW TEST TO SEE IF IT WAS A LOCAL LENGTH.
				beq SNDLMIT 			; BRANCH IF IT WAS.
				bne SNDPRFX1 			; GO MOVE NEXT CHAR IF IT WASN'T (ALWAYS TAKEN).

NULPREFX		tya  					; RETURN NUL STRING.
				sta (C.PATH),Y

GOTPRFX			clc  					; INDICATE NO ERROR.
				rts
*
FINDFCB			lda FCBADDRH 			; INITIALIZE INDIRECT POINTER TO
				sta FCBPTR+1 			; FILE CONTROL BLOCK (ALLOCATED WHEN SYSTEM
				lda #0 					; WAS FIRST BOOTED).
				sta FCBPTR 				; NOTE: ALWAYS STARTS ON PAGE BOUNDARY.
				lda FCBANKNM 			; SET SISTE PAGE BYTE TOO...
				sta SISFCBP
				ldy C.REFNUM 			; GET REQUESTED REFERENCE
				bmi ERRNOTBLK 			; BRANCH IF IT'S NOT A BLOCK DEVICE REFERENCE
				dey  					; (SHOULD BE IN THE RANGE OF 1-16 BEFORE DECREMENT)
				cpy #$10 				; IS IT A VALID REFNUM?
				bcs REEFER 				; NO, THE USER'S SMOKIN DOPE!
				tya  					; TO FIND ASSOCIATED FILE CONTROL STUFF,
				asl 					; MULTIPLY (REFNUM-1) BY 32.
				asl
				asl
				asl
				asl
				bcc SVFCBLO 			; BRANCH IF IT'S WITHIN FIRST HALF OF FCB
				inc FCBPTR+1 			; BUMP TO SECOND HAVE (REFNUM>8)

SVFCBLO			sta FCBPTR 				; SAVE LOW ADDRESS OF REFERENCED FCB
				lda C.REFNUM 			; NOW VERIFY THAT FILE IS OPEN.
				ldy #FCBREFN
				cmp (FCBPTR),Y 			; SHOULD BE EQUAL!
				bne ERRNOREF 			; BRANCH IF THEY'RE NOT

FNDFCBUF		ldy #FCBBUFN 			; IT'S A LEGAL FILE, NOW SET UP
				lda (FCBPTR),Y 			; INDIRECT POINTERS TO DATA

GTBUFFRS		ldx #DATPTR 			; (AND INDEX) BUFFER(S) IN ZERO PAGE
				jsr GETBUFADR 			; GET BUFFER ADDRESS UNLESS
				bcs REEFER1 			; BOB HAS BEEN SMOKIN DOPE...
				lda #2 					; (ASSUME AN INDEX BLOCK BUFFER IS ALSO PRESENT)
				adc DATPTR+1
				sta TINDX+1
				lda DATPTR
				sta TINDX
				lda SISDATP
				sta SSTIDXH
				ldy #FCBDEVN
				lda (FCBPTR),Y 			; MAKE SURE DEVICE
				sta D.DEV 				; NUMBER TEMPS MATCH
				sta DEVNUM 				; CURRENT FILE'S DEVICE
				lda #0 					; LOOK AT ALL VOLUMES LOGGED IN

FNDFVOL			tax
				lda VCB+VCBDEV,X 		; GET VOLUMES DEVICE NUMBER
				cmp (FCBPTR),Y 			; HVE WE FOUND A MATCH.
				bne FNDFV1
				ldy #FCBSWAP 			; SWAP BYTES
				lda VCB+VCBSWAP,X 		; MISMATCH
				cmp (FCBPTR),Y 			; MEANS FILE BELONGS
				bne FNDFV.1 			; TO ANOTHER VOLUME
				lda VCB,X 				; IS THIS AN OPEN DEVICE?
				beq FNDFV.1 			; NO, TRY ANOTHER VOLUME
				jsr FVOLFOUND 			; YES, SAVE VCB ADDRESS
				lda VCB+VCBSWAP,X 		; SWAPPED?
				beq REEFER1 			; NO, RETURN CALMLY TO USER
				jsr SWAPIN 				; YES, SWAP ME IN
				bcc REEFER1 			; RETURN WITHOUT ERROR
				lda #XIOERROR 			; USER REFUSED TO MOUNT PROPER VOLUME
				rts
*
FNDFV.1			ldy #FCBDEVN 			; RELOAD Y WITH DEVICE INDEX
FNDFV1			txa
				clc
				adc #VCBSIZE
				bcc FNDFVOL 			; LOOP UNTIL FOUND
				lda #VCBERR 			; OTHERWISE DIE A SYSTEM DEATH!
				jsr SYSDEATH
*
ERRNOREF		lda #0 					; DROP A ZERO INTO THIS FCB TO
				sta (FCBPTR),Y 			; SHOW FREE FCB
*
REEFER			lda #BADREFNUM 			; TELL USER THAT REQUESTED REFNUM
				sec  					; IS ILLEGAL (OUT OF RANGE) FOR THIS CALL.
REEFER1			rts
*
ERRNOTBLK		lda #NOTBLKDEV 			; TELL USER THAT SPECIFIED DEVICE IS NOT A BLOCK DEVICE
				sec
				rts
*
SVCBADR			.EQ *

FVOLFOUND		stx VCBPTR
				lda #VCB/256
				sta VCBPTR+1
				clc  					; INDICATE LEGAL REFNUM
				rts

* NAME : GETDNUM
* FUNCTION: GET DEVICE NUMBER
* INPUT : DVNAMP SETUP
* OUTPUT : DEVNUM IN 'SCRTCH'
* : 'BPL' IF NOT BLOCK DEV
* : 'BCS' IF NO DEVICE
* VOLATILE: ALL REGS
*
GETDNUM			lda #SCRTCH+1 			; SET UP POINTER TO SCRATCH AREA
				sta DVDNUM 				; TO RECIEVE DEVICE NUMBER.
				lda #SCRHIGH
				sta DVDNUM+1
				lda #0 					; PLACE A ZERO IN BANK BYTE SINCE
				sta SISTER+DVDNUM+1 	; IT'S NOT IN A BANK.
				sta VCBPTR+1
				lda #4 					; THE 'GET.DNUM' COMMAND.
				sta DHPCMD
				jsr RPEATIO0 			; CALL BOB FOR THE INFO.
				rts  					; RETURN WITH DEVMGR CC'S
*
* NAME : SRCHDEV
* FUNCTION: SEARCH FOR A VOLUME
*
SRCHDEV			jsr GETDNUM 			; GET DEVNUM
				bcs VOLERR1 			; BRANCH IF ANY ERROR OTHER THAN NOTBLOCKDEV
				bpl ERRNOTBLK 			; BRANCH IF NOT A BLOCK DEVICE
				lda #0 					; NOW SEARCH FOR A VOL WITH THE
				sta NFOPEN 				; INIT TEMP VCB POINTER

VOLOOK			tax  					; SAME DEVNUM AS SCRTCH
				lda VCB+VCBSTAT,X 		; ANY FILES OPEN?
				bne VLOOK00 			; BRANCH IF SOME FILE OPEN
				stx NFOPEN 				; ELSE SAVE THE VCB ENTRY PTR

VLOOK00			lda VCB+VCBSWAP,X 		; VOLUME SWAPPED OUT?
				bne VNOTEQ 				; YES, CANT BE THE ACTIVE VOL
				lda VCB+VCBDEV,X
				eor SCRTCH+1
				beq VLOOK0 				; BRANCH IF MATCH.

VNOTEQ			lda VCB,X 				; IS THIS A FREE VCB?
				bne VLOOK2 				; BRANCH IF NOT FREE, OTHEWISE TAKE NEXT BRANCH.

VLOOK0			eor VCB,X 				; TEST FOR A VOLUME NAME LENGTH
				beq VLOOK1 				; BRANCH IF VCB FREE
				jsr SVCBADR 			; SAVE CURRENT ADDRESS OF VCB.
				lda VCB+VCBSTAT,X 		; TEST FOR ANY OPEN FILES.
				bpl VLOOK3 				; LOG THE VOLUME IN JUST TO BE SURE
				lda SCRTCH+1 			; SET UP
				sta DEVNUM 				; DEVICE NUMBER ARGUMENT
				txa  					; SAVE PTR TO VCB
				pha  					; ON STACK
				jsr VERFYVOL 			; COMPARES VCBPTR TO DEVNUM CONTENTS
				bcc VNOSWIT
				cmp #VNFERR 			; SEE IF NOTHING IN DRIVE
				beq VLOOK7 				; BRANCH IF NOTHING IN DRIVE
				jsr TSTSOS 				; IS THE VOLUME AN UNRECOGNIZED SOS OR (UCSD OR DOS)?
				bcs KNOTSOS 			; DEFINITELY NOT SOS FORMAT
				ldx #0 					; START VCB SCAN AT BEGINNING
				jsr SNSWIT1 			; FIND A FREE VCB AND LOG IN THE NEW GUY
				bcs VNOSWIT1 			; CAN'T LOG IN NEW GUY--KEEP OLD
				pla
				ldx VCBPTR 				; PASS BACK X AS NEW VCB
				rts
*
NFOPEN			.BS 1 					; TEMP VCB PTR FOR VCB W/ NO FILES OPEN
*
VNOSWIT			clc 					; RETURN IT TO USER
				pla 					; REMEMBER OLD VCB PTR
				tax 					; AND PASS BACK TO USER
				rts 					; RETURN TO CALLER X=POINTER TO VCB.
*
VOLERR1			sec  					; RETURN SOME VOLUME ERROR
				rts

VNOSWIT1		cmp #DUPVOL
				bne VLOOK7 				; REPORT OTHER ERROR FROM LOGGING IN NEW VOL AS VNF
				tax
				pla  					; MAKE STACK CORRECT
				txa  					; RESTORE ERROR CODE
				sec
				rts  					; IF DUPLICATE VOLUME ERROR, RETURN FACT TO USER

KNOTSOS			pla 					; MAKE STACK CORRECT
				lda #NOTSOS 			; FOR THE PASCAL FOLK
				rts  					; NOTSOS MEANS UCSD OR DOS OR BAD SOS VOLUME
*
VLOOK7			pla  					; THROW AWAY OLD VCB PTR
				jmp NOVOLM				; AND REPORT VOLUME NOT FOUND
*
VLOOK1			jsr SVCBADR 			; SAVE ADDRESS OF FREE VCB.

VLOOK2			txa  					; BUMP TO NEXT VOLUME ENTRY.
				clc
				adc #VCBSIZE
				bcc VOLOOK 				; BRANCH IF MORE TO CHECK.
				ldx VCBPTR+1 			; FREE VCB YET FOUND?
				bne VLOOK3 				; BRANCH IF YES
				ldx NFOPEN 				; SAVE POSSIBLE FREE VCB
				jsr SVCBADR 			; AND SAVE PTR PERMANENTLY

VLOOK3			lda VCBPTR+1 			; WAS A FREE VCB FOUND?
				beq NOVOLM 				; BRANCH IF VOLUME CAN'T BE LOGGED IN.
				lda SCRTCH+1 			; GET DEVICE NUMBER
				sta DEVNUM 				; SAVE DEVICE NUMBER.
				lda #1 					; FAKE OUT 'LOKVOL'
				sta SCRTCH 				; TO THINK TO LOOK ONLY ONCE.
				sta TOTDEVS
				lda /VCB
				sta VCBPTR+1
				sta PATHNMH 			; (TO MAKE HARMLESS)
				lda #0
				sta SISTER+PATHNMH
				ldx VCBPTR
				stx PATHNML
				sta VCB,X 				; FORCE CURRENT VOLUME OFF LINE, THEN LOG WHATS THERE.
				jsr FREEVCB 			; GO READ ROOT DIRECTORY.
				bcs RTVOLNAM 			; RETURN ANY ERRORS
				ldx VCBPTR 				; MAKE SURE VOLUME WAS LOGGED IN
				lda VCB,X
				beq NOVOLM 				; RETURN ERROR
				rts  					; ELSE RETURN NORMALLY

NOVOLM			lda #VNFERR 			; TELL USER 'NO VOLUME'
				sec

RTVOLNAM		tax  					; SAVE REAL ERROR WHILE DUPLICATE IS CHECKED
				lda DUPLFLAG
				beq RTV1 				; BRANCH IF NOT DUPLICATE
				ldx #DUPVOL

RTV1			txa  ; RECALL ERROR
				rts
*--------------------------------------
MAN
SAVE /A3OSX.BUILD/SOS.13/sos.s.bfm.p
LOAD /A3OSX.BUILD/SOS.13/sos.s
ASM
