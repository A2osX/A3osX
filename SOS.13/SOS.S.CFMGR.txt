NEW
  AUTO 3,1
*--------------------------------------
*
* CHARACTER FILE MANAGER (VERSION = 1.1O )
* (DATE = 8/04/81)
*
* THIS MODULE TRANSFORMS CHARACTER FILE SYSTEM CALLS INTO
* DEVICE CALLS TO THE APPROPRIATE DEVICE HANDLER. ONLY
* OPEN, NEWLINE, READ, WRITE AND CLOSE CALLS ARE PERMITTED
* ON CHARACTER FILES.
*
*
* DATA DECLARATIONS
*
*
* FILE CALL PARM LOCATIONS ON SOS ZPAGE
*
F.TPARMX		.EQ $A0
REQCODE			.EQ F.TPARMX
O.PATH			.EQ F.TPARMX+1 			; OPEN'S PATHNAME LOC
O.REFNUM		.EQ F.TPARMX+3 			; OPEN'S REFNUM LOC
REFNUM			.EQ F.TPARMX+1 			; REFNUM'S LOC IN OTHER CALLS
NL.ISNL			.EQ F.TPARMX+2 			; NEWLINE'S ISNEWLINE LOC
NL.NLCHR		.EQ F.TPARMX+3 			; NEWLINE'S NEWLINECHAR LOC
RW.BUF			.EQ F.TPARMX+2 			; READ/WRITE'S BUF LOC
RW.BYTES		.EQ F.TPARMX+4 			; READ/WRITE'S BYTES LOC
RD.BYTESRD		.EQ F.TPARMX+6 			; READ'S BYTESREAD LOC
*
* FILE REQUEST CODE VALUES
*
OPEN			.EQ 8
NEWLINE			.EQ 9
READ			.EQ $A
WRITE			.EQ $B
CLOSE			.EQ $C
PAGE
* DEVICE CALL PARM LOCATIONS ON SOS ZPAGE
*
D.TPARMX		.EQ $C0
D.SCNUM			.EQ D.TPARMX 			; DEVICE SYS CALL # LOC
GDN.DNAME		.EQ D.TPARMX+1 			; GETDEVNUM DNAME LOC
GDN.DNUM		.EQ D.TPARMX+3 			; GETDEVNUM DNUM LOC
D.DNUM			.EQ D.TPARMX+1 			; OPN/CLOSE/RD/WR/CTRL'S DNUM LOC
DRW.BUF			.EQ D.TPARMX+2			; RD/WR'S BUF LOC
DRW.BYTES		.EQ D.TPARMX+4 			; RD/WR'S BYTES LOC
DRD.BYTESRD		.EQ D.TPARMX+8 			; RD/WR'S BYTESREAD LOC
DC.CCODE		.EQ D.TPARMX+2 			; DCTRL'S CTRLCODE LOC
DC.CLIST		.EQ D.TPARMX+3 			; DCTRL'S CTRLLIST LOC
*
* DEVICE REQUEST CODE VALUES
*
DREAD			.EQ $0
DWRITE			.EQ $1
DCTRL			.EQ $3
GETDEVNUM		.EQ $4
DOPEN			.EQ $6
DCLOSE			.EQ $7
*
CTRL.LIST		.BS 2 					; CONTAINER FOR NEWLINE DCTRL CALL
NEWLINECC		.EQ 2 					; NEWLINE CTRL CODE
*
* GETDNUM VARS
*
DNUM.TEMP		.BS 1
*
* CLOSEALL VARS
*
DCLOSE.ERR		.EQ F.TPARMX+$F
DCLOSE.TBL		.EQ $200
*
* CHARACTER FILE CONTROL BLOCK TABLE
* (ENTRY 0 IS NOT USED)
*
CFCB.MAX		.EQ 17
CFCB.DEV		.BS CFCB.MAX
CFCB.LVL		.BS CFCB.MAX
*
* CHARACTER FILE MANAGER - MAIN ENTRY POINT
*
* SWITCH, BASED ON REQUEST CODE
*
CFMGR			lda REQCODE
				cmp #OPEN
				beq CFOPEN 				; "OPEN"
				cmp #NEWLINE
				beq CFNEWLINE 			; "NEWLINE"
				cmp #READ
				beq CFREAD 				; "READ"
				cmp #WRITE
				bne CFM010
				jmp CFWRITE 			; "WRITE"
CFM010			cmp #CLOSE
				jmp	CFCLOSE 			; "CLOSE"
				bne	CFM020
CFM020			lda #BADSCNUM
				jsr	SYSERR 				; ERR EXIT

* OPEN(IN.PATHNAME; OUT.REFNUM; IN.OPENLIST,LENGTH) SYSTEM CALL

CFOPEN			.EQ * 					; BUILD "D.OPEN" CALL
				jsr GETDNUM 			; MAP PATH TO DEV#
				bcs CFOP.ERR1 			; ERR - FILE NOT FOUND
				sta D.DNUM
*
				jsr REQ.CFCB 			; BUILD NEW CFCB ENTRY
				bcs CFOP.ERR1 			; ERR - CFCB FULL
				ldx #0
				sta (O.REFNUM,X) 		; RETURN REFNUM TO CALLER
				cpy #1
				bne CFOP.EXIT 			; DEVICE ALREADY OPEN
*
				lda #DOPEN
				sta D.SCNUM
				jsr DMGR 				; DOPEN CALL
				bcs CFOP.ERR

CFOP.EXIT		rts  					; NORMAL EXIT
*
CFOP.ERR		lda SERR				;KLUDGE - 1.0 DRIVERS DON'T SUPPORT CARRY ERR PROTOCOL
				beq CFOP.EXIT 			;NO ERROR
				ldx #0 					; RELEASE CFCB ENTRY
				lda (O.REFNUM,X)
				jsr REL.CFCB

CFOP.ERR1		rts  					; ERR EXIT

* NEWLINE(IN.REFNUM,IS .NEWLINE,NEWLINE.CHAR) SYSTEM CALL


CFNEWLINE		.EQ * 					; BUILD "D.CONTROL" CALL
				lda #DCTRL
				sta D.SCNUM
				lda REFNUM
				jsr GET.CFCB 			; MAP REFNUM TO DEV #
				bcs CFNL.ERR 			; ERR - BAD REFNUM
*
				sta D.DNUM
				lda #NEWLINECC
				sta DC.CCODE
*
				lda #CTRL.LIST
				sta DC.CLIST
				lda /CTRL.LIST
				sta DC.CLIST+1
				lda #0
				sta SXPAGE+DC.CLIST+1
*
				lda NL.ISNL
				sta CTRL.LIST
				lda NL.NLCHR
				sta CTRL.LIST+1
*
				jsr DMGR 				; DCONTROL CALL
				rts 					; NORMAL EXIT
*
CFNL.ERR		rts 					; ERR EXIT

* READ(IN.REFNUM,BUF,BYTES,BYTESREAD) SYSTEM CALL

CFREAD			.EQ * 					; BUILD "D.READ" CALL
				lda #DREAD
				sta D.SCNUM
				lda REFNUM
				jsr GET.CFCB 			; MAP REFNUM TO DEV #
				bcs CFRD.ERR 			; ERR - BAD REFNUM
*
				sta D.DNUM
				ldx	#3

CFRD010			lda RW.BUF,X
				sta	DRW.BUF,X
				dex
				bpl	CFRD010
*
				lda	RD.BYTESRD
				sta	DRD.BYTESRD
				lda	RD.BYTESRD+1
				sta	DRD.BYTESRD+1
*
				lda	SXPAGE+RW.BUF+1
				sta	SXPAGE+DRW.BUF+1
				lda	SXPAGE+RW.BYTES+1
				sta	SXPAGE+DRW.BYTES+1
				lda	SXPAGE+RD.BYTESRD+1
				sta	SXPAGE+DRD.BYTESRD+1
*
				jsr	DMGR 				; DREAD CALL
				rts						; NORMAL EXIT
*
CFRD.ERR		rts 					; ERR EXIT

* WRITE(IN.REFNUM,BUF,BYTES) SYSTEM CALL

CFWRITE			.EQ * 					; BUILD "D.WRITE" CALL
				lda #DWRITE
				sta D.SCNUM
				lda REFNUM
				jsr GET.CFCB 			; MAP REFNUM TO DEV #
				bcs CFWR.ERR 			; ERR - BAD REFNUM
				sta D.DNUM
				ldx #3

CFWR010			lda RW.BUF,X
				sta DRW.BUF,X
				dex
				bpl CFWR010
				lda SXPAGE+RW.BUF+1
				sta SXPAGE+DRW.BUF+1
				lda SXPAGE+RW.BYTES+1
				sta SXPAGE+DRW.BYTES+1
*
				jsr DMGR 				; DWRITE CALL
				rts  					; NORMAL EXIT
*
CFWR.ERR		rts  					; ERR EXIT

* CLOSE(IN.REFNUM) SYSTEM CALL

CFCLOSE			.EQ * 					; BUILD "D.CLOSE" CALL
				lda #DCLOSE
				sta D.SCNUM
				lda REFNUM
				beq CLOSEALL
*
				jsr REL.CFCB 			; RELEASE CFCB ENTRY
				bcs CFCL010
				sta D.DNUM
				tya
				bne CFCL010
				jsr DMGR 				; DCLOSE CALL
CFCL010			rts  					; NORMAL EXIT
*
* CLOSE ALL CHARACTER FILES W/LEVELS >= TO CURRENT SYSTEM FILE LEVEL.
*
CLOSEALL		lda #FALSE 				; SET ENTRIES IN DEV CLOSE TBL TO FALSE
				ldx MAX.DNUM

CFCL020			sta DCLOSE.TBL,X
				dex
				bpl CFCL020

				ldx #CFCB.MAX-1 		; CLOSE ALL DEVICES >= TO CURRENT LEVEL
CFCL030			lda CFCB.DEV,X 			; AND MARK TRUE IN DEV CLOSE TBL
				tay
				bmi CFCL050
				lda CFCB.LVL,X
				cmp LEVEL
				bcc CFCL050
				lda #TRUE
				sta DCLOSE.TBL,Y
				sec
				ror CFCB.DEV,X
CFCL050			dex
				bne CFCL030

				ldx #CFCB.MAX-1 		; DON'T CLOSE DEVICES < CURRENT LEVEL

CFCL060			lda CFCB.DEV,X
				tay
				bmi CFCL070
				lda #FALSE
				sta DCLOSE.TBL,Y

CFCL070			dex
				bne CFCL060
*
				lda #0
				sta DCLOSE.ERR
				ldx MAX.DNUM 			; ISSUE D'CLOSE CALLS TO ALL DEVICES MARKED AS TRUE

CFCL080			lda DCLOSE.TBL,X 		; IN DEV CLOSE TABLE
				bpl CFCL090
				txa
				pha
				stx D.DNUM
				jsr DMGR
				pla
				tax
				lda SERR
				beq CFCL090 			; IF ERROR,
				sta DCLOSE.ERR 			; THEN SAVE IT

CFCL090			dex
				bne CFCL080
*
				lda DCLOSE.ERR 			; IF $0 THEN NO ERRORS FROM D.CLOSE CALLS
				bne CFCL.ERR
				rts  					; NORMAL EXIT

CFCL.ERR		jsr SYSERR 				; RETURN LAST D.CLOSE ERROR REPORTED
*
* GET DEVICE NUMBER
*
* INPUT: CPATH
* OUTPUT: DEVICE NUMBER (A)
* ERROR: CARRY SET ("FILE NOT FOUND")
*
* GETDNUM FIRST CALLS THE DMGR (GETDEVNUM) MAP THE PATHNAME
* TO A DEVICE #. GETDNUM THEN ENSURES THAT THE PATHNAME
* IS NOT A BLOCK DEVICE BY CHECKING THE DBLKLST TABLE.
*
GETDNUM			lda #GETDEVNUM
				sta D.SCNUM
*
				lda O.PATH
				sta GDN.DNAME
				lda O.PATH+1
				sta GDN.DNAME+1
*
				lda #DNUM.TEMP
				sta GDN.DNUM
				lda /DNUM.TEMP
				sta GDN.DNUM+1
*
				lda SXPAGE+O.PATH+1
				sta SXPAGE+GDN.DNAME+1
				lda #0
				sta SXPAGE+GDN.DNUM+1
*
				jsr DMGR
				bcs GETD.ERR 			; D.NAME NOT FOUND
				bmi GETD.ERR 			; BLOCK DEVICE FOUND
				lda DNUM.TEMP
				rts
*
GETD.ERR		lda #FNFERR
				jsr	SYSERR
*
* REQUEST FCB ENTRY
*
* INPUT: DNUM (A)
* OUTPUT: REFNUM (A), OPENCT (Y)
* ERROR: CARRY SET ("CFCB FULL")
*
* REQ.CFCB FIRST SEARCHES THE CFCB TABLE USING THE DEV#
* AS A KEY. IF FOUND THE OPENCT IS INCREMENTED, OTHERWISE,
* REQ.CFCB FINDS A FREE ENTRY AND STORES THE DEV# AND LEVEL #.
*
REQ.CFCB		ldx				 #CFCB.MAX-1
				tay

REQ010			lda CFCB.DEV,X
				bmi REQ020
				dex
				bne REQ010
				lda #CFCBFULL
				jsr SYSERR

REQ020			tya
				sta CFCB.DEV,X
				lda LEVEL
				sta CFCB.LVL,X
				txa
				pha
				tya
				jsr OPENCOUNT
				pla
				ora #$80
				clc
				rts  					; NORMAL EXIT
*
* RELEASE FCB ENTRY
*
* INPUT: REFNUM (A)
* OUTPUT: DNUM (A), OPENCT (Y)
* ERROR: CARRY SET ("INVALID REFNUM")
*
* USES REFNUM AS AN CFCB TABLE INDEX TO RELEASE A CFCB ENTRY.
*
REL.CFCB		and #$7F
				cmp #CFCB.MAX
				bcs REL.ERR
				tax
				lda CFCB.DEV,X
				bmi REL.ERR
				sec 					; MARK ENTRY FREE
				ror CFCB.DEV,X
				jsr OPENCOUNT
				clc
				rts 					; NORMAL EXIT
*
REL.ERR			lda #BADREFNUM
				jsr	SYSERR
*
* OPENCOUNT SUBROUTINE
*
* INPUT: DEVNUM (A)
* OUTPUT: DEVNUM (A), OPENCTR (Y)
*
* OPENCTR:=COUNT OF ALL CFCB ENTRIES W/CFCB.DEV=DEVNUM
*
OPENCOUNT		ldy #0
				ldx #CFCB.MAX-1

OPNCT010		cmp CFCB.DEV,X
				bne OPNCT020
				iny

OPNCT020		dex
				bne OPNCT010
				rts
*
* GET FCB ENTRY
*
* INPUT: REFNUM (A)
* OUTPUT: DNUM (A)
* ERROR: CARRY SET ("INVALID REFNUM")
*
* USES REFNUM AS AN INDEX TO RETURN THE CORRESPONDING DEVICE #.
* IF THE ENTRY INDICATED BY REFNUM IS A FREE ENTRY, THEN AN
* ERROR, "INVALID REF NUM" IS RETURNED.
*
GET.CFCB		and #$7F
				cmp #CFCB.MAX
				bcs GET.ERR
				tax
				lda CFCB.DEV,X
				bmi GET.ERR
				clc
				rts 					; NORMAL EXIT
*
GET.ERR			lda #BADREFNUM
				jsr SYSERR 				; ERR EXIT
*--------------------------------------
MAN
SAVE /A3OSX.BUILD/SOS.13/sos.s.cfmgr
LOAD /A3OSX.BUILD/SOS.13/sos.s
ASM
