NEW
  AUTO 3,1
*--------------------------------------
*************************************************************************  
* APPLE /// SOS 1.3 SOURCE CODE FILE: CFMGR.SRC  
*************************************************************************  
* ASSEMBLER: APPLE ][ 6502 ASSEMBLER from APPLE COMPUTER TOOLKIT  
				 
SBTL			 "SOS 1.1 CHARACTER FILE MANAGER"  
REL				  
INCLUDE			 SOSORG,6,1,254  
ORG				 ORGCFM  
ZZORG			 EQU *  
MSB				 OFF  
REP				 60  
* COPYRIGHT (C) APPLE COMPUTER INC. 1980  
* ALL RIGHTS RESERVED  
REP				 60  
*  
* CHARACTER FILE MANAGER (VERSION = 1.1O )  
* (DATE = 8/04/81)  
*  
* THIS MODULE TRANSFORMS CHARACTER FILE SYSTEM CALLS INTO  
* DEVICE CALLS TO THE APPROPRIATE DEVICE HANDLER. ONLY  
* OPEN, NEWLINE, READ, WRITE AND CLOSE CALLS ARE PERMITTED  
* ON CHARACTER FILES.  
*  
REP				 60  
*  
ENTRY			 CFMGR  
*  
ENTRY			 CFCB.MAX  
ENTRY			 CFCB.DEV  
*  
EXTRN			 DMGR  
EXTRN			 LEVEL  
EXTRN			 MAX.DNUM  
EXTRN			 SXPAGE  
*  
EXTRN			 SYSERR  
EXTRN			 SERR  
EXTRN			 BADSCNUM  
EXTRN			 CFCBFULL  
EXTRN			 BADREFNUM  
EXTRN			 FNFERR  
PAGE			  
REP				 60  
*  
* DATA DECLARATIONS  
*  
REP				 60  
*  
* FILE CALL PARM LOCATIONS ON SOS ZPAGE  
*  
F.TPARMX		 EQU $A0  
REQCODE			 EQU F.TPARMX  
O.PATH			 EQU F.TPARMX+1 ; OPEN'S PATHNAME LOC  
O.REFNUM		 EQU F.TPARMX+3 ; OPEN'S REFNUM LOC  
REFNUM			 EQU F.TPARMX+1 ; REFNUM'S LOC IN OTHER CALLS  
NL.ISNL			 EQU F.TPARMX+2 ; NEWLINE'S ISNEWLINE LOC  
NL.NLCHR		 EQU F.TPARMX+3 ; NEWLINE'S NEWLINECHAR LOC  
RW.BUF			 EQU F.TPARMX+2 ; READ/WRITE'S BUF LOC  
RW.BYTES		 EQU F.TPARMX+4 ; READ/WRITE'S BYTES LOC  
RD.BYTESRD		 EQU F.TPARMX+6 ; READ'S BYTESREAD LOC  
*  
* FILE REQUEST CODE VALUES  
*  
OPEN			 EQU 8  
NEWLINE			 EQU 9  
READ			 EQU $A  
WRITE			 EQU $B  
CLOSE			 EQU $C  
PAGE			  
* DEVICE CALL PARM LOCATIONS ON SOS ZPAGE  
*  
D.TPARMX		 EQU $C0  
D.SCNUM			 EQU D.TPARMX ; DEVICE SYS CALL # LOC  
GDN.DNAME		 EQU D.TPARMX+1 ; GETDEVNUM DNAME LOC  
GDN.DNUM		 EQU D.TPARMX+3 ; GETDEVNUM DNUM LOC  
D.DNUM			 EQU D.TPARMX+1 ; OPN/CLOSE/RD/WR/CTRL'S DNUM LOC  
DRW.BUF			 EQU D.TPARMX+2 ; RD/WR'S BUF LOC  
DRW.BYTES		 EQU D.TPARMX+4 ; RD/WR'S BYTES LOC  
DRD.BYTESRD		 EQU D.TPARMX+8 ; RD/WR'S BYTESREAD LOC  
DC.CCODE		 EQU D.TPARMX+2 ; DCTRL'S CTRLCODE LOC  
DC.CLIST		 EQU D.TPARMX+3 ; DCTRL'S CTRLLIST LOC  
*     
* DEVICE REQUEST CODE VALUES  
*  
DREAD			 EQU $0   
DWRITE			 EQU $1   
DCTRL			 EQU $3   
GETDEVNUM		 EQU $4   
DOPEN			 EQU $6   
DCLOSE			 EQU $7   
*     
CTRL.LIST		 DS 2 ; CONTAINER FOR NEWLINE DCTRL CALL  
NEWLINECC		 EQU 2 ; NEWLINE CTRL CODE  
*     
* GETDNUM VARS     
*     
DNUM.TEMP		 DS 1   
*     
* CLOSEALL VARS     
*     
DCLOSE.ERR		 EQU F.TPARMX+$F   
DCLOSE.TBL		 EQU $200   
TRUE			 EQU $80   
FALSE			 EQU $0   
*     
*     
				REP 60   
*  
* CHARACTER FILE CONTROL BLOCK TABLE  
* (ENTRY 0 IS NOT USED)  
*  
				REP 60  
CFCB.MAX		 EQU 17  
CFCB.DEV		 DS CFCB.MAX  
CFCB.LVL		 DS CFCB.MAX  
				PAGE   
				REP 60  
*    
* CHARACTER FILE MANAGER - MAIN ENTRY POINT   
*    
REP				 60   
CFMGR			 EQU *   
*    
* SWITCH, BASED ON REQUEST CODE   
*    
LDA				 REQCODE   
CMP				 #OPEN   
BEQ				 CFOPEN ; "OPEN"  
CMP				 #NEWLINE   
BEQ				 CFNEWLINE ; "NEWLINE"  
CMP				 #READ   
BEQ				 CFREAD ; "READ"  
CMP				 #WRITE   
BNE				 CFM010   
JMP				 CFWRITE ; "WRITE"  
CFM010			 CMP #CLOSE   
BNE				 CFM020   
JMP				 CFCLOSE ; "CLOSE"  
CFM020			 LDA #BADSCNUM   
JSR				 SYSERR ; ERR EXIT  
PAGE			    
REP				 60   
* OPEN(IN.PATHNAME; OUT.REFNUM; IN.OPENLIST,LENGTH) SYSTEM CALL  
				REP 60   
CFOPEN			 EQU * ; BUILD "D.OPEN" CALL  
				JSR GETDNUM ; MAP PATH TO DEV#  
				BCS CFOP.ERR1 ; ERR - FILE NOT FOUND  
				STA D.DNUM   
*     
				JSR REQ.CFCB ; BUILD NEW CFCB ENTRY  
				BCS CFOP.ERR1 ; ERR - CFCB FULL  
				LDX #0   
				STA (O.REFNUM,X) ; RETURN REFNUM TO CALLER  
				CPY #1   
				BNE CFOP.EXIT ; DEVICE ALREADY OPEN  
*     
				LDA #DOPEN   
				STA D.SCNUM   
				JSR DMGR ; DOPEN CALL  
				BCS CFOP.ERR   
CFOP.EXIT		 RTS  ; NORMAL EXIT  
*     
CFOP.ERR		 LDA SERR ;KLUDGE - 1.0 DRIVERS DON'T SUPPORT CARRY ERR PROTOCOL  
				BEQ CFOP.EXIT ;NO ERROR  
				LDX #0 ; RELEASE CFCB ENTRY  
				LDA (O.REFNUM,X)   
				JSR REL.CFCB   
CFOP.ERR1		 RTS  ; ERR EXIT  
				PAGE    
				REP 60   
* NEWLINE(IN.REFNUM,IS .NEWLINE,NEWLINE.CHAR) SYSTEM CALL  
REP				 60  
CFNEWLINE		 EQU * ; BUILD "D.CONTROL" CALL  
LDA				 #DCTRL  
STA				 D.SCNUM  
LDA				 REFNUM  
JSR				 GET.CFCB ; MAP REFNUM TO DEV #  
BCS				 CFNL.ERR ; ERR - BAD REFNUM  
*   
STA				 D.DNUM  
LDA				 #NEWLINECC  
STA				 DC.CCODE  
*   
LDA				 #>CTRL.LIST  
STA				 DC.CLIST  
LDA				 #<CTRL.LIST  
STA				 DC.CLIST+1  
LDA				 #0  
STA				 SXPAGE+DC.CLIST+1  
*   
LDA				 NL.ISNL  
STA				 CTRL.LIST  
LDA				 NL.NLCHR  
STA				 CTRL.LIST+1  
*   
JSR				 DMGR ; DCONTROL CALL  
RTS				 ; NORMAL EXIT  
*   
CFNL.ERR		 RTS ; ERR EXIT  
PAGE			   
REP				 60  
* READ(IN.REFNUM,BUF,BYTES,BYTESREAD) SYSTEM CALL  
REP				 60  
CFREAD			 EQU * ; BUILD "D.READ" CALL  
LDA				 #DREAD  
STA				 D.SCNUM  
LDA				 REFNUM  
JSR				 GET.CFCB ; MAP REFNUM TO DEV #  
BCS				 CFRD.ERR ; ERR - BAD REFNUM  
*  
STA				 D.DNUM  
LDX				 #3  
CFRD010			 LDA RW.BUF,X  
STA				 DRW.BUF,X  
DEX				  
BPL				 CFRD010  
*  
LDA				 RD.BYTESRD  
STA				 DRD.BYTESRD  
LDA				 RD.BYTESRD+1  
STA				 DRD.BYTESRD+1  
*  
LDA				 SXPAGE+RW.BUF+1  
STA				 SXPAGE+DRW.BUF+1  
LDA				 SXPAGE+RW.BYTES+1  
STA				 SXPAGE+DRW.BYTES+1  
LDA				 SXPAGE+RD.BYTESRD+1  
STA				 SXPAGE+DRD.BYTESRD+1  
*  
JSR				 DMGR ; DREAD CALL  
RTS				 ; NORMAL EXIT  
*  
CFRD.ERR		 RTS ; ERR EXIT  
PAGE			  
REP				 60  
* WRITE(IN.REFNUM,BUF,BYTES) SYSTEM CALL  
REP				 60  
CFWRITE			 EQU * ; BUILD "D.WRITE" CALL  
				LDA #DWRITE   
				STA D.SCNUM   
				LDA REFNUM   
				JSR GET.CFCB ; MAP REFNUM TO DEV #  
				BCS CFWR.ERR ; ERR - BAD REFNUM  
				STA D.DNUM   
				LDX #3   
CFWR010			 LDA RW.BUF,X   
				STA DRW.BUF,X   
				DEX    
				BPL CFWR010   
				LDA SXPAGE+RW.BUF+1   
				STA SXPAGE+DRW.BUF+1   
				LDA SXPAGE+RW.BYTES+1   
				STA SXPAGE+DRW.BYTES+1   
*     
				JSR DMGR ; DWRITE CALL  
				RTS  ; NORMAL EXIT  
*     
CFWR.ERR		 RTS  ; ERR EXIT  
				PAGE    
				REP 60   
* CLOSE(IN.REFNUM) SYSTEM CALL  
				REP 60   
CFCLOSE			 EQU * ; BUILD "D.CLOSE" CALL  
				LDA #DCLOSE   
				STA D.SCNUM   
				LDA REFNUM   
				BEQ CLOSEALL   
*     
				JSR REL.CFCB ; RELEASE CFCB ENTRY  
				BCS CFCL010   
				STA D.DNUM   
				TYA    
				BNE CFCL010   
				JSR DMGR ; DCLOSE CALL  
CFCL010			 RTS  ; NORMAL EXIT  
*     
				PAGE    
				REP 60   
*  
* CLOSE ALL CHARACTER FILES W/LEVELS >= TO CURRENT SYSTEM FILE LEVEL.  
*  
				REP 60   
*     
CLOSEALL		 EQU *   
				LDA #FALSE ; SET ENTRIES IN DEV CLOSE TBL TO FALSE  
				LDX MAX.DNUM   
CFCL020			 STA DCLOSE.TBL,X   
				DEX    
				BPL CFCL020   
*     
				LDX #CFCB.MAX-1 ; CLOSE ALL DEVICES >= TO CURRENT LEVEL  
CFCL030			 LDA CFCB.DEV,X ; AND MARK TRUE IN DEV CLOSE TBL  
				TAY    
				BMI CFCL050   
				LDA CFCB.LVL,X   
				CMP LEVEL   
				BCC CFCL050   
				LDA #TRUE   
				STA DCLOSE.TBL,Y   
				SEC    
				ROR CFCB.DEV,X   
CFCL050			 DEX    
				BNE CFCL030   
*     
				LDX #CFCB.MAX-1 ; DON'T CLOSE DEVICES < CURRENT LEVEL  
CFCL060			 LDA CFCB.DEV,X   
				TAY    
				BMI CFCL070   
				LDA #FALSE   
				STA DCLOSE.TBL,Y   
CFCL070			 DEX    
				BNE CFCL060   
*     
				LDA #0   
				STA DCLOSE.ERR   
				LDX MAX.DNUM ; ISSUE D'CLOSE CALLS TO ALL DEVICES MARKED AS TRUE  
CFCL080			 LDA DCLOSE.TBL,X ; IN DEV CLOSE TABLE  
				BPL CFCL090   
				TXA    
				PHA    
				STX D.DNUM   
				JSR DMGR   
				PLA    
				TAX    
				LDA SERR   
				BEQ CFCL090 ; IF ERROR,  
				STA DCLOSE.ERR ; THEN SAVE IT  
CFCL090			 DEX    
				BNE CFCL080   
*     
				LDA DCLOSE.ERR ; IF $0 THEN NO ERRORS FROM D.CLOSE CALLS  
				BNE CFCL.ERR   
				RTS  ; NORMAL EXIT  
CFCL.ERR		 JSR SYSERR ; RETURN LAST D.CLOSE ERROR REPORTED  
				PAGE    
				REP 60   
*  
* GET DEVICE NUMBER  
*  
* INPUT: CPATH  
* OUTPUT: DEVICE NUMBER (A)  
* ERROR: CARRY SET ("FILE NOT FOUND")  
*  
* GETDNUM FIRST CALLS THE DMGR (GETDEVNUM) MAP THE PATHNAME  
* TO A DEVICE #. GETDNUM THEN ENSURES THAT THE PATHNAME  
* IS NOT A BLOCK DEVICE BY CHECKING THE DBLKLST TABLE.  
*  
REP				 60  
*  
GETDNUM			 EQU *  
LDA				 #GETDEVNUM  
STA				 D.SCNUM  
*  
LDA				 O.PATH  
STA				 GDN.DNAME  
LDA				 O.PATH+1  
STA				 GDN.DNAME+1  
*  
LDA				 #>DNUM.TEMP  
STA				 GDN.DNUM  
LDA				 #<DNUM.TEMP  
STA				 GDN.DNUM+1  
*  
LDA				 SXPAGE+O.PATH+1  
STA				 SXPAGE+GDN.DNAME+1  
LDA				 #0  
STA				 SXPAGE+GDN.DNUM+1  
*  
JSR				 DMGR  
BCS				 GETD.ERR ; D.NAME NOT FOUND  
BMI				 GETD.ERR ; BLOCK DEVICE FOUND  
LDA				 DNUM.TEMP  
RTS				  
*  
GETD.ERR		 LDA #FNFERR  
JSR				 SYSERR  
PAGE			  
REP				 60  
* REQUEST FCB ENTRY  
*  
* INPUT: DNUM (A)  
* OUTPUT: REFNUM (A), OPENCT (Y)  
* ERROR: CARRY SET ("CFCB FULL")  
*  
* REQ.CFCB FIRST SEARCHES THE CFCB TABLE USING THE DEV#  
* AS A KEY. IF FOUND THE OPENCT IS INCREMENTED, OTHERWISE,  
* REQ.CFCB FINDS A FREE ENTRY AND STORES THE DEV# AND LEVEL #.  
*  
REP				 60  
*  
REQ.CFCB		 EQU *  
LDX				 #CFCB.MAX-1  
TAY				  
REQ010			 LDA CFCB.DEV,X  
BMI				 REQ020  
DEX				  
BNE				 REQ010  
LDA				 #CFCBFULL  
JSR				 SYSERR  
REQ020			 TYA    
				STA CFCB.DEV,X   
				LDA LEVEL   
				STA CFCB.LVL,X   
				TXA    
				PHA    
				TYA    
				JSR OPENCOUNT   
				PLA    
				ORA #$80   
				CLC    
				RTS  ; NORMAL EXIT  
				PAGE    
				REP 60   
*   
* RELEASE FCB ENTRY   
*   
* INPUT: REFNUM (A)   
* OUTPUT: DNUM (A), OPENCT (Y)   
* ERROR: CARRY SET ("INVALID REFNUM")   
*   
* USES REFNUM AS AN CFCB TABLE INDEX TO RELEASE A CFCB ENTRY.  
*   
REP				 60   
REL.CFCB		 EQU *   
AND				 #$7F   
CMP				 #CFCB.MAX   
BCS				 REL.ERR   
TAX				   
LDA				 CFCB.DEV,X   
BMI				 REL.ERR   
SEC				 ; MARK ENTRY FREE  
ROR				 CFCB.DEV,X   
JSR				 OPENCOUNT   
CLC				   
RTS				 ; NORMAL EXIT  
*   
REL.ERR			 LDA #BADREFNUM   
JSR				 SYSERR   
REP				 60   
*  
* OPENCOUNT SUBROUTINE  
*  
* INPUT: DEVNUM (A)  
* OUTPUT: DEVNUM (A), OPENCTR (Y)  
*  
* OPENCTR:=COUNT OF ALL CFCB ENTRIES W/CFCB.DEV=DEVNUM  
*  
REP				 60  
OPENCOUNT		 EQU *  
LDY				 #0  
LDX				 #CFCB.MAX-1  
OPNCT010		 CMP CFCB.DEV,X  
BNE				 OPNCT020  
INY				  
OPNCT020		 DEX  
BNE				 OPNCT010  
RTS				  
PAGE			  
REP				 60  
*  
* GET FCB ENTRY  
*  
* INPUT: REFNUM (A)  
* OUTPUT: DNUM (A)  
* ERROR: CARRY SET ("INVALID REFNUM")  
*  
* USES REFNUM AS AN INDEX TO RETURN THE CORRESPONDING DEVICE #.  
* IF THE ENTRY INDICATED BY REFNUM IS A FREE ENTRY, THEN AN  
* ERROR, "INVALID REF NUM" IS RETURNED.  
*  
REP				 60  
GET.CFCB		 EQU *  
AND				 #$7F  
CMP				 #CFCB.MAX  
BCS				 GET.ERR  
TAX				  
LDA				 CFCB.DEV,X  
BMI				 GET.ERR  
CLC				  
RTS				 ; NORMAL EXIT  
*   
GET.ERR			 LDA #BADREFNUM   
				JSR SYSERR ; ERR EXIT  
*     
				LST ON   
ZZEND			 EQU *   
ZZLEN			 EQU ZZEND-ZZORG   
				IFNE ZZLEN-LENCFM   
				FAIL 2,"SOSORG FILE IS INCORRECT FOR CFMGR"  
				FIN    
				    
*************************************************************************  
* END OF APPLE /// SOS 1.3 SOURCE CODE FILE: CFMGR.SRC  
*************************************************************************  
				 
*--------------------------------------
MAN
SAVE /A3OSX.BUILD/SOS.13/sos.s.cfmgr
LOAD /A3OSX.BUILD/SOS.13/sos.s
ASM
