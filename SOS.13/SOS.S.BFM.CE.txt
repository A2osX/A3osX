NEW
  AUTO 3,1
*--------------------------------------
BFM.CLOSE		lda C.REFNUM 			CLOSE ALL?
				bne	CLOSE1 				NO, JUST ONE OF 'EM
				sta	CFERR 				CLEAR GLOBAL CLOSE ERROR
				jsr	GFCBADR 			SET UP POINTER TO FCB

CLOSALL			lda #0 					BEGIN AT THE BEGINNING.

CLSALL1			sta FCBPTR 				SAVE CURRENT LOW BYTE OF POINTER
				ldy	#FCBLEVL 			FETCH THE LEVEL AT WHICH
				lda	(FCBPTR),Y 			FILE WAS OPENED
				cmp	LEVEL 				TEST AGAINST CURRENT GLOBAL LEVEL
				bcc	NXTCLOS 			DONT CLOSE IF FILES LEVEL IS < GLOBAL LEVEL
				ldy	#FCBREFN 			INDEX TO REFERENCE NUMBER
				lda	(FCBPTR),Y 			IS THIS REFERENCE FILE OPEN?
				beq	NXTCLOS 			NO, TRY NEXT.
				jsr	FLUSH2 				CLEAN IT OUT...
				bcs	CLOSERR 			RETURN FLUSH ERRORS
				jsr	CLOSE2 				UPDATE FCB & VCB
				ldy	C.REFNUM
				beq	NXTCLOS 			NO ERR IF CLOSE ALL
				bcs	CLOSERR

NXTCLOS			lda FCBPTR 				BUMP POINTER TO NEXT FILE CONTROL BLOCK.
				clc
				adc	#$20
				bcc	CLSALL1 			BRANCH IF WITHIN SAME PAGE.
				lda	FCBPTR+1
				inc	FCBPTR+1 			BUMP TO NEXT PAGE.
				cmp	FCBADDRH 			HAVE WE CHECKED BOTH PAGES?
				beq	CLOSALL 			YES, RETURN NO ERROR.
				clc
				lda	CFERR 				ON FINAL CLOSE OF CLOSE ALL REPORT LOGGED ERRORS
				beq	C3 					BRANCH IF NO ERRORS
				sec
C3				rts
*
*
CFERR			.BS 1 ; GLOBAL ERROR FLAG FOR FLUSH AND CLOSE ALL
*
*
CLOSE1			jsr FLUSH1 				FLUSH FILE FIRST (INCLUDING UPDATING BIT MAP)
				bcs CLOSERR
CLOSE2			ldy #FCBBUFN
				lda	(FCBPTR),Y
				jsr	RELBUF
				bcs	CLOSERR
				lda	#0
				ldy	#FCBREFN
				sta	(FCBPTR),Y
				iny						BUMP TO 'FCBDEVN'
				lda	(FCBPTR),Y
				sta	DEVNUM 				GO LOOK FOR ASSOCIATED VCB.
				jsr	DEVVCB
				ldx	VCBPTR 				GET VCBPTR
				dec	VCB+VCBOPNC,X 		INDICATE ONE LESS FILE OPEN.
				bne	CLOSEND 			BRANCH IF THAT WASN'T THE LAST...
				lda	VCB+VCBSTAT,X
				and	#$7F 				STRIP 'FILES OPEN' BIT
				sta	VCB+VCBSTAT,X
CLOSEND			clc
				rts

CLOSERR			jmp GLBERR 				DON'T REPORT CLOSALL ERR NOW
*
FLUSH			lda C.REFNUM 			FLUSH ALL?
				bne	FLUSH1 				NO, JUST ONE OF 'EM
				sta	CFERR 				CLEAR GLOBAL FLUSH ERROR
				jsr	GFCBADR 			SET UP POINTER TO FCB
FLSHALL			lda #0 					BEGIN AT THE BEGINNING.
FLSHAL1			sta FCBPTR 				SAVE CURRENT LOW BYTE OF POINTER
				ldy #FCBREFN 			INDEX TO REFERENCE NUMBER
				lda (FCBPTR),Y 			IS THIS REFERENCE FILE OPEN?
				beq NXFLUSH 			NO, TRY NEXT.
				jsr FLUSH2 				CLEAN IT OUT...
				bcs FLSHERR 			RETURN ANY ERRORS
*
				bcs CLOSERR

NXFLUSH			lda FCBPTR 				BUMP POINTER TO NEXT FILE CONTROL BLOCK.
				clc
				adc #$20
				bcc FLSHAL1 			BRANCH IF WITHIN SAME PAGE.
				lda FCBPTR+1
				inc FCBPTR+1 			BUMP TO NEXT PAGE.
				cmp FCBADDRH 			HAVE WE CHECKED BOTH PAGES?
				beq FLSHALL 			YES, RETURN NO ERROR.

FLUSHEND		clc
				lda CFERR 				ON LAST FLUSH OF A FLUSH(0)
				beq F3 					BRANCH IF NO LOGGED ERRORS
				sec  					REPORT ERROR NOW
F3				rts

FLSHERR			jmp GLBERR 				FLUSH ALL OR ONE?
*
FLUSH2			jsr FNDFCBUF 			MUST SET UP ASSOCIATED VCB AN BUFFER LOCATIONS FIRST.
				bcc FLUSH2A 			BRANCH IF NO ERROR ENCOUNTERED.
				jmp GLBERR 				CHECK FOR CLOSE OR FLUSH ALL
*
FLUSH1			lda #0 					CLEAR
				sta CFERR 				GLOBAL ERROR FOR NORMAL REFNUM FLUSH
				jsr FINDFCB 			SET UP POINTER TO FCB USER REFERENCES
				bcs FLSHERR 			RETURN ANY ERRORS

FLUSH2A			ldy #FCBATTR 			TEST TO SEE IF FILE IS
				lda (FCBPTR),Y 			MODIFIED. FIRST TEST WRITE ENABLED.
				and #WRITEN
				beq FLUSHEND 			BRANCH IF 'READ ONLY'
				ldy #FCBDIRTY 			SEE IF EOF HAS BEEN MODIFIED
				lda (FCBPTR),Y
				bmi FLUSH2B 			BRANCH IF IT HAS
				ldy #FCBSTAT 			NOW TEST FOR DATA MODIFIED.
				lda (FCBPTR),Y 			(IN OTHER WORDS: WAS FILE ACTUALLY
				and #USEMOD+EOFMOD+DATMOD WRITTEN TO WHILE IT'S BEEN OPEN?)
				beq FLUSHEND 			BRANCH IF FILE NOT MODIFIED.

FLUSH2B			jsr TWRPROT1 			DISK SWITCH CHECKING
				lda DSWGLOB
				beq FLUSH2C 			BRANCH IF NO SWITCH
				lda #XDISKSW
				sec
				rts 					FORCES A VERIFIED RETRY

FLUSH2C			ldy #FCBSTAT 			NOW TEST FOR DATA MODIFIED.
				lda (FCBPTR),Y
				and #DATMOD 			DOES CURRENT DATA BUFFER NEED TO BE
				beq FLUSH3 				WRITTEN? BRANCH IF NOT.
				jsr WFCBDAT 			IF SO, GO WRITE IT STUPID!
				bcs FLSHERR

FLUSH3			ldy #FCBSTAT 			CHECK TO SEE IF THE INDEX BLOCK (TREE FILES ONLY)
				lda (FCBPTR),Y 			NEEDS TO BE WRITTEN.
				and #IDXMOD
				beq FLUSH4 				BRANCH IF NOT...
				jsr WFCBIDX
				bcs FLSHERR 			RETURN ANY ERRORS.

*
FLUSH4			ldy #FCBENTN 			NOW PREPARE TO UPDATE DIRECTORY
OWNRMOV			lda (FCBPTR),Y 			NOTE: THIS CODE DEPENDS ON THE
				sta D.DEV-FCBDEVN,Y 	DEFINED ORDER OF THE FILE CONTROL
				dey 					BLOCK AND THE TEMPORARY DIRECTORY AREA IN 'WORKSPC'! *************
				cpy #FCBDEVN-1
				bne OWNRMOV
				lda D.HEAD 				READ IN THE DIRECTORY HEADER FOR THIS FILE
				sta BLOKNML
				lda D.HEAD+1
				sta BLOKNMH
				lda D.DEV
				sta DEVNUM
				jsr RDGBUF				READ IT INTO THE GENERAL PURPOSE BUFFER
				bcs FLSHERR 			BRANCH IF ERROR.
				jsr MOVHED0 			MOVE HEADER INFO.
				lda D.ENTBLK 			GET ADDRESS OF DIRECTORY BLOCK THAT
				ldy D.ENTBLK+1 			CONTAINS THE FILE ENTRY.
				cmp D.HEAD 				TEST TO SEE IF IT'S THE SAME BLOCK THAT
				bne FLSHEBLK 			THE HEADER IS IN. BRANCH IF NOT.
				cpy D.HEAD+1
				beq FLUSH5 				BRANCH IF HEADER BLOCK = ENTRY BLOCK.

FLSHEBLK		sta BLOKNML
				sty BLOKNMH
				jsr RDGBUF 				GET BLOCK WITH FILE ENTRY IN GENERAL BUFFER.

FLUSH5			jsr ENTCALC 			SET UP POINTER TO ENTRY
				jsr MOVENTRY 			MOVE ENTRY TO TEMP ENTRY BUFFER IN 'WORKSPC'
				ldy #FCBUSE 			UPDATE 'BLOCKS USED' COUNT.
				lda (FCBPTR),Y
				sta DFIL+D.USAGE
				iny
				lda (FCBPTR),Y
				sta DFIL+D.USAGE+1 		HI BYTE TOO...
				ldy #FCBEOF 			AND MOVE IN END OF FILE MARK WHETHER

EOFUPDTE		lda (FCBPTR),Y 			WE NEED TO OR NOT.
				sta DFIL+D.EOF-FCBEOF,Y
				iny  					MOVE ALL THREE BYTES.
				cpy #FCBEOF+3
				bne EOFUPDTE
				ldy #FCBFRST 			ALSO MOVE IN THE ADDRESS OF
				lda (FCBPTR),Y 			THE FILE'S FIRST BLOCK SINCE
				iny  					IT MIGHT HAVE CHANGED SINCE THE FILE
				sta DFIL+D.FRST 		FIRST OPENED.
				lda (FCBPTR),Y
				sta DFIL+D.FRST+1

				ldy #FCBSTYP 			AND THE LAST THING TO UPDATE IS
				lda (FCBPTR),Y 			THE STORAGE TYPE.
				asl 					(SHIFT IT INTO THE HI NIBBLE)
				asl
				asl
				asl
				sta SCRTCH
				lda DFIL+D.STOR 		GET OLD TYPE BYTE (IT MIGHT BE THE SAME)
				and #$F 				STRIP OFF OLD TYPE
				ora SCRTCH 				ADD IN THE NEW TYPE,
				sta DFIL+D.STOR 		AND PUT IT AWAY.
				jsr DREVISE 			GO UPDATE DIRECTORY!
				bcs FLUSHERR
				ldy #FCBDIRTY 			MARK
				lda (FCBPTR),Y 			FCB/DIRECTORY
				and #$FF-FCBMOD 		AS
				sta (FCBPTR),Y 			UNDIRTY
				ldx #0 					NOW CHECK TO SEE IF A BIT MAP
				lda D.DEV 				IS LYING AROUND THAT SHOULD BE WRITTEN.
				cmp BMADEV 				IS IT IN MAP BUFFER A?
				beq BMAPUP 				YES, PUT IT ON THE DISK IF NECESSARY.
				ldx #BMTABSZ 			SET INDEX TO BIT MAP TABLE 'B'
				cmp BMBDEV 				NO, WHAT ABOUT BIT MAP BUFFER B?
				bne FLSHEND1 			NOPE, ALL DONE.
BMAPUP			lda BMASTAT,X 			TEST TO SEE IF IT'S BEEN MODIFIED.
				bpl FLSHEND1 			NOPE, ALL DONE AS I SAID.
				stx BMTAB
				jsr WRTBMAP 			GO PUT IT AWAY.
				bcs FLUSHERR
				ldx BMTAB 				MARK MAP AS UPDATED
				lda #0
				sta BMASTAT,X
FLSHEND1		clc
				rts

FLUSHERR		.EQ * 					DROP INTO GLBERR
*
GLBERR			.EQ * 					REPORT ERROR IMMEDIATELY
* ONLY IF NOT A CLOSE ALL OR FLUSH ALL
				ldx C.REFNUM
				bne GLBERR1 			NOT AN 'ALL' SO REPORT NOW
				clc
				sta CFERR 				SAVE FOR LATER
GLBERR1			rts
*
*
GFCBADR			lda FCBANKNM 			GET BANK THAT FCB IS IN
				sta SISFCBP
				lda FCBADDRH 			AND HIGH BYTE ADDRESS OF FILE CONTORL BLOCK.
				sta FCBPTR+1
				rts  					SILLY THAT IT'S SO SHORT...
*
SETERR			lda #ACCSERR
				sec
EOFRETN			rts

*
SETEOF			ldy #FCBSTYP 			ONLY KNOW HOW TO MOVE EOF OF TREE TYPE
				lda (FCBPTR),Y
				cmp #TRETYP+1
				bcs SETERR 				BRANCH IF OTHER THAN TREE
				ldy #FCBATTR 			NOW CHECK TO INSURE WRITE IS ENABLED.
				lda (FCBPTR),Y
				and #WRITEN 			CAN WE SET NEW EOF?
				beq SETERR 				NOPE, ACCESS ERROR.
				jsr TSTWPROT 			FIND OUT IF MOD IS POSIBLE (HARDWARE WRITE PROTECT)
				bcs SETERR
				ldy #FCBEOF+2 			SAVE OLD EOF
				ldx #2 					SO IT CAN BE SEEN

SETSAVE			lda (FCBPTR),Y 			WHETHER BLOCKS NEED
				sta OLDEOF,X 			TO BE RELEASED
				dey  					UPON
				dex  					CONTRACTION
				bpl SETSAVE 			ALL THREE BYTES OF THE EOF
				jsr ADJMARK 			GET ADJUSTED END OF FILE ACCORDING TO 'C.BASE' INTO TPOS.
				bcs EOFRETN 			RETURN ANY ERROR IMMEDIATELY
				ldx #2

NEOFPOS			lda TPOSLL,X 			POSITION MARK TO NEW EOF
				sta C.NEWEOF,X
				dex
				bpl NEOFPOS
				ldy #FCBMARK+2 			FIND OUT IF EOF < MARK.
				ldx #2

NEOFTST			lda (FCBPTR),Y
				cmp C.NEWEOF,X 			COMPARE UNTIL NOT EQUAL OR CARRY CLEAR
				bcc SETEOF1 			BRANCH IF EOF>MARK
				bne SETEOF0 			BRANCH IF EOF<MARK
				dey
				dex
				bpl NEOFTST 			LOOP ON ALL THREE BYTES

SETEOF0			jsr RDPOSN 				READ IN NEW POSITION.
				bcs EOFRETN 			RETURN ANY ERRORS.

SETEOF1			ldx #2
				ldy #FCBEOF+2 			MOVE NEW EOF TO FCB.

SETEOF2			lda C.NEWEOF,X
				sta (FCBPTR),Y
				dey
				dex
				bpl SETEOF2 			MOVE ALL THREE BYTES.
				jsr FCBUSED 			MARK FCB AS DIRTY (FOR FLUSH)
*
				ldx #2 					POINT TO THIRD BYTE
PURTEST			lda OLDEOF,X 			SEE IF EOF MOVED BACKWARDS
				cmp C.NEWEOF,X 			SO BLOCKS CAN
				bcc PURTEST1 			BE RELEASED (BRANCH IF NOT)
				bne PURGE 				BRANCH IF BLOCKS TO BE RELEASED
				dex
				bpl PURTEST 			ALL THREE BYTES
PURTEST1		jmp FLSHEND1 			NEW EOF NOT SMALLER
TRELEAS1		jmp TRELEASE 			OVERFLOW PREVENTER
*
PURGE			ldy #FCBSTYP 			FIND OUT WHAT TYPE OF TREE
				lda (FCBPTR),Y 			TO PERFORM THE PROPER
				cmp #SEEDTYP 			STYLE OF BLOCK RELEASE
				beq EOFOUT 				SEED DON'T DEALLOCATE
				cmp #TRETYP 			FULL TREE?
				beq TRELEAS1 			BRANCH IF YES
*
* IF WE GET HERE, WE ARE RELEASING
* BLOCKS AT THE END OF A SAPLING FILE: CALCULATE CORRECT POSITION
* WITHIN THE INDEX BLOCK AND ALLOW SUBROUTINE
* PURGE LATTER BLOCKS TO DEALLOCATE
* ALL THE DATA BLOCKS THAT FOLLOW
*
				jsr FNDBMAP 			REFRESH THE RIGHT MAP FOR THIS VOLUME
				ldx TPOSHI 				PRELOAD
				ldy TPOSLH 				THE THREE EOF
				lda TPOSLL 				BYTES
				bne PUR1 				BRANCH IF NO BOUNDARY ADJUSTMENT NEEDED
				cpy #0
				bne PUR2 				MIDDLE BYTE ZERO MEANS NO CARRY
				cpx #0 					ALL BYTES ZERO??
				beq PUR1 				BRANCH IF YES
				dex
*
* THESE LINES IF CODE, SOMEWHAT CRYPTIC,
* CALCULATE THE POINT AT WHICH THE
* LAST BLOCK CONTAINING THE LAST BIT
* OF DATUM
*
* THE FOLLOWING IS ROUGHLY A /512
* ALGORITHM
*
PUR2			dey
PUR1			txa
				lsr
				tya
				ror
*
				jsr PURLBLKS 			MAKES A GOOD PTR TO DO THE RELEASING
				ldy #FCBSTAT 			MARK INDEX BLOCK
				lda (FCBPTR),Y 			AS DIRTY
				ora #IDXMOD
				sta (FCBPTR),Y
				lda PURUSE 				INDICATE NEW NUMBER OF BLOCKS USED
				clc
				adc #2 					ACCOUNT FOR CARDINAL AND INDEX
				ldy #FCBUSE
				sta (FCBPTR),Y 			FILE LOW BYTE
				iny
				lda #0 					ANTICIPATE <257 BLOCKS
				bcc PURHI
				lda #1					>256 BLOCKS IN FILE
PURHI			sta (FCBPTR),Y 			HIGH BYTE BLOCKS USED
EOFOUT			clc
				rts  					NO ERRORS POSSIBLE

* INPUT ARG: A REGISTER CONTAINING
* POINTER TO CURRENT DATA BLOCK WITHIN THE
* CURRENT INDEX BLOCK (TINDX)
* DEALLOCATE ALL LEGAL BLOCKS AFTER
* THE A REGISTER PTR. NO ERRORS POSSIBLE
*
PURLBLKS		.EQ * 					PURGE LATTER BLOCKS
				tay 					MAKE PROPER INDEX
				sty PURUSE 				INDICATES NUMBER OF BLOCKS IN USE IN FILE
PURLOOP			iny 					POINT TO A PTR TO DATA BLK TO DEALLOCATE
				beq	PURLRTS 			NO MORE BLOCKS IN INDEX
				inc	TINDX+1 			GET HIGH PART OF BLOCK ADDR
				lda	(TINDX),Y
				tax						X IS A PASSING PARM
				lda	#0 					TELL INDEX BLOCK THAT THE DATA
				sta	(TINDX),Y 			BLOCK IS NOW FREE
				txa
				dec	TINDX+1 			AND LOW PART
				ora	(TINDX),Y
				beq	PURLOOP 			INDICATED ADDR WAS ZERO-ZERO
				lda	(TINDX),Y 			A REG IS ANOTHER PASSING PARM
				pha
				lda	#0
				sta	(TINDX),Y 			AND SET LOW DATA ADDR AS FREED
				pla
				sty	PURPLACE 			TEMP STORAGE
				jsr	DEALLOC 			DEALLOCATE BLOCK (ADDR: A (LOW), X ( HIGH)
				ldy	#VCBTFRE
				clc
				lda	(VCBPTR),Y 			ADJUST NUMBER OF FREE BLOCKS ON VOLUME
				adc	#1
				sta	(VCBPTR),Y
				iny
				lda	(VCBPTR),Y 			HIGH BYTE OF TOTAL FREE
				adc	#0
				sta	(VCBPTR),Y
				ldy	PURPLACE
				jmp	PURLOOP
PURLRTS			rts

PURUSE			.BS 1 					CURRENT NUMBER OF BLOCKS USED
PURPLACE		.BS 1 					CURRENT PLACE IN RELEASE-BLOCK CYCLE

TRELEASE		jmp	EOFOUT 				RELEASE TWO LEVEL TREE CODE GOES HERE
*
GETEOF			ldy #FCBEOF 			INDEX TO END OF FILE MARK
				ldx	#0 					WE'VE GOT INDIRECT BOTH WAYS (IN & OUT)
OUTEOF			lda (FCBPTR),Y
				sta (C.OUTEOF,X)
				iny
				cpy #FCBEOF+3
				beq OFFRTS 				BRANCH IF ALL THREE BYTES TRANSFERED.
				inc C.OUTEOF 			BUMP USER'S POINTER.
				bne OUTEOF
				inc C.OUTEOF+1
				bne OUTEOF 				BRANCH ALWAYS
*--------------------------------------
MAN
SAVE /A3OSX.BUILD/SOS.13/sos.s.bfm.ce
LOAD /A3OSX.BUILD/SOS.13/sos.s
ASM
