NEW
  AUTO 3,1
*--------------------------------------
*************************************************************************  
* APPLE /// SOS 1.3 SOURCE CODE FILE: MEMMGR.B.SRC  
*************************************************************************  
* ASSEMBLER: APPLE ][ 6502 ASSEMBLER from APPLE COMPUTER TOOLKIT  
				 
PAGE			  
REP				 60  
*  
* NEXT FREE SEGMENT - INITIALIZATION  
*  
* INPUT: SEGMENT TABLE  
* OUTPUT: CFS.PTR "1ST FREE BANK/PAGE IN VIRTUAL MEMORY  
* CFS.PREV "PREVIOUS SEGMENT EXAMINED"  
* CFS.NEXT "SEGMENT FOLLOWING CFS.PREV"  
* ERROR: NONE (IF NO FREE BK/PG FOUND, THEN CFS.PTR="FFFF")  
*  
REP				 60  
*  
NXTFRSEG.I		 EQU *  
*  
* CFS.PTR := VRT.LIM  
* CFS.PREV := 0  
* CFS.NEXT := ST.ENTRY  
*  
LDA				 >VRT.LIM  
STA				 CFS.PTR  
LDA				 >VRT.LIM+1  
STA				 CFS.PTR+1  
*  
LDA				 #0  
STA				 CFS.PREV  
*  
LDX				 ST.ENTRY  
STX				 CFS.NEXT  
*  
* L0: IF CFS.NEXT=0 THEN DONE  
*  
FRSGI010		 BEQ FRSGI.EXIT  
*  
* IF ST.LIM(CFS.NEXT)<=VRT.LIM THEN GOTO L1  
*  
LDA				 >VRT.LIM  
CMP				 ST.LIML,X  
LDA				 >VRT.LIM+1  
SBC				 ST.LIMH,X  
BCS				 FRSGI020  
*  
* CFS.PREV:=CFS.NEXT  
* CFS.NEXT:=ST.FLINK(CFS.NEXT)  
* GOTO L0  
*  
STX				 CFS.PREV  
LDA				 ST.FLINK,X  
TAX				  
STX				 CFS.NEXT  
JMP				 FRSGI010  
*  
* L1: IF ST.LIM(CFS.NEXT)<VRT.LIM THEN DONE  
*  
FRSGI020		 LDA ST.LIML,X  
CMP				 >VRT.LIM  
LDA				 ST.LIMH,X  
SBC				 >VRT.LIM+1  
BCC				 FRSGI.EXIT  
*  
*  
JSR				 NXTFRPG  
*  
FRSGI.EXIT		 RTS ; NORMAL EXIT  
PAGE			  
REP				 60  
*  
* NEXT FREE SEGMENT  
*  
* INPUT: SEG TABLE  
* OUTPUT: CFS.BLINK  
* CFS.BASE  
* CFS.LIMIT  
* CFS.PGCT  
* OWN: CFS.PREV  
* CFS.NEXT  
* CFS.PTR  
*   
* BUILDS A CANDIDATE FREE SEGMENT, WHOSE LIMIT BANK/PAGE =  
* THE CURRENT FREE PAGE (CFS.PTR).  
*  
REP				 60  
*  
NXTFRSEG		 EQU *  
*  
* IF CFS.PTR="FFFF" THEN EXIT  
*  
LDA				 CFS.PTR+1  
BPL				 FRSG010  
*  
SEC				  
RTS				 ; EXIT - NO MORE FREE SEGMENTS LEFT  
*  
* CFS.BLINK:=CFS.PREV  
* CFS.LIM:=CFS.PTR  
*  
FRSG010			 LDA CFS.PREV  
STA				 CFS.BLINK  
*  
LDA				 CFS.PTR  
STA				 CFS.LIM  
LDA				 CFS.PTR+1  
STA				 CFS.LIM+1  
*  
* IF CFS.NEXT=0 THEN CFS.BASE:=0  
* ELSE CFS.BASE:=ST.LIM(CFS.NEXT)+1  
*  
LDA				 CFS.NEXT  
BNE				 FRSG020  
LDA				 #0  
STA				 CFS.BASE  
STA				 CFS.BASE+1  
BEQ				 FRSG030  
*  
FRSG020			 LDX CFS.NEXT  
CLC				  
LDA				 ST.LIML,X  
ADC				 #1  
STA				 CFS.BASE  
LDA				 ST.LIMH,X  
ADC				 #0  
STA				 CFS.BASE+1  
*  
* CFS.BASE0:=CFS.LIM AND $FF80  
*  
FRSG030			 LDY CFS.LIM+1  
STY				 CFS.BASE0+1  
LDA				 CFS.LIM  
AND				 #$80  
STA				 CFS.BASE0  
*  
* CFS.BASE1:=CFS.BASE0-32K  
*  
SEC				  
SBC				 #$80  
STA				 CFS.BASE1  
TYA				  
SBC				 #0  
STA				 CFS.BASE1+1  
BCS				 FRSG035  
LDA				 #0  
STA				 CFS.BASE1  
STA				 CFS.BASE1+1  
*  
* IF CFS.BASE>=CFS.BASE0 THEN GOTO L1  
*  
FRSG035			 LDA CFS.BASE  
CMP				 CFS.BASE0  
LDA				 CFS.BASE+1  
SBC				 CFS.BASE0+1  
BCS				 FRSG050  
*  
* IF SEARCH MODE=0 THEN CFS.BASE:=CFS.BASE0  
* GOTO L1  
*  
LDA				 SRCHMODE  
BNE				 FRSG040  
LDA				 CFS.BASE0  
STA				 CFS.BASE  
LDA				 CFS.BASE0+1  
STA				 CFS.BASE+1  
JMP				 FRSG050  
*  
* IF CFS.BASE<CFS.BASE1 AND SEARCH MODE=1  
* THEN CFS.BASE:=CFS.BASE1  
*  
FRSG040			 LDA CFS.BASE  
CMP				 CFS.BASE1  
LDA				 CFS.BASE+1  
SBC				 CFS.BASE1+1  
BCS				 FRSG050  
*  
LDA				 SRCHMODE  
CMP				 #1  
BNE				 FRSG050  
*  
LDA				 CFS.BASE1  
STA				 CFS.BASE  
LDA				 CFS.BASE1+1  
STA				 CFS.BASE+1  
*  
* L1: CFS.PGCT:=CFS.LIM-CFS.BASE+1  
*  
FRSG050			 SEC  
LDA				 CFS.LIM  
SBC				 CFS.BASE  
STA				 CFS.PGCT  
LDA				 CFS.LIM+1  
SBC				 CFS.BASE+1  
STA				 CFS.PGCT+1  
INC				 CFS.PGCT  
BNE				 FRSG052  
INC				 CFS.PGCT+1  
*  
* ADVANCE FREE PAGE POINTER TO NEXT FREE PAGE  
*  
* IF SEARCH MODE<>1 THEN L2:  
*  
FRSG052			 LDA SRCHMODE  
CMP				 #1  
BNE				 FRSG060  
*  
* IF CFS.BASE < CFS.BASE0 THEN CFS.PTR:=CFS.BASE0-1  
*  
LDA				 CFS.BASE  
CMP				 CFS.BASE0  
LDA				 CFS.BASE+1  
SBC				 CFS.BASE0+1  
BCS				 FRSG060  
*  
LDY				 CFS.BASE0+1  
LDX				 CFS.BASE0  
BNE				 FRSG055  
DEY				  
FRSG055			 DEX  
STX				 CFS.PTR  
STY				 CFS.PTR+1  
*  
JMP				 FRSG070 ; AND EXIT  
* L2: CFS.PTR:=CFS.BASE-1  
*  
FRSG060			 SEC  
LDA				 CFS.BASE  
SBC				 #1  
STA				 CFS.PTR  
LDA				 CFS.BASE+1  
SBC				 #0  
STA				 CFS.PTR+1  
*  
* IF CFS.PTR="FFFF" OR CFS.NEXT=0 THEN EXIT  
*  
BCC				 FRSG070  
LDA				 CFS.NEXT  
BEQ				 FRSG070  
*  
* IF CFS.PTR > ST.LIM(CFS.NEXT) THEN EXIT  
*  
LDX				 CFS.NEXT  
LDA				 ST.LIML,X  
CMP				 CFS.PTR  
LDA				 ST.LIMH,X  
SBC				 CFS.PTR+1  
BCC				 FRSG070  
*  
* OTHERWISE, ADVANCE CFS PTR TO NEXT FREE PAGE BELOW NEXT  
* SEGMENT IN SEGMENT LIST  
*  
JSR				 NXTFRPG  
*  
FRSG070			 CLC  
RTS				 ; EXIT - FREE SEGMENT FOUND  
PAGE			  
REP				 60  
*  
* NEXT FREE PAGE  
*  
* "WALKS" THE FREE PAGE PTR (CFS.PTR) TO THE NEXT FREE PAGE  
* IMMEDIATELY BELOW THE CURRENT FREE SEGMENT.  
*  
REP				 60  
*  
NXTFRPG			 EQU *  
*  
* L0: CFS.PTR:=ST.BASE(CFS.NEXT)-1  
* IF CFS.PTR="FFFF" THEN DONE  
*  
LDX				 CFS.NEXT  
SEC				  
LDA				 ST.BASEL,X  
SBC				 #1  
STA				 CFS.PTR  
LDA				 ST.BASEH,X  
SBC				 #0  
STA				 CFS.PTR+1  
BCC				 NFRPG.EXIT  
*  
* CFS.PREV:=CFS.NEXT  
* CFS.NEXT:=ST.FLINK(CFS.NEXT)  
*  
STX				 CFS.PREV  
LDA				 ST.FLINK,X  
TAX				  
STX				 CFS.NEXT  
*  
* IF CFS.NEXT=0 OR ST.LIM(CFS.NEXT)<CFS.PTR  
* THEN DONE  
* ELSE GOTO L0  
*  
BEQ				 NFRPG.EXIT  
LDA				 ST.LIML,X  
CMP				 CFS.PTR  
LDA				 ST.LIMH,X  
SBC				 CFS.PTR+1  
BCS				 NXTFRPG  
*  
NFRPG.EXIT		 RTS ; NORMAL EXIT  
PAGE			  
REP				 60  
*  
* CHANGE.SEG(IN.SEGNUM,CHG.MODE; INOUT.PAGECT) SYSTEM CALL  
*  
REP				 60  
*  
CHG.SEG			 EQU *  
*  
* MOVE CALLER'S PAGE COUNT TO INTERNAL BUFFER  
*  
LDY				 #0  
LDA				 (CHG.PGCT),Y  
STA				 CHG.PGCTX  
INY				  
LDA				 (CHG.PGCT),Y  
STA				 CHG.PGCTX+1  
*  
* IF SEG# OUT OF RANGE OR ST.FLINK(SEG#)=FREE THEN ERR
*
				LDX CHG.NUM   
				BEQ CHGS.ERR   
				CPX #ST.CNT   
				BCS CHGS.ERR   
				LDA ST.FLINK,X   
				BPL CHGS005   
*     
CHGS.ERR		 LDA #BADSEGNUM   
				JSR SYSERR ; ERR EXIT  
				REP 35   
* CASE OF CHANGE MODE    
REP				 35   
CHGS005			 LDY CHG.MODE   
CPY				 #1   
BCC				 CHGS010   
BEQ				 CHGS020   
CPY				 #3   
BCC				 CHGS030   
BEQ				 CHGS040   
*    
LDA				 #BADCHGMODE   
JSR				 SYSERR ; ERR EXIT  
PAGE			    
REP				 35   
* CHANGE MODE = 0(BASE UP)    
REP				 35   
* CHG.NEW:=ST.BASE(SEG#)+PGCT   
*   
CHGS010			 CLC   
LDA				 ST.BASEL,X   
ADC				 CHG.PGCTX   
STA				 CHG.NEW   
LDA				 ST.BASEH,X   
ADC				 CHG.PGCTX+1   
STA				 CHG.NEW+1   
*   
BCS				 CHGS014 ; OVERFLOW, PEG IT  
*   
* IF CHG.NEW <= ST.LIM(SEG#) THEN EXIT   
*   
LDA				 ST.LIML,X   
CMP				 CHG.NEW   
LDA				 ST.LIMH,X   
SBC				 CHG.NEW+1   
BCS				 CHGS016   
*   
* OTHERWISE, CHG.NEW:=ST.LIM(SEG#)   
*   
CHGS014			 LDA ST.LIML,X   
STA				 CHG.NEW   
LDA				 ST.LIMH,X   
STA				 CHG.NEW+1   
*   
CHGS016			 JMP CHGS.EXIT   
REP				 35   
* CHANGE MODE = 1(BASE DOWN)   
REP				 35   
* CHG.NEW:=ST.BASE(SEG#)-PGCT   
*   
CHGS020			 SEC   
LDA				 ST.BASEL,X   
SBC				 CHG.PGCTX   
STA				 CHG.NEW   
LDA				 ST.BASEH,X   
SBC				 CHG.PGCTX+1   
STA				 CHG.NEW+1   
BCS				 CHGS050   
BCC				 CHGS052 ; OVERFLOW, PEG IT  
REP				 35   
* CHANGE MODE = 2(LIMIT UP)   
REP				 35   
* CHG.NEW:=ST.LIM(SEG#)+PGCT   
*   
CHGS030			 CLC   
LDA				 ST.LIML,X   
ADC				 CHG.PGCTX   
STA				 CHG.NEW   
LDA				 ST.LIMH,X   
ADC				 CHG.PGCTX+1   
STA				 CHG.NEW+1   
BCC				 CHGS050   
BCS				 CHGS052 ; OVERFLOW, PEG IT  
REP				 35   
* CHANGE MODE = 3(LIMIT DOWN)   
REP				 35   
* CHG.NEW:=ST.LIM(SEG#)-PGCT   
*   
CHGS040			 SEC   
LDA				 ST.LIML,X   
SBC				 CHG.PGCTX   
STA				 CHG.NEW   
LDA				 ST.LIMH,X   
SBC				 CHG.PGCTX+1   
STA				 CHG.NEW+1   
BCC				 CHGS044 ; OVERFLOW, PEG IT  
*   
* IF CHG.NEW >= ST.BASE(SEG#) THEN EXIT   
*   
LDA				 CHG.NEW   
CMP				 ST.BASEL,X   
LDA				 CHG.NEW+1   
SBC				 ST.BASEH,X   
BCS				 CHGS046   
*   
* OTHERWISE CHG.NEW:=ST.BASE(SEG#)   
*   
CHGS044			 LDA ST.BASEL,X   
STA				 CHG.NEW   
LDA				 ST.BASEH,X   
STA				 CHG.NEW+1   
*   
CHGS046			 JMP CHGS.EXIT   
*   
* DETERMINE NEW BANK/PAGE'S REGION,   
* IF NEW BANK/PAGE IS INVALID THEN   
* SET TO BASE OR LIMIT (CASE CHANGE MODE)   
*   
CHGS050			 LDX CHG.NEW   
LDY				 CHG.NEW+1   
JSR				 REGION   
BCS				 CHGS052   
BNE				 CHGS052   
BEQ				 CHGS100   
CHGS052			 LDA CHG.MODE   
CMP				 #1   
BNE				 CHGS054   
LDX				 #>VRT.BASE   
LDY				 #<VRT.BASE   
JMP				 CHGS056   
CHGS054			 LDX >VRT.LIM   
LDY				 >VRT.LIM+1   
CHGS056			 STX CHG.NEW   
STY				 CHG.NEW+1   
PAGE			   
*   
* COMPUTE BANK/PAGE OF ADJACENT SEGMENT, IF ANY   
* CASE CHANGE MODE   
*   
CHGS100			 LDX CHG.NUM   
LDA				 CHG.MODE   
CMP				 #1   
BNE				 CHGS200   
* "1" IF ST.FLINK(SEG#)=0 THEN EXIT   
LDA				 ST.FLINK,X   
BEQ				 CHGS.EXIT   
* X,Y:=ST.LIM(ST.FLINK(SEG#))+1   
TAY				   
LDA				 ST.LIML,Y   
TAX				   
LDA				 ST.LIMH,Y   
TAY				   
INX				   
BNE				 CHGS110   
INY				   
* IF CHG.NEW < X,Y THEN CHG.NEW:=X,Y   
CHGS110			 CPY CHG.NEW+1   
BCC				 CHGS.EXIT   
BEQ				 CHGS120   
BCS				 CHGS300   
CHGS120			 CPX CHG.NEW   
BCC				 CHGS.EXIT  
BCS				 CHGS300  
* "2" IF ST.BLINK(SEG#)=0 THEN EXIT  
CHGS200			 LDA ST.BLINK,X  
				BEQ CHGS.EXIT  
*X,Y:= ST.BASE(ST.BLINK(SEG#))-1
AY
				LDA ST.BASEL,Y  
				TAX   
				LDA ST.BASEH,Y  
				TAY   
				TXA   
				BNE CHGS210  
				DEY   
CHGS210			 DEX   
000498			 * IF CHG.NEW > X,Y THEN CHG.NEW:=X,Y CPY CHG.NEW+1  
				BCC CHGS300  
				BEQ CHGS220  
				BCS CHGS.EXIT  
CHGS220			 CPX CHG.NEW  
				BCS CHGS.EXIT  
*    
CHGS300			 STX CHG.NEW  
				STY CHG.NEW+1  
				PAGE   
				REP 35  
*   
* COMPUTE DELTA PAGE COUNT AND RETURN IT TO CALLER  
* (CASE OF CHG.MODE)   
*   
REP				 35  
CHGS.EXIT		 LDX CHG.NUM  
LDY				 #0  
LDA				 CHG.MODE  
CMP				 #1  
BCC				 CHGS500  
BEQ				 CHGS510  
CMP				 #3  
BCC				 CHGS520  
BEQ				 CHGS530  
*  
* "0" -- PAGECOUNT:=NEW-BASE  
*  
CHGS500			 SEC   
				LDA CHG.NEW  
				SBC ST.BASEL,X  
				STA (CHG.PGCT),Y  
				LDA CHG.NEW+1  
				SBC ST.BASEH,X  
				JMP CHGS600  
*  
* "1" -- PAGECOUNT:=BASE-NEW  
*  
CHGS510			 SEC   
				LDA ST.BASEL,X  
				SBC CHG.NEW  
				STA (CHG.PGCT),Y  
				LDA ST.BASEH,X  
				SBC CHG.NEW+1  
				JMP CHGS600  
*    
* "2" -- PAGECOUNT:=NEW-LIM   
*    
CHGS520			 SEC   
				LDA CHG.NEW  
				SBC ST.LIML,X  
				STA (CHG.PGCT),Y  
				LDA CHG.NEW+1  
				SBC ST.LIMH,X  
				JMP CHGS600  
*    
* "3" -- PAGECOUNT:=LIM-NEW   
*    
CHGS530			 SEC   
				LDA ST.LIML,X  
				SBC CHG.NEW  
				STA (CHG.PGCT),Y  
				LDA ST.LIMH,X  
				SBC CHG.NEW+1  
*    
CHGS600			 INY   
				STA (CHG.PGCT),Y  
*  
* IF NEW PAGE COUNT < REQUESTED PAGECOUNT THEN ERR  
*  
TAX				  
DEY				  
LDA				 (CHG.PGCT),Y   
CMP				 CHG.PGCTX   
TXA				    
SBC				 CHG.PGCTX+1   
BCS				 CHGS610   
LDA				 #SEGRQDN   
JSR				 SYSERR ; ERR EXIT  
*  
* OTHERWISE, ENTER CHG.NEW IN SEGMENT TABLE AND EXIT  
*  
CHGS610			 LDX CHG.NUM   
				LDA CHG.MODE   
				CMP #2   
				LDA CHG.NEW   
				LDY CHG.NEW+1   
				BCS CHGS620   
*     
				STA ST.BASEL,X   
				TYA    
				STA ST.BASEH,X   
				CLC    
				RTS  ; NORMAL EXIT  
*     
*     
CHGS620			 STA ST.LIML,X   
				TYA    
				STA ST.LIMH,X   
				CLC    
				RTS  ; NORMAL EXIT  
				    
				CHN MEMMGR.C.SRC   
				    
*************************************************************************
* END OF APPLE /// SOS 1.3 SOURCE CODE FILE: MEMMGR.B.SRC
*************************************************************************


*--------------------------------------
MAN
SAVE /A3OSX.BUILD/SOS.13\sos.s.memmgr.b.txt
LOAD /A3OSX.BUILD/SOS.13/sos.s
ASM
