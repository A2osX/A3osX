NEW
  AUTO 3,1
*--------------------------------------
*************************************************************************  
* APPLE /// SOS 1.3 SOURCE CODE FILE: FNDFIL  
*************************************************************************  
* ASSEMBLER: APPLE ][ 6502 ASSEMBLER from APPLE COMPUTER TOOLKIT  
				 
PAGE			  
*  
*  
FINDFILE		 JSR LOOKFILE ; SEE IF FILE EXISTS  
BCS				 NOFIND ; BRANCH IF AN ERROR WAS ENCOUNTERED  
MOVENTRY		 LDY H.ENTLN ; MOVE ENTIRE ENTRY INFO TO A SAFE AREA  
MOVENT1			 LDA (DRBUFPL),Y  
STA				 DFIL+D.STOR,Y  
DEY				  
BPL				 MOVENT1  
LDA				 #0 ; TO INDICATE ALL IS WELL  
NOFIND			 RTS ; RETURN CONDITION CODES.  
PAGE			  
*  
*  
LOOKFILE		 JSR PREPROOT ; FIND VOLUME AND SET UP OTHER BORING STUFF  
BCS				 FNDERR ; PASS BACK ANY ERROR ENCOUNTERED  
LDY				 #0 ; TEST TO SEE IF ONLY ROOT WAS SPECIFIED.  
LDA				 (PATHNML),Y  
BNE				 LOOKFIL0 ; BRANCH IF MORE THAN ROOT.  
LDA				 #GBUF/256 ; OTHERWISE, REPORT A BADPATH ERROR  
STA				 DRBUFPH ; (BUT FIRST CREATE A PHANTOM ENTRY FOR OPEN)  
LDA				 #4  
STA				 DRBUFPL  
LDY				 #D.AUXID ; FIRST MOVE IN ID, AND DATE STUFF.  
PHANTM1			 LDA (DRBUFPL),Y  
STA				 DFIL,Y  
DEY				  
CPY				 #D.CREDT-1  
BNE				 PHANTM1  
PHANTM2			 LDA ROOTSTUF-D.FILID,Y  
STA				 DFIL,Y  
DEY				  
CPY				 #D.FILID-1  
BNE				 PHANTM2  
LDA				 #DIRTYP*$10 ; FAKE DIRECTORY FILE  
STA				 DFIL+D.STOR  
LDA				 #BADPATH ; (CARRY IS SET)  
RTS				  
*  
ROOTSTUF		 DFB 0,2,0,4  
DFB				 0,0,8,0  
*  
LOOKFIL0		 LDA #0 ; RESET FREE ENTRY INDICATOR  
STA				 NOFREE  
SEC				 ; INDICATE THAT THE DIRECTORY TO BE SEARCHED HAS HEADER IN THIS BLOCK  
LOOKFIL1		 LDA #0 ; RESET ENTRY COUNTER  
STA				 TOTENT  
JSR				 LOOKNAM ; LOOK FOR NAME POINTED TO BY 'PATHNML'  
BCC				 NAMFOJMP ; BRANCH IF NAME WAS FOUND.  
LDA				 ENTCNTL ; HAVE WE LOOKED AT ALL OF THE  
SBC				 TOTENT ; ENTRIES IN THIS DIRECTORY?  
BCC				 DCRENTH ; MAYBE, CHECK HI COUNT.  
BNE				 LOOKFIL2 ; NO, READ NEXT DIRECTORY BLOCK  
CMP				 ENTCNTH ; HAS THE LAST ENTRY BEEN LOOKED AT (ACC=0)  
BEQ				 ERRFNF ; YES, GIVE 'FILE NOT FOUND' ERROR.  
BNE				 LOOKFIL2 ; BRANCH ALWAYS.  
DCRENTH			 DEC ENTCNTH ; SHOULD BE AT LEAST 1  
BPL				 LOOKFIL2 ; (THIS SHOULD BE BRANCH ALWAYS...)  
ERRDIR			 LDA #DIRERR ; REPORT DIRECTORY MESSED UP.  
FNDERR			 SEC ; INDICATE ERROR HAS BEEN ENCOUNTERED.  
RTS				  
NAMFOJMP		 JMP NAMFOUND ; AVOID BRANCH OUT OF RANGE  
*  
PAGE			  
LOOKFIL2		 STA ENTCNTL ; KEEP RUNNING COUNT  
LDA				 #GBUF/256 ; RESET INDIRECT POINTER  
STA				 DRBUFPH  
LDA				 GBUF+2 ; GET LINK TO NEXT DIRECTORY BLOCK  
BNE				 NXTDIR0 ; (IF THERE IS ONE)  
CMP				 GBUF+3 ; ARE BOTH ZERO, I.E. NO LINK?  
				BEQ ERRDIR ; IF SO, THEN NOT ALL ENTRIES WERE ACCOUNTED FOR.  
NXTDIR0			 STA BLOKNML   
				LDA GBUF+3   
				STA BLOKNMH   
				JSR RDGBUF ; GO READ THE NEXT LINKED DIRECTORY IN.  
				BCC LOOKFIL1 ; BRANCH IF NO ERROR.  
				RTS  ; RETURN ERROR (IN ACCUMULATOR).  
TELFREEX		 JMP TELFREE   
*     
FNF0X			 JMP FNF0 ; AVOID BRANCH OUT OF RANGE  
*     
CFLAG			 DS 1 ; AM I CREATING?  
TTSAVE			 DS 2 ; CURRENT BLOCK ADDR  
BLOKSAVE		 DS 2 ; PARENT DIR ADDR  
*     
ERRFNF			 LDA NOFREE ; WAS ANY FREE ENTRY FOUND?  
				BNE FNF0X   
				LDA GBUF+2 ; TEST LINK  
				BNE TELFREEX   
				CMP GBUF+3 ; IF BOTH ARE ZERO, THEN GIVE UP  
				BNE TELFREEX ; BRANCH IF NOT LAST DIR BLOCK  
				LDA CFLAG ; DOING A CREATE?  
				BEQ FNF0X ; NO, SIMPLY REPORT NOT FOUND  
*    
* EXTEND THE DIRECTORY BY A BLOCK   
*    
LDA				 BLOKSAVE ; BUT NOT  
ORA				 BLOKSAVE+1 ; IF A ROOT DIRECTORY!  
BEQ				 FNF0X ; FORU BLOCKS HARD CODED  
LDA				 TTLINK ; FETCH CURRENT DIRECTORY  
STA				 TLINK ; ADDR (GBUF)  
LDA				 TTLINK+1 ; AND ALLLOCATE A NEW  
STA				 TLINK+1 ; BY LINKING TO CURRENT  
JSR				 DIRWRT   
BCS				 FNF0 ; RATS! NO SPACE SAY "DIRFULL"  
*    
* SAVE CURRENT BLOCK ADDR    
*    
LDA				 TTLINK   
STA				 TTSAVE   
LDA				 TTLINK+1   
STA				 TTSAVE+1   
*    
* FETCH DESCENDENT    
*    
LDA				 GBUF+2   
STA				 BLOKNML   
LDA				 GBUF+3   
STA				 BLOKNMH   
JSR				 ZERGBUF ; INIT THE NEW DIR BLOCK  
*    
* AND INSERT BACK POINTER    
* TO "CURRENT BLOCK"    
*    
LDA				 TTSAVE   
STA				 GBUF   
LDA				 TTSAVE+1   
STA				 GBUF+1   
JSR				 WRTGBUF   
BCS				 ERTS   
*    
* UPDATE DIR'S HEADER IN PARENT 000139 *  
LDA				 BLOKSAVE   
STA				 BLOKNML ; PREPARE TO READ PARENT  
LDX				 BLOKSAVE+1   
STX				 BLOKNMH   
JSR				 RDGBUF ; FETCH PARENT  
LDY				 #D.USAGE ; BUMP BLOCKS USED BY HEADER  
LDA				 (DEBUPTR),Y   
SEC				    
ADC				 #0 ; BY JUST ONE BLOCK  
STA				 (DEBUPTR),Y   
INY				    
LDA				 (DEBUPTR),Y ; TWO BYTE BLOCKS USED  
ADC				 #0   
STA				 (DEBUPTR),Y   
LDY				 #D.EOF+1 ; INCREASE EOF BY $200  
LDA				 (DEBUPTR),Y   
CLC				    
ADC				 #2   
				STA (DEBUPTR),Y   
				INY    
				LDA (DEBUPTR),Y   
				ADC #0   
				STA (DEBUPTR),Y   
				JSR WRTGBUF ; REWRITE PARENT DIR BLOCK  
				LDA TTSAVE+1 ; REFETCH CURRENT DIR BLOCK  
				STA BLOKNMH   
				LDA TTSAVE   
				STA BLOKNML   
				JSR RDGBUF ; BACK FROM THE SHADOWS AGAIN  
				JMP ERRFNF ; VOILA! WE HAVE EXTENDED THE DIRECTORY!  
*     
TELFREE			 STA D.ENTBLK   
				LDA GBUF+3   
				STA D.ENTBLK+1 ; ASSUME FIRST ENTRY OF NEXT BLOCK  
				LDA #1 ; IS FREE FOR USE.  
				STA D.ENTNUM   
				STA NOFREE ; MARK D.ENTNUM AS VALID (FOR CREATE)  
FNF0			 LDY #0 ; TEST FOR 'FILE NOT FOUND' VERSUS 'PATH NOT FOUND'  
				LDA (PATHNML),Y   
				TAY    
				INY    
				LDA (PATHNML),Y ; IF NON-ZERO THEN 'PATH NOT FOUND'  
ERRPATH1		 SEC  ; IN EITHER CASE, INDICATE ERROR.  
				BEQ FNF1   
				LDA #PATHNOTFND ; REPORT NO SUCH PATH.  
ERTS			 RTS    
FNF1			 LDA #FNFERR ; REPORT FILE NOT FOUND.  
				RTS    
				PAGE    
*     
NAMFOUND		 LDA (PATHNML),Y ; (Y=0)  
				SEC    
				ADC PATHNML ; TEST FOR LAST NAME IN PATH  
				TAY  ; IF ZERO, THEN THAT WAS LAST NAME  
				CLC  ; TO INDICATE SUCCESS  
				LDA PATHBUF,Y   
				BEQ FILFOUND   
*NOW CHANGE THE PATHNAME POINTER TO POINT AT THE NEXT NAME IN THE PATH  
				STY PATHNML   
				LDA DRBUFPL ; SAVE PARENTS  
				STA DEBUPTR ; ENTRY POINTER  
				LDA DRBUFPH   
				STA DEBUPTR+1 ; IN CASE ENTRY ON PAGE 2  
				LDA BLOKNML ; ADDRESS (DIR EXTEND)  
				STA BLOKSAVE   
				LDA BLOKNMH   
				STA BLOKSAVE+1   
				LDY #D.STOR ; BE SURE THIS IS A DIRECTORY ENTRY  
				LDA (DRBUFPL),Y ; HIGH NIBBLE WILL TELL  
				AND #$F0   
				CMP #DIRTYP*16 ; IS IT A SUB-DIRECTORY?  
				BNE ERRPATH1 ; REPORT THE USER'S MISTAKE  
				LDY #D.FRST ; GET ADDRESS OF FIRST SUB-DIRECTORY BLOCK  
				LDA (DRBUFPL),Y   
				STA BLOKNML ; (NO CHECKING IS DONE HERE FOR A VALID  
				INY  ; BLOCK NUMBER... )  
				STA D.HEAD ; SAVE AS FILE'S HEADER BLOCK TOO.  
				LDA (DRBUFPL),Y   
				STA BLOKNMH   
				STA D.HEAD+1   
				JSR RDGBUF ; READ SUB-DIRECTORY INTO GBUF  
				BCS FNDERR1 ; RETURN IMMEDIATELY ANY ERROR ENCOUNTERED.  
				LDA GBUF+HCENT+4 ; GET THE NUMBER OF FILES  
				STA ENTCNTL ; CONTAINED IN THIS DIRECTORY  
				LDA GBUF+HCENT+5   
				STA ENTCNTH   
				LDA GBUF+HCMP+4 ; TEST BACKWARD COMPATIBILITY  
				BEQ MOVHEAD   
ERRCOMP			 LDA #CPTERR ; TELL THEM THIS DIRECTORY IS NOT COMPATABLE  
NONAME			 EQU *   
FNDERR1			 SEC    
				RTS    
MOVHEAD			 JSR MOVHED0 ; MOVE INFO ABOUT THIS DIRECTORY  
				JMP LOOKFIL0 ; DO NEXT LOCAL PATHNAME  
*     
MOVHED0			 LDX #$A ; MOVE INFO ABOUT THIS DIRECTORY  
MOVHED1			 LDA GBUF+HCRDT+4,X   
				STA H.CREDT,X   
				DEX    
				BPL MOVHED1   
				RTS    
*     
				PAGE    
*     
*     
FILFOUND		 EQU *   
ENTADR			 LDA H.MAXENT ; FIGURE OUT WHICH IS ENTRY NUMBER THIS IS.  
				SEC    
				SBC CNTENT ; MAX ENTRIES - COUNT ENTRIES + 1 = ENTRY NUMBER  
				ADC #0 ; (CARRY IS/WAS SET)  
				STA D.ENTNUM   
				LDA BLOKNML   
				STA D.ENTBLK   
				LDA BLOKNMH ; AND INDICATE BLOCK NUMBER OF THIS DIRECTORY.  
				STA D.ENTBLK+1   
				CLC    
				RTS    
*     
LOOKNAM			 LDA H.MAXENT ; RESET COUNT OF FILES PER BLOCK  
				STA CNTENT   
				LDA #GBUF/256   
				STA DRBUFPH   
				LDA #4   
LOKNAM1			 STA DRBUFPL ; RESET INDIRECT POINTER TO GBUF  
				BCS LOKNAM2 ; BRANCH IF THIS BLOCK CONTAINS A HEADER  
				LDY #D.STOR   
				LDA (DRBUFPL),Y ; GET LENGTH OF NAME IN DIRECTORY  
				BNE ISNAME ; BRANCH IF THERE IS A NAME.  
				LDA NOFREE ; TEST TO SEE IF A FREE ENTRY HAS BEEN DECLARED.  
				BNE LOKNAM2 ; YES BUMP TO NEXT ENTRY  
				JSR ENTADR ; SET ADDRESS FOR CURRENT ENTRY  
				INC NOFREE ; INDICATE A FREE SPOT HAS BEEN FOUND  
				BNE LOKNAM2 ; BRANCH ALWAYS.  
*     
ISNAME			 AND #$F ; STRIP TYPE (THIS IS CHECKED BY 'FILFOUND')  
				INC TOTENT ; (BUMP COUNT OF VALID FILES FOUND)  
				CMP (PATHNML),Y ; ARE BOTH NAMES OF THE SAME LENGTH?  
				BNE LOKNAM2 ; NO, BUMP TO NEXT ENTRY  
				TAY    
CMPNAME			 LDA (DRBUFPL),Y ; COMPARE NAMES LETTER BY LETTER  
				CMP (PATHNML),Y   
				BNE LOKNAM2   
				DEY  ; HAVE ALL LETTERS BEEN COMPARED?  
				BNE CMPNAME ; NO, CONTINUE..  
				CLC  ; BY GOLLY, WE GOT US A MATCH!  
				RTS    
*     
LOKNAM2			 DEC CNTENT ; HAVE WE CHECKED ALL POSSIBLE ENTRIES IN THIS BLOCK?  
				BEQ NONAME ; YES, GIVE UP.  
				LDA H.ENTLN ; ADD ENTRY LENGTH TO CURRENT POINTER  
				CLC    
				ADC DRBUFPL   
				BCC LOKNAM1 ; BRANCH IF WE'RE STILL IN THE FIRST PAGE.  
				INC DRBUFPH ; LOOK ON SECOND PAGE  
				CLC  ; CARRY SHOULD ALWAYS BE CLEAR BEFORE LOOKING AT NEXT.  
				BCC LOKNAM1 ; BRANCH ALWAYS...  
				PAGE    
*     
*     
PREPROOT		 JSR FINDVOL ; FIND CORRECT VOLUME AND DEVICE NUMBER  
				BCC ROOT1 ; BRANCH IF IT WAS FOUND.  
ROOT0			 JSR LOOKVOL ; OTHERWISE LOOK ON ALL DEVICES.  
				BCS SRITZ ; CAN'T FIND IT.  
ROOT1			 LDA #0 ; ZERO OUT DIRECTORY TEMPS  
				LDY #42 ; (DECIMAL)  
CLRDSP			 STA D.DEV,Y   
				DEY    
				BPL CLRDSP   
				LDY #VCBDEV ; SET UP DEVICE NUMBER  
				LDA (VCBPTR),Y   
				STA DEVNUM   
				STA D.DEV ; FOR FUTURE REFERENCE  
				INY    
				LDA (VCBPTR),Y ; GET CURRENT STATUS OF THIS VOLUME  
				STA V.STATUS   
				LDY #VCBROOT ; GET BLOCK ADDRESS OF ROOT DIRECTORY TOO.  
				LDA (VCBPTR),Y   
				STA BLOKNML   
				STA D.HEAD ; PRESERVE AS HEADER  
				INY    
				LDA (VCBPTR),Y   
				STA BLOKNMH   
				STA D.HEAD+1   
				JSR RDGBUF ; GO READ IN ROOT  
				BCC ROOT2 ; BRANCH IF NO ERROR  
				PHA  ; SAVE ERROR CODE  
				LDY #VCBSTAT ; CHECK THIS BUGGER FOR AN OPEN FILE.  
				LDA (VCBPTR),Y   
				ASL A ; (SHIFT OPEN STATUS INTO CARRY)  
				PLA  ; GET ERROR CODE AGAIN  
				BCS ROOTERR ; BRANCH IF ERROR NEEDS TO BE REPORTED  
				BNE ROOT0 ; OTHERWISE, LOOK ELSEWHERE (BRANCH ALWAYS).  
*     
ROOT2			 JSR CHKROOT ; VERIFY ROOT NAME  
				BEQ ROOT3 ; BRANCH IF MATCHED.  
				LDY #VCBSTAT ; TEST FOR OPEN FILES ON THIS VOLUME BEFORE  
				LDA (VCBPTR),Y ; LOOKING FOR IT ELSEWHERE.  
				BPL ROOT0   
				JSR USRREQ ; REQUEST USER MOUNT VOLUME  
				BCC ROOT1 ; USER SAID S/HE DID-- CHECK IT  
				LDA #VNFERR ; REPORT VOLUME NOT FOUND ERR IF REFUSE TO INSERT  
SRITZ			 RTS    
*     
				PAGE    
ROOT3			 LDY #$F ; (NOTE: X CONTAINS THE LENGTH OF THE ROOT NAME)  
ROOTINFO		 LDA GBUF+HCRDT+3,Y ; SAVE HEADER INFO.  
				STA V.STATUS,Y   
				DEY    
				BNE ROOTINFO ; LOOP TIL ALL 15 BYTES MOVED  
				LDA H.FCNT   
				STA ENTCNTL   
				LDA H.FCNT+1   
				STA ENTCNTH   
				TXA  ; NOW THAT ROOT IS IDENTIFIED, ADJUST  
				SEC  ; PATH NAME POINTER TO NEXT NAME IN THE PATH  
				ADC PATHNML   
				STA PATHNML   
				CLC  ; INDICATE NO ERROR  
ROOTERR			 RTS    
*     
*     
CHKROOT			 LDY #0 ; GET LENGTH OF NAME  
				LDA (PATHNML),Y   
				TAY    
				TAX  ; SAVE IN X FOR LATTER ADJUSTMENT TO PATH POINTER  
				EOR GBUF+4   
				AND #$F ; DOES PATHNAME HAVE SAME LENGTH AS DIRECTORY NAME?  
				BNE NOTROOT ; BRANCH IF NOT  
CKROOT1			 LDA (PATHNML),Y ; COMPARE CHARACTER BY CHARACTER  
				CMP GBUF+4,Y   
				BNE NOTROOT   
				DEY    
				BNE CKROOT1 ; LOOP UNTIL ALL CHARACTERS MATCH  
NOTROOT			 RTS    
*     
				PAGE    
FINDVOL			 LDA #VCB/256 ; SEARCH VCB FOR VOLUME NAME  
				STA VCBPTR+1   
				LDA #0   
				STA D.DEV   
				STA VCBPTR   
FNDVOL1			 PHA  ; SAVE LAST SEARCH POSITION  
				TAX    
				LDY #0 ; (INDEX TO PATHNAME POINTER)  
				LDA VCB,X ; GET LENGTH OF VOLUME NAME TO COMPARE  
				BEQ NXTVCB ; BRANCH IF VCB ENTRY IS EMPTY  
				CMP (PATHNML),Y ; ARE NAMES OF SAME LENGTH?  
				BNE NXTVCB ; NO, INDEX NEXT VCB  
				CLC  ; SCAN NAME BACKWARDS  
				TAY    
				TXA    
				ADC VCB,X   
				TAX  ; NOW BOTH INDEXES POINT TO LAST CHARACTER OF THE NAMES TO COMPARE  
VOLNAM			 LDA (PATHNML),Y   
				CMP VCB,X   
				BNE NXTVCB   
				DEX    
				DEY    
				BNE VOLNAM ; CHECK ALL CHARACTERS  
				PLA  ; SINCE A MATCH IS FOUND  
				STA VCBPTR ; SET UP INDEX TO VCB ENTRY  
				TAX   
				LDA VCB+VCBSWAP,X ; BRANCH IF  
				BEQ FOUNDVOL ; VOLUME NOT SWAPPED  
				JSR SWAPIN ; IF USER REALLY WANTS IT, THEN BRING IN IF SWAPPED  
				BCC FOUNDVOL ; BRANCH IF SUCCESS  
				LDA #XIOERROR ; USER REFUSES TO MOUNT  
				RTS     
FOUNDVOL		 CLC  ; INDICATE VOLUME FOUND  
				RTS     
*      
NXTVCB			 PLA  ; GET CURRENT INDEX AGAIN.  
				CLC     
				ADC #VCBSIZE ; VCB ENTRY LENGTH.  
				BCC FNDVOL1 ; BRANCH IF THER IS ANOTHER TO CHECK  
				RTS  ; RETURN WITH CARRY SET TO SHOW FAILURE.  
				PAGE     
*      
*      
LOOKVOL			 LDX #12 ; (1) COUNT+(12)DEVICE LIST  
LOOKVOL1		 LDA BLKDLST,X ; EXTRN  
				STA SCRTCH,X ; MY CHANGEABLE COPY  
				DEX     
				BPL LOOKVOL1 ; WORK BACKWARDS SO  
				STA TOTDEVS ; ENTRY ZERO IS TOTAL DEVICES LISTED  
				INX  ; MAKE XREG = ZERO  
LOKDEV1			 INX     
				STX SCRTCH    
				LDA SCRTCH,X    
				CMP D.DEV    
				BEQ NXTDEV ; DON'T LOOK AGAIN ON A DRIVE THAT HAS BEEN CHECKED  
				STA DEVNUM ; CHECK FOR DEVICE ALREADY LOGGED IN A VCB  
				JSR DEVVCB ; (CARRY CLEAR IF IT'S THERE)  
				BCC LOKVOL1    
				LDA #0 ; FIND A FREE VCB TO LOG THIS GUY IN  
ENTVCB			 TAX  ; INDEX TO NEXT VCB ENTRY  
				LDA VCB,X    
				BEQ FREEVCB ; FOUND A FREE SPOT.  
				TXA  ; NOW INDEX TO NEXT, AND KEEP LOOKIN  
				CLC     
				ADC #VCBSIZE ; (EACH VCB ENTRY IS 32 BYTES)  
				BCC ENTVCB ; BRANCH IF MORE TO FIND  
				LDA #0    
ENTVCB2			 EQU * ; SEE IF WE CAN REPLACE A DEVICE  
				TAX     
				LDA VCB+VCBSTAT,X ; VCB HAS FILES OPEN?  
				BEQ FREEVCB ; NO, USE IT!  
				TXA     
				CLC     
				ADC #VCBSIZE ; SEARCH NEXT VCB ENTRY  
				BCC ENTVCB2    
				RTS  ; FAILED TO FIND A FREE VCB ENTRY  
*      
CHKVLOG			 LDY #0 ; MAKE SURE VOLUME WAS ACTUALLY LOGGED IN  
				LDA (VCBPTR),Y    
				BNE FOUNDVOL ; AH, MADE IT...  
				LDA #DUPVOL ; WELL, NOT QUITE, THIS VOLUME CAN'T BE LOGGED  
				SEC     
				RTS     
				PAGE     
*      
FREEVCB			 STX VCBPTR ; NOW THIS IS THE POINTER TO A FREE VCB  
				LDA #2 ; ROOT DIRECTORIES ALWAYS AT BLOCK 2  
				LDX #0    
				BEQ GETROOT ; BRANCH ALWAYS  
LOKVOL1			 LDY #VCBSTAT ; MAKE SURE NO FILES ARE ACTIVE ON  
				LDA (VCBPTR),Y ; THE VOLUME BEFORE LOGGING IT IN.  
				BMI SNSWIT ; BRANCH IF FILES ACTIVE  
				LDY #VCBROOT+1 ; GET ADDRESS OF ROOT DIRECTORY  
				LDA (VCBPTR),Y ; HIGH FIRST.  
				TAX     
				DEY  ; THEN LOW.  
				LDA (VCBPTR),Y    
GETROOT			 JSR GETROT0    
				BCC LOKVOL2 ; BRANCH IF SUCCESSFULLY READ.  
				LDA #0 ; OTHERWISE, TAKE THIS DEVICE OUT OF VCB  
				TAY     
				STA (VCBPTR),Y ; (VOLUME 'OFF LINE')  
				BEQ NXTDEV ; BRANCH ALWAYS  
*      
LOKVOL2			 JSR LOGVCB ; GO UPDATE VCB TO INCLUDE CURRENT VOLUME INFO  
				BCS NXTDEV ; IF NOT A SOS DISKETTE, SKIP TO NEXT DEVICE  
				JSR CHKROOT ; GO COMPARE TO SEE IF WE FOUND WHAT WE'RE  
				BEQ CHKVLOG ; LOOKING FOR...  
*      
NXTDEV			 LDX SCRTCH ; LOOK AT OTHER DEVICES?  
				CPX TOTDEVS    
				BCC LOKDEV1 ; YES.  
				LDA #VNFERR ; REPORT VOLUME NOT FOUND.  
				RTS     
*      
SNSWIT			 EQU * ; SENSE DSWITCH  
				LDY #VCBDEV    
				LDA (VCBPTR),Y    
				STA DEVNUM ; MAKE SURE DEVICE NUMBER IS CURRENT  
				JSR TWRPROT1 ; USES DEVNUM  
				LDA DSWGLOB ; DISK SWITCH GLOBAL  
				BEQ NXTDEV ; BRANCH IF NO DISK SWITCH  
				JSR VERFYVOL ; COMPARES VCBPTR VS. DEVNUM CONTENTS  
				BCC NXTDEV ; BRANCH IF DISK HAS NOT BEEN SWITCHED  
				JSR CHKROOT ; COMPARES PATHNML VS. GBUF  
				BNE NXTDEV ; IGNORE IF NOT WHAT WE ARE LOOKING FOR  
				LDX #0 ; LOOK FOR FREE  
				JSR SNSWIT1    
				BCS NXTDEV ; ANY ERRORS LOGGING IN THE NEW VOLUME  
				JMP CHKVLOG ; MAKE SURE THE NEW VOLUME IS LOGGED  
SNSWIT1			 LDA VCB,X ; VCB ENTRY  
				BEQ SNSWIT2 ; BRANCH IF FOUND  
				TXA     
				CLC     
				ADC #VCBSIZE ; LOOK AT NEXT VCB AREA  
				TAX     
				BCC SNSWIT1    
				RTS  ; CAN'T BE LOGGED IN!  
SNSWIT2			 LDA #0    
				STA DUPLFLAG ; TURN OFF DUPLICATE VOLUME FLAG  
				STX VCBPTR    
				JSR LOGVCB1 ; PARTIALLY LOG IN THE NEW VOLUME  
				BCS NONSOS ; CS MEANS NONSOS ERROR  
				LDA DUPLFLAG ; WAS IT A DUPLICATE VOLUME?  
				BNE SNSWIT6 ; BRANCH IF YES  
				LDY #VCBSWAP ; BY MAKING SWAP BYTE NON ZERO  
				LDA #1    
				STA (VCBPTR),Y ; SO SWAPOUT WON'T AFFECT  
				LDA DEVNUM ; A REG PASSES DEVNUM TO SWAPOUT  
				JSR SWAPOUT ; OLD ACTIVE MOUNT MUST BE SWAPPED  
				BCC SNSWIT3    
				LDA #XIOERROR ; USER REFUSED TO REPLACE OLD VOLUME  
				RTS     
SNSWIT3			 LDY #VCBSWAP ; NOW LOG IN THE NEW ALL THE WAY  
				LDA #0    
				STA (VCBPTR),Y    
SNSWIT4			 JSR VERFYVOL ; DON'T BOTHER TO ASK IF NEW VOLUME IS ALREADY MOUNTED  
				BCC SNSWIT5 ; BRANCH IF NEW VOLUME ON LINE  
				JSR USRREQ ; ASK USER TO REMOUNT NEW VOLUME  
				BCC SNSWIT4 ; USER SAYS THEY DID: CHECK IT OUT  
				LDA #VNFERR    
SNSWIT5			 RTS     
SNSWIT6			 LDA #DUPVOL    
				SEC     
				RTS     
				PAGE     
*      
NONSOS			 LDA #NOTSOS ; TELL EM IT'S NOT A SOS DISK (COULD BE PASCAL)  
				RTS  ; CARRY SHOULD ALREADY BE SET  
*      
*      
DEVVCB			 LDA #0 ; SCAN VCB FOR DEVICE SPECIFIED IN 'DEVNUM'  
DVCB1			 TAX  ; FIRST TEST FOR VALID VCB.  
				LDA VCB,X    
				BEQ DVCB2    
				LDA VCB+VCBSWAP,X ; SWAPPED VOLUMES DON'T COUNT  
				BNE DVCB2 ; AS LOGGED IN  
				LDA VCB+VCBDEV,X ; GET DEVICE NUMBER  
				CMP DEVNUM ; TEST AGAINST REQUESTED DEVICE  
				BEQ FOUNDEV ; YES, SET UP A POINTER TO IT  
DVCB2			 TXA  ; BUMP TO NEXT VCB  
				CLC     
				ADC #VCBSIZE    
				BCC DVCB1 ; BRANCH IF MORE TO LOOK AT.  
				RTS  ; RETURN CARRY SET TO INDICATE NOT FOUND  
*      
TSTDUPVOL		 LDX VCBPTR ; PRESERVE CURRENT ADDR OF FREE VCB  
				LDA #0 ; LOOK FOR A CURRENTLY LOGGED ON VOLUME OF THE SAME NAME.  
TSDUPV1			 STA VCBPTR   
				JSR CMPVCB   
				BCS TSDUPV2 ; BRANCH IF NO MATCH.  
				LDY #VCBSTAT ; TEST FOR ANY OPEN FILES.  
				LDA (VCBPTR),Y   
				BMI FOUNDDUP ; TELL THE SUCKER HE CAN'T LOOK AT THIS VOLUME!  
				LDA #0 ; TAKE DUPLICATE OFF LINE IF NO OPEN FILES.  
				TAY    
				STA (VCBPTR),Y   
				BEQ NODUPVOL ; RETURN THAT ALL IS OK TO LOG IN NEW.  
TSDUPV2			 LDA VCBPTR   
				CLC    
				ADC #VCBSIZE ; BUMP TO NEXT ENTRY.  
				BCC TSDUPV1   
NODUPVOL		 EQU *   
FOUNDEV			 CLC    
FNDDUP1			 STX VCBPTR   
				RTS    
*     
FOUNDDUP		 STA DUPLFLAG ; A DUPLICATE HAS BEEN DETECTED.  
				SEC  ; INDICATE ERROR  
				LDA VCBPTR ; SAVE ADDRESS OF DUPLICATE  
				STA VCBENTRY   
				BCS FNDDUP1 ; BRANCH ALWAYS TAKEN  
				PAGE    
*     
*     
LOGVCB			 LDY #VCBNML ; IS THIS A PREVIOUSLY LOGGED IN VOLUME  
				LDA (VCBPTR),Y ; (ACC=0?)  
				BEQ LOGVCB1 ; NO, GO AHEAD AND PREPARE VCB.  
				JSR CMPVCB ; DOES VCB MATCH VOLUME READ?  
				BCC VCBLOGD ; YES, DON'T DISTURB IT.  
LOGVCB1			 LDA #0 ; ZERO OUT VCB ENTRY  
				LDY #VCBSIZE-1   
ZERVCB			 STA (VCBPTR),Y   
				DEY    
				BPL ZERVCB   
				JSR TSTSOS ; MAKE SURE IT'S A SOS DISKETTE.  
				BCS VCBLOGD ; IF NOT, RETURN CARRY SET.  
				JSR TSTDUPVOL ; FIND OUT IF A DUPLICATE WITH OPEN FILES ALREADY EXISTS  
				BCS NOTLOG0   
				LDA GBUF+4 ; MOVE VOLUME NAME TO VCB  
				AND #$F ; STRIP ROOT MARKER  
				TAY    
				PHA    
MOVOLNM			 LDA GBUF+4,Y   
				STA (VCBPTR),Y   
				DEY    
				BNE MOVOLNM   
				PLA  ; GET LENGTH AGAIN  
				STA (VCBPTR),Y ; SAVE THAT TOO.  
				LDY #VCBDEV ; SAVE DEVICE NUMBER ALSO.  
				LDA DEVNUM   
				STA (VCBPTR),Y   
				JSR CLEARBMS ; MARKS THIS DEVICES OLD BITMAPS AS INVALID (A REG PASSED)  
				LDA GBUF+VTBLK+4 ; AND TOTOL NUMBER OF BLOCKS ON THIS UNIT,  
				LDY #VCBTBLK   
				STA (VCBPTR),Y   
				LDA GBUF+VTBLK+5   
				INY    
				STA (VCBPTR),Y   
				LDY #VCBROOT   
				LDA BLOKNML ; AND ADDRESS OF ROOT DIRECTORY  
				STA (VCBPTR),Y   
				INY    
				LDA BLOKNMH   
				STA (VCBPTR),Y   
				LDY #VCBDMAP   
				LDA GBUF+VBMAP+4 ; AND LASTLY, THE ADDRESS  
				STA (VCBPTR),Y ; OF THE FIRST BITMAP  
				LDA GBUF+VBMAP+5   
				INY    
				STA (VCBPTR),Y   
				CLC  ; INDICATE THAT IT WAS LOGGED IF POSIBLE.  
VCBLOGD			 RTS    
NOTLOG0			 JMP NOTLOG1   
				PAGE    
CMPVCB			 LDA GBUF+4 ; COMPARE VOLUME NAME IN VCB  
				AND #$F   
				LDY #VCBNML ; WITH NAME IN DIRECTORY  
				CMP (VCBPTR),Y ; ARE THEY SAME LENGTH  
				BNE NOTSAME  
				TAY   
VCBCMP1			 LDA GBUF+4,Y  
				CMP (VCBPTR),Y  
				BNE NOTSAME  
				DEY   
				BNE VCBCMP1  
				CLC ; INDICATE MATCH.  
				RTS   
*    
VERFYVOL		 LDX #0 ; READ IN ROOT DIRECTORY HEADER.  
				LDA #2  
				JSR GETROT0  
				BCS NOVRFY1 ; PASS BACK WHATEVER OTHER ERROR OCCURS.  
				JSR CMPVCB ; TEST ROOT WITH VOLUME NAME IN VCB.  
				BCC NOVRFY ; BRANCH IF ROOT MATCHES VCB  
				LDA #0 ; OTHERWISE, PASS BACK FOREIGN VOLUME ERROR (SOS OR UCSD)  
NOVRFY			 RTS ; RETURN RESULTS IN CARRY.  
NOVRFY1			 LDA #VNFERR ; NOTHING IN DRIVE  
				RTS   
*    
GETROT0			 STA BLOKNML  
				STX BLOKNMH ; STORE ADDRESS AND READ IN ROOT  
				JSR RDGBUF  
				BCC RETROT2 ; BRANCH IF SUCCESSFULLY READ.  
NOTSAME			 EQU *  
				SEC ; INDICATE ERROR  
RETROT2			 RTS   
*    
NOTLOG1			 LDX VCBPTR ; LOAD THE VCB ADDRESS  
				LDA VCBENTRY ; OF THE DUPLICATE VOLUME  
				STA VCBPTR  
				STX VCBENTRY ; AND SAVE THE FREE VCB SPACE ADDR  
				LDY #VCBDEV ; IS DUPLICATE ON SAME DEVICE?  
				LDA DEVNUM  
				CMP (VCBPTR),Y  
				BNE NOTLOG2 ; BRANCH IF NOT  
				JSR SWAPIN ; SWAP IN IF NECESSARY  
				LDA #0  
				STA DUPLFLAG ; NO MORE DUPLICATE VOLUME STATUS  
				LDA VCBPTR ; MAKE CHKROOT WORK IN A MOMENT  
				STA PATHNML ; THIS IS INCREDIBLY GROSS  
;				 BUT IS A RESULT OF MAKING VOLUME A SPECIAL    
;				 CASE OF SEARCHING ALL DEVICES FOR    
;				 A KNOWN VOLUME    
CLC				    
RTS				    
NOTLOG2			 LDA VCBENTRY ; REACH HERE IF REAL DUPLICATE VOLUME  
STA				 VCBPTR ; RESOTRE FREE VCB PTR  
CLC				    
RTS				 ; DUPLICATE VOLUME PRETENDS TO BE NO ERROR  
PAGE			    
*    
TSFRBLK			 LDY #VCBTFRE+1    
LDA				 (VCBPTR),Y ; FIND OUT IF ENOUGH FREE BLOCKS  
DEY				 ; ARE AVAILABLE TO ACCOMODATE REQEST.  
ORA				 (VCBPTR),Y ; BUT FIRST FIND OUT IF WE GOT A PROPER COUNT FOR THIS VOLUME.  
BNE				 CMPFREB ; BRANCH IF COUNT IS NON-ZERO  
DEY				 ; IF ZERO, THEN COUNT MUST BE TAKEN  
LDA				 (VCBPTR),Y ; GET HIGH TOTAL BLKS  
TAX				 ; SAVE IT  
DEY				 ; GET LOW  
LDA				 (VCBPTR),Y ; TOTAL BLKS  
BNE				 TSFR01    
DEX				 ; ADJUST FOR BITMAP BLOCK BOUNDARY  
TSFR01			 TXA    
LSR				 A ; DIVIDE BY 16. THE RESULT IS THE NUMBER  
LSR				 A ; OF BIT MAPS TO BE SEARCHED.  
LSR				 A    
LSR				 A    
STA				 BMCNT ; SAVE IT.  
LDA				 #0 ; START COUNT AT ZERO.  
STA				 SCRTCH    
STA				 SCRTCH+1    
LDA				 #$FF ; MARK 'FIRST FREE' TEMP AS UNKNOWN  
STA				 NOFREE    
LDY				 #VCBDEV ; MAKE SURE BIT MAP IS UP TO DATE  
LDA				 (VCBPTR),Y ; GET DEVICE NUMBER  
TAX				 ; PASS TO 'UPBMAP' IN X  
JSR				 UPBMAP ; (NOTHING HAPPENS IF IT DON'T HAFTA.)  
				BCS TFBERR ; BRANCH IF WE GOT TROUBLE,  
				LDY #VCBDMAP ; GET ADDRESS OF FIRST BIT MAP.  
				LDA (VCBPTR),Y   
				STA BLOKNML   
				INY  ; (FOR HIGH ADDRESS)  
				LDA (VCBPTR),Y   
				STA BLOKNMH   
BMAPRD			 JSR RDGBUF ; USE G(ENERAL)BUFF(ER) FOR TEMPORARY  
				BCS TFBERR ; SPACE TO COUNT FREE BLOCKS (BITS)  
				JSR COUNT ; GO COUNT EM  
				DEC BMCNT ; WAS THAT THE LAST BIT MAP?  
				BMI CHGVCB ; IF SO, GO CHANGE FCB TO AVOID DOING THIS AGAIN!  
				INC BLOKNML ; NOTE: THE ORGANIZATION OF THE BIT MAPS  
				BNE BMAPRD ; ARE CONTIGUOUS FOR SOS VERSION 0  
				INC BLOKNMH ; IF SOME OTHER ORGANIZATION IS IMPLEMENTED, THIS CODE  
				JMP BMAPRD ; MUST BE CHANGED!  
				PAGE    
*     
CHGVCB			 LDY #VCBCMAP ; MARK WHICH BLOCK HAD FIRST FREE SPACE  
				LDA NOFREE   
				BMI DSKFULL ; BRANCH IF NO FREE SPACE WAS FOUND.  
				STA (VCBPTR),Y   
				LDY #VCBTFRE+1 ; UPDATE THE FREE COUNT.  
				LDA SCRTCH+1 ; GET HIGH COUNT BYTE  
				STA (VCBPTR),Y ; UPDATE VOLUME CONTROL BLOCK.  
				DEY    
				LDA SCRTCH   
				STA (VCBPTR),Y ; AND LOW BYTE TOO...  
CMPFREB			 LDA (VCBPTR),Y ; COMPARE TOTAL AVAILABLE  
				SEC    
				SBC REQL ; FREE BLOCKS ON THIS VOLUME.  
				INY    
				LDA (VCBPTR),Y   
				SBC REQH   
				BCC DSKFULL   
				CLC    
				RTS    
DSKFULL			 LDA #OVRERR   
				SEC    
TFBERR			 RTS    
				PAGE    
*     
COUNT			 LDY #0 ; BEGIN AT THE BEGINNING.  
FRCONT			 LDA GBUF,Y ; GET BIT PATTERN  
				BEQ FRCNT1 ; DON'T BOTHER COUNTING NOTHIN'  
				JSR CNTFREE   
FRCNT1			 LDA GBUF+$100,Y ; DO BOTH PAGES WITH SAME LOOP  
				BEQ FRCNT2   
				JSR CNTFREE   
FRCNT2			 INY    
				BNE FRCONT ; LOOP TILL ALL 512 BYTES COUNTED  
				BIT NOFREE ; HAS FIRST BLOCK WITH FREE SPACE BEEN FOUND YET?  
				BPL FRCNT3 ; BRANCH IF IT HAS.  
				LDA SCRTCH ; TEST TO SEE IF ANY BLOCKS WERE COUNTED  
				ORA SCRTCH+1   
				BEQ FRCNT3 ; BRANCH IF NONE COUNTED.  
				LDY #VCBTBLK+1   
				LDA (VCBPTR),Y ; SHOW THIS MAP IS FIRST WITH FREE SPACE  
				SEC  ; CORRECT FOR EXACT MULTIPLES OF $1000  
				SBC #$01   
				LSR A   
				LSR A   
				LSR A   
				LSR A   
				SEC  ; SUBTRACT COUNTDOWN FROM TOTAL BIT MAPS  
				SBC BMCNT   
				STA NOFREE   
FRCNT3			 RTS    
*     
CNTFREE			 ASL A ; COUNT THE NUMBER OF BITS IN THIS BYTE.  
				BCC CFREE1   
				INC SCRTCH   
				BNE CFREE1   
				INC SCRTCH+1   
CFREE1			 TAX    
				BNE CNTFREE ; LOOP UNTIL ALL BITS COUNTED.  
				RTS    
				    
				CHN ALLOC,4,1   
				    
*************************************************************************  
* END OF APPLE /// SOS 1.3 SOURCE CODE FILE: FNDFIL
*************************************************************************


*--------------------------------------
MAN
SAVE /A3OSX.BUILD/SOS.13/sos.s.bfm.f
LOAD /A3OSX.BUILD/SOS.13/sos.s
ASM
