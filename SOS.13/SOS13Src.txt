================================================================================================
FILE: "SOS.ALLOC.TEXT"
================================================================================================
*************************************************************************
* APPLE /// SOS 1.3 SOURCE CODE FILE: ALLOC
*************************************************************************
* ASSEMBLER: APPLE ][ 6502 ASSEMBLER from APPLE COMPUTER TOOLKIT

*
DEALLOC				stx BMCNT ; SAVE HIGH ORDER ADDRESS OF BLOCK TO BE FREED.
					pha ;SAVE IT
					lda VCB+VCBTBLK+1,X ; DISK ADDRESS IS CHECKED
					cmp BMCNT ; TO SEE IF IT MAKES SENSE
					pla ; RESTORE
					bcc DEALERR1 ; BRANCH IF IMPOSSIBLE
					tax
					and #$7 ; GET THE BIT TO BE OR-ED IN.
					tay
					lda WHICHBIT,Y ; (SHIFTING TAKES 7 BYTES, BUT IS SLOWER)
					sta NOFREE ; SAVE BIT PATTERN
					txa ; GET LOW BLOCK ADDRESS AGAIN.
					lsr BMCNT
					ror A ; GET POINTER TO BYTE IN BITMAP THAT REPRESENTS
					lsr BMCNT ; THE BLOCK ADDRESS.
					ror A
					lsr BMCNT
					ror A
					sta BMPTR ; SAVE POINTER.
					lsr BMCNT ; NOW TRANSFER BIT WHICH SPECIFIES WHICH PAGE OF BITMAP.
					rol HALF
					ldx BMTAB ; (THIS POINTS TO THE TABLE FOR THE BITMAP BUFFER USED).
					lda BMACMAP,X ; WHAT IS THE CURRENT MAP
					cmp BMCNT ; IS IN CORE BIT MAP THE ONE WE WANT?
					beq DEALL1 ; BRANCH IF IN-CORE IS CORRECT.
					jsr BMAPUP ; PUT CURRENT MAP AWAY.
					bcs DEALERR ; PASS BACK ANY ERROR.
					lda BMCNT ; GET DESIRED MAP NUMBER.
					ldy #VCBCMAP
					sta (VCBPTR),Y ; AND MAKE IT CURRENT.
					ldx BMTAB
					lda BMADEV,X
					jsr GTBMAP ; READ IT INTO THE BUFFER,
					bcs DEALERR
DEALL1				ldy BMPTR ; INDEX TO BYTE.
					lsr HALF
					bcc DEALL2 ; BRANCH IF ON PAGE ONE OF BITMAP.
					inc BMADR+1
DEALL2				lda NOFREE ; THE INDIVIDUAL BIT.
					ora (BMADR),Y
					sta (BMADR),Y
					bcc DEALL3 ; BRANCH IF ADDRESS IS PROPER
					dec BMADR+1
DEALL3				ldx BMTAB ; MARK BITMAP AS MODIFIED.
					lda #$80
					ora BMASTAT,X
					sta BMASTAT,X
					clc
DEALERR				rts
DEALERR1			lda #BITMAPADR ; BIT MAP BLOCK NUMBER IMPOSSIBLE
					sec ; SAY BIT MAP DISK ADDRESS WRONG
					rts; (PROBABLY DATA MASQUERADING AS INDEX BLOCK)
*
WHICHBIT DFB $80,$40,$20,$10
DFB 8,4,2,1
*
*
*PAGE
*
ALCIDXS				lda #0 ; ALLOCATION OF THE INDEXES ALWAYS FILLS IN
					sta SAPTR ;				staRTING AT THE BEGINNING OF THE BLOCK.
					jsr ALC1BLK ; THIS GETS FIRST INDEX AND SETS UP A
					bcs ERRALC1 ; POINTER TO THE FREE BLOCKS (TO AVOID
ALIDX1				ldy SAPTR ; SCANNING THE WHOLE BLOCK EVERY TIME).
					sta (TINDX),Y ; SAVE INDEX BLOCK ADDRESS (LOW)
					inc TINDX+1
					lda SCRTCH+1 ; GET HIGH BYTE OF ADDRESS

					sta (TINDX),Y ; (AND SAVE IT)
					dec TINDX+1
					dec REQL ; HAS REQUEST BEEN SATIFIED?
					beq ALDXEND ; (CARRY IS CLEAR)
					inc SAPTR ; BUMP INDEX POINTER
					ldy BMPTR ; GET INDEX POINTER TO LAST ACCESSED BIT GROUP
					lda HALF ; WHICH HALF OF MAP? (BOTH BMPTR & HALF SET UP BY 'ALC1BLK')
					bne SECNDHAF
					jsr GETBITS1 ; GET NEXT FREE BLOCK ADDRESS.
					bcc ALIDX1 ; BRANCH IF NO ERROR
ERRALC1				rts
*
					clc
SECNDHAF			jsr GETBITS2 ; GET NEXT FREE BLOCK ADDRESS FROM SECOND HALF OF BIT MAP
					bcc ALIDX1 ; BRANCH IF NO ERROR.
ALDXEND				rts ; RETURN				staTUS (CARRY SET INDICATES ERROR)
*
*
ALC1BLK				rts FNDBMAP ; GET ADDRESS OF BIT MAP IN 'BMADR'
					bcs ERRALC1 ; BRANCH IF ERROR ENCOUNTERED
SRCHFRE				ldy #0 ;				staRT SEARCH AT BEGINNING OF BIT MAP BLOCK
					sty HALF ; INDICATE WHICH HALF (PAGE) WE'RE SEARCHING.
GETBITS1			lda (BMADR),Y
					bne BITFOUND ; FREE BLOCKS ARE INDICATED BY 'ON' BITS
					iny
					bne GETBITS1 ; CHECK ALL OF 'EM IN FIRST PAGE.
					inc BMADR+1 ; BUMP HIGH ADDRESS OF CURRENT BITMAP
					inc HALF ; INDICATE SEARCH HAS PROGRESSED TO PAGE 2
					inc BASVAL ; BASE VALUE= BASE ADDRESS/2048
GETBITS2			lda (BMADR),Y ; SEARCH SECOND HALF FOR FREE BLOCK
					bne BITFOUND
					iny
					bne GETBITS2
					dec BMADR+1 ; RESET BIT MAP ADDRESS TO BEGINNING.
					inc BASVAL ; ADD 2048 OFFSET FOR NEXT PAGE
					jsr NXTBMAP ; GET NEXT BITMAP (IF IT EXISTS) AND UPDATE VCB.
					bcc SRCHFRE ; BRANCH IF NO ERROR ENCOUNTERED.
					rts; RETURN ERROR.
*PAGE
*
BITFOUND			sty BMPTR ; SAVE INDX POINTER TO VALID BIT GROUP
					lda BASVAL ; SET UP FOR BLOCK ADDRESS CALCULATION
					sta SCRTCH+1
					tya ; GET ADDRESS OF BIT PATTERN
					asl A ; MULTIPLY THIS AND BASVAL BY 8
					rol SCRTCH+1
					asl A
					rol SCRTCH+1
					asl A
					rol SCRTCH+1
					tax; NOW X= LOW ADDRESS WITHIN 7 OF ACTUAL ADDRESS.
					lda (BMADR),Y ; GET BIT PATTERN AGAIN
					clc ; MARK RIGHT END OF BYTE.
					adcALC ROL A ; FIND LEFT MOST 'ON' BIT
					bcs BOUNCE ; BRANCH IF FOUND.
					inx ; ADJUST LOW ADDRESS
					bne ADCALC ; BRANCH ALWAYS
BOUNCE				lsr A ; RESTORE ALL BUT LEFT MOST BIT TO ORIGINAL POSITION
					bcc BOUNCE ; LOOP UNTIL MARK (SET ABOVE) MOVES INTO CARRY
					sta (BMADR),Y ; UPDATE BITMAP TO SHOW ALLOCATED BLOCK IN USE.
					stx SCRTCH ; SAVE LOW ADDRESS.
					ldx BMTAB ; UPDATE BIT MAP BUFFER				staTUS
					lda #$80 ; INDICATE MAP HAS BEEN MODIFIED
					ora BMASTAT,X ; (X IS EITHER 0 OR 6 FOR
					sta BMASTAT,X ; BUFFER 'A' OR 'B' RESPECTIVELY.)
					ldy #VCBTFRE ; SUBTRACT 1 FROM TOTAL FREE
					lda (VCBPTR),Y ; BLOCKS IN VCB TO ACCOUNT FOR NEWLY
					sbc #1 ; ALLOCATED BLOCK (CARRY IS SET FROM 'BOUNCE')
					sta (VCBPTR),Y
					bcs RET1BLK ; BRANCH IF HI FREE COUNT DOESN'T NEED ADJUSTMENT.
					iny
					lda (VCBPTR),Y ; ADJUST HIGH COUNT.
					sbc #0 ; (CARRY IS CLEAR, SO ACC=ACC-1)
					sta (VCBPTR),Y
RET1BLK				clc ; INDICATE NO ERROR ENCOUNTERED
					lda SCRTCH ; GET ADDRESS LOW IN ACC.
					ldy SCRTCH+1 ; AND HIGH ADDRESS IN Y
					rts ; RETURN ADDRESS OF NEWLY ALLOCATED BLOCK.
*
*PAGE
*
GTTINDX				ldy #VCBDEV ; GET DEVICE NUMBER SO WE DON'T

					ldx #0 ; ANTICPATE USING BUFFER 'A'.
					lda (VCBPTR),Y ; USE THE BUFFER USED BY IT!
					cmp BMADEV ; IS IT IN BUFFER 'A'?
					beq FREEBE ; IF SO, FREE 'B'!
					cmp BMBDEV ; IF NOT, IS IT IN 'B'?
					beq FREEA ; IF SO, FREE UP BUFFER 'A'
					jsr FNDBMAP ; OTHERWISE, FORCE ALLOCATION FOR ONE OF THE BUFFERS
					bcc GTTINDX ; NOW TRY AGAIN.
					rts; RETURN ERROR.
*
FREEBE				ldx #BMTABSZ ; DE-ALLOCATE BUFFER IF NECESSARY
FREEA				stx NOFREE ; SAVE WHICH BUFFER WE'RE LOOKIN AT.
					ldy BMASTAT,X ; DO WE NEED TO WRITE BUFFER TO FREE IT?
					bpl USEBUF ; NO, THEN USE IT.
					stx ZPGTEMP ; SAVE BM BUFFER ID FOR A BIT
					jsr WRTBMAP ; WRITE BM TO OWNING UNIT
					bcs SOMERR1 ; RETURN ANY ERROR (W/O RELEASING BM)
					ldx ZPGTEMP ; FETCH THE BM BUFFER ID
					lda #0
					sta BMASTAT,X ; AND MARK BM BUFFER AS FREE
USEBUF				ldx NOFREE ; GET INDEX TO BUFFER INFO
					lda #0 ; MARK				staTUS OF BUFFER AS FREE.
					sta BMADEV,X ; (DEVICE 0 IS NOT ANY DEVICE)
					ldy TINDX
					sta BMADR
					lda BMAMADR,X ; GET MEMORY ADDRESS OF FREE BUFFER.
					sta TINDX+1
					txa ; SET UP PROPER HI ADDRESS OF BIT MAP TOO...
					eor #BMTABSZ ; SELECT ALTERNATE BIT MAP TABLE.
					sta BMTAB ; (TO INDICATE WHICH IS BITMAP)
					tax
					lda BMAMADR,X ; GET HIGH ADDRESS OF BIT MAP.
					sta BMADR+1
					lda BMBUFBNK ; AND BANK PAIR NUMBER.
					sta SSTIDXH
					sta SISBMADR
					clc ; INDICATE NO ERRORS
SOMERR1				rts
*
*PAGE
NXTBMAP				ldy #VCBTBLK+1 ; BEFORE BUMPING TO NEXT MAP,
					lda (VCBPTR),Y ; CHECK TO BE SURE THERE IS
					lsr A ; INDEED A NEXT MAP!
					lsr A
					lsr A
					lsr A
					ldy #VCBCMAP
					cmp (VCBPTR),Y ; ARE THERE MORE MAPS?
					beq NOMORBIT ; BRANCH IF NO MORE TO LOOK AT.
					lda (VCBPTR),Y ; ADD 1 TO CURRENT MAP
					clc
					adc #1
					sta (VCBPTR),Y
					ldy #VCBDEV
					lda (VCBPTR),Y
					tax; GO WRITE OUT LAST MAP IF NECESSARY
					jsr UPBMAP
					jmp FNDBMAP ; READ NEXT BIT MAP INTO BUFFER
*
GETA.BUF			ldx #0
					beq FRESHMAP
*
GETB.BUF			ldx #BMTABSZ
					bne FRESHMAP ; BRANCH ALWAYS
*
*
FNDBMAP				ldy #VCBDEV ; GET DEVICE NUMBER
					lda (VCBPTR),Y
					ldx #0 ;				staRT WITH MAP 'A'
FNDMAP1				cmp BMADEV,X
					bne TRYMAP2
FRESHMAP			stx BMTAB ; SAVE POINTER TO BIT MAP INFO TABLE
					ldy BMASTAT,X ; IS THIS ONE ALREADY MODIFIED?
					bmi BMFOUND ; YES, RETURN POINTER IN 'BMADR'
					jsr GTBMAP ; OTHERWISE READ IN FRESH BIT MAP
					bcc BMFOUND ; BRANCH IF SUCCESSFUL.
					rts; OTHERWISE, RETURN ERROR.
*
TRYMAP2				dex ; WAS LAST FAILURE MAP 'A'
					bpl FRBMBUF ; NO, MUST FREE UP ONE OF THE BUFFERS
					ldx #BMTABSZ ; TRY BIT MAP BUFFER 'B'.

					jmp FNDMAP1
*PAGE
*
BMFOUND				ldx BMTAB ; WHICH TABLE?
					ldy #VCBCMAP
					lda (VCBPTR),Y
					asl A
					sta BASVAL
					lda BMAMADR,X ; GET HIGH ADDRESS
					sta BMADR+1
					lda BMBUFBNK ; GET BANK NUMBER OF BUFFER BIT MAP BUFFERS
					sta SISBMADR
					lda #0 ; BUFFERS ALWAYS FALL ON A PAGE BOUNDARY
					sta BMADR
					clc ; INDICATE ALL IS VALID AND GOOD!
					rts
*
NOMORBIT			lda #OVRERR ; INDICATE REQUEST CAN'T BE FILLED.
					clc ; INDICATE ERROR
					rts
*
FRBMBUF				sec
					ldx BMTAB ; FIND OUT WHICH WAS LAST USED.
					beq CHKBMB ; IF 'A' WAS USED CHECK 'B' FIRST
					clc ; INDICATE 'A' IS CHECKED FIRST
					bit BMASTAT ; IS BUFFER 'A' FREE (UNMODIFIED)?
					bpl GETA.BUF ; YES, USE IT.
CHKBMB				bit BMBSTAT ; IS BUFFER 'B' FREE?
					bcc FREBUF1 ; BRANCH IF BOTH ARE USED
					bpl GETB.BUF ; YES...
					bit BMASTAT ; (CHECK 'A')
					bpl GETA.BUF
FREBUF1				ldx #0
					bcc FREBUFA ; BRANCH IF BUFFER 'A' HAS LEAST PRIORITY.
					ldx #BMTABSZ
FREBUFA				stx ZPGTEMP ; SAVE BM BUFF ID FOR A BIT
					jsr WRTBMAP ; XREG PASSES BM BUFF ID
					bcs NOGO ; ERROR ENCOUNTERED ON WRITING
					ldx ZPGTEMP ; FETCH BM BUFF ID
					lda #0
					sta BMASTAT,X ; AND MARK BM BUFFER AS FREE
					bcc FNDBMAP ; LOOK AGAIN FOR FRRE BIT MAP BUFFER SPACE
NOGO				rts ; RETURN ERROR ON WRITING BM
*
UPBMAP				cpx BMADEV ; UPDATE BIT MAP OF DEVICE X
					bne UPBM1
					clc ; FREE BUFFER 'A' IF NEEDED.
					bit BMASTAT
					bmi FREBUF1 ; (CARRY CLEAR FOR BUFFER 'A')
					rts
*PAGE
*
UPBM1				cpx BMBDEV
					bne NOUPDAT ; DON'T UPDATE IF NOT NECESSARY.
					bit BMBSTAT
					bmi FREBUF1 ; (CARRY IS SET)
NOUPDAT				clc
					rts; RETURN 'NO ERROR'
*
CLEARBMS			.eq *; MAKE SURE ALL BIT MAPS ASSOCIATED
* WITH A DEVICE ARE MARKED INVALID
* IF A NEW VOLUME IS LOGGED IN ON IT.
* INPUT ARG: A REG = DEVNUM
* X REG PRESERVED
					ldy #0
					cmp BMADEV
					bne CLRBM1 ; BRANCH IF BIT MAP A NOT OWNED
					bit BMASTAT
					bmi CLRBM2 ; BRANCH IF BITMAP A BUSY
					sty BMADEV ; ELSE, CLEAR IT
CLRBM2				rts ; NEED ONLY CLEAR ONE
CLRBM1				cmp BMBDEV ; BIT MAP B?
					bne CLRBM2 ; BRANCH IF BIT MAP B NOT OWNED BY DEVNUM
					bit BMBSTAT
					bmi CLRBM2 ; BRANCH IF BITMAP B BUSY
					sty BMBDEV ; ELSE CLEAR IT
					rts; AND RETURN TO CALLER (NO ERRORS)
*
GTBMAP				sta BMADEV,X ; SAVE ACC AS CURRENT DEVICE FOR BUFFER
					lda BMAMADR,X ; GET HIGH ORDER ADDRESS OF BUFFER
					sta BMADR+1 ; SELECTED BY X

					lda BMBUFBNK ; AND GET BANK PAIR NUMBER
					sta SISBMADR ; OF BOTH BIT MAP BUFFERS 'A' AND 'B'
					ldy #VCBCMAP ; GET LOWEST MAP NUMBER WITH FREE BLOCKS IN IT.
					lda (VCBPTR),Y
					sta BMACMAP,X ; ASSOCIATE THE OFFSET WITH THE BITMAP CONTROL BLOCK
					clc
					ldy #VCBDMAP ; ADD THIS NUMBER TO THE BASE
					adc (VCBPTR),Y ; ADDRESS OF FIRST BIT MAP
					sta BMADADR,X ; SAVE LOW ADDRESS OF BIT MAP TO BE USED.
					iny ; NOW GET HIGH DISK ADDRESS OF MAP
					lda (VCBPTR),Y ; ADD TO THIS THE				staTE OF THE CARRY
					adc #0
					sta BMADADR+1,X ; SAVE HIGH DISK ADDRESS TOO.
; DROP INTO 'RDBMAP'
*
*PAGE
*
					lda #RDCMD ; (X CONTAINS AN INDEX TO DETERMINE WHICH BUFFER)
DOBMAP				sta DHPCMD ; SAVE DEVICE COMMAND
					lda DEVNUM ; FIX THE 'BIT MAP TRASH BUG'
					pha ;BY NOT MUNGING DEVNUM
					lda BMADEV,X ; GET DEVICE NUMBER.
					sta DEVNUM
					lda BMADADR,X ; AND MAP'S DISK ADDRESS
					sta BLOKNML
					lda BMADADR+1,X
					sta BLOKNMH
					lda BMAMADR,X ; LASTLY GET THE ADDRESS OF THE BUFFER
					ldx BMBUFBNK ; AND BANK NUMBER.
					jsr DOBITMAP ; (NOTE: LOW ADDRESS IS FIXED TO ZERO AS THIS IS A BUFFER)
					pla ; RESTORE
					sta DEVNUM ; THE DEVNUM WE CAME IN WITH!
					rts
*
WRTBMAP				lda #WRTCMD ; WRITE BIT MAP POINTED TO BY X
					jmp DOBMAP
*
WRTGBUF				lda #WRTCMD ; SET CALL FOR WRITE.
					bne SVGCMD ; BRANCH ALWAYS.
RDGBUF				lda #RDCMD ; SET CALL FOR READ.
SVGCMD				sta DHPCMD ; PASSED TO DEVICE HANDLER.
					lda BLOKNML ; SAVE CURRENT
					sta TTLINK ; GBUF BLOCK
					lda BLOKNMH ; ADDRESS
					sta TTLINK+1 ; FOR DIRECTORY EXTEND
					lda #GBUF/256 ; GET HIGH ADDRESS OF GENERAL BUFFER
					ldx #0 ; TO FORCE ACCESS TO NON BANK MEMORY.
DOBITMAP			.eq *
DOIDX				sta DBUFPH
					stx SISBPH ; SELECT BANK
					lda #0 ; GENERAL PURPOSE BUFFERS ALWAYS
					sta DBUFPL ;				staRT ON A PAGE BOUNDARY.
					jmp FILEIO2 ; END VIA DEVICE DISPATCHER.
*
TTLINK DS 2 ; GBUF CURRENT ADDRESS
*
WRTINDX				lda #WRTCMD
					ldx IDXADRL ; GET BLOCK ADDRESS OF INDEX BLOCK
					ldy IDXADRH
DOFRST				sta DHPCMD ; (ENTRY USED BY RD/WRTDFRST)
					stx BLOKNML
					sty BLOKNMH
					lda TINDX+1 ; HIGH RAM ADDRESS OF INDEX BLOCK
					ldx SSTIDXH ; AND BANK NUMBER.
					jmp DOIDX ; AND GO DO REQUESTED OPERATION.
*
WRTDFRST			lda #WRTCMD ; WRITE FILE'S FIRST BLOCK (USED
					bne FADDR ; BY CREATE, SO ADDRESS IN 'D.' STUFF).
RDFRST				lda #RDCMD
FADDR				ldx DFIL+D.FRST ; (BUFFER ADDRESS IS IN 'TINDX')
					ldy DFIL+D.FRST+1
					jmp DOFRST
*
*
CHN POSN/OPEN,4,2

*************************************************************************
* END OF APPLE /// SOS 1.3 SOURCE CODE FILE: ALLOC
*************************************************************************




================================================================================================
FILE: "SOS.BFM.INIT2.SRC.TEXT"
================================================================================================
*************************************************************************
* APPLE /// SOS 1.3 SOURCE CODE FILE: BFM.INIT2.SRC
*************************************************************************
* ASSEMBLER: APPLE ][ 6502 ASSEMBLER from APPLE COMPUTER TOOLKIT

*SBTL "SOS 1.1 BFM.INIT2"
*REL
					INCLUDE SOSORG,6,1,254
ORG ORGBFMI
*MSB OFF
*REP 60
* COPYRIGHT (C) APPLE COMPUTER INC. 1980
* ALL RIGHTS RESERVED
*REP 60
*
* BLOCK FILE MANAGER INIT2
*
* SECONDARY INITIALIZATION ROUTINE FOR BLOCK FILE MANAGER
*
* MODIFIED: 03/25/81 TO UTILIZE NEW
* DISK DRIVER'S SEEKDSK3 ROUTINE.
* CHANGES MARKED BY 'D3RRA81084'
*
* MODIFIED: 08/19/81 TO WORK WITH NEW
* SOSLDR MODULE.
*REP 60
*
*ENTRY BFM.INIT2
*
*EXTRN I.BASE.P ; ENTRY IN SOSLDR
*EXTRN SYSBANK
*EXTRN SXPAGE
*EXTRN CZPAGE
*EXTRN SEEKDSK3 ;IN DISKDH/D3RRA81084
*EXTRN NMIDSBL ;/D3RRA81084
I.BASE.P .eq $2
*PAGE
*
* CONSTANTS
*
KERNEL.BASE .eq $B800 ; BASE ADDRESS OF SOS KERNEL
ROMID .eq $A0 ;$F1B9 OF NEW ROM/D3RRA81084
SLOT .eq $60
BEGTRK .eq $9
BEGSECT .eq $2
ENDSECT .eq $6
*
* ZERO PAGE
*
TRACK .eq $99
					clcTOR .eq $98
VOLUME .eq $9A
KEY .eq $E0 ; THRU $E7
PREV.K .eq KEY+$8
XIDX .eq KEY+$9
I .eq KEY+$A ; & $B
*
* ROM ROUTINES
*
RDADR .eq $F1B9 ;REV1
RDADRX .eq $F1BD ;REV0
*
* HARDWARE LOCATIONS
*
E.REG .eq $FFDF
B.REG .eq $FFEF
MOTORON .eq $C089
MOTOROFF .eq $C088
*PAGE
*REP 60
*
* BFM.INIT2 ENTRY POINT
*
*REP 60
*
STATE DFB $FE ; FF=1ST ENTRY, 0=2ND ENTRY, 1=PROT

*
BFM.INIT2 .eq *
					inc				staTE
					bmi BFMI050
					jsr GETK
					lda RETRY
					beq BADNEWS
					bcc BFMI050
					jsr NMIDSBL
					jsr DC
					inc				staTE
BFMI050 CLC
					rts
BADNEWS SEC ; I/O ERROR
					rts
*PAGE
*REP 60
*
* DECODE SUBROUTINE
*
* TO ENCODE:
* E0.E8: - INIT KEY & PREV.K
* B84E:4C 64 B8 - JUMPS AROUND INTERP'S 3 BYTE OVERWRITE
* 1A02.1A03: - NEW INTERP'S LOAD ADR (LO,HII)
* B81DG: -				jsr FROM MONITOR
*
*REP 60
DC					.eq *
					lda B.REG ; SAVE BANK REGISTER
					pha
					lda SYSBANK ; AND SWITCH TO SYSTEM BANK
					sta B.REG
					clc ; FETCH LOADER'S INTERPRETER POINTER
					lda CZPAGE+I.BASE.P
					adc #3
					sta I
					pha
					lda CZPAGE+I.BASE.P+1
					adc #0
					sta I+1
					pha
					lda #0
					sta SXPAGE+I+1
*
					ldy I ; ALIGN I PTR TO PAGE BOUNDARY
					lda #0
					sta I
					sta PREV.K
*
					jsr DCLOOP ; DECODE
*
					pla ; RETRIEVE LOADER'S INTERPRETER POINTER
					sta I+1
					pla
					sta I
*
					ldy #1 ; REPOSITION LOADER'S INTERPRETER POINTER (PUT ENCODE JMP HERE)
					lda (I),Y
					sta CZPAGE+I.BASE.P
					iny
					lda (I),Y
					sta CZPAGE+I.BASE.P+1
*
					ldy #2 ; WALK ON INTERPRETER'S FIRST INSTRUCTION (3 BYTES)
					lda #0
DCA				sta (I),Y
					dey
					bpl DCA
					pla ; RESTORE BANK REGISTER (ENCODE JMP JUMPS TO HERE)
					sta B.REG
					rts
*PAGE
*REP 60
*
* DECODE LOOP SUBROUTINE
*
*REP 60
DCLOOP .eq *
					ldx #7 ; SHIFT LEFT ONE BIT
					clc
					lda KEY

					bpl DC1
					clc
DC1 ROL KEY,X
					dex
					bpl DC1
*
DC2 TYA
					and #7
					eor #2
					tax
					lda KEY,X
					pha
					and #7
					tax
					pla
					clc
					adc PREV.K
					clc
					adc KEY,X
					sta PREV.K
					eor (I),Y ; DECODE BYTE
					sta (I),Y ; AND PUT IT BACK
					iny
					bne DC2
					inc I+1
					lda I+1
					cmp #<KERNEL.BASE
					bcc DCLOOP
					rts
*PAGE
*REP 60
*
* GETKEY SUBROUTINE
*
*REP 60
*
RETRY DFB 10+1 ;TEN RETRIES
OURTRACK DS 1 ;CURRENT TRACK/D3RRA81084
*
GETK .eq *
					ldx #7
					stx XIDX
					ldx #SLOT
					lda MOTORON,X ;ENSURE MOTOR				staYS ON
					lda E.REG ; SELECT 1MHZ, ROM
					ora #$83
					sta E.REG
*
* NOTE: THE SEEKDSK3 ROUTINE HAS THESE /D3RRA81084
* CAVEATS: 1MHZ MODE, MOTOR IS ON, /D3RRA81084
* DRIVE CURRENTLY SELECTED, ROM+I/O ENABLED! /D3RRA81084
*
GETK010				lda #BEGTRK
					sta OURTRACK ;WHERE WE SEEK TO /D3RRA81084
					jsr SEEKDSK3 ;HAVE DISKDH SEEK FOR US /D3RRA81084
GETK020				ldx #SLOT
					jsr DOREAD ;FIND A SECTOR HEADER
					bcs IOERROR ;=>RETRY IF BAD
					lda SECTOR ;WHERE ARE WE?
					cmp #BEGSECT ;AT THE RIGHT PLACE?
					bne GETK020 ;=>NO, GET THERE
*
GETK100				ldx #1
					jsr WAIT ; (X * 1284) + 15 MILISECONDS
					ldx XIDX
					lda VOLUME
					sta KEY,X
					dec XIDX
					bmi ENUFF
					inc OURTRACK ;BUMP FOR NEXT TRACK /D3RRA81084
					lda OURTRACK ;WHERE TO GO /D3RRA81084
					ldx #SLOT
					jsr SEEKDSK3 ;DISKDH, PLEASE SEEK ME /D3RRA81084
					ldx #SLOT
					jsr DOREAD
					bcc GETK100
					bcs IOERROR
*
ENUFF				ldx #SLOT
					lda MOTOROFF,X
					lda E.REG ; SELECT 2MHZ, RAM

					and #$7C
					sta E.REG
*PAGE
					lda SECTOR
					cmp #ENDSECT ;TRACKS SYNC'ED?
					bne NOTPROT
					lda KEY
					eor KEY+1
					beq NOTPROT ;IF FIRST 2 VOLS ARE EQUAL
					clc
					rts
*
NOTPROT				lda #0
					clc
					rts
*
*
DOREAD				jsr WHICHROM
					bcs OLDREAD
					jmp RDADR
OLDREAD JMP RDADRX
*
*
WHICHROM			lda RDADR
					cmp #ROMID
					clc
					beq NEWROM
					clc
NEWROM				rts
*
*
IOERROR DEC RETRY
					beq ERR1
					jmp GETK ; TRY, TRY AGAIN
ERR1 JMP ENUFF ; I/O ERROR, CLEANUP AND EXIT
*
*
WAIT LDY #0
W1 DEY
					bne W1
					dex
					bne W1
					rts

ZZLEN .eq $400
IFNE ZZLEN-LENBFMI
FAIL 2,"SOSORG FILE IS INCORRECT FOR BFM.INIT2"
FIN

*************************************************************************
* END OF APPLE /// SOS 1.3 SOURCE CODE FILE: BFM.INIT2.SRC
*************************************************************************




================================================================================================
FILE: "SOS.BUFMGR.SRC.TEXT"
================================================================================================
*************************************************************************
* APPLE /// SOS 1.3 SOURCE CODE FILE: BUFMGR.SRC
*************************************************************************
* ASSEMBLER: APPLE ][ 6502 ASSEMBLER from APPLE COMPUTER TOOLKIT

*SBTL "SOS 1.1 BUFFER MANAGER"
*REL
					INCLUDE SOSORG,6,1,254
*ORGBUFMG .eq $F552
*LENBUFMG .eq $31C
ORG ORGBUFMG
ZZORG .eq *
*MSB OFF
*REP 60
* COPYRIGHT (C) APPLE COMPUTER INC. 1980
* ALL RIGHTS RESERVED
*REP 60
*
* BUFFER MANAGER (VERSION = 1.1O )
* (DATE = 8/04/81)
*
* THIS MODULE IS RESPONSIBLE FOR CREATING AND RELEASING BUFFERS
* FOR BOTH THE BLOCK FILE MANAGER AND, LATER, DEVICE HANDLERS
* THE BUFFER MANAGER CREATES BUFFERS BY REQUESTING MEMORY
* SEGMENTS FROM THE MEMORY MANAGER, AND RELEASES THEM VIA SAME.
* THE PRIMARY DATA STRUCTURE IN THIS MODULE IS THE BUFFER TABLE.
*
*REP 60
*
*ENTRY REQBUF
*ENTRY REQFXBUF
*ENTRY GETBUFADR
*ENTRY CHKBUF
*ENTRY RELBUF
*
*EXTRN MMGR
*EXTRN SXPAGE
*EXTRN CZPAGE
*EXTRN CXPAGE
*
*EXTRN SYSERR
*EXTRN SERR
*EXTRN OUTOFMEM
*EXTRN BUFTBLFULL
*EXTRN BADSYSBUF
*
*EXTRN SYSDEATH
*EXTRN BADBUFNUM
*EXTRN BADBUFSIZ
*
*ENTRY BUF.CNT
*ENTRY PGCT.T
*ENTRY XBYTE.T
*ENTRY BUFREF
*PAGE
*REP 60
*
* DATA DECLARATIONS
*
*REP 60
*
Z.REG .eq $FFD0
*
* MEMORY MGMT CALL PARM LOCATIONS ON SOS ZPAGE
*
M.TPARMX .eq $60 ; FIRST ADR OF MEM SYS CALL PARMS ON SOS ZPAGE
REQCODE .eq M.TPARMX+$0
*
FINDSEG .eq $1
SRCHMODE .eq M.TPARMX+$1
F.ID .eq M.TPARMX+$2
F.PGCT .eq M.TPARMX+$3
F.PGCTX DS 2 ; TEMP LOC FOR F.PGCT PARM
F.BASE .eq M.TPARMX+$5
F.BASEX DS 2 ; TEMP LOC FOR F.BASE PARM
F.LIM .eq M.TPARMX+$7

F.LIMX DS 2 ; TEMP LOC FOR F.LIM PARM
F.NUM .eq M.TPARMX+$9
F.NUMX DS 1 ; TEMP LOC FOR F.NUM PARM
*
RELSEG .eq $5
RLS.NUM .eq M.TPARMX+$1
*
* REQBUF DATA DECLARATIONS
*
RQB.PGCT DS 1 ; REQUESTED PAGE COUNT
RQB.BNUM DS 1 ; BUFFER NUMBER (FM GETFREE CALL)
*
* REQFXBUF DATA DECLARATIONS
*
RQFB.PGCT DS 1 ; REQUESTED PAGE COUNT
RQFB.BNUM DS 1 ; BUFFER NUMBER (FM GETFREE CALL)
MAXPGCT .eq 64 ; MAX BUFSIZE=16K
F.TPARMX .eq $A0 ; FIRST ADR OF FILE SYS CALL PARMS ON SOS ZPAGE
OPEN.LIST .eq F.TPARMX+$5 ; LOC OF OPEN.LIST PARM (OPEN SYS CALL)
*
* BUFCOMPACT DATA DECLARATIONS (SOURCE ALSO USED BY CHKBUF)
*
BUFC.BNUM DS 1 ; BUF# OF LOWEST BUFFER IN BUF.TBL
SOURCE .eq M.TPARMX+$10 ; & $11
DEST .eq M.TPARMX+$12 ; & $13
*PAGE
*REP 60
*
* BUFFER TABLE
*
* THE BUFFER TABLE CONSISTS OF "CNT"-1 ENTRIES (1 TO "CNT"-1).
* EACH ENTRY IS "SIZ" BYTES IN LENGTH. THE "PGCT" FIELD
* CONTAINS 3 SUBFIELDS. BIT 7 IS THE "FREE" FLAG (0=ACTIVE,1=FREE)
* BIT 6 IS THE "FIXED" FLAG (0=FLOATING BUFFER,1=FIXED BUFFER)
* BITS 5 THRU 0 CONTAIN THE PAGE COUNT OF AN "ACTIVE" ENTRY
* (0=>1 PAGE,63=>64 PAGES DECIMAL). THE "XBYTE" FIELD CONTAINS
* THE PROPER XBYTE OF AN "ACTIVE" ENTRY. THE "ADRH" FIELD
* CONTAINS THE HIGH BYTE OF THE BUFFER ADDRESS. IF THE
* BUFFER ENTRY IS "FLOATING", THEN THE "SEG" FIELD CONTAINS THE
* SEGMENT NUMBER AND THE LOW BYTE OF THE BUFFER ADDRESS IS
* ASSUMMED TO BE ZERO.
*
* THUS, THE FOLLOWING RESTRICTIONS APPLY TO BUFFERS:
*
* (1) MAXIMUM BUFFER LENGTH IS 64 PAGES (16K)
* (2) "FLOATING" BUFFERS ALWAYS BEGIN ON A PAGE BOUNDARY
* "FIXED" BUFFERS DO NOT.
* (3) BUFFERS ARE ALWAYS AN INTEGRAL NUMBER OF PAGES IN LENGTH
* (4) BUFFERS ALWAYS RESIDE IN THE 32K BANK MEMORY REGION,
* A LIMITATION OF FIND.SEG (MEMORY MANAGER)
* (5) MAXIMUM NUMBER OF BUFFERS = 16; ENTRY 0 IS NOT USED.
*
*REP 60
*
* BUFFER TABLE
*
BUF.SIZ .eq 5
BUF.CNT .eq 17
BUF.TBL DS BUF.SIZ*BUF.CNT
PGCT.T .eq BUF.TBL
XBYTE.T .eq PGCT.T+BUF.CNT
ADRH.T .eq XBYTE.T+BUF.CNT
SEG.T .eq ADRH.T+BUF.CNT
ADRL.T .eq SEG.T
CHK.T .eq ADRL.T+BUF.CNT
ISFIXED .eq $40
ISFREE .eq $80
*
* BUFFER REFERENCE TABLE
*
* FIRST BYTE IS COUNT, FOLLOWED BY "COUNT" BUFFER #S.
* THIS TABLE IS A LIST OF ALL BUFFERS REFERENCED DURING ONE
* SOS SYSTEM CALL. BUFFER #S ARE ADDED TO THIS LIST BY
* GETBUFADR AND REMOVED BY CHKSUM.
*
BUFREF.CNT .eq 17
BUFREF DS BUFREF.CNT
ZPAGEX DS 1
*PAGE
*REP 60
*

* REQBUF
*
* INPUT: PAGE.CNT (A)
* OUTPUT: BUFNUM (A)
* ERROR: "BUFFER TABLE FULL" - SYSERR
* "OUT OF MEMORY" - SYSERR
* "BAD BUFFER SIZE" - SYSDEATH
*
* THIS ROUTINE FINDS A FREE ENTRY IN THE BUFFER TABLE
* AND THEN CALLS FIND.SEG (MMGR) TO OBTAIN MEMORY FOR IT.
* IF MEMORY IS FOUND THEN THE BUFFER ENTRY IS MARKED "ACTIVE"
* AND THE BUFFER INFO IS INSERTED INTO THE ENTRY
*
*REP 60
*
REQBUF .eq *
*
* IF REQUESTED PGCT OUT OF BOUNDS THEN FATAL ERR
*
					tay
					beq RQB.ERR2 ; FATAL ERR, INVALID BUFFER SIZE
					cpy #MAXPGCT+1
					bcs RQB.ERR2 ; FATAL ERR, INVALID BUFFER SIZE
					sty RQB.PGCT ; SAVE PAGE COUNT
*
* FIND FREE ENTRY IN BUF.TBL
*
					jsr GETFREE
					bcs RQB.ERR ; ERR, BUFFER TABLE FULL
					stx RQB.BNUM
*
* FIND PGCT*256 BYTES OF FREE MEMORY
*
					lda RQB.PGCT
					jsr FSEG
					bcs RQB.ERR1 ; ERR, OUT OF MEMORY
*
* INSERT PGCT, XBYTE, ADRH, SEG#, CHK BYTE IN BUF.TBL(BUF#)
*
					ldx RQB.BNUM
					dec RQB.PGCT ; PAGE COUNT FIELD
					lda RQB.PGCT
					sta PGCT.T,X
*
					ldx #$7F ; IF XBYTE=$8F THEN XBYTE:=$7F
RQB010				txa
					ldx RQB.BNUM
					sta XBYTE.T,X
					tya
					sta ADRH.T,X
*
					lda F.NUMX ; SEG# FIELD
					sta SEG.T,X
*
					lda #0 ; INIT CHECK BYTE TO NULL
					sta CHK.T,X
*
					txa ; RETURN BUF#
					clc
					rts; NORMAL EXIT
*
*
RQB.ERR				lda #BUFTBLFULL
					jsr SYSERR
*
RQB.ERR1			lda #OUTOFMEM
					jsr SYSERR
*
RQB.ERR2			lda #BADBUFSIZ
					jsr SYSDEATH
*PAGE
*REP 60
*
* REQFXBUF
*
* INPUT: PAGE.CNT (A)

* OUTPUT: BUFNUM (A)
* ERROR: "BUFFER TABLE FULL" - SYSERR
* "BAD SYSTEM.BUF PARM ADDRESS" - SYSERR
* "BAD BUFFER SIZE" - SYSDEATH
*
* THIS ROUTINE COMPUTES THE ACTUAL BUFFER ADDRESS IN THE OPEN
* CALL (PARM "OPEN.LIST"), AND ALLOCATES A BUFFER ENTRY FOR IT.
* NOTE: THE SYSBUF PARAMETER MUST BE AN EXTENDED INDIRECT PTR!!
*
*REP 60
*
REQFXBUF .eq *
*
* IF REQUESTED PGCT OUT OF BOUNDS THEN FATAL ERR
*
					tay
					beq RQFB.ERR2 ; FATAL ERR, BAD BUFFER SIZE
					cpy #MAXPGCT+1
					bcs RQFB.ERR2 ; FATAL ERR, BAD BUFFER SIZE
*
					sty RQFB.PGCT ; SAVE PAGE COUNT
*
* GET A FREE BUFFER ENTRY
*
					jsr GETFREE
					bcs RQFB.ERR ; ERR, BUFFER TABLE FULL
					stx RQFB.BNUM ; SAVE BUF#
*
* FETCH SYSTEM.BUF PARAMETER IN OPEN SYSTEM CALL
*
					ldy #3
					lda (OPEN.LIST),Y
					bne RQFB.ERR1 ; ERR, SYSBUF ADR
					dey
					lda (OPEN.LIST),Y
					tay
					lda CXPAGE+1,Y
					bpl RQFB.ERR1 ; ERR, SYSBUF ADR
					cmp #$8F
					bcs RQFB.ERR1 ; ERR, SYSBUF ADR
*
* INSERT XBYTE, ADRH, ADRL, PGCT, CHK BYTE INTO BUF.TBL(BUF#)
*
					ldx RQFB.BNUM
					sta XBYTE.T,X
*
					lda CZPAGE+1,Y
					beq RQFB.ERR1 ; ERR SYSBUF ADR
					cmp #$81 ; CHECK FOR ADDRESS COMPENSATION
					bcc RQFB010
					inc XBYTE.T,X
					and #$7F
RQFB010				sta ADRH.T,X
*
					lda CZPAGE,Y
					sta ADRL.T,X
*
					dec RQFB.PGCT
					lda RQFB.PGCT
					ora #ISFIXED
					sta PGCT.T,X ; BUFFER ENTRY NOW "ACTIVE"
*
					lda #0 ; INIT CHECK BYTE TO NULL
					sta CHK.T,X
*
					txa ; RETURN BUF#
					clc
					rts; NORMAL EXIT
*
RQFB.ERR			lda #BUFTBLFULL
					jsr SYSERR
*
RQFB.ERR1			lda #BADSYSBUF
					jsr SYSERR
*
RQFB.ERR2			lda #BADBUFSIZ
					jsr SYSDEATH
*PAGE
*REP 60
*
* GETBUFADR

*
* INPUT: BUFNUM (A)
* ZPAGELOC (X)
* OUTPUT: BUF ADR AT: X,X+1 & SXPAGE+1,X
* PAGE.CNT (A)
* BUFNUM (Y)
*
* ERROR: "BADBUFNUM" SYSDEATH
*
*REP 60
*
GETBUFADR .eq *
*
* IF BUF# OUT OF RANGE OR BUF.TBL(BUF#)=FREE
* THEN FATAL ERR
*
					tay
					beq GTBF.ERR ; BUF#=0, FATAL ERR
					cpy #BUF.CNT
					bcs GTBF.ERR ; BUF# > MAX BUF TABLE ENTRY, FATAL ERR
					lda PGCT.T,Y
					bmi GTBF.ERR ; BUF ENTRY MARKED "FREE", FATAL ERR
*
* OTHERWISE, CONSTRUCT BUFFER PTR ON SOS ZPAGE
*
					jsr GETBUFADR1
*
* IF BUFFER NOT PREVIOUSLY REFERENCED ON THIS SOS CALL AND CHECK BYTE <> 0
* THEN COMPARE FIRST BYTE OF BUFFER WITH CHECK BYTE IN BUFFER TABLE.
* IF NO MATCH THEN KILL SYSTEM.
*
					stx ZPAGEX
					tya
					ldx BUFREF
					beq GTBF020 ; BUFREF EMPTY
*
GTBF010 CMP BUFREF,X ; SEARCH FOR PREVIOUS REFERENCE
					beq GTBF030 ; MATCH FOUND
					dex
					bne GTBF010
*
GTBF020 INC BUFREF ; LOG BUF # IN BUFREF TABLE
					ldx BUFREF
					cpx #BUFREF.CNT
					bcs GTBF.ERR ; BUFREF TABLE OVFLOW, KILL SYSTEM
					sta BUFREF,X
*
					lda CHK.T,Y
					beq GTBF030 ; NO CHECK BYTE, SKIP CHECK
					ldx ZPAGEX
					lda ($0,X) ; COMPARE FIRST BYTE OF BUFFER
					cmp CHK.T,Y ; WITH CHECK BYTE IN BUF TABLE
					bne GTBF.ERR ; NO MATCH, PULL THE PLUG
*
* RETURN PAGE.CNT TO CALLER
*
GTBF030				lda PGCT.T,Y
					and #$3F ; STRIP OFF FREE,FIXED FLAGS
					clc
					adc #1
*
					clc
					rts
*
*
GTBF.ERR				lda #BADBUFNUM
					jsr SYSDEATH
*
*
*REP 60
*
* GETBUFADR1
*
* INPUT: PGCT.T(BUF#) (A)
* ZPAGELOC (X)
* BUF# (Y)
* ERROR: NONE.
*
* EXTRACTS THE BUFFER POINTER FROM THE BUFFER TABLE AND
* PLACES IT ON ZERO PAGE AT X, X+1 & SXPAGE+1,X
*

*REP 60
*
GETBUFADR1 .eq *
					and #$40
					bne GTB1010
					lda #0 ; "FIXED" BUFFER
					beq GTB1020 ; ALWAYS TAKEN
GTB1010				lda ADRL.T,Y ; "FLOATING" BUFFER
GTB1020				sta 0,X
					lda ADRH.T,Y
					sta 1,X
					lda XBYTE.T,Y
					ora #$80 ; ENSURE $7F->$8F
					sta SXPAGE+1,X
					rts
*PAGE
*REP 60
*
* CHKBUF
*
* CHECK BUFFER. FETCHES THE FIRST BYTE OF EACH BUFFER
* REFERENCED DURING THE CURRENT SYSTEM CALL AND PLACES IT
* IN CHK.T(BUF#).
*
* INPUT: BUFREF TABLE
* BUFFER TABLE
* OUTPUT: EMPTY BUFREF TABLE
* BUFFER TABLE'S CHECK BYTES UPDATED
* Z REG:=$18
* ERROR: NONE.
*
*REP 60
*
CHKBUF .eq *
					ldy BUFREF ; PICK UP COUNT
					beq CHKB.EXIT ; EXIT IF BUFREF EMPTY
*
					lda #$18 ; ENSURE SOS ZPAGE SWITCHED IN
					sta Z.REG
*
* UPDATE THE CHECK BYTE OF EACH BUF# IN THE BUFREF TABLE
*
CHKB010				ldx #>SOURCE
					lda BUFREF,Y
					tay
					lda PGCT.T,Y
					jsr GETBUFADR1 ; PUT BUF#S ADR ON ZPAGE
					lda ($0,X)
					sta CHK.T,Y
					dec BUFREF
					ldy BUFREF
					bne CHKB010 ; IF COUNT<>0 THEN PROCESS NEXT BUF# IN BUFREF TABLE
*
CHKB.EXIT			rts ; BUFREF TABLE IS EMPTY (COUNT=0)
*PAGE
*REP 60
*
* RELBUF
*
* INPUT: BUFNUM (A)
* OUTPUT: NONE.
* ERROR: "BADBUFNUM" SYSDEATH
*
* THIS ROUTINE RELEASES THE BUFFER ENTRY, CALLS FIND.SEG TO
* RELEASE THE CORRESPONDING MEMORY SEGMENT, AND CALLS
* BUFCOMPACT TO PERFORM BUFFER COMPACTION.
*
*REP 60
*
RELBUF .eq *
*
* IF BUF# OUT OF RANGE OR BUF.TBL(BUF#)=FREE
* THEN FATAL ERR
*
					tay
					beq RLBF.ERR
					cpy #BUF.CNT
					bcs RLBF.ERR
					lda PGCT.T,Y
					bmi RLBF.ERR
*

* MARK BUF.TBL(BUF#)=FREE
*
					ora #ISFREE
					sta PGCT.T,Y
*
* IF BUF.TBL(BUF#)=FIXED THEN EXIT
*
					and #ISFIXED
					bne RLBF.EXIT
*
* OTHERWISE CALL MEMORY MGR TO RELEASE BUFFER'S MEMORY SEG
*
					lda #RELSEG
					sta REQCODE
*
					lda SEG.T,Y
					sta RLS.NUM
*
					jsr MMGR
					bcs RLBF.ERR ; ANY ERR IS FATAL
*
* AND COMPACT BUFFERS
*
					jsr BUFCOMPACT
*
RLBF.EXIT			clc
					rts
*
RLBF.ERR			lda #BADBUFNUM
					jsr SYSDEATH
*PAGE
*REP 60
*
* BUFCOMPACT
*
* THIS ROUTINE IS RESPONSIBLE FOR PACKING ALL SOS BUFFERS UP
* AGAINST THE HIGHEST AVAILABLE FREE MEMORY. COULD IMPROVE THE
* EFFICIENCY OF THIS COMPACTION CYCLE BY NOT RELEASING THE "RELEASED" BUFFER
* UNTIL IT IS KNOWN THAT ANOTHER BUFFER WILL NOT BE MOVED INTO ITS LOC.
*
*REP 60
*
BUFCOMPACT .eq *
*
* FIND THE FLOATING BUFFER IN BUF.TBL WITH THE LOWEST ADDRESS.
*
BUFC010 LDY #0
					ldx #BUF.CNT-1
*
BUFC020				lda PGCT.T,X
					and #$C0 ; STRIP OUT PAGE COUNT BITS
					bne BUFC030
*
					lda ADRH.T,X
					cmp ADRH.T,Y
					lda XBYTE.T,X
					sbc XBYTE.T,Y
					bcs BUFC030
*
					txa ; SMALLER BUFFER FOUND, SAVE IN Y
					tay
*
BUFC030				dex
					bne BUFC020
*
* IF NO BUFFER FOUND THEN DONE
*
					tya
					bne BUFC040
					jmp BUFC.EXIT
BUFC040 STY BUFC.BNUM ; OTHERWISE SAVE BUF# IN Y REG.
*
* CALL FIND.SEG: FINDS HIGHEST AVAILABLE FREE MEMORY
*
					lda PGCT.T,Y
					and #$3F ; STRIP OUT "FREE","FIXED" FLAGS
					clc
					adc #1
					jsr FSEG
					bcs BUFC.EXIT ; DONE IF NO FREE SEG FOUND
*

* CONVERT BASE.BKPG TO BUFFER ADR
*
					ldx F.BASEX ; BASE BANK
					ldy F.BASEX+1 ; BASE PAGE
					jsr CNVRT.ADR
					stx F.BASEX ; XBYTE
					sty F.BASEX+1 ; ADRH
*
* IF NEW SEG'S BASE < CURRENT BUFFER'S BASE ADR THEN DONE
*
					ldy BUFC.BNUM
					lda ADRH.T,Y
					sta SOURCE+1
					cmp F.BASEX+1
					lda XBYTE.T,Y
					sta SXPAGE+SOURCE+1
					sbc F.BASEX
					bcs BUFC.EXIT1
*
* MOVE DATA FROM CURRENT BUFFER TO NEW BUFFER
*
					ldx F.BASEX
					stx SXPAGE+DEST+1
					ldy F.BASEX+1
					sty DEST+1
					lda #0
					sta SOURCE
					sta DEST
*
					tay
					ldx F.PGCTX
BUFC200				lda (SOURCE),Y ; MOVE LOOP
					sta (DEST),Y
					dey
					bne BUFC200
					inc SOURCE+1
					inc DEST+1
					dex
					bne BUFC200
*
* UPDATE BUF.TBL(BUF#)
*
					ldy BUFC.BNUM
					lda F.BASEX
					sta XBYTE.T,Y
					lda F.BASEX+1
					sta ADRH.T,Y
*
					ldx SEG.T,Y
					lda F.NUMX
					sta SEG.T,Y
*
* AND RELEASE OLD MEMORY SEGMENT
*
					stx RLS.NUM
					lda #RELSEG
					sta REQCODE
					jsr MMGR
					bcs BUFC.ERR
*
					jmp BUFC010 ; REPEAT COMPACTION CYCLE
*
*
BUFC.EXIT1				ldx F.NUMX ; DONE,
					stx RLS.NUM ; RELEASE SEG BEFORE EXIT
					lda #RELSEG
					sta REQCODE
					jsr MMGR
					bcs BUFC.ERR
*
BUFC.EXIT				lda #0
					sta SERR ; MASK OUT ANY ERROR FROM MEMORY MGR
					clc
					rts; NORMAL EXIT
*
*
BUFC.ERR				lda #BADBUFNUM
					jsr SYSDEATH
*PAGE
*REP 60
*

* FSEG
*
* INPUT: PAGE.CNT (A)
* OUTPUT: PAGE.CNT (A) UNCHANGED IF FIND.SEG SUCCESSFUL
* ERROR: CARRY SET "UNABLE TO FIND MEMORY SEG OF PAGE.CNT*256 BYTES"
*
* THIS ROUTINE BUILDS THE PARAMETERS FOR A FIND.SEG SYSTEM CALL
* AND THEN CALLS THE MEMORY MANAGER.
*
*REP 60
*
FSEG .eq *
*
* SETUP INPUT PARAMETERS FOR FIND.SEG CALL
*
					sta F.PGCTX
					lda #FINDSEG
					sta REQCODE
					lda #2
					sta SRCHMODE
					lda #4
					sta F.ID
*
* SETUP OUTPUT PARAMETER ADRESSES
*
					lda #>F.PGCTX
					sta F.PGCT
					lda #<F.PGCTX
					sta F.PGCT+1
					lda #>F.BASEX
					sta F.BASE
					lda #<F.BASEX
					sta F.BASE+1
					lda #>F.LIMX
					sta F.LIM
					lda #<F.LIMX
					sta F.LIM+1
					lda #>F.NUMX
					sta F.NUM
					lda #<F.NUMX
					sta F.NUM+1
*
					lda #0
					sta F.PGCTX+1
					sta SXPAGE+F.PGCT+1
					sta SXPAGE+F.BASE+1
					sta SXPAGE+F.LIM+1
					sta SXPAGE+F.NUM+1
*
					jsr MMGR
					lda F.PGCTX
*
					rts; EXIT. CARRY SET->ERR
*PAGE
*REP 60
*
* GETFREE
*
* INPUT: NONE
* OUTPUT: BUF# (X)
* ERROR: "BUFTBLFULL" SYSERR
*
* THIS ROUTINE SEARCHES THE BUFFER TABLE, LOOKING FOR A FREE
* ENTRY. IF FOUND, IT RETURNS THE BUFFER NUMBER, ELSE ERROR.
*
*REP 60
*
GETFREE .eq *
					ldx #BUF.CNT-1
GFR010				lda PGCT.T,X
					bmi GFR.EXIT ; FREE ENTRY FOUND
					dex
					bne GFR010
*
					lda #BUFTBLFULL
					jsr SYSERR ; ERR EXIT
*
GFR.EXIT CLC
					rts; NORMAL EXIT
*PAGE
*REP 60

*
* CNVRT.ADR
*
* INPUT: BANK VALUE (X)
* PAGE VALUE (Y)
* OUTPUT: XBYTE (X)
* ADRH (Y)
* ERROR: NONE.
*
* THIS ROUTINE CONVERTS A BASE.BKPG PARM (MMGR) INTO A
* VIRTUAL POINTER
*
*REP 60
*
CNVRT.ADR .eq *
*
* IF PAGE <> $20 THEN GOTO L2
*
					cpy #$20
					bne CNVA020
*
* IF BANK <> 0 THEN GOTO L1
*
					txa
					bne CNVA010
*
* XBYTE=$8F
* ADRH:=PAGE
*
					ldx #$8F
					bmi CNVA.EXIT
*
* L1: XBYTE:=(BANK-1) ORA #$80
* ADRH:=#$80
*
CNVA010 ORA #$80
					tax
					dex
					ldy #$80
					bmi CNVA.EXIT
*
* L2: XBYTE:=BANK ORA #$80
* ADRH:=ADRH-#$20
*
CNVA020				txa
					ora #$80
					tax
					clc
					tya
					sbc #$20
					tay
*
CNVA.EXIT			rts
*
*LST ON
ZZEND .eq *
ZZLEN .eq ZZEND-ZZORG
IFNE ZZLEN-LENBUFMG
FAIL 2,"SOSORG FILE IS INCORRECT FOR BUFMGR"
FIN

*************************************************************************
* END OF APPLE /// SOS 1.3 SOURCE CODE FILE: BUFMGR.SRC
*************************************************************************



================================================================================================
FILE: "SOS.C.BI2.TEXT"
================================================================================================
*************************************************************************
* APPLE /// SOS 1.3 SOURCE CODE FILE: C.BI2
*************************************************************************
* ASSEMBLER: APPLE ][ 6502 ASSEMBLER from APPLE COMPUTER TOOLKIT

:TABS 17,23,40
::PR#1,L58 132N
SL4:DR1:ASM BFM.INIT2.SRC,BFM.INIT2.OBJ,6,1

*************************************************************************
* END OF APPLE /// SOS 1.3 SOURCE CODE FILE: C.BI2
*************************************************************************


================================================================================================
FILE: "SOS.C.S.TEXT"
================================================================================================
*************************************************************************
* APPLE /// SOS 1.3 SOURCE CODE FILE: C.S
*************************************************************************
* ASSEMBLER: APPLE ][ 6502 ASSEMBLER from APPLE COMPUTER TOOLKIT

:TABS 17,23,40
::PR#1,L58 132N
SL4:DR2:ASM BUFMGR.SRC,BUFMGR.OBJ,6,1
SL4:DR2:ASM MEMMGR.A.SRC,MEMMGR.OBJ,6,1
END

*************************************************************************
* END OF APPLE /// SOS 1.3 SOURCE CODE FILE: C.S
*************************************************************************


================================================================================================
FILE: "SOS.C3.TEXT"
================================================================================================
*************************************************************************
* APPLE /// SOS 1.3 SOURCE CODE FILE: C3
*************************************************************************
* ASSEMBLER: APPLE ][ 6502 ASSEMBLER from APPLE COMPUTER TOOLKIT

:TABS 17,23,40
::PR#1,L58 132N
SL4:DR1:ASM SOSLDR.SRC,SOSLDR.OBJ,6,1
SL4:DR2:ASM BUFMGR.SRC,BUFMGR.OBJ,6,1
SL4:DR2:ASM MEMMGR.A.SRC,MEMMGR.OBJ,6,1
END

*************************************************************************
* END OF APPLE /// SOS 1.3 SOURCE CODE FILE: C3
*************************************************************************


================================================================================================
FILE: "SOS.CFMGR.SRC.TEXT"
================================================================================================
*************************************************************************
* APPLE /// SOS 1.3 SOURCE CODE FILE: CFMGR.SRC
*************************************************************************
* ASSEMBLER: APPLE ][ 6502 ASSEMBLER from APPLE COMPUTER TOOLKIT

*SBTL "SOS 1.1 CHARACTER FILE MANAGER"
*REL
					INCLUDE SOSORG,6,1,254
ORG ORGCFM
ZZORG .eq *
*MSB OFF
*REP 60
* COPYRIGHT (C) APPLE COMPUTER INC. 1980
* ALL RIGHTS RESERVED
*REP 60
*
* CHARACTER FILE MANAGER (VERSION = 1.1O )
* (DATE = 8/04/81)
*
* THIS MODULE TRANSFORMS CHARACTER FILE SYSTEM CALLS INTO
* DEVICE CALLS TO THE APPROPRIATE DEVICE HANDLER. ONLY
* OPEN, NEWLINE, READ, WRITE AND CLOSE CALLS ARE PERMITTED
* ON CHARACTER FILES.
*
*REP 60
*
*ENTRY CFMGR
*
*ENTRY CFCB.MAX
*ENTRY CFCB.DEV
*
*EXTRN DMGR
*EXTRN LEVEL
*EXTRN MAX.DNUM
*EXTRN SXPAGE
*
*EXTRN SYSERR
*EXTRN SERR
*EXTRN BADSCNUM
*EXTRN CFCBFULL
*EXTRN BADREFNUM
*EXTRN FNFERR
*PAGE
*REP 60
*
* DATA DECLARATIONS
*
*REP 60
*
* FILE CALL PARM LOCATIONS ON SOS ZPAGE
*
F.TPARMX .eq $A0
REQCODE .eq F.TPARMX
O.PATH .eq F.TPARMX+1 ; OPEN'S PATHNAME LOC
O.REFNUM .eq F.TPARMX+3 ; OPEN'S REFNUM LOC
REFNUM .eq F.TPARMX+1 ; REFNUM'S LOC IN OTHER CALLS
NL.ISNL .eq F.TPARMX+2 ; NEWLINE'S ISNEWLINE LOC
NL.NLCHR .eq F.TPARMX+3 ; NEWLINE'S NEWLINECHAR LOC
RW.BUF .eq F.TPARMX+2 ; READ/WRITE'S BUF LOC
RW.BYTES .eq F.TPARMX+4 ; READ/WRITE'S BYTES LOC
RD.BYTESRD .eq F.TPARMX+6 ; READ'S BYTESREAD LOC
*
* FILE REQUEST CODE VALUES
*
OPEN .eq 8
NEWLINE .eq 9
READ .eq $A
WRITE .eq $B
CLOSE .eq $C
*PAGE
* DEVICE CALL PARM LOCATIONS ON SOS ZPAGE
*
D.TPARMX .eq $C0
D.SCNUM .eq D.TPARMX ; DEVICE SYS CALL # LOC
GDN.DNAME .eq D.TPARMX+1 ; GETDEVNUM DNAME LOC
GDN.DNUM .eq D.TPARMX+3 ; GETDEVNUM DNUM LOC

D.DNUM .eq D.TPARMX+1 ; OPN/CLOSE/RD/WR/CTRL'S DNUM LOC
DRW.BUF .eq D.TPARMX+2 ; RD/WR'S BUF LOC
DRW.BYTES .eq D.TPARMX+4 ; RD/WR'S BYTES LOC
DRD.BYTESRD .eq D.TPARMX+8 ; RD/WR'S BYTESREAD LOC
DC.CCODE .eq D.TPARMX+2 ; DCTRL'S CTRLCODE LOC
DC.CLIST .eq D.TPARMX+3 ; DCTRL'S CTRLLIST LOC
*
* DEVICE REQUEST CODE VALUES
*
DREAD .eq $0
DWRITE .eq $1
DCTRL .eq $3
GETDEVNUM .eq $4
DOPEN .eq $6
DCLOSE .eq $7
*
CTRL.LIST DS 2 ; CONTAINER FOR NEWLINE DCTRL CALL
NEWLINECC .eq 2 ; NEWLINE CTRL CODE
*
* GETDNUM VARS
*
DNUM.TEMP DS 1
*
* CLOSEALL VARS
*
DCLOSE.ERR .eq F.TPARMX+$F
DCLOSE.TBL .eq $200
TRUE .eq $80
FALSE .eq $0
*
*
*REP 60
*
* CHARACTER FILE CONTROL BLOCK TABLE
* (ENTRY 0 IS NOT USED)
*
*REP 60
CFCB.MAX .eq 17
CFCB.DEV DS CFCB.MAX
CFCB.LVL DS CFCB.MAX
*PAGE
*REP 60
*
* CHARACTER FILE MANAGER - MAIN ENTRY POINT
*
*REP 60
CFMGR .eq *
*
* SWITCH, BASED ON REQUEST CODE
*
					lda REQCODE
					cmp #OPEN
					beq CFOPEN ; "OPEN"
					cmp #NEWLINE
					beq CFNEWLINE ; "NEWLINE"
					cmp #READ
					beq CFREAD ; "READ"
					cmp #WRITE
					bne CFM010
					jmp CFWRITE ; "WRITE"
CFM010 CMP #CLOSE
					bne CFM020
					jmp CFCLOSE ; "CLOSE"
CFM020				lda #BADSCNUM
					jsr SYSERR ; ERR EXIT
*PAGE
*REP 60
* OPEN(IN.PATHNAME; OUT.REFNUM; IN.OPENLIST,LENGTH) SYSTEM CALL
*REP 60
CFOPEN				.eq *; BUILD "D.OPEN" CALL
					jsr GETDNUM ; MAP PATH TO DEV#
					bcs CFOP.ERR1 ; ERR - FILE NOT FOUND
					sta D.DNUM
*
					jsr REQ.CFCB ; BUILD NEW CFCB ENTRY
					bcs CFOP.ERR1 ; ERR - CFCB FULL
					ldx #0
					sta (O.REFNUM,X) ; RETURN REFNUM TO CALLER
					cpy #1
					bne CFOP.EXIT ; DEVICE ALREADY OPEN
*

					lda #DOPEN
					sta D.SCNUM
					jsr DMGR ; DOPEN CALL
					bcs CFOP.ERR
CFOP.EXIT			rts ; NORMAL EXIT
*
CFOP.ERR				lda SERR ;KLUDGE - 1.0 DRIVERS DON'T SUPPORT CARRY ERR PROTOCOL
					beq CFOP.EXIT ;NO ERROR
					ldx #0 ; RELEASE CFCB ENTRY
					lda (O.REFNUM,X)
					jsr REL.CFCB
CFOP.ERR1			RTS ; ERR EXIT
*PAGE
*REP 60
* NEWLINE(IN.REFNUM,IS .NEWLINE,NEWLINE.CHAR) SYSTEM CALL
*REP 60
CFNEWLINE			.eq *; BUILD "D.CONTROL" CALL
					lda #DCTRL
					sta D.SCNUM
					lda REFNUM
					jsr GET.CFCB ; MAP REFNUM TO DEV #
					bcs CFNL.ERR ; ERR - BAD REFNUM
*
					sta D.DNUM
					lda #NEWLINECC
					sta DC.CCODE
*
					lda #>CTRL.LIST
					sta DC.CLIST
					lda #<CTRL.LIST
					sta DC.CLIST+1
					lda #0
					sta SXPAGE+DC.CLIST+1
*
					lda NL.ISNL
					sta CTRL.LIST
					lda NL.NLCHR
					sta CTRL.LIST+1
*
					jsr DMGR ; DCONTROL CALL
					rts; NORMAL EXIT
*
CFNL.ERRRTS ; ERR EXIT
*PAGE
*REP 60
* READ(IN.REFNUM,BUF,BYTES,BYTESREAD) SYSTEM CALL
*REP 60
CFREAD				.eq *; BUILD "D.READ" CALL
					lda #DREAD
					sta D.SCNUM
					lda REFNUM
					jsr GET.CFCB ; MAP REFNUM TO DEV #
					bcs CFRD.ERR ; ERR - BAD REFNUM
*
					sta D.DNUM
					ldx #3
CFRD010				lda RW.BUF,X
					sta DRW.BUF,X
					dex
					bpl CFRD010
*
					lda RD.BYTESRD
					sta DRD.BYTESRD
					lda RD.BYTESRD+1
					sta DRD.BYTESRD+1
*
					lda SXPAGE+RW.BUF+1
					sta SXPAGE+DRW.BUF+1
					lda SXPAGE+RW.BYTES+1
					sta SXPAGE+DRW.BYTES+1
					lda SXPAGE+RD.BYTESRD+1
					sta SXPAGE+DRD.BYTESRD+1
*
					jsr DMGR ; DREAD CALL
					rts; NORMAL EXIT
*
CFRD.ERR RTS ; ERR EXIT
*PAGE
*REP 60
* WRITE(IN.REFNUM,BUF,BYTES) SYSTEM CALL
*REP 60

CFWRITE				.eq *; BUILD "D.WRITE" CALL
					lda #DWRITE
					sta D.SCNUM
					lda REFNUM
					jsr GET.CFCB ; MAP REFNUM TO DEV #
					bcs CFWR.ERR ; ERR - BAD REFNUM
					sta D.DNUM
					ldx #3
CFWR010				lda RW.BUF,X
					sta DRW.BUF,X
					dex
					bpl CFWR010
					lda SXPAGE+RW.BUF+1
					sta SXPAGE+DRW.BUF+1
					lda SXPAGE+RW.BYTES+1
					sta SXPAGE+DRW.BYTES+1
*
					jsr DMGR ; DWRITE CALL
					rts; NORMAL EXIT
*
CFWR.ERR RTS ; ERR EXIT
*PAGE
*REP 60
* CLOSE(IN.REFNUM) SYSTEM CALL
*REP 60
CFCLOSE				.eq *; BUILD "D.CLOSE" CALL
					lda #DCLOSE
					sta D.SCNUM
					lda REFNUM
					beq CLOSEALL
*
					jsr REL.CFCB ; RELEASE CFCB ENTRY
					bcs CFCL010
					sta D.DNUM
					tya
					bne CFCL010
					jsr DMGR ; DCLOSE CALL
CFCL010 RTS ; NORMAL EXIT
*
*PAGE
*REP 60
*
* CLOSE ALL CHARACTER FILES W/LEVELS >= TO CURRENT SYSTEM FILE LEVEL.
*
*REP 60
*
CLOSEALL .eq *
					lda #FALSE ; SET ENTRIES IN DEV CLOSE TBL TO FALSE
					ldx MAX.DNUM
CFCL020				sta DCLOSE.TBL,X
					dex
					bpl CFCL020
*
					ldx #CFCB.MAX-1 ; CLOSE ALL DEVICES >= TO CURRENT LEVEL
CFCL030				lda CFCB.DEV,X ; AND MARK TRUE IN DEV CLOSE TBL
					tay
					bmi CFCL050
					lda CFCB.LVL,X
					cmp LEVEL
					bcc CFCL050
					lda #TRUE
					sta DCLOSE.TBL,Y
					clc
					ror CFCB.DEV,X
CFCL050 DEX
					bne CFCL030
*
					ldx #CFCB.MAX-1 ; DON'T CLOSE DEVICES < CURRENT LEVEL
CFCL060				lda CFCB.DEV,X
					tay
					bmi CFCL070
					lda #FALSE
					sta DCLOSE.TBL,Y
CFCL070 DEX
					bne CFCL060
*
					lda #0
					sta DCLOSE.ERR
					ldx MAX.DNUM ; ISSUE D'CLOSE CALLS TO ALL DEVICES MARKED AS TRUE
CFCL080				lda DCLOSE.TBL,X ; IN DEV CLOSE TABLE
					bpl CFCL090

					txa
					pha
					stx D.DNUM
					jsr DMGR
					pla
					tax
					lda SERR
					beq CFCL090 ; IF ERROR,
					sta DCLOSE.ERR ; THEN SAVE IT
CFCL090 DEX
					bne CFCL080
*
					lda DCLOSE.ERR ; IF $0 THEN NO ERRORS FROM D.CLOSE CALLS
					bne CFCL.ERR
					rts; NORMAL EXIT
CFCL.ERR				jsr SYSERR ; RETURN LAST D.CLOSE ERROR REPORTED
*PAGE
*REP 60
*
* GET DEVICE NUMBER
*
* INPUT: CPATH
* OUTPUT: DEVICE NUMBER (A)
* ERROR: CARRY SET ("FILE NOT FOUND")
*
* GETDNUM FIRST CALLS THE DMGR (GETDEVNUM) MAP THE PATHNAME
* TO A DEVICE #. GETDNUM THEN ENSURES THAT THE PATHNAME
* IS NOT A BLOCK DEVICE BY CHECKING THE DBLKLST TABLE.
*
*REP 60
*
GETDNUM .eq *
					lda #GETDEVNUM
					sta D.SCNUM
*
					lda O.PATH
					sta GDN.DNAME
					lda O.PATH+1
					sta GDN.DNAME+1
*
					lda #>DNUM.TEMP
					sta GDN.DNUM
					lda #<DNUM.TEMP
					sta GDN.DNUM+1
*
					lda SXPAGE+O.PATH+1
					sta SXPAGE+GDN.DNAME+1
					lda #0
					sta SXPAGE+GDN.DNUM+1
*
					jsr DMGR
					bcs GETD.ERR ; D.NAME NOT FOUND
					bmi GETD.ERR ; BLOCK DEVICE FOUND
					lda DNUM.TEMP
					rts
*
GETD.ERR				lda #FNFERR
					jsr SYSERR
*PAGE
*REP 60
* REQUEST FCB ENTRY
*
* INPUT: DNUM (A)
* OUTPUT: REFNUM (A), OPENCT (Y)
* ERROR: CARRY SET ("CFCB FULL")
*
* REQ.CFCB FIRST SEARCHES THE CFCB TABLE USING THE DEV#
* AS A KEY. IF FOUND THE OPENCT IS INCREMENTED, OTHERWISE,
* REQ.CFCB FINDS A FREE ENTRY AND STORES THE DEV# AND LEVEL #.
*
*REP 60
*
REQ.CFCB .eq *
					ldx #CFCB.MAX-1
					tay
REQ010				lda CFCB.DEV,X
					bmi REQ020
					dex
					bne REQ010
					lda #CFCBFULL
					jsr SYSERR

REQ020 TYA
					sta CFCB.DEV,X
					lda LEVEL
					sta CFCB.LVL,X
					txa
					pha
					tya
					jsr OPENCOUNT
					pla
					ora #$80
					clc
					rts; NORMAL EXIT
*PAGE
*REP 60
*
* RELEASE FCB ENTRY
*
* INPUT: REFNUM (A)
* OUTPUT: DNUM (A), OPENCT (Y)
* ERROR: CARRY SET ("INVALID REFNUM")
*
* USES REFNUM AS AN CFCB TABLE INDEX TO RELEASE A CFCB ENTRY.
*
*REP 60
REL.CFCB .eq *
					and #$7F
					cmp #CFCB.MAX
					bcs REL.ERR
					tax
					lda CFCB.DEV,X
					bmi REL.ERR
					clc ; MARK ENTRY FREE
					ror CFCB.DEV,X
					jsr OPENCOUNT
					clc
					rts; NORMAL EXIT
*
REL.ERR				lda #BADREFNUM
					jsr SYSERR
*REP 60
*
* OPENCOUNT SUBROUTINE
*
* INPUT: DEVNUM (A)
* OUTPUT: DEVNUM (A), OPENCTR (Y)
*
* OPENCTR:=COUNT OF ALL CFCB ENTRIES W/CFCB.DEV=DEVNUM
*
*REP 60
OPENCOUNT .eq *
					ldy #0
					ldx #CFCB.MAX-1
OPNCT010 CMP CFCB.DEV,X
					bne OPNCT020
					iny
OPNCT020 DEX
					bne OPNCT010
					rts
*PAGE
*REP 60
*
* GET FCB ENTRY
*
* INPUT: REFNUM (A)
* OUTPUT: DNUM (A)
* ERROR: CARRY SET ("INVALID REFNUM")
*
* USES REFNUM AS AN INDEX TO RETURN THE CORRESPONDING DEVICE #.
* IF THE ENTRY INDICATED BY REFNUM IS A FREE ENTRY, THEN AN
* ERROR, "INVALID REF NUM" IS RETURNED.
*
*REP 60
GET.CFCB .eq *
					and #$7F
					cmp #CFCB.MAX
					bcs GET.ERR
					tax
					lda CFCB.DEV,X
					bmi GET.ERR
					clc
					rts; NORMAL EXIT

*
GET.ERR				lda #BADREFNUM
					jsr SYSERR ; ERR EXIT
*
*LST ON
ZZEND .eq *
ZZLEN .eq ZZEND-ZZORG
IFNE ZZLEN-LENCFM
FAIL 2,"SOSORG FILE IS INCORRECT FOR CFMGR"
FIN

*************************************************************************
* END OF APPLE /// SOS 1.3 SOURCE CODE FILE: CFMGR.SRC
*************************************************************************



================================================================================================
FILE: "SOS.CLOSE.EOF.TEXT"
================================================================================================
*************************************************************************
* APPLE /// SOS 1.3 SOURCE CODE FILE: CLOSE.EOF
*************************************************************************
* ASSEMBLER: APPLE ][ 6502 ASSEMBLER from APPLE COMPUTER TOOLKIT

*PAGE
*
*
CLOSE				lda C.REFNUM ; CLOSE ALL?
					bne CLOSE1 ; NO, JUST ONE OF 'EM
					sta CFERR ; CLEAR GLOBAL CLOSE ERROR
					jsr GFCBADR ; SET UP POINTER TO FCB
CLOSALL				lda #0 ; BEGIN AT THE BEGINNING.
CLSALL1				sta FCBPTR ; SAVE CURRENT LOW BYTE OF POINTER
					ldy #FCBLEVL ; FETCH THE LEVEL AT WHICH
					lda (FCBPTR),Y ; FILE WAS OPENED
					cmp LEVEL ; TEST AGAINST CURRENT GLOBAL LEVEL
					bcc NXTCLOS ; DONT CLOSE IF FILES LEVEL IS < GLOBAL LEVEL
					ldy #FCBREFN ; INDEX TO REFERENCE NUMBER
					lda (FCBPTR),Y ; IS THIS REFERENCE FILE OPEN?
					beq NXTCLOS ; NO, TRY NEXT.
					jsr FLUSH2 ; CLEAN IT OUT...
					bcs CLOSERR ; RETURN FLUSH ERRORS
					jsr CLOSE2 ; UPDATE FCB & VCB
					ldy C.REFNUM
					beq NXTCLOS ; NO ERR IF CLOSE ALL
					bcs CLOSERR
NXTCLOS				lda FCBPTR ; BUMP POINTER TO NEXT FILE CONTROL BLOCK.
					clc
					adc #$20
					bcc CLSALL1 ; BRANCH IF WITHIN SAME PAGE.
					lda FCBPTR+1
					inc FCBPTR+1 ; BUMP TO NEXT PAGE.
					cmp FCBADDRH ; HAVE WE CHECKED BOTH PAGES?
					beq CLOSALL ; YES, RETURN NO ERROR.
					clc
					lda CFERR ; ON FINAL CLOSE OF CLOSE ALL REPORT LOGGED ERRORS
					beq C3 ; BRANCH IF NO ERRORS
					clc
C3 RTS
*
*
CFERR DS 1 ; GLOBAL ERROR FLAG FOR FLUSH AND CLOSE ALL
*
*
CLOSE1				jsr FLUSH1 ; FLUSH FILE FIRST (INCLUDING UPDATING BIT MAP)
					bcs CLOSERR
CLOSE2 LDY #FCBBUFN
					lda (FCBPTR),Y
					jsr RELBUF
					bcs CLOSERR
					lda #0
					ldy #FCBREFN
					sta (FCBPTR),Y
					iny ; BUMP TO 'FCBDEVN'
					lda (FCBPTR),Y
					sta DEVNUM ; GO LOOK FOR ASSOCIATED VCB.
					jsr DEVVCB
					ldx VCBPTR ; GET VCBPTR
					dec VCB+VCBOPNC,X ; INDICATE ONE LESS FILE OPEN.
					bne CLOSEND ; BRANCH IF THAT WASN'T THE LAST...
					lda VCB+VCBSTAT,X
					and #$7F ; STRIP 'FILES OPEN' BIT
					sta VCB+VCBSTAT,X
CLOSEND CLC
					rts
CLOSERR JMP GLBERR ; DON'T REPORT CLOSALL ERR NOW
*
*PAGE
*
FLUSH				lda C.REFNUM ; FLUSH ALL?
					bne FLUSH1 ; NO, JUST ONE OF 'EM
					sta CFERR ; CLEAR GLOBAL FLUSH ERROR
					jsr GFCBADR ; SET UP POINTER TO FCB
FLSHALL				lda #0 ; BEGIN AT THE BEGINNING.
FLSHAL1				sta FCBPTR ; SAVE CURRENT LOW BYTE OF POINTER

					ldy #FCBREFN ; INDEX TO REFERENCE NUMBER
					lda (FCBPTR),Y ; IS THIS REFERENCE FILE OPEN?
					beq NXFLUSH ; NO, TRY NEXT.
					jsr FLUSH2 ; CLEAN IT OUT...
					bcs FLSHERR ; RETURN ANY ERRORS
*
					bcs CLOSERR
NXFLUSH				lda FCBPTR ; BUMP POINTER TO NEXT FILE CONTROL BLOCK.
					clc
					adc #$20
					bcc FLSHAL1 ; BRANCH IF WITHIN SAME PAGE.
					lda FCBPTR+1
					inc FCBPTR+1 ; BUMP TO NEXT PAGE.
					cmp FCBADDRH ; HAVE WE CHECKED BOTH PAGES?
					beq FLSHALL ; YES, RETURN NO ERROR.
FLUSHEND CLC
					lda CFERR ; ON LAST FLUSH OF A FLUSH(0)
					beq F3 ; BRANCH IF NO LOGGED ERRORS
					clc ; REPORT ERROR NOW
F3 RTS
FLSHERR JMP GLBERR ; FLUSH ALL OR ONE?
*
FLUSH2				jsr FNDFCBUF ; MUST SET UP ASSOCIATED VCB AN BUFFER LOCATIONS FIRST.
					bcc FLUSH2A ; BRANCH IF NO ERROR ENCOUNTERED.
					jmp GLBERR ; CHECK FOR CLOSE OR FLUSH ALL
*
FLUSH1				lda #0 ; CLEAR
					sta CFERR ; GLOBAL ERROR FOR NORMAL REFNUM FLUSH
					jsr FINDFCB ; SET UP POINTER TO FCB USER REFERENCES
					bcs FLSHERR ; RETURN ANY ERRORS
FLUSH2A LDY #FCBATTR ; TEST TO SEE IF FILE IS
					lda (FCBPTR),Y ; MODIFIED. FIRST TEST WRITE ENABLED.
					and #WRITEN
					beq FLUSHEND ; BRANCH IF 'READ ONLY'
					ldy #FCBDIRTY ; SEE IF EOF HAS BEEN MODIFIED
					lda (FCBPTR),Y
					bmi FLUSH2B ; BRANCH IF IT HAS
					ldy #FCBSTAT ; NOW TEST FOR DATA MODIFIED.
					lda (FCBPTR),Y ; (IN OTHER WORDS: WAS FILE ACTUALLY
					and #USEMOD+EOFMOD+DATMOD ; WRITTEN TO WHILE IT'S BEEN OPEN?)
					beq FLUSHEND ; BRANCH IF FILE NOT MODIFIED.
FLUSH2B				jsr TWRPROT1 ; DISK SWITCH CHECKING
					lda DSWGLOB
					beq FLUSH2C ; BRANCH IF NO SWITCH
					lda #XDISKSW
					clc
					rts; FORCES A VERIFIED RETRY
FLUSH2C LDY #FCBSTAT ; NOW TEST FOR DATA MODIFIED.
					lda (FCBPTR),Y
					and #DATMOD ; DOES CURRENT DATA BUFFER NEED TO BE
					beq FLUSH3 ; WRITTEN? BRANCH IF NOT.
					jsr WFCBDAT ; IF SO, GO WRITE IT STUPID!
					bcs FLSHERR
FLUSH3 LDY #FCBSTAT ; CHECK TO SEE IF THE INDEX BLOCK (TREE FILES ONLY)
					lda (FCBPTR),Y ; NEEDS TO BE WRITTEN.
					and #IDXMOD
					beq FLUSH4 ; BRANCH IF NOT...
					jsr WFCBIDX
					bcs FLSHERR ; RETURN ANY ERRORS.
*PAGE
*
FLUSH4 LDY #FCBENTN ; NOW PREPARE TO UPDATE DIRECTORY
OWNRMOV				lda (FCBPTR),Y ; NOTE: THIS CODE DEPENDS ON THE
					sta D.DEV-FCBDEVN,Y ; DEFINED ORDER OF THE FILE CONTROL
					dey ; BLOCK AND THE TEMPORARY DIRECTORY AREA IN 'WORKSPC'! *************
					cpy #FCBDEVN-1
					bne OWNRMOV
					lda D.HEAD ; READ IN THE DIRECTORY HEADER FOR THIS FILE
					sta BLOKNML
					lda D.HEAD+1
					sta BLOKNMH
					lda D.DEV
					sta DEVNUM
					jsr RDGBUF ; READ IT INTO THE GENERAL PURPOSE BUFFER
					bcs FLSHERR ; BRANCH IF ERROR.
					jsr MOVHED0 ; MOVE HEADER INFO.
					lda D.ENTBLK ; GET ADDRESS OF DIRECTORY BLOCK THAT
					ldy D.ENTBLK+1 ; CONTAINS THE FILE ENTRY.
					cmp D.HEAD ; TEST TO SEE IF IT'S THE SAME BLOCK THAT
					bne FLSHEBLK ; THE HEADER IS IN. BRANCH IF NOT.
					cpy D.HEAD+1

					beq FLUSH5 ; BRANCH IF HEADER BLOCK = ENTRY BLOCK.
FLSHEBLK				sta BLOKNML
					sty BLOKNMH
					jsr RDGBUF ; GET BLOCK WITH FILE ENTRY IN GENERAL BUFFER.
FLUSH5				jsr ENTCALC ; SET UP POINTER TO ENTRY
					jsr MOVENTRY ; MOVE ENTRY TO TEMP ENTRY BUFFER IN 'WORKSPC'
					ldy #FCBUSE ; UPDATE 'BLOCKS USED' COUNT.
					lda (FCBPTR),Y
					sta DFIL+D.USAGE
					iny
					lda (FCBPTR),Y
					sta DFIL+D.USAGE+1 ; HI BYTE TOO...
					ldy #FCBEOF ; AND MOVE IN END OF FILE MARK WHETHER
EOFUPDTE				lda (FCBPTR),Y ; WE NEED TO OR NOT.
					sta DFIL+D.EOF-FCBEOF,Y
					iny ; MOVE ALL THREE BYTES.
					cpy #FCBEOF+3
					bne EOFUPDTE
					ldy #FCBFRST ; ALSO MOVE IN THE ADDRESS OF
					lda (FCBPTR),Y ; THE FILE'S FIRST BLOCK SINCE
					iny ; IT MIGHT HAVE CHANGED SINCE THE FILE
					sta DFIL+D.FRST ; FIRST OPENED.
					lda (FCBPTR),Y
					sta DFIL+D.FRST+1
*PAGE
					ldy #FCBSTYP ; AND THE LAST THING TO UPDATE IS
					lda (FCBPTR),Y ; THE STORAGE TYPE.
					asl A ; (SHIFT IT INTO THE HI NIBBLE)
					asl A
					asl A
					asl A
					sta SCRTCH
					lda DFIL+D.STOR ; GET OLD TYPE BYTE (IT MIGHT BE THE SAME)
					and #$F ; STRIP OFF OLD TYPE
					ora SCRTCH ; ADD IN THE NEW TYPE,
					sta DFIL+D.STOR ; AND PUT IT AWAY.
					jsr DREVISE ; GO UPDATE DIRECTORY!
					bcs FLUSHERR
					ldy #FCBDIRTY ; MARK
					lda (FCBPTR),Y ; FCB/DIRECTORY
					and #$FF-FCBMOD ; AS
					sta (FCBPTR),Y ; UNDIRTY
					ldx #0 ; NOW CHECK TO SEE IF A BIT MAP
					lda D.DEV ; IS LYING AROUND THAT SHOULD BE WRITTEN.
					cmp BMADEV ; IS IT IN MAP BUFFER A?
					beq BMAPUP ; YES, PUT IT ON THE DISK IF NECESSARY.
					ldx #BMTABSZ ; SET INDEX TO BIT MAP TABLE 'B'
					cmp BMBDEV ; NO, WHAT ABOUT BIT MAP BUFFER B?
					bne FLSHEND1 ; NOPE, ALL DONE.
BMAPUP				lda BMASTAT,X ; TEST TO SEE IF IT'S BEEN MODIFIED.
					bpl FLSHEND1 ; NOPE, ALL DONE AS I SAID.
					stx BMTAB
					jsr WRTBMAP ; GO PUT IT AWAY.
					bcs FLUSHERR
					ldx BMTAB ; MARK MAP AS UPDATED
					lda #0
					sta BMASTAT,X
FLSHEND1 CLC
					rts
FLUSHERR			.eq *; DROP INTO GLBERR
*
GLBERR				.eq *; REPORT ERROR IMMEDIATELY
* ONLY IF NOT A CLOSE ALL OR FLUSH ALL
					ldx C.REFNUM
					bne GLBERR1 ; NOT AN 'ALL' SO REPORT NOW
					clc
					sta CFERR ; SAVE FOR LATER
GLBERR1 RTS
*
*
GFCBADR				lda FCBANKNM ; GET BANK THAT FCB IS IN
					sta SISFCBP
					lda FCBADDRH ; AND HIGH BYTE ADDRESS OF FILE CONTORL BLOCK.
					sta FCBPTR+1
					rts; SILLY THAT IT'S SO SHORT...
*
SETERR				lda #ACCSERR
					clc
EOFRETN RTS
*PAGE
*

SETEOF LDY #FCBSTYP ; ONLY KNOW HOW TO MOVE EOF OF TREE TYPE
					lda (FCBPTR),Y
					cmp #TRETYP+1
					bcs SETERR ; BRANCH IF OTHER THAN TREE
					ldy #FCBATTR ; NOW CHECK TO INSURE WRITE IS ENABLED.
					lda (FCBPTR),Y
					and #WRITEN ; CAN WE SET NEW EOF?
					beq SETERR ; NOPE, ACCESS ERROR.
					jsr TSTWPROT ; FIND OUT IF MOD IS POSIBLE (HARDWARE WRITE PROTECT)
					bcs SETERR
					ldy #FCBEOF+2 ; SAVE OLD EOF
					ldx #2 ; SO IT CAN BE SEEN
SETSAVE				lda (FCBPTR),Y ; WHETHER BLOCKS NEED
					sta OLDEOF,X ; TO BE RELEASED
					dey ; UPON
					dex ; CONTRACTION
					bpl SETSAVE ; ALL THREE BYTES OF THE EOF
					jsr ADJMARK ; GET ADJUSTED END OF FILE ACCORDING TO 'C.BASE' INTO TPOS.
					bcs EOFRETN ; RETURN ANY ERROR IMMEDIATELY
					ldx #2
NEOFPOS				lda TPOSLL,X ; POSITION MARK TO NEW EOF
					sta C.NEWEOF,X
					dex
					bpl NEOFPOS
					ldy #FCBMARK+2 ; FIND OUT IF EOF < MARK.
					ldx #2
NEOFTST				lda (FCBPTR),Y
					cmp C.NEWEOF,X ; COMPARE UNTIL NOT EQUAL OR CARRY CLEAR
					bcc SETEOF1 ; BRANCH IF EOF>MARK
					bne SETEOF0 ; BRANCH IF EOF<MARK
					dey
					dex
					bpl NEOFTST ; LOOP ON ALL THREE BYTES
SETEOF0				jsr RDPOSN ; READ IN NEW POSITION.
					bcs EOFRETN ; RETURN ANY ERRORS.
SETEOF1				ldx #2
					ldy #FCBEOF+2 ; MOVE NEW EOF TO FCB.
SETEOF2				lda C.NEWEOF,X
					sta (FCBPTR),Y
					dey
					dex
					bpl SETEOF2 ; MOVE ALL THREE BYTES.
					jsr FCBUSED ; MARK FCB AS DIRTY (FOR FLUSH)
*
					ldx #2 ; POINT TO THIRD BYTE
PURTEST				lda OLDEOF,X ; SEE IF EOF MOVED BACKWARDS
					cmp C.NEWEOF,X ; SO BLOCKS CAN
					bcc PURTEST1 ; BE RELEASED (BRANCH IF NOT)
					bne PURGE ; BRANCH IF BLOCKS TO BE RELEASED
					dex
					bpl PURTEST ; ALL THREE BYTES
PURTEST1 JMP FLSHEND1 ; NEW EOF NOT SMALLER
TRELEAS1 JMP TRELEASE ; OVERFLOW PREVENTER
*
PURGE LDY #FCBSTYP ; FIND OUT WHAT TYPE OF TREE
					lda (FCBPTR),Y ; TO PERFORM THE PROPER
					cmp #SEEDTYP ; STYLE OF BLOCK RELEASE
					beq EOFOUT ; SEED DON'T DEALLOCATE
					cmp #TRETYP ; FULL TREE?
					beq TRELEAS1 ; BRANCH IF YES
*
* IF WE GET HERE, WE ARE RELEASING
* BLOCKS AT THE END OF A SAPLING FILE: CALCULATE CORRECT POSITION
* WITHIN THE INDEX BLOCK AND ALLOW SUBROUTINE
* PURGE LATTER BLOCKS TO DEALLOCATE
* ALL THE DATA BLOCKS THAT FOLLOW
*
					jsr FNDBMAP ; REFRESH THE RIGHT MAP FOR THIS VOLUME
					ldx TPOSHI ; PRELOAD
					ldy TPOSLH ; THE THREE EOF
					lda TPOSLL ; BYTES
					bne PUR1 ; BRANCH IF NO BOUNDARY ADJUSTMENT NEEDED
					cpy #0
					bne PUR2 ; MIDDLE BYTE ZERO MEANS NO CARRY
					cpx #0 ; ALL BYTES ZERO??
					beq PUR1 ; BRANCH IF YES
					dex
*
* THESE LINES IF CODE, SOMEWHAT CRYPTIC,
* CALCULATE THE POINT AT WHICH THE
* LAST BLOCK CONTAINING THE LAST BIT

* OF DATUM
*
* THE FOLLOWING IS ROUGHLY A /512
* ALGORITHM
*
PUR2 DEY
PUR1				txa
					lsr A
					tya
					ror A
*
					jsr PURLBLKS ; MAKES A GOOD PTR TO DO THE RELEASING
					ldy #FCBSTAT ; MARK INDEX BLOCK
					lda (FCBPTR),Y ; AS DIRTY
					ora #IDXMOD
					sta (FCBPTR),Y
					lda PURUSE ; INDICATE NEW NUMBER OF BLOCKS USED
					clc
					adc #2 ; ACCOUNT FOR CARDINAL AND INDEX
					ldy #FCBUSE
					sta (FCBPTR),Y ; FILE LOW BYTE
					iny
					lda #0 ; ANTICIPATE <257 BLOCKS
					bcc PURHI
					lda #1 ; >256 BLOCKS IN FILE
PURHI				sta (FCBPTR),Y ; HIGH BYTE BLOCKS USED
EOFOUT CLC
					rts; NO ERRORS POSSIBLE
*
PURLBLKS			.eq *; PURGE LATTER BLOCKS
* INPUT ARG: A REGISTER CONTAINING
* POINTER TO CURRENT DATA BLOCK WITHIN THE
* CURRENT INDEX BLOCK (TINDX)
* DEALLOCATE ALL LEGAL BLOCKS AFTER
* THE A REGISTER PTR. NO ERRORS POSSIBLE
*
					tay ; MAKE PROPER INDEX
					sty PURUSE ; INDICATES NUMBER OF BLOCKS IN USE IN FILE
PURLOOP INY ; POINT TO A PTR TO DATA BLK TO DEALLOCATE
					beq PURLRTS ; NO MORE BLOCKS IN INDEX
					inc TINDX+1 ; GET HIGH PART OF BLOCK ADDR
					lda (TINDX),Y
					tax; X IS A PASSING PARM
					lda #0 ; TELL INDEX BLOCK THAT THE DATA
					sta (TINDX),Y ; BLOCK IS NOW FREE
					txa
					dec TINDX+1 ; AND LOW PART
					ora (TINDX),Y
					beq PURLOOP ; INDICATED ADDR WAS ZERO-ZERO
					lda (TINDX),Y ; A REG IS ANOTHER PASSING PARM
					pha
					lda #0
					sta (TINDX),Y ; AND SET LOW DATA ADDR AS FREED
					pla
					sty PURPLACE ; TEMP STORAGE
					jsr DEALLOC ; DEALLOCATE BLOCK (ADDR: A (LOW), X ( HIGH)
					ldy #VCBTFRE
					clc
					lda (VCBPTR),Y ; ADJUST NUMBER OF FREE BLOCKS ON VOLUME
					adc #1
					sta (VCBPTR),Y
					iny
					lda (VCBPTR),Y ; HIGH BYTE OF TOTAL FREE
					adc #0
					sta (VCBPTR),Y
					ldy PURPLACE
					jmp PURLOOP
PURLRTS RTS
PURUSE DS 1 ; CURRENT NUMBER OF BLOCKS USED
PURPLACE DS 1 ; CURRENT PLACE IN RELEASE-BLOCK CYCLE
TRELEASE .eq *
					jmp EOFOUT ; RELEASE TWO LEVEL TREE CODE GOES HERE
*
GETEOF LDY #FCBEOF ; INDEX TO END OF FILE MARK
					ldx #0 ; WE'VE GOT INDIRECT BOTH WAYS (IN & OUT)
OUTEOF				lda (FCBPTR),Y
					sta (C.OUTEOF,X)
					iny
					cpy #FCBEOF+3
					beq OFFRTS ; BRANCH IF ALL THREE BYTES TRANSFERED.
					inc C.OUTEOF ; BUMP USER'S POINTER.

					bne OUTEOF
					inc C.OUTEOF+1
					bne OUTEOF ; BRANCH ALWAYS
*
CHN DESTROY,4,2

*************************************************************************
* END OF APPLE /// SOS 1.3 SOURCE CODE FILE: CLOSE.EOF
*************************************************************************



================================================================================================
FILE: "SOS.COMP.OPR.IPL.TEXT"
================================================================================================
*************************************************************************
* APPLE /// SOS 1.3 SOURCE CODE FILE: COMP.OPR.IPL
*************************************************************************
* ASSEMBLER: APPLE ][ 6502 ASSEMBLER from APPLE COMPUTER TOOLKIT

:TABS 17,23,40
::PR#1,L58 132N
SL4:DR1:ASM OPRMSG.SRC,OPRMSG.OBJ,6,1
SL4:DR1:ASM IPL.SRC1,IPL.OBJ,6,1
SL4:DR1:A,6,1
END

*************************************************************************
* END OF APPLE /// SOS 1.3 SOURCE CODE FILE: COMP.OPR.IPL
*************************************************************************


================================================================================================
FILE: "SOS.COMP.SOS.NOLIST.TEXT"
================================================================================================
*************************************************************************
* APPLE /// SOS 1.3 SOURCE CODE FILE: COMP.SOS.NOLIST
*************************************************************************
* ASSEMBLER: APPLE ][ 6502 ASSEMBLER from APPLE COMPUTER TOOLKIT

:TABS 17,23,40
SL4:DR1:ASM SOSLDR.SRC,SOSLDR.OBJ,6,1
SL4:DR1:ASM INIT.SRC,INIT.OBJ,6,1
SL4:DR1:ASM SYSGLOB.SRC,SYSGLOB.OBJ,6,1
SL4:DR1:ASM OPRMSG.SRC,OPRMSG.OBJ,6,1
SL4:DR1:ASM BFM.INIT2.SRC,BFM.INIT2.OBJ,6,1
SL4:DR1:ASM IPL.SRC1,IPL.OBJ,6,1
SL4:DR1:ASM UMGR.SRC,UMGR.OBJ,6,1
SL4:DR2:ASM DISK3.SRC,DISK3.OBJ,6,1
SL4:DR2:ASM SYSERR.SRC,SYSERR.OBJ,6,1
SL4:DR2:ASM SCMGR.SRC,SCMGR.OBJ,6,1
SL4:DR2:ASM FMGR.SRC,FMGR.OBJ,6,1
SL4:DR2:ASM CFMGR.SRC,CFMGR.OBJ,6,1
SL4:DR2:ASM DEVMGR.SRC,DEVMGR.OBJ,6,1
SL4:DR2:ASM BUFMGR.SRC,BUFMGR.OBJ,6,1
SL4:DR2:ASM MEMMGR.A.SRC,MEMMGR.OBJ,6,1
END

*************************************************************************
* END OF APPLE /// SOS 1.3 SOURCE CODE FILE: COMP.SOS.NOLIST
*************************************************************************



================================================================================================
FILE: "SOS.COMPILE.BFM.TEXT"
================================================================================================
*************************************************************************
* APPLE /// SOS 1.3 SOURCE CODE FILE: COMPILE.BFM
*************************************************************************
* ASSEMBLER: APPLE ][ 6502 ASSEMBLER from APPLE COMPUTER TOOLKIT

:T 17,23,40
::PR#1,L58 132N
::SL4:DR1:ASM PRINT,BFM.OBJ,6,1
::END

*************************************************************************
* END OF APPLE /// SOS 1.3 SOURCE CODE FILE: COMPILE.BFM
*************************************************************************


================================================================================================
FILE: "SOS.COMPILE.SOS.TEXT"
================================================================================================
*************************************************************************
* APPLE /// SOS 1.3 SOURCE CODE FILE: COMPILE.SOS
*************************************************************************
* ASSEMBLER: APPLE ][ 6502 ASSEMBLER from APPLE COMPUTER TOOLKIT

:TABS 17,23,40
::PR#1,L58 132N
SL4:DR1:ASM SOSLDR.SRC,SOSLDR.OBJ,6,1
SL4:DR1:ASM INIT.SRC,INIT.OBJ,6,1
SL4:DR1:ASM SYSGLOB.SRC,SYSGLOB.OBJ,6,1
SL4:DR1:ASM BFM.INIT2.SRC,BFM.INIT2.OBJ,6,1
SL4:DR1:ASM OPRMSG.SRC,OPRMSG.OBJ,6,1
SL4:DR1:ASM IPL.SRC1,IPL.OBJ,6,1
SL4:DR2:ASM UMGR.SRC,UMGR.OBJ,6,1
SL4:DR2:ASM DISK3.SRC,DISK3.OBJ,6,1
SL4:DR2:ASM SYSERR.SRC,SYSERR.OBJ,6,1
SL4:DR2:ASM DEVMGR.SRC,DEVMGR.OBJ,6,1
SL4:DR2:ASM SCMGR.SRC,SCMGR.OBJ,6,1
SL4:DR2:ASM FMGR.SRC,FMGR.OBJ,6,1
SL4:DR2:ASM CFMGR.SRC,CFMGR.OBJ,6,1
SL4:DR2:ASM BUFMGR.SRC,BUFMGR.OBJ,6,1
SL4:DR2:ASM MEMMGR.A.SRC,MEMMGR.OBJ,6,1
::END

*************************************************************************
* END OF APPLE /// SOS 1.3 SOURCE CODE FILE: COMPILE.SOS
*************************************************************************



================================================================================================
FILE: "SOS.CREATE.TEXT"
================================================================================================
*************************************************************************
* APPLE /// SOS 1.3 SOURCE CODE FILE: CREATE
*************************************************************************
* ASSEMBLER: APPLE ][ 6502 ASSEMBLER from APPLE COMPUTER TOOLKIT

*PAGE
CREATE .eq *
					inc CFLAG ; SAY WE ARE IN CREATE (DIR EXTEND)
					jsr LOOKFILE ; CHECK FOR DUPLICATE / GET FREE ENTRY
					bcs TSTFNF ; ERROR CODE IN ACC MAY BE 'FILE NOT FOUND'
					lda #DUPERR ; TELL EM A FILE OF THAT NAME ALREADY EXISTS
CRERR1 SEC ; INDICATE ERROR ENCOUNTERED
					rts; RETURN ERROR IN ACC.
*
TSTFNF CMP #FNFERR ; 'FILE NOT FOUND' IS WHAT WE WANT
					bne CRERR1 ; PASS BACK OTHER ERROR.
					lda NOFREE ; TEST FOR DIRECTORY SPACE
					bne CREAT1 ; BRANCH IF VALID FREE ENTRY WAS FOUND.
					lda #DIRFULL ; RETURN DIRECTORY FULL ERROR
					clc
					rts
*
CREAT1 LDY #$9 ; SET UP DEFAULT PARAMETERS FOR CREATE
					lda #0 ; IN THE SPACE DIRECTLY FOLLOWING THE
ZERCALL				sta C.FILID,Y ; CALL SPECIFCATION AND THEN
					dey ; CHECK FOR ADDITIONAL PARAMETERS FROM
					bpl ZERCALL ; USER'S CALL SPEC VIA 'C.CLIST'
					lda #SEEDTYP ; DEFAULT TYPE IS 'SEED' TREE INDEX
					sta C.STOR
					ldy C.XLEN ; GET THE LENGTH OF THE CALL XTENSION LIST
					beq CRENAM ; IF ZERO THEN USE DEFAULTS
					dey ; (SINCE THE POINTER IS AT BYTE 0)
					cpy #$9 ; MAKE SURE WE DON'T HAVE TOO MANY PARAMETERS
					bcc MOVPARM ; MOVE 'EM IF REASONABLE COUNT.
					lda #BADLSTCNT ; INVALID LIST COUNT
					rts; RETURN ERROR.
*
MOVPARM				lda (C.XLIST),Y ; MOVE IN THE USER SPECIFIED
					sta C.FILID,Y ; PARAMETERS. VALIDITY IS CHECKED
					dey ; AT VARIOUS POINTS FURTHER ALONG IN
					bpl MOVPARM ; THIS PROCESS.
CRENAM LDY #0 ; MOVE LOCAL FILE NAME TO ENTRY BUFFER.
					lda (PATHNML),Y ; GET LENGTH OF LOCAL NAME
					tay
CRENAM1				lda (PATHNML),Y
					sta DFIL+D.STOR,Y
					dey ; (MOVE ALL, INCLUDING LENGTH BYTE.)
					bpl CRENAM1
					lda C.FILID ; MOVE FILE AND AUX ID.
					sta DFIL+D.FILID
					lda C.AUXID
					sta DFIL+D.AUXID
					lda C.AUXID+1
					sta DFIL+D.AUXID+1
					lda #READEN+WRITEN+RENAMEN+DSTROYEN
					sta DFIL+D.ATTR
					lda D.HEAD ; SAVE FILE'S HEADER ADDRESS TOO.
					sta DFIL+D.DHDR
					lda D.HEAD+1
					sta DFIL+D.DHDR+1
					jsr TWRPROT1 ; CAN WE WRITE TO THIS DISKETTE?
					bcs CRERR1
					lda C.STOR ; NOW TEST STORAGE TYPE FOR TREE TYPE FILES
					cmp #4 ; NOTE: THIS IS HARD CODED SINCE ALL TREES ARE LESS THAN 4 ***********
					bcc SEED ; BRANCH IF SOME TYPE OF TREE (SEED, SAPLING...)
					jmp NOTREE ; GO TEST FOR SOME OTHER TYPE (SUCH AS DIRECTORY).
*PAGE
*
SEED				ldx #SEEDTYP ;				staRT OUT ASSUMING A SEED FILE
					lda C.EOFHH ; TEST FOR OUT OF RANGE PREALLOCATION
					beq SEED1 ; (HOPEFULLY BRANCH ALWAYS)
OVFLOW				lda #OVRERR ; REPORT UNABLE TO SATISFY REQUEST.
					clc ; INDICATE ERROR
					rts
*
SEED1				lda C.EOFHL ; CALCULATE THE NUMBER OF

					sta DFIL+D.EOF+2 ; BLOCKS NEEDED FOR PRE-ALLOCATION
					lsr A
					tay ; Y HOLDS THE NUMBER OF INDEX BLOCKS NEEDED
					sta DATBLKH
					lda C.EOFLH ; (CARRY UNDISTURBED FROM LAST SHIFT)
					sta DFIL+D.EOF+1
					ror A ; WE NOW HAVE THE LOW ORDER COUNT OF NEEDED DATA BLOCKS
					sta DATBLKL
					lda C.EOFLL
					sta DFIL+D.EOF ; (CARRY IN TACT FROM LOW COUNT)
					bne INCDATA ; BUMP THE COUNT ON DATA BLOCKS IF REQUEST
					bcc TSTSAP ; IS NOT A MULTIPLE OF 512.
					incDATA INC DATBLKL
					bne TSTSAP
					iny ; MUST INCREASE NUMBER OF INDEXES ALSO.
					inc DATBLKH
TSTSAP TYA ; IF NON ZERO, THEN IT'S AT LEAST A SAPLING.
					bne SAPLING
					lda DATBLKL ; TO QUALIFY AS AN HONEST SEED,
					bne TSTSEED ; THEN ONE OR LESS DATA BLOCKS REQUESTED
					inc DATBLKL ; (MUST BE AT LEAST ONE BLOCK ALLOCATED
					bne CREALC ; TYPE IS SEED. BRANCH ALWAYS
TSTSEED CMP #1 ; IF GREATER THAN ONE, IT'S NOT A SEED.
					beq CREALC ; IT IS A SEED. CONTINUE CREATION
					inx ; THE TYPE IS SAPLING.
					iny ; ONE INDEX BLOCK IS NEEDED.
					bne CREALC ; BRANCH ALWAYS
*PAGE
*
SAPLING INX ; TYPE IS AT LEAST SAPLING.
					cmp #1 ; NO MORE THAN ONE INDEX BLOCK FOR A SAPLING
					bne TREE
					lda DATBLKL ; MUST BE SURE THIS IS REAL MAX SAPLING (128K FILE)
					beq CREALC ; BRANCH IF IT IS.
TREE INY ; ACCOUNT FOR ADDITIONAL 2ND LEVEL INDEX
*
					inx ; TYPE IS TREE (2 LEVEL INDEX)
					iny ; ADD AN EXTRA INDEX BLOCK FOR TOP INDEX
CREALC STY INDXBLK ; STORE INDEX BLOCK COUNT
					txa ; PUT STORAGE TYPE IN DIRECTORY ENTRY
					asl A
					asl A
					asl A
					asl A
					ora DFIL+D.STOR
					sta DFIL+D.STOR
					stx LEVELS ; SAVE NUMBER OF INDEX LEVELS FOR PREALLOCATION.
					tya ; NOW FIGURE THE TOTAL NUMBER OF
					clc ; BLOCKS NEEDED (DATA + INDEX BLOCKS)
					adc DATBLKL
					sta DFIL+D.USAGE ; (MIGHT AS WELL RECORD IT IN DIR
					sta REQL ; WHILE WE'RE AT IT.)
					lda DATBLKH
					adc #0 ; UPDATE HI BYTE TOO
					sta DFIL+D.USAGE+1
					sta REQH
					ldx D.DEV ; PASS ALONG THE DEVICE WE'RE TALKIN ABOUT.
					jsr TSFRBLK ; 'TEST FREE BLOCKS' FINDS OUT IF ENOUGH FREE SPACE EXISTS
					bcs OVFLOW ; BRANCH IF NOT ENOUGH SPACE.
					jsr ALC1BLK ; GO ALLOCATE FIRST BLOCK
					bcs CRERR
					sta DFIL+D.FRST ; (RETURNS ACC=LOW Y=HIGH)
					sta IDXADRL ; SAVE AS ADDRESS FOR INCORE INDEX ALSO.
					sty DFIL+D.FRST+1
					sty IDXADRH
					jsr ZERGBUF ; GO CLEAN OUT GBUF
					jsr GTTINDX ; GET TEMPORARY SPACE FOR AN INDEX BLOCK
					jsr ZTMPIDX ; AND ZERO IT OUT.
					ldx LEVELS
					dex ; TEST FOR NUMBER OF LEVELS NEEDED.
					beq ENDCRE ; BRANCH IF SEED FILE.
					dex ; IS IT A SAPLING PRE-ALLOCATION.
					beq SAPFILE
					ldy INDXBLK ; LOAD NUMBER OF INDEX BLOCKS NEEDED
					dey ; REMOVE THE ONE JUST ALLOCATED.
					sty REQL
					sty INDXBLK
					jsr ALCIDXS ; GO ALLOCATE INDEXES FOR LOWER INDEX BLOCKS.
					bcs CRERR
					jsr WRTDFRST ; GO WRITE TREE TOP INDEX BLOCK.
					bcs CRERR ; BRANCH IF UNABLE TO DO THIS.

					lda #0 ; INIT INDEX POINTER
					sta TREPTR
*PAGE
FILLTREE LDY TREPTR
					lda (TINDX),Y ; GET ADDRESS OF LOWER BLOCK
					sta IDXADRL
					inc TINDX+1 ; BUMP TO PAGE 2 TO GET HI ADDRESS.
					lda (TINDX),Y ; GET HIGH ADDRESS.
					sta IDXADRH
					dec TINDX+1 ; CLEAN UP AFTER SELF...
					dec INDXBLK ; IS THIS THE LAST BLOCK ALLOCATED?
					beq LSTSAP ; YES, ALLOCATE PARTIAL FILLED INDEX BLOCK
					lda #0 ; ALLOCATE ALL 256 INDEXES
					sta REQL
					jsr SAPINDX ; AND WRITE ZEROED DATA BLOCKS.
					bcs CRERR ; STOP IF ERROR ENCOUNTERED.
					jsr WRTINDX ; WRITE INDEX BLOCK
					bcs CRERR ; HOPEFULLY NEVER TAKEN.
					inc TREPTR
					jsr RDFRST ; READ IN TOP INDEX AGAIN.
					bcc FILLTREE ; BRANCH IF NO ERROR.
CRERR SEC ; JUST IN CASE IT WAS CLEAR.
					rts; RETURN ERROR.
*
*
SAPFILE .eq *
LSTSAP				lda DATBLKL ; GET NUMBER OF DATA BLOCKS (LOW BYTE) REQUESTED.
					sta REQL
					jsr SAPINDX ; GO ALLOCATE DATA BLOCKS AND WRITE EM.
					bcs CRERR
ENDCRE				jsr WRTINDX ; GO WRITE INDEX BLOCK. (FOR SEED THIS IS DATA.)
					bcs CRERR
					ldx #3 ; MOVE CREATION TIME FOR THIS ENTRY
TRETIME				lda DATELO,X
					sta DFIL+D.CREDT,X
					dex
					bpl TRETIME
ENDCRE0 INC H.FCNT ; ADD ONE TO TOTAL NUMBER OF FILES IN SPECIFIED DIRECTORY.
					bne ENDCRE1
					inc H.FCNT+1
					ldx #3 ; ENSURE MOD
ENDCRX				lda DATELO,X ; DATE/TIME
					sta DFIL+D.MODDT,X ; IS
					dex ; INITIALIZED
					bpl ENDCRX
ENDCRE1				ldx D.DEV ; UPDATE APPROPRIATE BIT MAP
					jsr UPBMAP
					bcs CRERR2 ; BRANCH ON BITMAP UPDATE ERR
					jsr DREVISE ; UPDATE DIRECTORY LAST
					rts; RETURN ERRORS OR OK RESULT
*
*PAGE
SAPINDX				jsr ZTMPIDX ; ZERO OUT ANY STUFF LEFT OVER.
					lda REQL ; PRESERVE REQUEST COUNT
					sta TLINK
					jsr ALCIDXS ; GO ALLOCATE REQUESTED NUMBER OF BLOCKS.
					bcs CRERR
					ldy #0 ; THEN WRITE ZEROS TO DATA BLOCKS.
					sty SAPTR ; USE AS POINTER TO INDEX BLOCK
					lda (TINDX),Y ; GET DATA BLOCK ADDRESS (LOW BYTE).
					sta BLOKNML
					inc TINDX+1
					lda (TINDX),Y ; GET HIGH ADRRESS OF PRE-ALLOCATED DATA BLOCK.
					sta BLOKNMH
					dec TINDX+1 ; (RESET BUFFER ADDRESS)
					jsr WRTGBUF ; WRITE DATA BLOCK
					bcs CRERR
					lda TLINK ; GET NUMBER REQUESTED AGAIN
					sta REQL
DATINIT LDY SAPTR ; GET POINTER TO INDEX BLOCK AGAIN.
					iny ; ANTICIPATE DOIN' THE NEXT DATA BLOCK
					dec REQL ; DO WE INDEED HAVE ANOTHER BLOCK TO WRITE.
					beq DATDONE ; NO, ALL DONE (CARRY CLEAR).
					sty SAPTR ; USE AS POINTER TO INDEX BLOCK
					lda (TINDX),Y ; GET DATA BLOCK ADDRESS (LOW BYTE).
					sta BLOKNML
					inc TINDX+1 ; BUMP HI ADDR OF INDEX BUFFER TO ACCESS HIGH ADDR.
					tax; WAS LOW ADDRESS A ZERO?
					bne DATIT1 ; IF NOT, NO NEED TO CHECK VALIDITH OF HI BYTE
					cmp (TINDX),Y
					bne DATIT1 ; BOTH BYTES CAN'T BE ZERO.

					lda #ALCERR
					jsr SYSDEATH
DATIT1				lda (TINDX),Y ; GET HIGH ADRRESS OF PRE-ALLOCATED DATA BLOCK.
					sta BLOKNMH
					dec TINDX+1 ; (RESET BUFFER ADDRESS)
					lda #GBUF/256
					sta DBUFPH ; RESET TO ADDR TO GBUF JUST TO BE SURE.
					jsr REPEATIO ; WRITE DATA BLOCK
					bcc DATINIT
DATDONE RTS ; RETURN				staTUS (CARRY SET IF ERROR)
*
REPEATIO .eq *
					lda #RPTCMD
					sta DHPCMD
					jmp RPEATIO1
*
ZERGBUF LDY #0 ; ZERO OUT THE GENERAL PURPOSE BUFFER
					tya
ZGBUF				sta GBUF,Y ; WIPE OUT BOTH PAGES
					sta GBUF+$100,Y ; WITH SAME LOOP.
					iny
					bne ZGBUF
					rts
*
*
ZTMPIDX LDY #0 ; ZERO OUT TEMPORARY INDEX BLOCK
					tya
ZINDX1				sta (TINDX),Y ; THIS HAS TO BE DONE A
					iny ; TIME SINCE IT'S INDIRECT.
					bne ZINDX1
					inc TINDX+1
ZINDX2				sta (TINDX),Y
					iny
					bne ZINDX2
					dec TINDX+1 ; RESTORE PROPER ADDRESS
CRERR2 RTS
*PAGE
NOTREE CMP #DIRTYP ; IS A DIRECTORY TO BE CREATED?
					beq ISDIR ; YES, DO SO...
					jmp NOTDIR ; NO, TRY NEXT TYPE.
*
ISDIR				lda C.EOFHH ; CAN'T CREATE A DIRECTORY LARGER THAN
					ora C.EOFHL ; 127 BLOCKS (THAT'S HUGE!)
					beq ISDIR1 ; BRANCH IF WITHIN LIMITS, OTHEWISE
DIROVR				lda #OVRERR ; REQUESTED DIRECTORY SIZE CAN'T BE
					clc ; CREATED. SET CARRY TO INDICATE ERROR.
					rts
*
ISDIR1				lda C.EOFLH ; CALCULATE HOW MANY BLOCKS WILL
					lsr A ; BE NEEDED FOR THIS NEW DIRECTORY.
					tay ; (SAVE INITIAL COUNT IN Y)
					lda C.EOFLL ; IF REQUESTED EOF IS NOT AN EVEN BLOCK
					bne DADD1 ; SIZE, THEN ROUND UP.
					bcc TSDIRSZ ; BRANCH IF ROUNING UNNECESSARY.
DADD1 INY ; ADD ONE TO BLOCK COUNT.
TSDIRSZ TYA ; TEST TO BE SURE SIZE IS GREATER THAN ZERO
					beq DADD1 ; IF ZERO THEN SIZE=1
					sta DFIL+D.USAGE ; SAVE NUMBER OF BLOCKS TO BE USED.
					sta REQL
					asl A ; NOW SAVE ADJUSTED END OF FILE
					sta DFIL+D.EOF+1
					lda #0
					sta DFIL+D.EOF
					sta DFIL+D.EOF+2
					sta REQH ; REQUESTED NUMBER OF BLOCKS NEVER EXCEEDS 128.
					jsr TSFRBLK ; TEST TO BE SURE ENOUGH DISK SPACE IS FREE.
					bcs DIROVR ; BRANCH IF REQUEST TOO LARGE.
					jsr ZERGBUF ; CLEAR CRAP FROM GBUF.
					jsr ALC1BLK ; GET ADDRESS OF FIRST (HEADER) BLOCK.
					bcs CRERR2
					sta DFIL+D.FRST
					sta TLINK
					sty DFIL+D.FRST+1
					sty TLINK+1 ; (TLINK IS FOR REVERSE LINKAGE.)
					lda SOSTMPL ; STORE SOS				staMP IN NEW DIRECTORY
					sta GBUF
					lda SOSTMPH
					sta GBUF+1
					ldy #4 ; MOVE OTHER VARIOUS THINGS
					bne DRSTUF1 ; BRANCH ALWAYS
DRSTUF				lda D.ENTBLK,Y ; MOVE OWNING ENTRY'S

					sta GBUF+HRBLK+4,Y ; BLOCK ADDRESSES AND NUMBER TO NEW HEADER.
DRSTUF1				lda SOSVER,Y ; MOVE VERSION, COMPATABLITY,
					sta GBUF+HVER+4,Y ; ATTRIBUTES, AND ENTRY SIZE
					dey
					bpl DRSTUF
					lda H.ENTLN ; OVER WRITE LAST BYTE MOVED IN ABOVE LOOP WITH
					sta GBUF+HRELN+4 ; THE PARENT DIRECTORY ENTRY LENGTH.
					lda DFIL+D.STOR ; SET HEADER TYPE AND NAME
					tay
					ora #HEDTYP*16
					sta GBUF+HNLEN+4
					tya ; (AND WHILE WE'RE AT IT SET DIRECTORY TYPE)
					ora #DIRTYP*16
					sta DFIL+D.STOR
*
MVHNAME				lda DFIL+D.STOR,Y
					sta GBUF+HNLEN+4,Y ; MOVE HEADER NAME
					dey
					bne MVHNAME
					ldx #3 ; GET CURRENT DATE.
CRETIME				lda DATELO,X
					sta GBUF+HCRDT+4,X ; SAVE AS HEADER CREATION TIME
					sta DFIL+D.CREDT,X ; AND DATE OF FILE CREATE.
					dex
					bpl CRETIME
					lda #$76
					sta GBUF+HPENAB+4 ; DUMMY PASSWORD
					dec REQL ; TEST FOR ONE BLOCK DIRECTORY
					beq DIRCREND ; IT IS, FINISH UP.
					jsr DIRWRT ; GO WRITE FIRST DIRECTORY BLOCK AND ALLOCATE NEXT
					bcs DERROR ; PASS BACK ERROR.
					jsr ZERGBUF ; CLEAN OUT GENERAL BUFFER AGAIN.
CRNXTDIR				lda TLINK ; MOVE LAST BLOCK ADDRESS
					sta GBUF ; AS BACKWARD LINK.
					lda TLINK+1
					sta GBUF+1
					lda FLINK ; MAKE FORWARD LINK INTO CURRENT ADDRESS
					sta TLINK
					lda FLINK+1
					sta TLINK+1
					dec REQL ; IS THIS THE LAST BLOCK?
					beq DIRCREND
					jsr DIRWRT ; WRITE THIS BLOCK AND ALLOCATE NEXT.
					bcs DERROR
					lda #0 ; ZERO OUT FORWARD LINK
					sta GBUF+2
					sta GBUF+3
					beq CRNXTDIR ; BRANCH ALWAYS
*
DIRCREND				jsr DIRWRT1 ; WRITE LAST BLOCK OF THIS DIRECTORY
					bcs DERROR
					jmp ENDCRE0 ; FINISH UP WRITING OWNER DIRECTORY STUFF.
*
DIRWRT				jsr ALC1BLK ; GET ADDRESS OF NEXT BLOCK.
					bcs DERROR
					sta GBUF+2
					sty GBUF+3 ; SAVE LINK ADDRESS
					sta FLINK
					sty FLINK+1
DIRWRT1				lda TLINK ; GET ADDRESS OF CURRENT BLOCK
					sta BLOKNML
					lda TLINK+1
					sta BLOKNMH
					jmp WRTGBUF ; GO WRITE IT OUT
*PAGE
*
ERRGBUF .eq *
DERROR RTS
*
*
SOSTMPL DFB $0 ; THE FOLLOWING TWO BYTES ARE THE 'SOS				staMP'
SOSTMPH DFB $0
*
SOSVER DFB 0,0,0,$27,13
*
*
RNDTAB .eq *
ENTCALC				lda #GBUF/256 ; SET HIGH ADDRESS OF DIRECTORY ENTRY INDEX POINTER
					sta DRBUFPH
					lda #4 ; CALCULATE ADDRESS OF ENTRY BASED
					ldx D.ENTNUM ; ON THE ENTRY NUMBER

ECALC0 CLC
ECALC1 DEX ; ADDR=GBUF+((ENTNUM-1)*ENTLEN)
					beq ECALC2
					adc H.ENTLN
					bcc ECALC1
					inc DRBUFPH ; BUMP HI ADDRESS
					bcs ECALC0 ; BRANCH ALWAYS.
*
ECALC2				sta DRBUFPL ; SAVE NEWLY CALCULATED LOW ADDRESS
					rts
*PAGE
DERROR2 RTS
*
DREVISE				lda DATELO ; IF NO CLOCK,
					beq DREVISE1 ; THEN DON'T TOUCH MOD T/D
					ldx #3 ; MOVE LAST MODIFICATION DATE/TIME TO ENTRY BEING UPDATED.
MODTIME				lda DATELO,X
					sta DFIL+D.MODDT,X
					dex
					bpl MODTIME
*
DREVISE1				lda DFIL+D.ATTR ; MARK ENTRY AS BACKUPABLE
					ora BKBITFLG ; BIT 5 = BACKUP NEEDED BIT
					sta DFIL+D.ATTR
					lda D.DEV ; GET DEVICE NUMBER OF DIRECTORY
					sta DEVNUM ; TO BE REVISED.
					lda D.ENTBLK ; AND ADDRESS OF DIRECTORY BLOCK
					sta BLOKNML ; THAT CONTAINS THE ENTRY.
					lda D.ENTBLK+1
					sta BLOKNMH
					jsr RDGBUF ; READ BLOCK INTO GENERAL PURPOSE BUFFER.
					bcs ERRGBUF
					jsr ENTCALC ; FIX UP POINTER TO ENTRY LOCATION WITHIN GBUF.
					ldy H.ENTLN ; NOW MOVE 'D.' STUFF TO DIRECTORY.
					dey
MVDENT				lda DFIL+D.STOR,Y
					sta (DRBUFPL),Y
					dey
					bpl MVDENT
					lda D.HEAD ; IS THE ENTRY BLOCK THE SAME AS THE
					cmp BLOKNML ; ENTRY'S HEADER BLOCK?
					bne SVENTDIR ; NO, SAVE ENTRY BLOCK
					lda D.HEAD+1 ; MAYBE, TEST HIGH ADDRESSES
					cmp BLOKNMH
					beq UPHEAD ; BRANCH IF THEY ARE THE SAME BLOCK.
SVENTDIR				jsr WRTGBUF ; WRITE UPDATED DIRECTORY BLOCK
					bcs DERROR2 ; RETURN ANY ERROR.
					lda D.HEAD ; GET ADDRESS OF HEADER BLOCK
					sta BLOKNML
					lda D.HEAD+1
					sta BLOKNMH
					jsr RDGBUF ; READ IN HEADER BLOCK FOR MODIFICATION
					bcs DERROR2
UPHEAD LDY #1 ; UPDATE CURRENT NUMBER OF FILES IN THIS DIRECTORY
UPHED1				lda H.FCNT,Y
					sta GBUF+HCENT+4,Y ; (CURRENT ENTRY COUNT)
					dey
					bpl UPHED1
					lda H.ATTR ; ALSO UPDATE HEADER'S ATTRIBUTES.
					sta GBUF+HATTR+4
					jsr WRTGBUF ; GO WRITE UPDATED HEADER
DERROR1 RTS ; IMPLICITLY RETURN ANY ERRORS
*
*PAGE
*
NOTDIR				lda #TYPERR ; NOT TREE OR DIRECTORY- NOT A RECOGNIZED TYPE!
TSTERR SEC
					rts; DO NOTHING.
*
*
TSTSOS				lda GBUF ; TEST SOS				staMP
					cmp SOSTMPL
					bne TSTERR
					lda GBUF+1
					cmp SOSTMPH
					bne TSTERR
					lda GBUF+4 ; TEST FOR HEADER
					and #$E0
					cmp #HEDTYP*16
					bne TSTERR ; BRANCH IF NOT SOS HEADER (NO ERROR NUMBER)
					clc ; INDICATE NO ERROR

					rts
*
CHN FNDFIL,4,1
NE TSTERR
					lda GBUF+4 ; TEST FOR HEADER
					and #$E0
					cmp #HEDTYP*16
					bne TSTERR ; BRANCH IF NOT SOS HEADER (NO ERROR NUMBER)
					clc ; INDICATE NO ERROR
					rts
*
CHN FNDFIL,4,1
O ERROR
					rts
*
CHN FNDFIL,4,1
*ENTRY TOO.
					ldy #D.MODDT+3
RIPTIME				lda DATELO,X
					sta (DRBUFPL),Y
					dey
					dex
					bpl RIPTIME ;MOVE ALL FOR BYTES...
RUPDATE				jsr WRTGBUF ;WRITE UPDATED ENTRY BACK TO DISK. (ASSUMES BLOKNM UNDISTURBEDD)
					bcs DERROR1 ;GIVE UP ON ANY ERROR.
					ldy #D.DHDR ;NOW COMPARE CURRENT BLOCK NUMBER TO THIS
					lda (DRBUFPL),Y ; ENTRY'S HEADER BLOCK
					iny
					cmp BLOKNML ;ARE LOW ADDRESSES THE SAME?
					sta BLOKNML ;(SAVE IT IN CASE IT'S NOT)
					bne RIPPLE2 ;BRANCH IF ENTRY DOES NOT RESIDE IN SAME BLOCK AS HEADER.
					lda (DRBUFPL),Y ;CHECK HIGH ADDRESS JUST TO BE SURE.
					cmp BLOKNMH
					beq RIPPLE ;THEY ARE THE SAME, CONTINUE RIPPLE TO ROOT DIRECTORY.
RIPPLE2				lda (DRBUFPL),Y ;THEY AREN'T THE SAME, READ IN THIS DIRECTORY'S HEADER.
					sta BLOKNMH
					jsr RDGBUF
					bcc RIPPLE ;CONTINUE IF READ WAS GOOD.
DERROR1 .eq *
					rts
*PAGE
*
NOTDIR				lda #TYPERR ;NOT TREE OR DIRECTORY- NOT A RECOGNIZED TYPE!
TSTERR SEC
					rts;DO NOTHING.
*
*
TSTSOS				lda GBUF ;TEST SOS				staMP
					cmp SOSTMPL
					bne TSTERR
					lda GBUF+1
					cmp SOSTMPH
					bne TSTERR
					lda GBUF+4 ;TEST FOR HEADER
					and #$E0
					cmp #HEDTYP*16
					bne TSTERR ;BRANCH IF NOT SOS HEADER (NO ERROR NUMBER)
DRVISDNE CLC ;INDICATE NO ERROR./
					rts
*
CHN FNDFIL,4,1


*************************************************************************
* END OF APPLE /// SOS 1.3 SOURCE CODE FILE: CREATE
*************************************************************************


================================================================================================
FILE: "SOS.DESTROY.TEXT"
================================================================================================
*************************************************************************
* APPLE /// SOS 1.3 SOURCE CODE FILE: DESTROY
*************************************************************************
* ASSEMBLER: APPLE ][ 6502 ASSEMBLER from APPLE COMPUTER TOOLKIT

*PAGE
*
NEWLINE LDY #FCBATTR ; ADJUST NEWLINE				staTUS FOR OPEN FILE.
					lda C.ISNEWL ; ON OR OFF?
					bpl OFFNEWL ; BRANCH IF NEW LINE IS TO BE CLEARED.
					lda #NLINEN
					ora (FCBPTR),Y ; SET NEW LINE BIT IN ATTRIBUTES
					sta (FCBPTR),Y
					ldy #FCBNEWL ; AND MOVE IN NEW 'NEW-LINE' BYTE.
					lda C.NEWL
					sta (FCBPTR),Y
					clc
					rts; NO ERROR POSSIBLE.
*
OFFNEWL				lda #$FF-NLINEN
					and (FCBPTR),Y
					sta (FCBPTR),Y ; CLEAR NEW-LINE BIT.
OFFRTS CLC ; THE NEW LINE CHARACTER DOES'T MATTER...
					rts
*PAGE
*
GETINFO				jsr FINDFILE ; LOOK FOR FILE THEY WANT OT KNOW ABOUT.
					bcc GTINFO1 ; BRANCH IF NO ERRORS.
					cmp #BADPATH ; WAS IT A ROOT DIRECTORY FILE?
					clc ; (IN CASE OF NO MATCH)
					bne GINFOERR
					lda #$F0
					sta DFIL+D.STOR ; FOR GET INFO, REPORT PROPER STORAGE TYPE
					lda #0 ; FORCE A COUNT OF FREE BLOCKS.
					sta REQL
					sta REQH
					jsr TSFRBLK ; (RETURNS IF IMMEDIATELY IF COUNT HAS PREVIOUSLY BEEN TAKEN)
					ldy #VCBTFRE+1
					lda (VCBPTR),Y ; RETURN TOTAL BLOCKS AND TOTAL IN USE.
					sta REQH ; FIRST TRANSFER 'FREE' BLOCKS TO ZPAGE FOR LATER SUBTRACT
					dey
					lda (VCBPTR),Y ; TO DETERMINE THE 'USED' COUNT
					sta REQL
					dey
					lda (VCBPTR),Y ; TRANSFER TO 'D.' TABLE AS AUX I.D.
					sta DFIL+D.AUXID+1 ; (TOTAL BLOCK COUNT IS CONSIDERED AUX I.D. FOR THE VOLUME)
					tax
					dey
					lda (VCBPTR),Y
					sta DFIL+D.AUXID
					clc ; NOW SUBTRACT AND REPORT THE NUMBER OF BLOCKS 'IN USE'
					sbc REQL
					sta DFIL+D.USAGE
					txa
					sbc REQH
					sta DFIL+D.USAGE+1
GTINFO1 LDY #0 ; TRANSFER BYTES FROM THERE INTERNAL ORDER TO CALL SPEC VIA 'INFTABL'
TRANSLATION
GTINFO2				lda INFTABL,Y
					bpl GTINFO3 ; BRANCH IF THIS IS DATA IS VALID AS IS.
					and #$7F ; IS THIS THE 4TH BYTE OF THE EOF PARAMETER?
					beq GTINFO4 ; YES, AND IT'S ALWAYS A ZERO.
					cmp #D.STOR+1 ; IS THIS THE STORAGE TYPE BYTE?
					bne GINFOEND ; NO, IT'S THE END OF INFO THAT CAN BE RETURNED.
					lda DFIL+D.STOR ; GET STORAGE TYPE
					lsr A
					lsr A
					lsr A
					lsr A ; MAKE IT A VALUE 1-$F BY SHIFTING OUT FILE NAME LENGTH.
					bpl GTINFO4 ; BRANCH ALWAYS
*
GTINFO3 TAX ; USE AS OFFSET INTO 'D.' TABLE.
					lda DFIL,X
GTINFO4				sta (C.FILIST),Y ; PASS TO USER'S BUFFER
					iny
					cpy C.FILSTLN ; HAS REQUEST BEEN FILLED?

					bne GTINFO2 ; NO, PASS NEXT
GINFOEND CLC ; INDICATE NO ERRORS
GINFOERR RTS
*
*
*PAGE
*
SETINFO				jsr FINDFILE ; FIND WHAT USER WANTS...
					bcs SINFOERR ; RETURN ANY FAILURE.
					lda C.FILSTLN ; TEST FOR NUL CHANGE
					beq SINFEND ; BRANCH IF NOTHING TO CHANGE.
					ldy #0 ; INIT POINTER TO USER SUPPLIED LIST.
					lda (C.FILIST),Y ; FETCH FILE ATTRIBUTES
					and #$1C ; FORBIDDEN BITS? <SRS 82.162>
					beq SETINF1 ; NO
					lda #ACCSERR ; YES
					clc
					rts; RETURN AN ERROR
SETINF1				lda BACKMASK ; GET CURRENT BACKMASK <SRS 82.162>
* BACKUP KNOWS HOW TO RESET THIS BIT. <SRS 82.162>
					sta BKBITFLG ; BIT (USED BY DREVISE)
SETINF1X				ldx INFTABL,Y ; GET INDEX INTO CORESPONDING 'D.' TABLE
					bmi SETINF2 ; BRANCH IF WE'VE REACHED STORAGE TYPE PARAMETER
					lda (C.FILIST),Y
					sta DFIL,X
					iny ; HAS USER'S REQUEST BEEN SATISFIED?
					cpy C.FILSTLN
					bne SETINF1X ; NO, MOVE NEXT BYTE.
SINFEND JMP DREVISE ; GO UPDATE DIRECTORY WITH CURRENT TIME.
*
SETINF2 LDY C.FILSTLN ; TEST TO SEE IF USER WANTS HIS TIME				staMP ADDED
					cpy #$F ; (LIST MUST BE AT LEAST $F BYTES LONG)
					bcc SINFEND ; NO PUT CURRENT TIME INSTEAD.
					ldy #$B ; MOVE IN THE NEXT GROUP OF BYTES
SETINF3				ldx INFTABL,Y
					bmi SINFEND1
					lda (C.FILIST),Y
					sta DFIL,X
					iny
					cpy C.FILSTLN ; SATISFACTION YET?
					bne SETINF3 ; NOPE, KEEP EM PUMPIN'
SINFEND1 JMP DREVISE1
*
BKBITFLG DS 1 ; FOR TURNING OFF BACKUP BIT
*
*
INFTABL DFB D.ATTR,D.FILID,D.AUXID,D.AUXID+1
DFB D.STOR+1+$80,D.EOF,D.EOF+1,D.EOF+2 ; (D.STOR=0 THUS D.STOR+1 WAS NECESSARY)
DFB $80,D.USAGE,D.USAGE+1,D.MODDT ; (THE $80 IS FOR THE FOURTH BYTE OF EOF)
DFB D.MODDT+1,D.MODTM,D.MODTM+1,$FF ; TABLE ALWAYS ENDS IN $FF
*PAGE
*
RENAME				jsr LOOKFILE ; LOOK FOR SOURCE (ORIGINAL) FILE.
					bcc RNAME0 ; BRANCH IF FOUND.
					cmp #BADPATH ; TRYING TO RENAME A VOLUME?
					bne RNAMERR ; NO, RETURN OTHER ERROR.
					jsr RENPATH ; SYNTAX NEW NAME.
					bcs RNAMERR
					lda WRKPATH ; FIND OUT IF ONLY ROOTNAME FOR NEW NAME
					cmp PATHNML
					bne RNBADPTH ; NOT SINGLE NAME, RETURN ERROR!
					ldy #VCBSTAT ; TEST FOR OPEN FILES BEFORE CHANGING
					lda (VCBPTR),Y
					bpl RNAMEVOL ; BRANCH IF VOLUME NOT BUSY
					lda #FILBUSY
SINFOERR .eq *
					rts; (CARRY IS SET)
RNAMEVOL LDY #0 ; GET NEWNAME'S LENGTH.
					lda (WRKPATH),Y
					tay
					ora #$F0 ; (ROOT FILE STORAGE TYPE)
					jsr MVROTNAM ; UPDATE ROOT DIRECTORY.
					bcs RNAMERR
					ldy #0
					lda (WRKPATH),Y ; UPDATE VCB ALSO.
					tay
RNMEVOL				lda (WRKPATH),Y
					sta (VCBPTR),Y
					dey
					bpl RNMEVOL
					clc

					rts
*
RNAME0				jsr RENPATH ; SET UP AND SYNTAX NEW NAME.
					bcs RNAMERR
					ldy #0 ; VERIFY THAT BOTH NAMES HAVE SAME ROOT.
					lda (PATHNML),Y
					tay
TSTSMROT				lda (PATHNML),Y ; COMPARE NEWNAME'S ROOT NAME WITH
					cmp (VCBPTR),Y ; OLD NAME'S VOLUME NAME.
					bne RNBADPTH ; RETURN 'BADPATH' IF NOT SAME VOLUME.
					dey
					bpl TSTSMROT ; (TEST SAME 'ROT')
					jsr LOOKFILE ; TEST FOR DUPLICATE FILE NAME.
					bcs TSTFNF1 ; BRANCH IF ERROR TO TEST FOR FILE NOT FOUND.
					lda #DUPERR ; TELL USER THAT NEW NAME ALREADY EXISTS.
RNAMERR SEC
					rts
*PAGE
TSTFNF1 CMP #FNFERR ; WAS IT A VALID FILE NOT FOUND?
					bne RNAMERR ; NO, RETURN OTHER ERROR CODE.
					ldx #2 ; NOW MOVE NEW NAME'S OWNERSHIP (DIRECTORY HEADER) I.D.
SVENEWID				lda D.DEV,X ; THIS CONSISTS OF THE UNIT NUMBER,
					sta NPATHDEV,X ; AND THE ADDRESS OF THE DIRECTORY THE FILE
					dex ; WASN'T FOUND IN. LOGIC BY NEGATION...
					bpl SVENEWID
					jsr SETPATH ; NOW SYNTAX THE PATHNAME OF THE FILE TO BE CHANGED.
					bcs RNAMERR
					jsr FINDFILE ; GET ALL THE INFO ON THIS ONE.
					bcs RNAMERR
					jsr TSTOPEN ; DON'T ALLOW RENAME TO OCCUR IF FILE IS IN USE.
					lda #FILBUSY ; ANTICIPATE ERROR
					bcs RNAMERR
					lda DFIL+D.ATTR ; TEST BIT THAT SAYS IT'S OK TO RENAME
					and #RENAMEN
					bne RNAME1 ; BRANCH IF IT'S ALRIGHT TO RENAME.
					lda #ACCSERR ; OTHERWISE REPORT ILLEGAL ACCESS.
					clc
					rts
*
RNAME1				ldx #2 ; NOW TEST TO SEE IF NEW PATHNAME FITS IN THE
SAMOWNR				lda D.DEV,X ; SAME DIRECTORY FILE.
					cmp NPATHDEV,X
					beq RNAME2
RNBADPTH				lda #BADPATH ; TELL USER THAT PATHNAMES INCOMPATABLE.
					clc
					rts
*
RNAME2 DEX ; TEST ALL THREE BYTES.
					bpl SAMOWNR
					jsr RENPATH ; WELL... SINCE BOTH NAMES WOULD GO INTO THE
					bcs RNAMERR ; DIRECTORY, RE-SYNTAX THE NEW NAME TO GET LOCAL NAME ADDRESS.
					tya ; (Y CONTAINS THE LOCAL NAME LENGTH+1)
					beq RNBADPTH ; REPORT ERROR IF LENGTH INFO NOT IMMEDIATELY AVAILABLE.
					dey ; (REMOVE THE +1)
RNAME3				lda (WRKPATH),Y ; MOVE LOCAL NAME TO DIR ENTRY WORKSPACE.
					sta DFIL+D.STOR,Y
					dey
					bne RNAME3
					lda DFIL+D.STOR ; PRESERVE FILE STORAGE TYPE.
					and #$F0 ; STRIP OFF OLD NAME LENGTH.
					tax
					ora (WRKPATH),Y ; ADD IN NEW NAME'S LENGTH
					sta DFIL+D.STOR
					cpx #DIRTYP*16 ; THAT FILE MUST BE CHANGED ALSO.
					bne RNAMDONE ; BRANCH IF NOT DIRECTORY TYPE.
*PAGE
					lda DFIL+D.FRST ; READ IN FIRST (HEADER) BLOCK OF SUB DIRECTORY
					sta BLOKNML
					lda DFIL+D.FRST+1
					sta BLOKNMH
					jsr RDGBUF
					bcs RNAMERR ; REPORT ERRORS
					ldy #0 ; CHANGE THE HEADER'S NAME TO MATCH THE OWNER'S NEW NAME.
					lda (WRKPATH),Y ; GET LOCAL NAME LENGTH AGAIN
					tay
					ora #HEDTYP*16 ; ASSUME IT'S A HEADER.
					jsr MVROTNAM
					bcs RNAMERR
RNAMDONE JMP DREVISE1 ; END BY UPDATING ALL PATH DIRECTORIES
*
*

MVROTNAM				sta GBUF+4
MVHEDNAM				lda (WRKPATH),Y
					sta GBUF+4,Y
					dey
					bne MVHEDNAM
					jmp WRTGBUF ; WRITE CHANGED HEADER BLOCK.
*
*
RENPATH				lda C.NWPATH ; GET ADDRESS TO NEW PATHNAME.
					sta TPATH
					lda C.NWPATH+1 ; SET UP FOR SYNTAXING ROUTINE (SYNPATH).
					sta TPATH+1
					lda SSNWPATH ; (MOVE BYTE FOR SISTER PAGE, TOO.)
					sta SISTPATH
					jmp SYNPATH ; GO SYNTAX IT. (RETURNS LAST LOCAL NAME LENGTH IN Y).
*
*
DEALBLK LDY #0 ; BEGIN AT THE BEGINNING.
DALBLK1 STY SAPTR ; SAVE CURRENT INDEX.
					lda GBUF,Y ; GET ADDRESS (LOW) OF BLOCK TO BE DEALLOCATED.
					cmp GBUF+$100,Y ; TEST FOR NUL BLOCK.
					bne DALBLK2 ; BRANCH IF NOT NUL.
					cmp #0
					beq DALBLK3 ; SKIP IT IF NUL.
DALBLK2				ldx GBUF+$100,Y ; GET THE REST OF THE BLOCK ADDRESS.
					jsr DEALLOC ; FREE IT UP ON VOLUME BIT MAP.
					bcs DALBLKERR ; RETURN ANY ERROR.
					ldy SAPTR ; GET INDEX TO SAPLING LEVEL INDEX BLOCK AGAIN.
DALBLK3 INY ; POINT AT NEXT BLOCK ADDRESS.
					bne DALBLK1 ; BRANCH IF MORE TO DEALLOCATE (OR TEST).
					clc ; INDICATE NO ERROR.
DALBLKERR RTS
*
*
*PAGE
*
DESTROY				jsr FINDFILE ; LOOK FOR FILE TO BE WIPED OUT.
					bcs DESTERR ; PASS BACK ANY ERROR.
					jsr TSTOPEN ; IS THIS FILE OPEN?
					lda TOTENT
					beq DSTROY1 ; BRANCH IF FILE NOT OPEN.
					lda #FILBUSY
					clc ; INFORM USER THAT FILE CAN'T BE DESTORYED AT THIS TIME.
					rts
*
DSTROY1				lda #0 ; FORCE PROPER FREE COUNT IN VOLUME.
					sta REQL ; (NO DISK ACCESS OCCURS IF ALREADY PROPER)
					sta REQH
					jsr TSFRBLK
					bcc DSTROY2
					cmp #OVRERR ; WAS IT JUST A FULL DISK?
					clc
					bne DESTERR ; NOPE, REPORT ERROR.
*
DSTROY2				lda DFIL+D.ATTR ; MAKE SURE IT'S OK TO DESTROY THIS FILE.
					and #DSTROYEN
					bne DSTROY3 ; BRANCH IF OK.
					lda #ACCSERR ; TELL USER IT'S NOT KOSHER.
					jsr SYSERR ; (RETURNS TO CALLER OF DESTORY)
*
DSTROY3				jsr TWRPROT1 ; BEFORE GOING THRU DEALLOCATION,
					bcs DESTERR ; TEST FOR WRITE PROTECTED HARDWARE.
					lda DFIL+D.STOR ; FIND OUT WHICH STORAGE TYPE.
					and #$F0 ; STRIP OFF NAME LENGTH.
					cmp #TRETYP+1*$10 ; IS IT A SEED, SAPLING, OR TREE?
					bcc DSTREE ; BRANCH IF IT IS.
					jmp DSTDIR ; OTHERWISE TEST FOR DIRECTORY DESTROY.
*
DSTREE				jsr GTTINDX ; GET A BIT MAP BUFFER AND TEMPORARY INDEX BUFFER.
					bcs DESTERR
					lda DFIL+D.STOR ; GET STORAGE TYPE AGAIN
					and #$F0
					cmp #TRETYP*$10 ; IS THIS A TREE (FULL 2-LEVEL)?
					bne DSTSAP ; NO, TEST FOR SAPLING.
					jsr RDFRST ; READ IN ROOT INDEX FOR THIS FILE.
					bcc DSTRE2 ; BRANCH IF ALL IS WELL.
DESTERR RTS ; OTHERWISE RETURN ERROR.
*
DSTSAP CMP #SAPTYP*$10 ; IS IT A SAPLING
					bne DSTLAST ; NO, JUST DEALLOCATE FIRST (AND ONLY) BLOCK.
					jsr ZTMPIDX ; CLEAR OUT TEMPORARY INDEX BUFFER.

					lda DFIL+D.FRST ; MAKE THIS SAP LOOK LIKE A TREE...
					ldy #0 ; THIS IS DONE BY PLACING THE FIRST BLOCK ADDRESS
					sta (TINDX),Y ; IN THE TEMP (TOP) INDEX BUFFER AS
					inc TINDX+1
					lda DFIL+D.FRST+1 ; A SUB INDEX WOULD APPEAR.
					sta (TINDX),Y
					dec TINDX+1
DSTRE2 LDY #0 ; BEGIN SCAN OF TOP LEVEL INDEX AT ZERO.
DSTNXT STY TREPTR ; SAVE POINTER TO TREE LEVEL.
					lda (TINDX),Y ; GET BLOCK ADDRESS OF A SUB INDEX BLOCK
					inc TINDX+1 ; (TEST FOR NUL BLOCK)
					cmp (TINDX),Y
					bne DSTRE3 ; BRANCH IF WE'VE GOT AN BLOCK TO DEALLOCATE.
					cmp #0 ; IS ENTIRE ADDRESS ZERO?
					beq DSTRE4 ; YES, DO NEXT. (CARRY SET)
DSTRE3 CLC ; INDICATE THERE IS A BLOCK OF INDEXES TO FREE UP.
					sta BLOKNML
					lda (TINDX),Y ; GET HI ADDRESS TOO.
					sta BLOKNMH
DSTRE4 DEC TINDX+1 ; (RESTORE PROPER ADDRESS FOR BUFFER)
					bcs DSTNXT1 ; BRANCH IF NO SUB INDEX.
					jsr RDGBUF ; USE GENERAL BUFFER FOR SUB INDEX BUFFER.
					bcs DESTERR
					jsr DEALBLK ; GO FREE UP BLOCKS IN SUB INDEX
					bcs DESTERR
					ldy TREPTR ; AND FREE UP SUB INDEX BLOCK TOO.
					inc TINDX+1
					lda (TINDX),Y
					tax
					dec TINDX+1
					lda (TINDX),Y
					jsr DEALLOC
					bcs DESTERR
					ldy TREPTR
DSTNXT1 INY ; HAVE ALL SUB INDEXES BEEN LOCATED?
					bne DSTNXT ; NO, DO NEXT...
DSTLAST				lda DFIL+D.FRST ; DEALLOCATE FIRST BLCOK OF FILE.
					ldx DFIL+D.FRST+1
					jsr DEALLOC
					bcs DESTERR
					lda #0 ; UPDATE DIRECTORY TO FREE ENTRY SPACE.
					sta DFIL+D.STOR
					cmp H.FCNT ; FILE ENTRY WRAP?
					bne DST1 ; BRANCH IF NO CARRY ADJUSTMENT
					dec H.FCNT+1 ; TAKE CARRY FROM HIGH BYTE OF FILE ENTRIES
DST1 DEC H.FCNT ; MARK HEADER WITH ONE LESS FILE
					ldx BMTAB ; UPDATE (LAST) BITMAP.
					jsr BMAPUP
					bcs DESTERR
					ldy #VCBTFRE
					lda DFIL+D.USAGE
					adc (VCBPTR),Y
					sta (VCBPTR),Y ; UPDATE CURRENT FREE BLOCK COUNT.
					iny
					lda DFIL+D.USAGE+1
					adc (VCBPTR),Y
					sta (VCBPTR),Y
					lda #0 ; FORCE RESCAN FROM FIRST BITMAP
					ldy #VCBCMAP
					sta (VCBPTR),Y
					jmp DREVISE ; UPDATE DIRECTORY LAST...
*
*PAGE
*
DSTDIR CMP #DIRTYP*16 ; IS THIS A DIRECTORY FILE?
					beq DSDIR1 ; YES, PROCEED.
					lda #CPTERR ; FILE IS NOT COMPATABLE.
					jsr SYSERR ; GIVE UP.
*
DSDIR1				jsr FNDBMAP ; MAKE SURE A BUFFER IS AVAILABLE FOR THE BITMAP.
					bcs DSDIRERR
					lda DFIL+D.FRST ; READ IN FIRST BLOCK OF DIRECTORY INTO GBUF.
					sta BLOKNML
					lda DFIL+D.FRST+1
					sta BLOKNMH
					jsr RDGBUF
					bcs DSDIRERR
					lda GBUF+HCENT+4 ; FIND OUT IF ANY FILES EXIST ON THIS DIRECTORY.
					bne DSDIRACC ; BRANCH IF ANY EXIST.
					lda GBUF+HCENT+5
					beq DSDIR2

DSDIRACC				lda #ACCSERR
					jsr SYSERR
*
DSDIR2				lda GBUF+2 ; GET FORWARD LINK.
					cmp GBUF+3 ; TEST FOR NO LINK.
					bne DSDIR3
					cmp #0
					beq DSTLAST ; IF NO LINK, THEN FINISHED.
DSDIR3				ldx GBUF+3
					jsr DEALLOC ; FREE THIS BLOCK.
					bcs DSDIRERR
					lda GBUF+2
					sta BLOKNML
					lda GBUF+3
					sta BLOKNMH ; READ IN LINKED BLOCK.
					jsr RDGBUF
					bcc DSDIR2 ; LOOP UNTIL ALL ARE FREED.
DSDIRERR RTS
*
*
*PAGE
WORKSPC .eq *
V.STATUS DS 1 ; VOLUME				staTUS, INCLUDES 'ACTIVE' IN BIT 7
H.CREDT DS 2 ; DIRECTORY CREATION DATE
DS 2 ; DIRECTORY CREATION TIME
DS 1 ; VERSION UNDER WHICH THIS DIRECTORY WAS CREATED
DS 1 ; EARLIEST VERSION THAT IT'S COMPATABLE WITH
H.ATTR DS 1 ; ATTRIBUTES (PROTECT BIT, ETC.)
H.ENTLN DS 1 ; LENGTH OF EACH ENTRY IN THIS DIRECTORY.
H.MAXENT DS 1 ; MAXIMUM NUMBER OF ENTRIES PER BLOCK
H.FCNT DS 2 ; CURRENT NUMBER OF FILES IN THIS DIRECTORY
DS 2 ; ADDRESS OF FIRST ALLOCATION BIT MAP
DS 2 ; TOTAL NUMBER OF BLOCKS ON THIS UNIT
DS 5 ; (FOR FUTURE EXPANSION)
*
D.DEV DS 1 ; DEVICE NUMBER OF THIS DIRECTORY ENTRY
D.HEAD DS 2 ; ADDRESS OF <SUB> DIRECTORY HEADER
D.ENTBLK DS 2 ; ADDRESS OF BLOCK WHICH CONTAINS THIS ENTRY
D.ENTNUM DS 1 ; ENTRY NUMBER WITHIN BLOCK.
DFIL .eq *
D.STOR .eq *-DFIL ; STORAGE TYPE * 16 + FILE NAME LENGTH
DS 1
; *-DFIL ; FILE NAME
DS 15
D.FILID .eq *-DFIL ; USER'S IDENTIFICATION BYTE
DS 1
D.FRST .eq *-DFIL ; FIRST BLOCK OF FILE
DS 2
D.USAGE .eq *-DFIL ; NUMBER OF BLOCKS CURRENTLY ALLOCATED TO THIS FILE
DS 2
D.EOF .eq *-DFIL ; CURRENT END OF FILE MARKER
DS 3
D.CREDT .eq *-DFIL ; DATE OF FILE'S CREATION
DS 2
; *-DFIL ; TIME OF FILE'S CREATION
DS 2
; .eq *-DFIL ; SOS VERSION THAT CREATED THIS FILE
DS 1
D.COMP .eq *-DFIL ; BACKWARD VERSION COMPATABILTY
DS 1
D.ATTR .eq *-DFIL ; 'PROTECT', READ/WRITE 'ENABLE' ETC.
DS 1
D.AUXID .eq *-DFIL ; USER AUXILLARY IDENTIFACATION
DS 2
D.MODDT .eq *-DFIL ; FILE'S LAST MODIFICATION DATE
DS 2
D.MODTM .eq *-DFIL ; FILE'S LAST MODIFICATION TIME
DS 2
D.DHDR .eq *-DFIL ; HEADER BLOCK ADDRESS OF FILE'S DIRECTORY
DS 2
*
CMDADR DS 2
SCRTCH DS 13 ; SCRATCH AREA FOR ALLOCATION ADDRESS CONVERSION
OLDEOF DS 3 ; TEMP USED IN W/R
OLDMARK DS 3 ; USED BY 'RDPOSN' AND 'WRITE'
SCRHIGH .eq <SCRTCH ; AND DEVICE NUMBERS FROM BOB'S CODE.
*
CHN SWAPOUT/IN,4,2

*************************************************************************
* END OF APPLE /// SOS 1.3 SOURCE CODE FILE: DESTROY

*************************************************************************



================================================================================================
FILE: "SOS.DEVMGR.SRC.TEXT"
================================================================================================
*************************************************************************
* APPLE /// SOS 1.3 SOURCE CODE FILE: DEVMGR.SRC
*************************************************************************
* ASSEMBLER: APPLE ][ 6502 ASSEMBLER from APPLE COMPUTER TOOLKIT

*SBTL "SOS 1.1 DEVICE MANAGER"
*REL
					INCLUDE SOSORG,6,1,254
ORG ORGDMGR
ZZORG .eq *
*MSB OFF
*REP 100
* COPYRIGHT (C) APPLE COMPUTER INC. 1980
* ALL RIGHTS RESERVED
*REP 100
*
* DEVICE MANAGER (VERSION = 1.1O )
* (DATE = 8/04/81)
*
* THIS MODULE IS RESPONSIBLE FOR CALLING THE CORRECT DEVICE
* DRIVER WHEN A D.READ...D.INIT SYSTEM CALL IS MADE.
* (NOTE: D.OPEN,D.CLOSE AND D.INIT ARE ONLY CALLABLE FROM
* INSIDE THE OPERATING SYSTEM). D.INFO AND GET.DNUM CALLS
* ARE HANDLED INSIDE THIS MODULE. REPEAT.IO BYPASSES THIS MODULE.
*REP 100
*
*ENTRY DMGR
*
*ENTRY MAX.DNUM
*ENTRY SDT.SIZE
*ENTRY SDT.DIBL
*ENTRY SDT.DIBH
*ENTRY SDT.ADRL
*ENTRY SDT.ADRH
*ENTRY SDT.BANK
*ENTRY SDT.UNIT
*ENTRY BLKD.SIZE
*ENTRY BLKDLST
*
*EXTRN SYSERR
*EXTRN SERR
*EXTRN NODNAME
*EXTRN BADDNUM
*EXTRN SYSDEATH
*EXTRN BADSYSCALL
*
*EXTRN SXPAGE
*
E.REG .eq $FFDF ; ENVIRONMENT REGISTER
B.REG .eq $FFEF ; BANK REGISTER
*PAGE
*REP 100
*
* SYSTEM DEVICE TABLE (SDT)
*
* CONTAINS THE ADDRESS OF EACH DRIVER'S DIB (SDT.DIB), THE
* ADDRESS OF EACH DRIVER'S ENTRY POINT (SDT.ADR), AND THE
* UNIT # OF EACH DRIVER (SDT.UNIT). THE TABLE IS INDEXED
* BY DEVICE NUMBER. ENTRY 0 IS RESERVED FOR FUTURE USE.
*
*REP 100
*
SDT.SIZE .eq 25
*
MAX.DNUM DS 1 ;MAX DEV NUMBER IN SYSTEM+1
SDT.DIBL DS SDT.SIZE ;ADR OF DEVICE INFORMATION BLOCK
SDT.DIBH DS SDT.SIZE
*
SDT.ADRL DS SDT.SIZE ;ADR OF ENTRY POINT
SDT.ADRH DS SDT.SIZE
*
SDT.BANK DS SDT.SIZE ;BANK # OF DEVICE
*
SDT.UNIT DS SDT.SIZE ;UNIT # OF DRIVER
*
*REP 100

* BLOCK DEVICE LIST TABLE
*
BLKD.SIZE .eq 13
BLKDLST DFB $00
DS BLKD.SIZE-1
*PAGE
*REP 100
*
* DATA DECLARATIONS
*
*REP 100
*
D.TPARMX .eq $C0
REQCODE .eq D.TPARMX
*
* D.READ/WRITE/CTRL/STATUS/OPEN/CLOSE/INIT/REPEAT PARMS
*
DNUM .eq D.TPARMX+1
*
* D.INFO PARMS
*
I.DNUM .eq D.TPARMX+1
I.DNAME .eq D.TPARMX+2
I.DLIST .eq D.TPARMX+4
I.LENGTH .eq D.TPARMX+6
*
* GET.DEV.NUM PARMS
*
G.DNAME .eq D.TPARMX+1
G.DNUM .eq D.TPARMX+3
*
* SDT ENTRY (=DIB) FIELDS
*
DIB.SLOT .eq $11 ;DIB'S DEVICE SLOT FIELD
DIB.DTYPE .eq $13 ;DIB'S DEVICE TYPE FIELD
*
SDTP .eq D.TPARMX+$10 ; PTR TO CURRENT SDT ENTRY
*PAGE
*REP 100
*
* DEVICE MANAGER (MAIN ENTRY POINT)
*
*REP 100
DMGR .eq *
*
					lda REQCODE
					cmp #4
					bcc DRIVER ; D.READ/WRITE/CTRL/STATUS CALL
					bne DM000
					jmp GET.DNUM ; GET.DEV.NUM CALL
DM000 CMP #5
					beq D.INFO ; D.INFO CALL
					cmp #$A
					bcc DRIVER ; D.OPEN/CLOSE/INIT
					lda #BADSYSCALL ; ELSE FATAL ERROR
					jsr SYSDEATH ; EXIT
*PAGE
*REP 100
* D.READ/WRITE/CTRL/STATUS/OPEN/CLOSE/INIT CALLS
* "JSR" TO DEVICE DRIVER
*REP 100
DRIVER .eq *
*
					ldx DNUM ; GET DNUM SYSCALL PARM
					beq DM005 ; WITHIN BOUNDS?
					cpx MAX.DNUM ; "
					bcc DM010
*
* DNUM TOO LARGE
*
DM005				lda #>BADDNUM ; INVALID DEVICE NUMBER
					jsr SYSERR ; ERROR EXIT
*
* MAP DEV# TO UNIT#
*
DM010				lda SDT.UNIT,X
					sta DNUM
*
* "JSR" TO DEVICE DRIVER VIA JMP TABLE
*
					lda B.REG ;				staCK B.REG

					pha
					lda #<DM.RTN-1 ;				staCK RETURN ADDRESS
					pha
					lda #>DM.RTN-1
					pha
*
					lda SDT.BANK,X ; SELECT RAM BANK
					sta B.REG
					lda SDT.ADRH,X ;				staCK DRIVER ENTRY POINT ADDRESS
					pha
					lda SDT.ADRL,X
					pha
*
					lda E.REG ; SWITCH IN I/O BANK
					ora #$40
					sta E.REG
					rts; AND, "JSR" TO DEVICE DRIVER
*
DM.RTN				lda E.REG ; SWITCH OUT I/O BANK
					and #$BF
					sta E.REG
					pla ; RESTORE B.REG
					sta B.REG
					clc
					lda SERR ; RETRIEVE ERROR CODE
					bne DM017 ; ENSURE CARRY CLEARED IF NO ERROR
					clc
DM017 RTS ; AND, EXIT TO CALLER
*PAGE
*REP 100
* D.INFO(IN.DNUM, OUT.DNAME, OUT.DEVLIST, IN.LENGTH) SYSTEM CALL
*REP 100
D.INFO .eq *
*
					ldx I.DNUM ; GET DNUM PARM
					beq DM020 ; WITHIN BOUNDS?
					cpx MAX.DNUM ; "
					bcc DM030
DM020				lda #>BADDNUM ; NO, DNUM TOO LARGE
					jsr SYSERR ; ERROR EXIT
*
* MOVE PARMS FM SDT ENTRY (DEV INFO BLOCK) TO CALLER'S
* PARM LIST
*
DM030				jsr SETUP.SDT ; SET UP ZPAGE PTR TO SDT ENTRY
*
* OUPUT DNAME PARM
*
					lda (SDTP),Y ; LOAD PARM'S BYTE COUNT
					tay
DM040				lda (SDTP),Y
					sta (I.DNAME),Y
					dey
					bpl DM040
*
* OUTPUT DEVINFO PARM (SLOT,UNIT,DEVID,PRODCODE)
*
					lda #DIB.SLOT
					clc ; ADVANCE SDTP TO 2ND PARM IN SDT
					adc SDTP
					sta SDTP
					bcc DM045
					inc SDTP+1
DM045 LDY I.LENGTH ; LOAD BYTE COUNT
					beq DM.EXIT ; IF 0 THEN DONE
					dey
					cpy #$B
					bcc DM050
					ldy #$A
DM050				lda (SDTP),Y
					sta (I.DLIST),Y
					dey
					bpl DM050
*
DM.EXIT CLC
					rts; NORMAL EXIT
*PAGE
*REP 100
* GET.DEV.NUM(IN.DNAME; OUT.DNUM) SYSTEM CALL
*REP 100
*

GET.DNUM .eq *
*
					ldx #1 ; SETUP PTR TO 1ST SDT ENTRY
*
DM070				jsr SETUP.SDT ; SET UP ZPAGE PTR TO SDT ENTRY
*
					lda (SDTP),Y ; COMPARE DNAME LENGTHS
					cmp (G.DNAME),Y
					bne NXTSDT
*
					tay ; LENGTHS MATCH, NOW COMPARE CHARS
DM080				lda (G.DNAME),Y
					cmp #$60
					bcc DM090
					and #$DF ; UPSHIFT
DM090 CMP (SDTP),Y
					bne NXTSDT
					dey
					bne DM080
*
					txa ; CHARS MATCH
					ldy #0
					sta (G.DNUM),Y ; OUTPUT DEV NUM PARM
					ldy #DIB.DTYPE ; SET "N" FLAG IN				staTUS REG.
					lda (SDTP),Y ; N=1(BLOCK DEVICE) N=0(CHAR DEVICE)
					clc
					rts; NORMAL EXIT
*
NXTSDT INX ; LAST SDT ENTRY?
					cpx MAX.DNUM
					bcc DM070
*
					lda #>NODNAME ; ERROR, DNAME NOT FOUND IN SDT
					jsr SYSERR ; RETURN TO CALLER
*PAGE
*REP 100
* SETUP.SDT(IN.X=DNUM, OUT.SDTP, B.REG, Y=0) X="UNCHANGED"
*REP 100
SETUP.SDT .eq *
					lda SDT.DIBL,X ; SET UP ZPAGE PTR TO SDT ENTRY
					sta SDTP ; (POINTS TO DNAME FIELD)
					lda SDT.DIBH,X
					sta SDTP+1
					lda SDT.BANK,X
					sta B.REG
					ldy #0
					sty SXPAGE+SDTP+1
					rts
*
*LST ON
ZZEND .eq *
ZZLEN .eq ZZEND-ZZORG
IFNE ZZLEN-LENDMGR
FAIL 2,"SOSORG FILE IS INCORRECT FOR DEVMGR"
FIN

*************************************************************************
* END OF APPLE /// SOS 1.3 SOURCE CODE FILE: DEVMGR.SRC
*************************************************************************



================================================================================================
FILE: "SOS.DISK3.DATA.SRC.TEXT"
================================================================================================
*************************************************************************
* APPLE /// SOS 1.3 SOURCE CODE FILE: DISK3.DATA.SRC
*************************************************************************
* ASSEMBLER: APPLE ][ 6502 ASSEMBLER from APPLE COMPUTER TOOLKIT

*PAGE
* GENERAL DATA:
*
PREVUNIT DS 1 ;PRIOR UNIT ACCESSED (FOR REPEAT)
PREVCMD DS 1 ;PRIOR CMD (FOR REPEAT)
*
ESAVE DS 1 ;SAVED E.REG
VBLSAVE DS 1 ;SAVED E.IER
INITFLAG DFB 0 ;<0 IS INITTED
DO REV0ROM
ROMREV DS 1 ;0=REV0, <>0=REV1
FIN
*
* MOTOR-UP TIMES PER COMMAND
T50MS .eq $02 ; 50MS FOR MONTIMEH
T200MS .eq $08 ;200 MS FOR MONTIMEH
T1SEC .eq $27 ;1-SEC FOR MONTIMEH
*
MTIMES DFB T200MS,T1SEC,T50MS ;READ,WRITE,SENSE
*
*REP 40
* DRIVE TABLES:
*
DRIVESEL DS 4 ;NONZERO IF SELECTED
*
UPTIME DS 4 ;MOTOR RUNTIME SINCE				staRTED
DRVTRACK DS 4 ;CURRENT HEAD POSITION
*PAGE
DO REV0ROM ;ONLY IF SUPPORTING IT!
* JUMP TABLE TO MONITOR ROUTINES.
* THIS TABLE FILLED IN BY 'INIT'.
*
					jmpTAB .eq *
RDADR JMP *
READ JMP *
WRITE JMP *
SEEK JMP *
MSWAIT JMP *
PRENIB JMP *
POSTNIB JMP *
*
REV0				.eq *;REV0 ADDRESSES
					jmp $F1BD ;RDADR
					jmp $F148 ;READ
					jmp $F219 ;WRITE
					jmp $F400 ;SEEK
					jmp $F456 ;MSWAIT
					jmp $F2C6 ;PRENIB
					jmp $F311 ;POSTNIB
VSIZE .eq *-REV0 ;TABLE SIZE
*
REV1				.eq *;REV1 ADDRESSES
					jmp $F1B9 ;RDADR
					jmp $F148 ;READ
					jmp $F216 ;WRITE
					jmp $F400 ;SEEK
					jmp $F456 ;MSWAIT
					jmp $F2C4 ;PRENIB
					jmp $F30F ;POSTNIB
ELSE ;FOR REV1 WE USE EQUATES
RDADR .eq $F1B9 ;RDADR
READ .eq $F148 ;READ
WRITE .eq $F216 ;WRITE
SEEK .eq $F400 ;SEEK
MSWAIT .eq $F456 ;MSWAIT
PRENIB .eq $F2C4 ;PRENIB
POSTNIB .eq $F30F ;POSTNIB
FIN

ZZEND .eq *
ZZLEN .eq *-ZZORG

IFNE ZZLEN-LENDISK3
FAIL 2,"SOSORG FILE IS INCORRECT FOR DISK3"
FIN

*************************************************************************
* END OF APPLE /// SOS 1.3 SOURCE CODE FILE: DISK3.DATA.SRC
*************************************************************************



================================================================================================
FILE: "SOS.DISK3.MAIN.SRC.TEXT"
================================================================================================
*************************************************************************
* APPLE /// SOS 1.3 SOURCE CODE FILE: DISK3.MAIN.SRC
*************************************************************************
* ASSEMBLER: APPLE ][ 6502 ASSEMBLER from APPLE COMPUTER TOOLKIT

*PAGE
* MAIN ENTRY POINT:
*
* DISABLE NMI/RESET AND ENABLE ROM/IO SPACE
*
MAIN .eq *
					lda E.REG ;SAVE CALLER'S
					and #$FF-$20 ;DROP SCREEN BIT
					sta ESAVE ; ENVIRONMENT
DO 1-TEST ;NO RESETLOCK FOR TESTING
					lda E.REG ;GET EREG AGAIN
					and #$FF-$10 ;DISABLE NMI/RESET
FIN
					ora #$03 ;ENABLE ROM/IO SPACE
					sta E.REG
*
					lda NOSCROLL ;DISABLE SMOOTHSCROLL
*
					php ;IF ALREADY SEI'D, THEN WE
					pla ;				staY THAT WAY...
					ror A
					ror A
					ror A
					ror A
					sta IRQMASK ;'I' BIT INTO BIT7
*
* MAKE SURE WE HAVE A VALID COMMAND:
*
					lda D.COMMAND ;GET IT
					bmi BADCMD ;=>WOW!
					beq IOSETUP ;=>ZERO IS A READ
					cmp #10 ;OFF THE END?
					bcs BADCMD ;=>YES
					cmp #9 ;REPEAT?
					bne CMD1 ;=>NOPE
*
* REPEAT. SIMPLY GET PRIOR COMMAND:
*
					lda PREVUNIT ;IS THIS REPEAT FOR
					cmp D.UNITNUM ; SAME UNIT?
					bne BADOP ;=>NO? ILLEGAL!
					lda PREVCMD ;YES, SET COMMAND
					beq RPTOK ;=>REPEAT'ED READ IS OK
					cmp #1 ;IF NOT, IS IT REPEAT'ED WRITE?
					bne BADOP ;=>CAN'T REPEAT OTHER COMMANDS
RPTOK .eq *
					sta D.COMMAND ;SAME AS BEFORE
					cmp #0 ;READ?
					beq IOSETUP ;=>YES
* NOW REPEAT GOES LIKE OTHERS:
*
*
CMD1 .eq *
					cmp #1 ;WRITE?
					bne CMD2 ;=>NOPE
					jmp IOSETUP ;=>YES
CMD2 .eq *
					cmp #2 ;STATUS?
					bne CMD3 ;=>NOT				staTUS
					lda D.STATCODE ;IS IT 'SENSE'?
					beq GOSTAT ;=>YES
					lda #XCTLCODE ;ILLEGAL CODE
					jmp EXIT
GOSTAT .eq *
					jmp DRVSETUP ;=>YES
*
CMD3 .eq *
					cmp #8 ;INIT?
					bne BADOP ;=>NOPE
					jmp INIT ;=>YES, DO INIT
*

BADOP .eq *
					lda #XBADOP ;ILLEGAL COMMAND
					jmp EXIT ;BACK TO YOU
*
BADCMD .eq *
					lda #XREQCODE ;INVALID COMMAND
					jmp EXIT ;BACK TO YOU
*PAGE
* SETUP WHAT WE HAVE TO BEFORE
* PERFORMING THE I/O OPERATION:
*
IOSETUP .eq *
					lda D.BLOCK+1 ;VALIDATE BLOCKNUM
					beq CHKBYTE ;=> IF <256, IT'S OK
					cmp #2 ;IS IT <512?
					bcs BADBLOCK ;=>BAD BOY!
					lda D.BLOCK ;YES, CHECK LO HALF
					cmp #280-256 ; FOR RANGE
					bcc CHKBYTE ;=>IT'S OK
BADBLOCK			.eq *
					lda #XBLKNUM ;BAD BLOCK NUMBER
					jmp EXIT ;RETURN BAD NEWS
*
CHKBYTE				.eq *
					lda D.BYTES ;GET LO COUNT
					bne BADCOUNT ;=>ERR, NOT INTEGRAL BLOCK(S)
					lda D.BYTES+1 ;GET HI COUNT
					lsr A ;MAKE BLOCK COUNT
					bcs BADCOUNT ;=>BAD IF HALF-BLOCK COUNT
					sta BLKCOUNT ;SAVE COUNT OF BLOCKS
*
* DOES REQUESTED BYTECOUNT CAUSE US
* TO RUN OFF END OF DISK?
*
					lda BLKCOUNT ;NO. ADD STARTBLOCK
					clc ; AND BLKCOUNT AND SEE
					adc D.BLOCK ; IF WE'RE TOO BIG
					ldx D.BLOCK+1 ;DID IT START OUT > 255?
					bne BLKG255 ;=>YES
					bcc DRVSETUP ;=>DEFINITELY < 256
					bcs CHKLO ;=>IF CARRY,THEN >256
BLKG255				.eq *
					bcs BADCOUNT ;>255+CARRY IS NOW >511
CHKLO				.eq *
					cmp #280-256+1 ;281..511 ?
					bcc DRVSETUP ;=>NO, WE ARE OK
BADCOUNT			.eq *
					lda #XBYTECNT ;ILLEGAL BYTECOUNT
					jmp EXIT ;SORRY...
*PAGE
*
* SELECT THE APPROPRIATE DRIVE:
*
DRVSETUP			.eq *
					lda D.COMMAND ;SAVE THIS COMMAND
					sta PREVCMD ; AND DEVICE FOR
					lda D.UNITNUM ; SUBSEQUENT
					sta PREVUNIT ; 'REPEAT' CALL
					lda E.REG ;DOWNSHIFT TO
					ora #$80 ; 1MHZ FOR REMAINDER
					sta E.REG ; OF DRIVER EXECUTION
					jsr UNITSEL ;SELECT & START IT
*
* SEE IF THE MOTOR STARTED. IF NOT,
* THEN IT'S EITHER DISKSWITCH OR NODRIVE.
*
					jsr CHKDRV ;MOTOR RUNNING?
					bne DOIO ;=>YES, GREAT.
*
* IF WE GET A MOTOR WHEN WE MOVE
* THE HEAD, THEN IT'S DISKSWITCH.
*
					ldx D.UNITNUM ;FORCE HEAD MOTION
					inc DRVTRACK,X ; EVEN IF ALREADY ON ZERO
					inc DRVTRACK,X ;GIVE HIM A FIRM KNOCKER
					lda #0 ;SEEK TO TRACK ZERO
					jsr MYSEEK ; FOR BFM DIR READ
					jsr CHKDRV ;RUNNING NOW?
					bne DSWITCH ;=>YES, A SWITCHEROO
					lda #0
					ldy D.UNITNUM ;FORGET THAT THIS

					sta DRIVESEL,Y ; DRIVE WAS 'SELECTED'
					lda #XNODRIVE ;NO, A MISSING DRIVE!
					jmp EXIT
*
DSWITCH				.eq *
					lda #XDISKSW ;USER PULLED A FAST ONE
					jmp EXIT ; BUT HE CAN'T FOOL US.
*PAGE
* PREPARE TO DO THE OPERATION:
*
DOIO				.eq *
					lda D.BUFL ;COPY USER BUFFER
					sta BUFTEMP ; AND BLOCK NUMBER
					lda D.BUFH ; TO OUR WORKSPACE
					sta BUFTEMP+1
					lda $1400+D.BUFH
					sta $1400+BUFTEMP+1
					lda D.BLOCK
					sta BLKTEMP
					lda D.BLOCK+1
					sta BLKTEMP+1
*
* IF CALLER GAVE US A COUNT OF ZERO BYTES,
* THEN WE'RE ALL DONE!
*
					lda D.COMMAND ;IS IT STATUS?
					cmp #2 ;IF SO, THEN BYTECOUNT
					bne DOIO2 ; IS MEANINGLESS
					jmp				staTUS
DOIO2				.eq *
					ldy BLKCOUNT ;BLKS=0?
					beq READOK ;=>YES, YOU GET GOOD RETURN
					cmp #0 ;READ COMMAND?
					beq READREQ ;=>YES
					jmp WRITEREQ
*PAGE
*REP 40
* -- READ --
*REP 40
READREQ				.eq *
					lda #0 ;CLEAR COUNT OF
					ldy #0
					sta (D.BYTRD),Y ; BYTES READ
					iny
					sta (D.BYTRD),Y
READREQ2			.eq *
					jsr BLK2SECT ;COMPUTE TRK/SECTOR THIS BLOCK
*
					jsr SECTORIO ;READ IT PLEASE
					bcs READERR ;=>WE LOSE.
					inc SECTOR ;BUMP TO NEXT
					inc SECTOR ; LOGICAL SECTOR
					inc BUF+1 ;BUMP SECTOR BUFFER
					jsr SECTORIO ;READ IT TOO
					bcs READERR ;=>WE LOSE.
					ldy #1
					lda (D.BYTRD),Y ;BUMP COUNT OF
					clc
					adc #2
					sta (D.BYTRD),Y ; BYTES READ
*
* MORE BLOCKS TO GO?
*
					jsr MOREBLKS ;SETUP FOR NEXT BLOCK
					bne READREQ2 ;=>MORE TO READ...
READOK				.eq *
					lda #0 ;GOOD RETURN
					jmp EXIT ;TELL HAPPY USER
*
READERR				.eq *
					jmp EXIT ;RETURN ERROR CODE
CHN DISK3.WRT.SRC

*************************************************************************
* END OF APPLE /// SOS 1.3 SOURCE CODE FILE: DISK3.MAIN.SRC
*************************************************************************



================================================================================================
FILE: "SOS.DISK3.SIO.SRC.TEXT"
================================================================================================
*************************************************************************
* APPLE /// SOS 1.3 SOURCE CODE FILE: DISK3.SIO.SRC
*************************************************************************
* ASSEMBLER: APPLE ][ 6502 ASSEMBLER from APPLE COMPUTER TOOLKIT

*PAGE
*REP 40
* NAME : SECTORIO
* FUNCTION: READ OR WRITE A SECTOR
* INPUT : IBSTRK, IBSECT, MONTIME,
* RETURNS : CARRY CLEAR IF OK (AC=00)
* : CARRY SET IF ERROR (AC=ERRCODE)
* : SEEKWAIT ALL SETUP
* DESTROYS: ALL REGISTERS
*REP 40
*
SECTORIO			.eq *
					lda #R.RECAL ;SETUP THE
* R.RECAL MUST BE NON-ZERO!! (SEE BELOW)
					sta RECALCNT ; RECAL TRIES
					nop ; PAD ONE BYTE
					sta E1908 ; A-REG MUST BE NON-ZERO !!!
* E1908 = NON-ZERO LOCKOUT MOUSE
*
					ldy D.UNITNUM ;ARE WE ON-TRACK?
					lda TRACK
					cmp DRVTRACK,Y
					beq SOUGHT ;=>IF SO, FORGET SEEK & DELAY!
*
* WAIT BEFORE STEPPING:
*
					lda SEEKWAIT ;SEEK DELAY NEEDED?
					beq GOSEEK ;=>NAW...
					lda #0
					sta SEEKWAIT ;CLEAR THE FLAG
					lda #4 ;ADD SEEKDELAY TO
					jsr ADDTIME ; THE TOTAL UPTIME(S)
					tay ;4*25 MS DELAY
SEEKDEL				.eq *
					lda #0
					jsr MSWAIT
					dey
					bne SEEKDEL
*
* ISSUE THE SEEK:
*
GOSEEK				.eq *
					lda TRACK ;GET DESTINATION TRACK
					jsr MYSEEK ;=>..AND YOU SHALL FIND...
*
SOUGHT				.eq *
					lda IRQMASK ;SET IRQ MASK FOR
					sta IMASK ; CORE ROUTINES
					lda #R.IRQ ;SETUP IRQ RETRIES
					sta INTRTRY
					lda #R.IOERR ; AND ERROR RETRIES
					sta RETRYCNT
*
* DELAY FOR ANY REMAINING MOTOR-UP TIME:
*
MDELAY				.eq *
					lda MONTIMEH ;ANY TIME REMAINING?
					bpl FINDIT ;=>NO, WE'RE UP TO SPEED.
					lda #1 ;YES, SO BUMP A SLICE OF
					jsr ADDTIME ; UPTIME WHILE WE WAIT
					lda #0
					jsr MSWAIT
					jmp MDELAY ;=>GO TILL ENOUGH
*
* FIND THE DESIRED SECTOR:
*
* NOTE: FINDSECT RETURNS WITH
* IRQ INHIBITED!
*
FINDIT				.eq *
					php ;INHIBIT IRQ WHILE

					sei ; MESSING WITH VBL FLAGS
					lda E.IER ;DISABLE VBL IRQ
					and #$18 ; DURING SECTOR I/O
					sta E.IER
					ora #$80 ;FOR 'SET' LATER
					sta VBLSAVE
					plp ;RESTORE IRQ				staTUS
					jsr FINDSECT ;FIND ME PLEASE
					bcs TRYRECAL ;=>NO? RECAL OR GIVE UP!
					ldx #$60 ;SET UP SLOT FOR CORE RTNS
					lda D.COMMAND ;WHAT'S YOUR PLEASURE?
					bne SIOWRITE ;=>WRITE
*
*REP 40
* READ A SECTOR:
*
					jsr READ ;READ THAT SECTOR
					jsr FIXIRQ ;ENABLE IRQ IF OK
					lda VBLSAVE ;ALLOW VBL DURING
					sta E.IER ; POSTNIB
					bcs BADIO ;=>I/O ERR OR IRQ
					lda E.REG ;SET 2MHZ FOR POSTNIB
					and #$7F
					sta E.REG
					jsr POSTNIB ;POSTNIB/CHECKSUM
					bcs IORETRY ;=>I/O ERR:BAD CHKSUM
					jmp SIOGOOD ;=>GOOD READ
*
*REP 40
* WRITE A SECTOR:
*
SIOWRITE .eq *
					jsr WRITE ;WRITE THE DATA
					jsr FIXIRQ ;RE-ENABLE IRQ IF OK
					lda VBLSAVE ;RESTORE
					sta E.IER ; VBL IRQ
					bcc SIOGOOD ;=>GOOD WRITE
BVC SIOWPROT ;=>WRITE PROTECTED
*
*REP 40
* IT DIDN'T GO WELL FOR US:
*
BADIO				.eq *
					.DO 1-REV0ROM ;FOR REV1
					bvs FINDIT ;=>IRQ. JUST RETRY IT.
					.ELSE ;FOR REV0
*
* THE REV1 ROM TAKES CARE OF THE
* IRQ RETRY COUNT, BUT REV0 DOESN'T:
*
					bvc IORETRY ;=>I/O ERROR. RETRY IT
					lda ROMREV ;WHICH ROM?
					bne FINDIT ;=>REV1. HE DOES IT.
					lda INTRTRY ;REV0. OUT OF RETRIES?
					bpl BADIO2 ;=>NO.
					sta IMASK ;SET HI BIT FOR IRQ MASK
BADIO2				.eq *
					dec INTRTRY ;ONE LESS RETRY
					jmp FINDIT ;=>RETRY AFTER IRQ
					.FIN
*
* RETRY AFTER AN I/O ERROR:
*
IORETRY				.eq *
					dec RETRYCNT ;ANY RETRIES LEFT?
					bne FINDIT ;=>YEAH, RETRY AFTER ERROR
*
* RETRIES EXHAUSTED. RECALIBRATE:
*
TRYRECAL .eq *
					lda VBLSAVE ;ALLOW VBL IF RECAL
					sta E.IER ; OR UNRECOVERABLE ERROR
					dec RECALCNT ;HAVE WE RECALIBRATED YET?
					bmi SIOERR ;=>YUP. WE'RE DEAD.
					jsr RECAL ;NO, TRY OUR LUCK
					ldy D.UNITNUM ;ARE WE ON-TRACK?
					lda TRACK
					cmp DRVTRACK,Y
					bne NOTSAME
					jmp SOUGHT ;=>IF SO, FORGET RESEEK
NOTSAME				.eq *
					jmp GOSEEK ;TRY AGAIN ON TARGET TRACK
*
*REP 40
SIOERR				.eq *
					lda #XIOERROR ;RETURN CODE
					clc ;INDICATE HARD ERROR
					bcs SIORET
SIOWPROT			.eq *
					lda #XNOWRITE ;RETURN CODE
					clc ;INDICATE HARD ERROR
					bcs SIORET
SIOGOOD				.eq *
					lda #0
					clc ;INDICATE GOOD COMPLETION
SIORET				ldx #0 ; SAY OK TO MOUSE
					stx E1908 ; WITH THIS GLOBAL $1908
					rts
*PAGE
*REP 40
* NAME : FINDSECT
* FUNCTION: LOCATE A DESIRED SECTOR
* INPUT : IBTRK, IBSECT SETUP
* RETURNS : CARRY CLEAR IF OK,
* : CARRY SET IF ERROR.
* DESTROYS: ALL REGISTERS & 'TEMP'
* NOTE : RETURNS WITH IRQ DISABLED IF NO ERROR!
*REP 40
*
FINDSECT			.eq *
					lda #R.FIND*16 ;SETUP NUMBER OF REVS
					sta RETRYADR ; ALLOWED TO FIND SECTOR
					lsr TEMP ;COMPUTE LATENCY FIRST TIME THRU
FINDSEC2			.eq *
					ldx #$60 ;FAKE SLOT FOR CORE ROUTINES
					jsr RDADR ;GET NEXT ADDRESS FIELD
					bcs RDADERR ;=>UGH! AN ERROR!
*
* MAKE SURE WE'RE ON THE CORRECT TRACK:
*
					lda TRACK ;IS IT
					cmp CSSTV+2 ; CORRECT TRACK?
					bne FINDERR ;=>NO?!? IT'S USELESS!
					lda SECTOR ;IS IT
					cmp CSSTV+1 ; DESIRED SECTOR?
					beq FINDGOOD ;=>YEAH. GOT IT!
*
* COMPUTE LATENCY. EACH TWO-SECTOR
* DISTANCE IS 25 MS OF UPTIME.
*
					lda TEMP ;LATENCY ALREADY COMPUTED?
					bmi RDADERR ;=>YES.
					lda SECTOR ;HOW FAR AWAY IS OUR
					clc ; DESIRED SECTOR?
					ror TEMP ;PREVENT RECOMPUTATION
					sbc CSSTV+1
					and #$0F
					lsr A ;EACH 2-SECTORS IS 25 MS
					jsr ADDTIME
*
* KEEP LOOKING TILL WE FIND IT:
*
RDADERR				.eq *
					jsr FIXIRQ ;ENABLE IRQ IF APPROPRIATE
					dec RETRYADR ;ANY RETRIES LEFT?
					beq FINDERR ;=>NO, WE CAN'T FIND IT.
*
* COMPENSATE FOR A BUG IN RDADR: IF WE TRY
* TO CALL RDADR AGAIN BEFORE THE DATA MARK
* GOES BY, THEN RDADR WILL ACCIDENTALLY CALL
* THAT AN ERROR. WE CAN AVOID THIS 'FAKE'
* ERROR BY DELAYING PAST THE DATA MARK.
					ldy #200 ;1 MS IS PLENTY
ADRDELAY			.eq *
					dey
					bne ADRDELAY
					jmp FINDSEC2 ;=>NOW TRY LOOKING AGAIN
*
*REP 40
FINDGOOD			.eq *
					lda #0 ;CLEAR VOLNUM OUT OF
					sta MONTIMEH ; MOTORTIME!

					clc ;INDICATE NO ERROR
					rts
*
FINDERR				.eq *
					jsr FIXIRQ ;ENABLE IRQ IF APPROPRIATE
					lda #0 ;CLEAR VOLNUM OUT OF
					sta MONTIMEH ; MOTORTIME!
					clc ;INDICATE THE ERROR
					rts

CHN DISK3.USEL.SRC

*************************************************************************
* END OF APPLE /// SOS 1.3 SOURCE CODE FILE: DISK3.SIO.SRC
*************************************************************************




================================================================================================
FILE: "SOS.DISK3.SRC.TEXT"
================================================================================================
*************************************************************************
* APPLE /// SOS 1.3 SOURCE CODE FILE: DISK3.SRC
*************************************************************************
* ASSEMBLER: APPLE ][ 6502 ASSEMBLER from APPLE COMPUTER TOOLKIT

*SBTL 'SOS 1.1 DISK /// DRIVER'
TEST				.eq 0 ;FOR FUNNY-MODE TESTING
					INCLUDE SOSORG,6,1,254
DO TEST
ORG $2000
ELSE
*REL
ORG ORGDISK3
FIN
ZZORG .eq *
CHR '-'
*MSB OFF
*
*REP 40
* COPYRIGHT (C) APPLE COMPUTER INC.
* ALL RIGHTS RESERVED
*REP 40
*
REV0ROM .eq 0 ;1=SUPPORT REV0 ROM
*
DO 1-TEST
*ENTRY DIB1 ;DIB1
*ENTRY DIB2 ;DIB2
*ENTRY DIB3 ;DIB3
*ENTRY DIB4 ;DIB4
*ENTRY SEEKDSK3 ;SEEK CURRENT DRIVE
*
*EXTRN SYSERR
*
*EXTRN XREQCODE
*EXTRN XBADOP
*EXTRN XNODRIVE
*EXTRN XIOERROR
*EXTRN XNOWRITE
*EXTRN XBYTECNT
*EXTRN XBLKNUM
*EXTRN XDISKSW
*EXTRN XCTLCODE
*
*EXTRN E1908 ; GLOBAL FLAG FOR MOUSE DRIVER
* TO SAY WE CANNOT BE INTERRUPTED
*
ELSE
XREQCODE .eq $20
XBADOP .eq $26
XNODRIVE .eq $28
XIOERROR .eq $27
XNOWRITE .eq $2B
XBYTECNT .eq $2C
XBLKNUM .eq $2D
XDISKSW .eq $2E
XCTLCODE .eq $21
FIN
*PAGE
* DISK /// CONTROLLER EQUATES:
*
* MOTOR SELECT BITS:
*
* DRIVE INT EXT1 EXT2
* ----- --- ---- ----
* .D1 1 X X
* .D2 X 0 1
* .D3 X 1 0
* .D4 X 1 1
*
MS.INT .eq $C0D4 ;MOTOR SELECT:INTERNAL DRIVE
MD.INT .eq $C0D5 ;MOTOR DESELECT:INTERNAL DRIVE
*
MS.EXT1 .eq $C0D3 ;MOTOR SELECT:EXTERNAL DRIVE
MS.EXT2 .eq $C0D1 ;MOTOR SELECT:EXTERNAL DRIVE
MD.EXT1 .eq $C0D2 ;MOTOR DESELECT:EXTERNAL DRIVE

MD.EXT2 .eq $C0D0 ;MOTOR DESELECT:EXTERNAL DRIVE
*
IS.INT .eq $C0EA ;I/O SELECT:INTERNAL DRIVE
IS.EXT .eq $C0EB ;I/O SELECT:EXTERNAL DRIVE
*
NOSCROLL .eq $C0D8 ;SMOOTHSCROLL OFF
*
MOTOROFF .eq $C0E8 ;MOTOR(S)				staRT POWEROFF T/O
MOTORON .eq $C0E9 ;MOTOR(S) POWER ON
Q6L .eq $C08C ;Q7L,Q6L=READ
Q6H .eq $C08D ;Q7L,Q6H=SENSE WPROT
Q7L .eq $C08E ;Q7H,Q6L=WRITE
Q7H .eq $C08F ;Q7H,Q6H=WRITE STORE
*
* OTHER EQUATES:
*
E.REG .eq $FFDF ;ENVIRONMENT REGISTER
E.IER .eq $FFEE ;INTERRUPT ENABLE REGISTER
*
* RETRY COUNTERS:
*
R.RECAL .eq 1 ;MAX RECALIBRATES
* R.RECAL MUST NOT BECOME ZERO! (MOUSE WILL BE LOCKED OUT)
* SEE DISK3.SIO.SRC LINE 14 FOR DETAIL
R.FIND .eq 3 ;MAX REVS TO FIND A SECTOR
R.IOERR .eq 4 ;MAX RETRIES ON READ ERROR
R.IRQ .eq 6 ;MAX IRQ'S TOLERATED BEFORE SEI
*PAGE
* ZPAGE EQUATES FOR CORE ROUTINES:
*
DSECT
ORG $81
IBSLOT DS 1 ;SLOT=$60 FOR RTNS
DS 7 ;N/A
DS 1 ;RDADR:CHECKSUM
DS 1 ;N/A
IMASK DS 1 ;BIT7 SET IF IRQ ALLOWED
CURTRK DS 1 ;SEEK:CURRENT TRACK
DS 2 ;N/A
INTRTRY DS 1 ;READ: IRQ RETRY COUNT
DS 5 ;N/A
DS 1 ;RDADR:'MUST FIND' COUNT
DS 1 ;READ,WRITE: CHECKSUM
CSSTV DS 4 ;RDADR:CKSUM,SEC,TRK,VOL
MONTIMEL .eq CSSTV+2 ;MSWAIT:MOTOR-ON TIME
MONTIMEH .eq MONTIMEL+1
BUF DS 2 ;PRENIB,POSTNIB:USER BUFFER
DS 1 ;SEEK:PRIOR PHASE
TRKN DS 1 ;SEEK:TARGET TRACK
*
* LOCAL TEMPS:
*
ORG $D0 ;WE'RE ALLOWED TO $FF
BLKTEMP DS 2 ;LOCAL TEMP FOR BLKNUMBER
BUFTEMP DS 2 ;LOCAL TEMP FOR BUFFER ADDRESS
TRACK DS 1 ;LOCAL TEMP FOR TRACK
					clcTOR DS 1 ;LOCAL TEMP FOR SECTOR
RETRYADR DS 1 ;LOCAL TEMP FOR SECTOR-FIND RETRIES
RETRYCNT DS 1 ;LOCAL TEMP FOR I/O RETRIES
RECALCNT DS 1 ;LOCAL TEMP FOR RECAL COUNT
BLKCOUNT DS 1 ;BLKS REQD TO SATISFY BYTECOUNT
SEEKWAIT DS 1 ;<>0 IF SEEK DELAY NEEDED
IRQMASK DS 1 ;ENTRY 'I' BIT
TEMP DS 1 ;JUST A TEMP
DEND
*PAGE
* DRIVER INTERFACE AREA:
*
DSECT
ORG $C0
D.COMMAND DS 1 ;COMMAND CODE
D.UNITNUM DS 1 ;UNIT NUMBER
D.BUFL DS 2 ;BUFFER ADDRESS
D.BUFH .eq D.BUFL+1
D.STATCODE .eq D.BUFL ;DSTATUS CODE
D.STATBUF .eq D.BUFH ;^DSTATUS LIST
D.BYTES DS 2 ;BYTECOUNT
D.BLOCK DS 2 ;REQUESTED BLOCKNUM
D.BYTRD DS 2 ;BYTES READ (READ)
DS 6 ;SPARES (OK AS TEMPS)
DEND

*PAGE
DIB1				.eq *;DIB FOR .D1
DW DIB2 ;FLINK
DW MAIN ;ENTRY POINT
DFB 3 ;NAME LENGTH
ASC '.D1 '
DFB $80 ;DEVNUM: ACTIVE
DFB 0 ;SLOT
DFB 0 ;UNIT NUMBER
DFB $E1,1,0 ;TYPE,SUB,FILLER
DW 280 ;BLOCKCOUNT
DW 1 ;MANUFACTURER=APPLE
DW $1100 ;VERSION=1.1
*
DIB2				.eq *;DIB FOR .D2
DW DIB3 ;FLINK
DW MAIN ;ENTRY POINT
DFB 3 ;NAME LENGTH
ASC '.D2 '
DFB $80 ;DEVNUM: ACTIVE
DFB 0 ;SLOT
DFB 1 ;UNIT NUMBER
DFB $E1,1,0 ;TYPE,SUB,FILLER
DW 280 ;BLOCKCOUNT
DW 1 ;MANUFACTURER=APPLE
DW $1100 ;VERSION=1.1
*
DIB3			.eq *;DIB FOR .D3
DW DIB4 ;FLINK
DW MAIN ;ENTRY POINT
DFB 3 ;NAME LENGTH
ASC '.D3 '
DFB $80 ;DEVNUM: ACTIVE
DFB 0 ;SLOT
DFB 2 ;UNIT NUMBER
DFB $E1,1,0 ;TYPE,SUB,FILLER
DW 280 ;BLOCKCOUNT
DW 1 ;MANUFACTURER=APPLE
DW $1100 ;VERSION=1.1
*
DIB4				.eq *;DIB FOR .D4
DW 0 ;NO FLINK
DW MAIN ;ENTRY POINT
DFB 3 ;NAME LENGTH
ASC '.D4 '
DFB $80 ;DEVNUM: ACTIVE
DFB 0 ;SLOT
DFB 3 ;UNIT NUMBER
DFB $E1,1,0 ;TYPE,SUB,FILLER
DW 280 ;BLOCKCOUNT
DW 1 ;MANUFACTURER=APPLE
DW $1100 ;VERSION=1.1
DW 1 ;MANUFACTURER=APPLE
DW $1100 ;VERSION=1.1

CHN DISK3.MAIN.SRC
INCLUDE SOSORG,6,1,254

*************************************************************************
* END OF APPLE /// SOS 1.3 SOURCE CODE FILE: DISK3.SRC
*************************************************************************




================================================================================================
FILE: "SOS.DISK3.SUBS.SRC.TEXT"
================================================================================================
*************************************************************************
* APPLE /// SOS 1.3 SOURCE CODE FILE: DISK3.SUBS.SRC
*************************************************************************
* ASSEMBLER: APPLE ][ 6502 ASSEMBLER from APPLE COMPUTER TOOLKIT

*PAGE
*REP 40
* NAME : CHKDRV
* FUNCTION: CHECK IF MOTOR(S) RUNNING
* INPUT : NONE
* RETURNS : 'BNE' IF RUNNING
* : 'BEQ' IF NOT
* DESTROYS: AC,X
*REP 40
* NOTES: DUE TO A FLOATING PIN, THERE
* COULD BE A GLITCH WHICH CAUSES THE
* SHIFTER TO 'FLASH' ONTO THE BUS
* INSTEAD OF ALWAYS BEING TRISTATED.
* THIS COULD CAUSE CHKDRV TO THINK
* THAT THE MOTOR IS SPINNING WHEN IT
* IS NOT. THUS WE WILL SAMPLE THE SHIFTER
* FOR 40 US AT 6-US INTERVALS. IF, AFTER
* THREE (3) CONSECUTIVE PASSES, ANY OF
* THE PASSES SEES A 'LOCKED' SHIFTER,
* THEN WE SAY THE DRIVE IS STOPPED.
*
*
CHKDRV				.eq *
					ldx #3 ;CHECK SHIFTER SEVERAL TIMES
CHKD1				.eq *
					lda Q6L+$60 ;GET DATA
					cmp Q6L+$60 ;HAS IT CHANGED?
					bne CHANGED ;=>YES
					cmp Q6L+$60 ;HAS IT CHANGED?
					bne CHANGED ;=>YES
					cmp Q6L+$60 ;HAS IT CHANGED?
					bne CHANGED ;=>YES
					cmp Q6L+$60 ;HAS IT CHANGED?
					bne CHANGED ;=>YES
					cmp Q6L+$60 ;HAS IT CHANGED?
					bne CHANGED ;=>YES
					cmp Q6L+$60 ;HAS IT CHANGED?
					bne CHANGED ;=>YES
					cmp Q6L+$60 ;HAS IT CHANGED?
					bne CHANGED ;=>YES
					rts;IF EVER LOCKED, IT'S STOPPED
*
CHANGED				.eq *
					dex
					bne CHKD1 ;TRY SEVERAL TIMES
					dex ;SET CC=BNE
					rts;RETURN ZFLAG APPROPRIATELY
*PAGE
*REP 40
* NAME : ADDTIME
* FUNCTION: ADD TO MOTOR UPTIME(S)
* INPUT : AC=NO. OF 25 MS INCREMENTS
* DESTROYS: Y
*REP 40
*
ADDTIME				.eq *
					pha;PRESERVE AC
					ldy #4 ;TABLE INDEX/COUNT
ADD2				.eq *
					lda DRIVESEL-1,Y ;IS IT SELECTED?
					beq ADD3 ;=>NOPE
					pla
					pha;RECOVER DELTA-T
					clc
					adc UPTIME-1,Y ;ADD TO MOTOR UPTIME
					cmp #T1SEC+2 ;IS IT AT MAX TIME?
					bcc ADD2A ;=>NO, STORE NEW TIME
					lda #T1SEC+1 ;YES, SET TO >1 SEC
ADD2A				.eq *
					sta UPTIME-1,Y
ADD3				.eq *

					dey
					bne ADD2 ;=>DO ALL 4 DRIVES
*
					pla ;RESTORE AC
					rts
*PAGE
*REP 40
* NAME : RECAL
* FUNCTION: RECALIBRATE DRIVE HEAD
* INPUT : NONE
* DESTROYS: ALL REGISTERS
* NOTE : A 'QUIET' RECALIBRATE IS DONE
* : USING TWO ITERATIONS. IF WE ARE
* : LOST, THEN SEEK 48-TRACKS
* : TOWARD TRACK ZERO. IF WE KNOW
* : WHAT TRACK WE'RE CURRENTLY
* : ON (+- 1/2 TRACK), THEN JUST
* : ADD A LITTLE EXTRA AND SEEK
* : TO TRACK ZERO. A 48-TRACK
* : SEEK WILL ALWAYS GET US BACK
* : ONTO THE MEDIA, EVEN IF WE
* : WERE "OFF THE CAM". FROM THAT
* : POINT, THE 2ND SEEK GETS US
* : BACK TO TRACK ZERO QUIETLY.
*REP 40
*
RECAL				.eq *
					lda #2 ;TWO ITERATIONS, PLEASE
RECAL1				.eq *
					pha;SAVE LOOPCOUNT
					ldx #$60 ;SETUP SLOT FOR CORE RTNS
					jsr RDADR ;WHERE ARE WE?
					bcc RECAL2 ;=>NOW WE KNOW
					jsr RDADR ;GIVE SECOND SHOT
					bcc RECAL2 ;=>THAT GOT IT
					lda #48 ;LOST? TRY 48-TRACK SEEK
					jmp RECAL3
RECAL2				.eq *
					lda CSSTV+2 ;HERE'S WHERE WE ARE
					clc ;ADD SOME SO WE GET A
					adc #3 ; HARDER SEEK TO ZERO
RECAL3				.eq *
					ldy D.UNITNUM ;THIS IS NOW WHERE
					sta DRVTRACK,Y ; WE ARE
					jsr FIXIRQ ;ENABLE IRQ IF OK
*
					lda #0 ;DESTINATION TRACK IS 00
					sta MONTIMEH ;CLEAR MOTOR-UP TIME SO
					sta MONTIMEL ; SEEK KNOWS HOW LONG RECAL TAKES
					jsr MYSEEK ;=>SLAM IT BACK!
					pla ;HAVE WE DONE IT TWICE?
					tay
					dey
					tya
					bne RECAL1 ;=>DO TWO ITERATIONS
					rts
*PAGE
*REP 40
* NAME : SEEKDSK3
* FUNCTION: SEEK CURRENT DRIVE
* INPUT : AC=DESTINATION TRACK
* OUTPUT : NONE
* DESTROYS: ALL REGISTERS
* NOTE : MUST BE CALLED WHILE
* : MOTOR IS RUNNING, IN
* : 1MHZ+ROM+IO MODE
*REP 40
SEEKDSK3			.eq *
					ldy PREVUNIT ;GET DRIVENUM
					sty D.UNITNUM ;SET IT UP
					jsr MYSEEK ;MOVE IT!
					rts
*REP 40
* NAME : MYSEEK
* FUNCTION: SEEK TO DESIRED TRACK
* INPUT : AC=DESTINATION TRACK
* DESTROYS: ALL REGISTERS
*REP 40
MYSEEK				.eq *
					sta TRKN ;TEMP HOLD OF AC
					ldy D.UNITNUM ;GET DRIVENUM

					lda DRVTRACK,Y ;SETUP CURRENT TRACK
					asl A ;SET IN HALFTRACKS FOR SEEK
					sta CURTRK ; FOR SEEK ROUTINE
					ldx #$60 ;SET UP SLOT FOR CORE RTNS
					lda MONTIMEH ;GET STARTING MOTOR TIME
					sta TEMP
*
* NOTE: IRQ'S WHICH SUSPEND SEEK MAY CAUSE A
* SEEK FAILURE. WE WILL HAVE TO RECALIBRATE
* SINCE WE WON'T BE ON-TRACK. WE CAN NOT GET
* ON A HALFTRACK SINCE SEEK ALLOWS SETTLING
* TIME OF THE PHASE. BECAUSE VBL IS A SERIOUS
* OFFENDER, WE INHIBIT HIM.
*
					php ;INHIBIT IRQ WHILE
					sei ; MESSING WITH VBL FLAGS
					lda E.IER
					and #$18
					sta VBLSAVE
					sta E.IER
					plp ;RESTORE IRQ				staTUS
					lda TRKN ;RESTORE DESTINATION TRACK
					sta DRVTRACK,Y ;DEST IS NOW CURRENT
					asl A ;MAKE IT IN HALFTRACKS
					jsr SEEK ;GO MOVE THE HEAD...
					lda VBLSAVE ;NOW ALLOW THAT
					ora #$80 ; NASTY
					sta E.IER ; VBL INTERRUPT
*
* COMPUTE THE TIME USED BY SEEK:
*
					lda MONTIMEH ;INCLUDE SEEKTIME IN
					clc
					sbc TEMP
					jsr ADDTIME ; TOTAL MOTOR UPTIME(S)
					rts
*PAGE
*REP 40
* NAME : BLK2SECT
* FUNCTION: COMPUTE TRACK/SECTOR FOR A BLOCK
* AND ADJUST BUFFER ADDRESS
* INPUT : D.BLOCK, D.BUF
* OUTPUT : TRACK, SECTOR, D.BUF
* DESTROYS: AC,Y
*REP 40
*
BLK2SECT			.eq *
					lda BLKTEMP+1 ;GET HI BLK HALF
					ror A ;MOVE LO BIT TO CARRY
					lda BLKTEMP ;GET LO HALF
					ror A ;COMBINE WITH HI BIT
					lsr A
					lsr A ;FINISH OFF DIVIDE-BY-8
					sta TRACK ;THAT'S THE TRACK
					lda BLKTEMP ;GET LO HALF AGAIN
					and #7
					tay
					lda SECTABLE,Y ;GET				staRT SECTOR
					sta SECTOR
*
* ADJUST BUFFER ADDRESS SO THAT I/O
* WON'T WRAPAROUND IN THE BANK:
* (THIS ALGORITHM RIPPED OFF FROM 1.0)
*
					lda BUFTEMP+1 ;GET BUFFER HI ADDRESS
					ldy $1400+BUFTEMP+1 ; AND XTND BYTE
					cmp #$82 ;IF RAM ADDR >=8200 THEN BUMP TO
					bcc NOADJ ; NEXT BANK PAIR
					cpy #$80
					bcc NOADJ ;=>NOT USING BANKPAIR
					cpy #$8F ;SPECIAL BANK 0?
					beq NOADJ ;=>YES
					and #$7F ;DROP HI ADDRESS AND
					sta BUFTEMP+1 ; BUMP BANK NUMBER
					inc $1400+BUFTEMP+1
*
NOADJ				.eq *
					lda BUFTEMP+1 ;COPY BUFFER ADDRESS
					sta BUF+1 ; FOR PRE & POSTNIB
					lda BUFTEMP
					sta BUF

					lda $1400+BUFTEMP+1
					sta $1400+BUF+1
					rts
*
					clcTABLE DFB $00,$04,$08,$0C,$01,$05,$09,$0D
*PAGE
*REP 40
* NAME : MOREBLKS
* FUNCTION: SETUP TO DO NEXT BLOCK
* INPUT : NONE
* RETURNS : 'BNE' IF MORE TO DO
* : 'BEQ' IF NO MORE TO DO
* DESTROYS:NOTHING
*REP 40
*
MOREBLKS .eq *
					inc BUFTEMP+1 ;BUMP BUFFER ADDRESS
					inc BUFTEMP+1
					inc BLKTEMP ;BUMP BLOCK NUMBER
					bne MORE2
					inc BLKTEMP+1
MORE2 .eq *
					dec BLKCOUNT ;MORE BLOCKS TO GO?
					rts ;RETURN RESULT OF DEC
*SKP 4
*REP 40
* NAME : FIXIRQ
* FUNCTION: ENABLE IRQ IF APPROPRIATE
* INPUT : NONE
* DESTROYS: NOTHING
*REP 40
*
FIXIRQ .eq *
					pha
					lda IRQMASK ;SHOULD IRQ BE ENABLED?
					bmi FIXRET ;=>NO, LEAVE IT ALONE
CLI ;ENABLE IRQ
FIXRET .eq *
					pla
					rts

CHN DISK3.DATA.SRC

*************************************************************************
* END OF APPLE /// SOS 1.3 SOURCE CODE FILE: DISK3.SUBS.SRC
*************************************************************************




================================================================================================
FILE: "SOS.DISK3.USEL.SRC.TEXT"
================================================================================================
*************************************************************************
* APPLE /// SOS 1.3 SOURCE CODE FILE: DISK3.USEL.SRC
*************************************************************************
* ASSEMBLER: APPLE ][ 6502 ASSEMBLER from APPLE COMPUTER TOOLKIT

*PAGE
*REP 40
* NAME : UNITSEL
* FUNCTION: SELECT & START A DRIVE,
* SET UP MOTOR & SEEK DELAYS
* INPUT : NONE
* OUTPUT : MONTIME,SEEKTIME
* DESTROYS: ALL REGISTERS
*REP 40
*
UNITSEL .eq *
					ldy D.UNITNUM ;GET DRIVENUM
					lda #0 ;ASSUME NO SEEKWAIT
					sta SEEKWAIT ; WILL BE NEEDED
					sta MONTIMEL ;CLEAR MONTIME
					sta MONTIMEH
*
* SEE IF MOTOR(S) STILL SPINNING:
*
					jsr CHKDRV ;MOTOR(S) POWERED UP?
					bne SPINNING ;=>YES. WHO IS IT?
*
* NO MOTOR(S) SPINNING. DESELECT
* ALL MOTORS AND START AFRESH:
*
					ldx MD.INT ;DESELECT ALL
					lda #0 ;SHOW INTERNAL AS
					sta DRIVESEL+0 ; NOT SELECTED
					sta UPTIME+0 ;INDICATE DRIVE IS FULLY STOPPED
					jsr EXTDESEL ;DESELECT ALL EXTERNALS TOO
					jmp SETTIME ;GO SETUP MOTOR DELAY
*REP 40
* MOTOR(S) SPINNING: OURS?
*
SPINNING .eq *
					lda DRIVESEL,Y ;HAD WE BEEN SELECTED?
					bne GOFORIT ;=>YES, GO FOR IT RIGHT AWAY.
*
* WE AREN'T SPINNING. SHUTDOWN ANOTHER
* DRIVE, IF NECESSARY, TO GET GOING:
*
					cpy #0 ;ARE WE THE INTERNAL DRIVE?
					beq SETTIME ;=>YES, LEAVE EXT MOTOR ALONE
*
* WE'RE AN EXTERNAL DRIVE. STOP ALL EXTERNAL MOTORS
* UNCONDITIONALLY, BUT LEAVE THE INTERNAL MOTOR ALONE.
* IF WE *DID* HAVE TO STOP ANOTHER EXTERNAL, THEN
* MAKE SURE WE SET THE CORRECT PRE-SEEK DELAY!
*
					lda #0 ;SEE IF ANOTHER EXTERNAL
					ora DRIVESEL+3 ; HAD BEEN
					ora DRIVESEL+2 ; SELECTED
					ora DRIVESEL+1 ; BEFORE...
					beq SETTIME ;=>NO, SEEK DELAY IS UNNECESSARY
					inc SEEKWAIT ;YES, DELAY BEFORE STEPPING
					jsr EXTDESEL ;DESELECT ALL EXTERNALS
					jmp SETTIME ;=>GO SETUP MOTOR DELAY
*PAGE
*REP 40
* OUR DRIVE IS SPINNING. GO FOR IT!
* DEPENDING OF HOW LONG THE MOTOR'S BEEN ON,
* THIS COMMAND MAY REQUIRE A MOTOR DELAY.
*
GOFORIT .eq *
					ldx D.COMMAND ;GET CURRENT COMMAND
					lda MTIMES,X ;GET REQUIRED UPTIME FOR IT
					clc
					sbc UPTIME,Y ;DRIVE RUNNING LONG ENOUGH?
					bcs SELECT ;=>NO, AC NOW HAS DELTA-T
					lda #0 ;OTHERWISE, WAIT=0
					jmp SELECT ;SET MONTIME & SELECT DRIVE

*REP 40
*
* ALL MOTORS WERE OFF. CHOOSE THE
* APPROPRIATE MOTOR-ON TIME:
*
SETTIME .eq *
					lda #0 ;INDICATE THAT
					sta UPTIME,Y ; THE DRIVE WAS OFF
					ldx D.COMMAND ;GET CURRENT COMMAND
					lda MTIMES,X ;GET CORRECT DELAY TIME
*REP 40
*
* SELECT THE DRIVE &				staRT IT:
*
SELECT .eq *
					sta MONTIMEH ;NEGATE IT BECAUSE
					lda #0 ; IT GETS INCREMENTED
					clc ; INSTEAD OF
					sbc MONTIMEH ; DECREMENTED
					sta MONTIMEH ;STUFF MOTOR DELAY
					cpy #1 ;ARE WE THE INTERNAL DRIVE?
					bcs SELEXT ;=>NO, AN EXTERNAL
					lda IS.INT ;I/O SELECT INTERNAL
					lda MS.INT ;MOTOR SELECT INTERNAL
					jmp UNITRET ;=>ALL DONE!
*
SELEXT .eq *
					lda IS.EXT ;I/O SELECT EXTERNAL
					cpy #2 ;ARE WE 2, 3, OR 4 ?
					bcs NOTD2 ;=>DEFINITELY 3 OR 4
					lda MD.EXT1 ;MOTOR SELECT
					lda MS.EXT2 ; ONLY .D2
					jmp UNITRET ;=>ALL DONE!
*
NOTD2 .eq *
					bne ISD4 ;=>DEFINITELY NOT 3
					lda MS.EXT1 ;MOTOR SELECT
					lda MD.EXT2 ; ONLY .D3
					jmp UNITRET ;=>ALL DONE!
*
ISD4 .eq *
					lda MS.EXT1 ;MOTOR SELECT
					lda MS.EXT2 ; ONLY .D4
*
*
UNITRET .eq *
					lda MOTORON ;PROVIDE MOTOR POWER
					lda #1 ;SAY WE'VE SELECTED
					sta DRIVESEL,Y ; THIS DRIVE
*
* IF WE HAVE MOTORTIME TO BURN,
* THEN DELAY 50 MS. THIS ENSURES
* A GOOD SOLID CHKDRV AFTER
* TURNING ON THE MOTOR.
*
					lda MONTIMEH ;ANY MOTORTIME?
					bpl UNITRTS ;=>NO, WE GO FOR IT.
					ldy #5 ;5*10 MS
UNITDEL .eq *
					lda #100 ;100*100US IS 10MS
					jsr MSWAIT
					dey
					bne UNITDEL
					lda #2 ;INCLUDE THE 50MS
					jsr ADDTIME ; IN MOTOR UPTIME(S)
UNITRTS .eq *
					rts
*SKP 5
*REP 40
* NAME : EXTDESEL
* FUNCTION: DESELECT ALL EXTERNAL DRIVE MOTORS
* INPUT : NONE
* DESTROYS: AC,X
*REP 40
*
EXTDESEL .eq *
					lda MD.EXT1 ;DESELECT ALL EXTERNAL
					lda MD.EXT2 ; DRIVE MOTORS
					ldx #3 ;SHOW THAT THEY ARE
					lda #0 ; ARE ALL DEAD DUCKS
EDS1				sta DRIVESEL,X

					sta UPTIME,X ;DRIVE MOTORS ARE OFF
					dex
					bne EDS1
					rts

CHN DISK3.SUBS.SRC

*************************************************************************
* END OF APPLE /// SOS 1.3 SOURCE CODE FILE: DISK3.USEL.SRC
*************************************************************************



================================================================================================
FILE: "SOS.DISK3.WRT.SRC.TEXT"
================================================================================================
*************************************************************************
* APPLE /// SOS 1.3 SOURCE CODE FILE: DISK3.WRT.SRC
*************************************************************************
* ASSEMBLER: APPLE ][ 6502 ASSEMBLER from APPLE COMPUTER TOOLKIT

*PAGE
*REP 40
* --- WRITE ---
*REP 40
*
WRITEREQ .eq *
					jsr BLK2SECT ;COMPUTE TRK/SECTOR THIS BLOCK
					lda E.REG ;SET 2 MHZ
					and #$7F
					sta E.REG
					jsr PRENIB ;PRENIBBLIZE FOR WRITE
					jsr SECTORIO ;WRITE IT OUT...
					bcs WRITERR ;=>SOMETHING'S WRONG
*
					inc SECTOR ;BUMP TO NEXT
					inc SECTOR ; LOGICAL SECTOR
					inc BUF+1 ;BUMP SECTOR BUFFER ADDRESS
					lda E.REG ;SET 2 MHZ
					and #$7F
					sta E.REG
					jsr PRENIB ;PRENIBBLIZE FOR WRITE
					jsr SECTORIO ;WRITE IT OUT
					bcs WRITERR ;=>SOMETHING'S WRONG
*
* MORE BYTES TO DO?
*
					jsr MOREBLKS ;SETUP FOR NEXT
					bne WRITEREQ ;=>MORE TO DO
					lda #0 ;GOOD RETURN
					jmp EXIT
*
WRITERR .eq *
					jmp EXIT ;RETURN ERROR CODE
*PAGE
*REP 40
* ---				staTUS ---
*REP 40
*
STATUS .eq *
					ldx #$60 ;DUMMY SLOT
					lda Q6H,X ;SENSE WRITE PROTECT
					lda Q7L,X
					asl A ;PRESERVE IT IN CARRY
					lda Q6L,X ;BACK TO READ MODE
					lda #0 ;NOW MOVE BIT TO
					rol A ; PROPER POSITION
					rol A ; ($02)
					ldy #0
					sta (D.STATBUF),Y ;RETURN IT
					lda #0 ;GOOD RETURN
					jmp EXIT ;DONE
*PAGE
*REP 40
* --- INIT ---
*REP 40
*
INIT .eq *
					lda INITFLAG ;INIT'ED YET?
					bmi GOODINIT ;=>YES, DONE
*
					lda #$60 ;SETUP SLOT FOR
					sta IBSLOT ; CORE ROUTINES
					lda #$FF ;PREVENT SECOND
					sta INITFLAG ; INIT
					lda #0 ;CLEAR STUFF OUT
					sta PREVUNIT ;SOSBOOT JUST USED .D1
					ldy #4
CLRDRVS .eq *
					lda #0
					sta DRIVESEL-1,Y ;NOBODY SELECTED
					sta UPTIME-1,Y ;ALL OFF

					sta DRVTRACK-1,Y
					dey
					bne CLRDRVS
DO 1-TEST ;ONLY IF NOT TESTING
*
* SET UP .D1 SINCE LOADER'S USING IT:
*
					lda E.REG ;SET 1MHZ FOR THE
					ora #$80 ;				staTEMACHINE I/O
					sta E.REG
					jsr CHKDRV ;IS .D1 MOTOR SPINNING?
					beq INIT2 ;=>NO, MOTOR'S OFF
					lda #T200MS ;UPTIME GOOD FOR READS
					sta UPTIME+0
INIT2 .eq *
					lda #1
					sta DRIVESEL+0 ;.D1 IS THE CURRENT DRIVE
					lda $0300+CURTRK ;RETRIEVE CURRENT TRACK
					sta DRVTRACK+0 ;REMEMBER IT
FIN
*
* SET UP JMP TABLE FOR CORRECT ROM:
*
DO REV0ROM ;ONLY IF SUPPORTING IT!
					lda $F1B9 ;LOOK FOR				staRT OF RDADR
					cmp #$A0 ;IS IT RDADR (REV1)?
					beq INITREV1 ;=>YES
					cmp #$60 ;IS IT END OF READ (REV0)?
					bne INITERR ;=>NEITHER!
					ldy #0 ;REV=0
					beq INITVECT ;(ALWAYS TAKEN)
INITREV1 .eq *
					ldy #VSIZE
INITVECT .eq *
					sty ROMREV ;SET ROM REVISION INDICATOR
					ldx #VSIZE
MOVEVECT .eq *
					lda REV0,Y ;GET A BYTE
					sta JMPTAB,Y ;MOVE IT
					iny
					dex
					bne MOVEVECT
FIN
GOODINIT .eq *
					lda #0 ;RETCODE=GOOD, IF YOU CARE
					clc ;SAY 'GOOD INIT'
					bcc EXIT ;(ALWAYS TAKEN)
DO REV0ROM
INITERR .eq *
					clc ;SAY 'BAD INIT'
* FALL THRU TO EXIT
FIN
*PAGE
*REP 40
* -- EXIT PATH --
*REP 40
*
EXIT .eq *
					pha;SAVE RETURN CODE
*
* UPDATE UPTIME BY 50 MS (3 SECTOR-TIMES)
* TO ACCOUNT FOR READ/WRITE TIME:
*
					lda D.COMMAND ;GET COMMAND
					cmp #2 ;SENSE OR INIT?
					bcs EXIT2 ;=>YES, NO TIME USED UP
					lda #2 ;TIME=50 MS (2 UNITS)
					jsr ADDTIME ;BUMP UPTIME(S)
*
* RESTORE CALLER ENVIRONMENT:
*
EXIT2 .eq *
					lda E.REG ;GET CURRENT				staTE
					and #$20 ; OF THE SCREEN
					ora ESAVE ;MERGE WITH CALLER				staTE
					sta E.REG
					jsr FIXIRQ ;RE-ENABLE IRQ IF OK
					lda MOTOROFF ;START MOTOR-OFF TIMEOUT
					pla ;RESTORE RETURN CODE
DO TEST ;IF TEST, NO SYSERR
					rts

ELSE
					bne GOERR ;=>ERROR RETURN VIA SYSERR
					clc
					rts;GOOD RETURN W/CARRY CLEAR
GOERR .eq *
					jsr SYSERR ;RETURN VIA SYSERR
FIN

CHN DISK3.SIO.SRC

*************************************************************************
* END OF APPLE /// SOS 1.3 SOURCE CODE FILE: DISK3.WRT.SRC
*************************************************************************


================================================================================================
FILE: "SOS.EQUATES.TEXT"
================================================================================================
*************************************************************************
* APPLE /// SOS 1.3 SOURCE CODE FILE: EQUATES
*************************************************************************
* ASSEMBLER: APPLE ][ 6502 ASSEMBLER from APPLE COMPUTER TOOLKIT

*
*ENTRY BFMGR
*
* BFM INITIALIZATION ENTRIES
* (INIT CODE FOUND IN INIT.SRC)
*
*ENTRY BFMFCB1 ; FCB PAGE 1 ADDR
*ENTRY BFMFCB2 ; AND PAGE 2
*ENTRY FCBZPP
*ENTRY SISTER
*ENTRY PATHBUF
*ENTRY VCB
*ENTRY WORKSPC
*ENTRY PFIXPTR
*ENTRY BMAPAGE
*ENTRY BMBPAGE
*ENTRY FCBADDRH
*ENTRY BMAMADR
*ENTRY BMBMADR
*
*
*EXTRN LEVEL ; FILE LEVEL (LOW BYTE)
*EXTRN OPMSGRPLY ; OPERATOR MESSAGE
*EXTRN DATETIME ; THANKS TOM...
*EXTRN DMGR ; THANKS BOB...
*EXTRN REQBUF ; "
*EXTRN REQFXBUF ; "
*EXTRN GETBUFADR ; "
*EXTRN RELBUF ; "
*EXTRN BLKDLST ; "
*EXTRN SERR
*EXTRN BACKMASK
*
* ERRORS
*
*EXTRN SYSERR
*
*EXTRN BADPATH ; INVALID PATHNAME SYNTAX
*EXTRN FCBFULL ; FILE CONTROL BLOCK FULL
*EXTRN BADREFNUM ; INVALID REFNUM
*EXTRN PATHNOTFND ; PATHNAME NOT FOUND
*EXTRN VNFERR ; VOLUME NOT FOUND
*EXTRN FNFERR ; FILE NOT FOUND
*EXTRN DUPERR ; DUPLICATE FILE NAME ERROR
*EXTRN DUPVOL ; DUPLICATE VOLUME CAN'T BE LOGGED IN.
*EXTRN OVRERR ; NOT ENOUGH DISK SPACE FOR PREALLOCATION
*EXTRN DIRFULL ; DIRECTORY FULL ERROR
*EXTRN CPTERR ; FILE INCOMPATIBLE SOS VERSION
*EXTRN TYPERR ; NOT CURRENTLY SUPPORTED FILE TYPE
*EXTRN EOFERR ; POSITION ATTEMPTED BEYOND END OF FILE
*EXTRN POSNERR ; ILLEGAL POSITION (L.T. 0 OR G.T. $FFFFFF)
*EXTRN ACCSERR ; FILE ACCESS R/W REQUEST CONFLICTS WITH ATTRIBUTES.
*EXTRN BTSERR ; USER SUPPLIED BUFFER TOO SMALL
*EXTRN FILBUSY ; EITHER WRITE WAS REQUESTED OR WRITE ACCESS ALREADY ALLOCATED.
*EXTRN NOTSOS ; NOT A SOS DISKETTE
*EXTRN BADLSTCNT ; INVALID VALUE IN LIST PARAMETER
*EXTRN XDISKSW ; DISK SWITCHED
*EXTRN NOTBLKDEV ; NOT A BLOCK DEVICE
*EXTRN XNOWRITE ; DISK/MEDIA IS HARDWARE WRITE PROTECTED
*EXTRN XIOERROR ; INFORMATION ON BLOCK DEVICE NOT ACCESSABLE
*EXTRN DIRERR ; DIRECTORY ENTRY COUNT INCONSISTENT WITH ACTUAL ENTRIES
*EXTRN BITMAPADR ; BIT MAP DISK ADDRESS IMPOSSIBLE
*
* FATAL ERRORS
*
*EXTRN SYSDEATH
*
*EXTRN VCBERR ; VOLUME CONTROL BLOCK NOT USABLE
*EXTRN ALCERR ; ALLOCATION BLOCKS INVALID
*EXTRN TOOLONG ; PATHNAME BUFFER OVERFLOW
*PAGE

*
* CONSTANTS
*
DLIMIT .eq $2F ; DELIMITER IS CURRENTLY AN ASCII '/'
SEEDTYP .eq 1
SAPTYP .eq 2
TRETYP .eq 3
DIRTYP .eq $D
HEDTYP .eq $E
RDCMD .eq $0
WRTCMD .eq $1
RPTCMD .eq $9
STATCMD .eq $02 ; REQUEST				staTUS OF BLOCK DEVICE. (BIT 0 = WRITE PROTECTED)
STATSUB .eq $0
PRETIME .eq $20 ; COMMAND NEEDS CURRENT DATE/TIME				staMP
PREREF .eq $40 ; COMMAND REQUIRES FCB ADDRESS AND VERIFICATION
PREPATH .eq $80 ; COMMAND HAS PATHNAME TO PREPROCESS
SISTER .eq $1400
*
* VOLUME				staTUS CONSTANTS (BITS)
*
DSWITCH .eq $40 ; FOR DISK SWITCHED ERROR RECOVERY.
*
* FILE				staTUS CONSTANTS
*
DATALC .eq $1 ; DATA BLOCK NOT ALLOCATED.
IDXALC .eq $2 ; INDEX NOT ALLOCATED
TOPALC .eq $4 ; TOP INDEX NOT ALLOCATED
STPMOD .eq $8 ; STORAGE TYPE MODIFIED
USEMOD .eq $10 ; FILE USAGE MODIFIED
EOFMOD .eq $20 ; END OF FILE MODIFIED
DATMOD .eq $40 ; DATA BLOCK MODIFIED
IDXMOD .eq $80 ; INDEX BLOCK MODIFIED
FCBMOD .eq $80 ; HAS FCB/DIRECTORY BEEN MODIFIED? (FLUSH)
*
* FILE ATTRIBUTES CONSTANTS
*
READEN .eq $1 ; READ ENABLED
WRITEN .eq $2 ; WRITE ENABLED
NLINEN .eq $10 ; NEW LINE ENABLED
BKBITVAL .eq $20 ; FILE NEEDS BACKUP IF SET (BKBITFLG)
RENAMEN .eq $40 ; RENAME OK WHEN ON.
DSTROYEN .eq $80 ; DESTROY OK WHEN ON.
*PAGE
* HEADER INDEX CONSTANTS
*
HNLEN .eq $0 ; HEADER NAME LENGTH (OFFSET INTO HEADER)
*HNAME .eq $1 ; HEADER NAME
HPENAB .eq $10 ; PASSWORD ENABLE BYTE
HPASS .eq $11 ; ENCODED PASSWORD
HCRDT .eq $18 ; HEADER CREATION DATE
* HCRTM .eq $1A ; HEADER CREATION TIME
HVER .eq $1C ; SOS VERSION THAT CREATED DIRECTORY
HCMP .eq $1D ; BACKWARD COMPATIBLE WITH SOS VERSION
HATTR .eq $1E ; HEADER ATTRIBUTES- PROTECT ETC.
* HENTLN .eq $1F ; LENGTH OF EACH ENTRY
* HMENT .eq $20 ; MAXIMUM NUMBER OF ENTRIES/BLOCK
HCENT .eq $21 ; CURRENT NUMBER OF FILES IN DIRECTORY
HRBLK .eq $23 ; OWNER'S DIRECTORY ADDRESS
HRENT .eq $25 ; OWNER'S DIRECTORY ENTRY NUMBER
HRELN .eq $26 ; OWNER'S DIRECTORY ENTRY LENGTH
VBMAP .eq HRBLK
VTBLK .eq HRENT ; (USED FOR ROOT DIRECTORY ONLY)
*
* VOLUME CONTROL BLOCK INDEX CONSTANTS
*
VCBSIZE .eq $20 ; CURRENT VCB IS 32 BYTES PER ENTRY (VER 0)
VCBNML .eq 0 ; VOLUME NAME LENGTH BYTE
VCBNAM .eq 1 ; VOLUME NAME
VCBDEV .eq $10 ; VOLUME'S DEVICE
VCBSTAT .eq $11 ; VOLUME				staTUS. (80=FILES OPEN. 40=DISK SWITCHED.)
VCBTBLK .eq $12 ; TOTAL BLOCKS ON THIS VOLUME
VCBTFRE .eq $14 ; NUMBER OF UNUSED BLOCKS
VCBROOT .eq $16 ; ROOT DIRECTORY (DISK) ADDRESS
*VCBMORG .eq $18 ; MAP ORGANIZATION (NOT SUPPORTED BY V 0)
*VCBMBUF .eq $19 ; BIT MAP BUF NUM
VCBDMAP .eq $1A ; FIRST (DISK) ADDRESS OF BITMAP(S)
VCBCMAP .eq $1C ; RELATIVE ADDRESS OF BIT MAP WITH SPACE (ADD TO VCBDMAP)
*VCBMNUM .eq $1D ; RELATIVE BIT MAP CURRENTLY IN MEMORY
VCBOPNC .eq $1E ; CURRENT NUMBER OF OPEN FILES.

VCBSWAP .eq $1F ; $8X IF VOLUME SWAPPED; $00 IF UNSWAPPED WHERE X=LOW ORDER BYTE OF VCB
ADR/16
*
* FILE CONTROL BLOCK INDEX CONSTANTS
*
FCBREFN .eq 0 ; FILE REFERENCE NUMBER (POSITION SENSITIVE)
FCBDEVN .eq 1 ; DEVICE (NUMBER) ON WHICH FILE RESIDES
*FCBHEAD .eq 2 ; BLOCK ADDRESS OF FILE'S DIRECTORY HEADER
*FCBDIRB .eq 4 ; BLOCK ADDRESS OF FILE'S DIRECTORY
FCBENTN .eq 6 ; ENTRY NUMBER WITHIN DIRECTORY BLOCK
FCBSTYP .eq 7 ; STORAGE TYPE - SEED, SAPLING, TREE, ETC.
FCBSTAT .eq 8 ;				staTUS - INDEX/DATA/EOF/USAGE/TYPE MODIFIED.
FCBATTR .eq 9 ; ATTRIBUTES - READ/WRITE ENABLE, NEWLINE ENABLE.
FCBNEWL .eq $A ; NEW LINE TERMINATOR (ALL 8 BITS SIGNIFICANT).
FCBBUFN .eq $B ; BUFFER NUMBER
FCBFRST .eq $C ; FIRST BLOCK OF FILE
FCBIDXB .eq $E ; BLOCK ADDRESS OF INDEX (0 IF NO INDEX)
FCBDATB .eq $10 ; BLOCK ADDRESS OF DATA
FCBMARK .eq $12 ; CURRENT FILE MARKER.
FCBEOF .eq $15 ; LOGICAL END OF FILE.
FCBUSE .eq $18 ; ACTUAL NUMBER OF BLOCKS ALLOCATED TO THIS FILE.
FCBSWAP .eq $1A ; $8N = SWAPPED, $00 = UNSWAPPED VOLUME ("N" = VCB ENTRY NUMBER)
FCBLEVL .eq $1B ; LEVEL AT WHICH THIS FILE WAS OPENED
FCBDIRTY .eq $1C ; FCB MARKED AS MODIFIED
*PAGE
*
* ZERO PAGE STUFF
*
PAR .eq $A0
COMMAND .eq PAR
C.DNAMP .eq PAR+1
C.PATH .eq PAR+1
C.REFNUM .eq PAR+1
C.ISNEWL .eq PAR+2
C.OUTEOF .eq PAR+2
C.BASE .eq PAR+2
C.MRKPTR .eq PAR+2
C.OUTBUF .eq PAR+2
C.NWPATH .eq PAR+3
C.FILIST .eq PAR+3
C.NEWL .eq PAR+3
C.OUTVOL .eq PAR+3
C.OUTREF .eq PAR+3
C.XLIST .eq PAR+3
C.MAXPTH .eq PAR+3
C.MARK .eq PAR+3
C.NEWEOF .eq PAR+3
C.BYTES .eq PAR+4
C.FILSTLN .eq PAR+5
C.OUTBLK .eq PAR+5
C.OPLIST .eq PAR+5
C.XLEN .eq PAR+5
C.FILID .eq PAR+6
C.OUTCNT .eq PAR+6
C.OPLSTLN .eq PAR+7
C.AUXID .eq PAR+7
C.STOR .eq PAR+9
C.EOFLL .eq PAR+$A
C.EOFLH .eq PAR+$B
C.EOFHL .eq PAR+$C
DEBUPTR .eq PAR+$D ; NOTE SAME AS BELOW
C.EOFHH .eq PAR+$D
* C.SPARE .eq PAR+$E
*
DEVICE .eq $C0
DHPCMD .eq DEVICE
UNITNUM .eq DEVICE+1
DSTATREQ .eq DEVICE+2
DBUFPL .eq DEVICE+2
DBUFPH .eq DBUFPL+1
DSTATBFL .eq DEVICE+3 ; TO PASS BACK BUSY, WRITE PROTECT, READ PROTECT.
DSTATBFH .eq DSTATBFL+1
RQCNTL .eq DEVICE+4
RQCNTH .eq RQCNTL+1
BLOKNML .eq DEVICE+6
BLOKNMH .eq BLOKNML+1
BRDPTR .eq DEVICE+8 ; (AND 9)
*
DVNAMP .eq DEVICE+1 ; USED FOR 'VOLUME' TO CALL
DVDNUM .eq DEVICE+3 ; 'GET.DNUM' IN DEVICE MANAGER.
*

SISBPH .eq SISTER+DBUFPH
SISDSTAT .eq SISTER+DSTATBFH
SSBRDPH .eq SISTER+BRDPTR+1
*
*PAGE
*
* ZERO PAGE TEMPORARIES
*
ZTEMPS .eq $B0
PATHNML .eq ZTEMPS
PATHNMH .eq PATHNML+1
USRBUF .eq ZTEMPS
TPATH .eq ZTEMPS+2
WRKPATH .eq ZTEMPS+4
TINDX .eq ZTEMPS+2
DRBUFPL .eq ZTEMPS+4
DRBUFPH .eq DRBUFPL+1
VCBPTR .eq ZTEMPS+6
BMADR .eq ZTEMPS+8
FCBPTR .eq ZTEMPS+$A
DATPTR .eq ZTEMPS+$C
POSPTR .eq ZTEMPS+$E
*
MAXTEMPS .eq $F
SISTEMPS .eq SISTER+ZTEMPS
SSTIDXH .eq SISTER+TINDX+1
SISPATH .eq SISTER+C.PATH+1
SSNWPATH .eq SISTER+C.NWPATH+1
SISUSRBF .eq SISTER+USRBUF+1
SISOUTBF .eq SISTER+C.OUTBUF+1
SISTPATH .eq SISTER+TPATH+1
SISBMADR .eq SISTER+BMADR+1
SISFCBP .eq SISTER+FCBPTR+1
SISDATP .eq SISTER+DATPTR+1
SISPOSP .eq SISTER+POSPTR+1
*
*
* ADDRESSES
*
PATHBUF .eq $1000 ; NOTE: THIS IS $100 BYTES LONG.
VCB .eq $1100
GBUF .eq $1200 ; THRU $13FF
*
* INITIALIZATION EQUATES
*
BFMFCB1 .eq $1C ; FCB PAGE 1 ADDR
BFMFCB2 .eq $1D ; FCB PAGE 2 ADDR
BMAPAGE .eq <$B800 ; BIT MAP A ADDR
BMBPAGE .eq <$BA00 ; BIT MAP B ADDR
FCBZPP .eq FCBPTR
*
*
*
*PAGE
DSECT
ORG $0 ; (THE FOLLOWING DO NOT NEED TO BE ON ZERO PAGE. 7/16/80 JRH.)
DATBLKL DS 1
DATBLKH DS 1
IDXADRL DS 1 ; DISK ADDRESS OF INDEX BLOCK
IDXADRH DS 1
REQL DS 1
REQH DS 1
INDXBLK DS 1
LEVELS DS 1
TOTENT DS 1
ENTCNTL DS 1
ENTCNTH DS 1
CNTENT DS 1
NOFREE DS 1
BMCNT DS 1
SAPTR DS 1
TREPTR DS 1
TLINK DS 2
FLINK DS 2
PATHCNT DS 1
PFIXPTR DS 2
BMPTR DS 1
BASVAL DS 1
HALF DS 1
*
*

*PAGE
*
* BIT MAP INFO TABLES (A & B)
*
BMTABSZ .eq $6
BMTAB DS 1
BMBUFBNK DS 1
BMASTAT DS 1
BMADEV DS 1
BMAMADR DS 1
BMADADR DS 2
BMACMAP DS 1 ; SIMILAR TO VCBCMAP
BMBSTAT DS 1
BMBDEV DS 1
BMBMADR DS 1
DS 2 ; BMBDADR
DS 1 ; BMBCMAP
*
FCBADDRH DS 1 ; FILE CONTROL BLOCK'S BUFFER ADDRESS.
FCBANKNM DS 1 ; AND BANK (SISTER PAGE) BYTE.
TPOSLL DS 1
TPOSLH DS 1
TPOSHI DS 1
RWREQL DS 1
RWREQH DS 1
BULKCNT DS 1
NLCHAR DS 1
NPATHDEV DS 3 ; FOR NEW PATHNAME DEVICE AND DIRECTORY HEADER ADDRESS
IOACCESS DS 1 ; USED TO DETERMINE IF A CALL HAS BEEN MADE TO THE DISK DEVICE HANDLER
DEVNUM DS 1 ; CURRENT DEVICE TO BE ACCESSED.
TOTDEVS DS 1 ; USED FOR ACCESSING DRIVES IN NUMERIC ORDER
CMDTEMP DS 1 ; USED FOR TESTING REFNUM, TIME, AND DSKSWTCH (PRE)PROCESSING.
DATELO DS 1 ; DATE AND TIME MUST RESIDE ON ZERO PAGE.
DATEHI DS 1
TIMELO DS 1
TIMEHI DS 1
*
DUPLFLAG DS 1 ; USED FOR DIFFERENCE BETWEEN VNFERR AND DUPVOL BY SYNPATH
ZPGTEMP DS 1 ; A ONE-BYTE UNSTABLE TEMPORARY
VCBENTRY DS 1 ; POINTER TO CURRENT VCB ENTRY
*
DEND
*
CHN PATH,4,1

*************************************************************************
* END OF APPLE /// SOS 1.3 SOURCE CODE FILE: EQUATES
*************************************************************************



================================================================================================
FILE: "SOS.FEB01.1982.TEXT"
================================================================================================
*************************************************************************
* APPLE /// SOS 1.3 SOURCE CODE FILE: FEB01.1982
*************************************************************************
* ASSEMBLER: APPLE ][ 6502 ASSEMBLER from APPLE COMPUTER TOOLKIT

SL4:DR1:ASM SOSLDR.SRC,SOSLDR.OBJ,6,1
SL4:DR1:ASM INIT.SRC,INIT.OBJ,6,1
SL4:DR1:ASM SYSGLOB.SRC,SYSGLOB.OBJ,6,1
SL4:DR1:ASM OPRMSG.SRC,OPRMSG.OBJ,6,1
SL4:DR1:ASM BFM.INIT2.SRC,BFM.INIT2.OBJ,6,1
SL4:DR1:ASM IPL.SRC1,IPL.OBJ,6,1
SL4:DR1:ASM UMGR.SRC,UMGR.OBJ,6,1
SL4:DR2:ASM DISK3.SRC,DISK3.OBJ,6,1
SL4:DR2:ASM SYSERR.SRC,SYSERR.OBJ,6,1
SL4:DR2:ASM SCMGR.SRC,SCMGR.OBJ,6,1
SL4:DR2:ASM FMGR.SRC,FMGR.OBJ,6,1
SL4:DR2:ASM CFMGR.SRC,CFMGR.OBJ,6,1
SL4:DR2:ASM DEVMGR.SRC,DEVMGR.OBJ,6,1
SL4:DR2:ASM BUFMGR.SRC,BUFMGR.OBJ,6,1
SL4:DR2:ASM MEMMGR.A.SRC,MEMMGR.OBJ,6,1
END

*************************************************************************
* END OF APPLE /// SOS 1.3 SOURCE CODE FILE: FEB01.1982
*************************************************************************


================================================================================================
FILE: "SOS.FMGR.SRC.TEXT"
================================================================================================
*************************************************************************
* APPLE /// SOS 1.3 SOURCE CODE FILE: FMGR.SRC
*************************************************************************
* ASSEMBLER: APPLE ][ 6502 ASSEMBLER from APPLE COMPUTER TOOLKIT

*SBTL "SOS 1.1 FILE MANAGER"
*REL
					INCLUDE SOSORG,6,1,254
ORG ORGFMGR
ZZORG .eq *
*MSB OFF
*REP 60
* COPYRIGHT (C) APPLE COMPUTER INC. 1980
* ALL RIGHTS RESERVED
*REP 60
*
* FILE MANAGER (VERSION = 1.1O )
* (DATE = 8/04/81)
*
* THIS MODULE IS ENTERED FROM THE SYSTEM CALL MANAGER, AND
* IS RESPONSIBLE FOR SWITCHING TO EITHER THE BLOCK FILE
* MANAGER, OR THE CHARACTER FILE MANAGER.
*
*REP 60
*
*ENTRY FMGR
*ENTRY LEVEL
*
*EXTRN BFMGR
*EXTRN CFMGR
*EXTRN SYSERR
*EXTRN SERR
*EXTRN BADPATH
*EXTRN FNFERR
*EXTRN LVLERR
*
F.TPARMX .eq $A0 ; LOC OF FILE SYSTEM CALL PARMS
OPEN .eq $8
CLOSE .eq $C
SETLEVEL .eq $12
GETLEVEL .eq $13
F.REQCODE .eq F.TPARMX
F.LEVEL .eq F.TPARMX+$1
PATHNAME .eq F.TPARMX+$1
REFNUM .eq F.TPARMX+$1
PERIOD .eq $2E
LEVEL DFB $1
*PAGE
*REP 60
*
* FILE MANAGER
*
*REP 60
FMGR .eq *
*
					lda F.REQCODE
					cmp #OPEN
					bcc FMGR010
					beq FMGR020
					cmp #CLOSE
					bcc FMGR030
					beq FMGR040
					cmp #SETLEVEL
					beq SLEVEL
					cmp #GETLEVEL
					beq GLEVEL
*
FMGR010 JMP BFMGR ; EXIT
*
FMGR020 LDY #1
					lda (PATHNAME),Y
					cmp #PERIOD
					bne FMGR010
					jsr CFMGR
					bcc FMGR024
					lda SERR

					cmp #FNFERR
					beq FMGR026
FMGR024 RTS ; EXIT
*
FMGR026				lda #0
					sta SERR
					jmp BFMGR ; EXIT
*
FMGR030				lda REFNUM
FMGR031 BPL FMGR010
					jmp CFMGR ; EXIT
*
FMGR040				lda REFNUM
					bne FMGR031
					jsr BFMGR ; CLOSE (0)
					jmp CFMGR ; EXIT
*
SLEVEL				lda F.LEVEL
					beq LVL.ERR
					cmp #4
					bcs LVL.ERR
					sta LEVEL
					rts
LVL.ERR				lda #LVLERR
					jsr SYSERR
*
GLEVEL LDY #0
					lda LEVEL
					sta (F.LEVEL),Y
					rts
*
*LST ON
ZZEND .eq *
ZZLEN .eq ZZEND-ZZORG
IFNE ZZLEN-LENFMGR
FAIL 2,"SOSORG FILE IS INCORRECT FOR FMGR"
FIN

*************************************************************************
* END OF APPLE /// SOS 1.3 SOURCE CODE FILE: FMGR.SRC
*************************************************************************




================================================================================================
FILE: "SOS.FNDFIL.TEXT"
================================================================================================
*************************************************************************
* APPLE /// SOS 1.3 SOURCE CODE FILE: FNDFIL
*************************************************************************
* ASSEMBLER: APPLE ][ 6502 ASSEMBLER from APPLE COMPUTER TOOLKIT

*PAGE
*
*
FINDFILE				jsr LOOKFILE ; SEE IF FILE EXISTS
					bcs NOFIND ; BRANCH IF AN ERROR WAS ENCOUNTERED
MOVENTRY LDY H.ENTLN ; MOVE ENTIRE ENTRY INFO TO A SAFE AREA
MOVENT1				lda (DRBUFPL),Y
					sta DFIL+D.STOR,Y
					dey
					bpl MOVENT1
					lda #0 ; TO INDICATE ALL IS WELL
NOFIND RTS ; RETURN CONDITION CODES.
*PAGE
*
*
LOOKFILE				jsr PREPROOT ; FIND VOLUME AND SET UP OTHER BORING STUFF
					bcs FNDERR ; PASS BACK ANY ERROR ENCOUNTERED
					ldy #0 ; TEST TO SEE IF ONLY ROOT WAS SPECIFIED.
					lda (PATHNML),Y
					bne LOOKFIL0 ; BRANCH IF MORE THAN ROOT.
					lda #GBUF/256 ; OTHERWISE, REPORT A BADPATH ERROR
					sta DRBUFPH ; (BUT FIRST CREATE A PHANTOM ENTRY FOR OPEN)
					lda #4
					sta DRBUFPL
					ldy #D.AUXID ; FIRST MOVE IN ID, AND DATE STUFF.
PHANTM1				lda (DRBUFPL),Y
					sta DFIL,Y
					dey
					cpy #D.CREDT-1
					bne PHANTM1
PHANTM2				lda ROOTSTUF-D.FILID,Y
					sta DFIL,Y
					dey
					cpy #D.FILID-1
					bne PHANTM2
					lda #DIRTYP*$10 ; FAKE DIRECTORY FILE
					sta DFIL+D.STOR
					lda #BADPATH ; (CARRY IS SET)
					rts
*
ROOTSTUF DFB 0,2,0,4
DFB 0,0,8,0
*
LOOKFIL0				lda #0 ; RESET FREE ENTRY INDICATOR
					sta NOFREE
					clc ; INDICATE THAT THE DIRECTORY TO BE SEARCHED HAS HEADER IN THIS BLOCK
LOOKFIL1				lda #0 ; RESET ENTRY COUNTER
					sta TOTENT
					jsr LOOKNAM ; LOOK FOR NAME POINTED TO BY 'PATHNML'
					bcc NAMFOJMP ; BRANCH IF NAME WAS FOUND.
					lda ENTCNTL ; HAVE WE LOOKED AT ALL OF THE
					sbc TOTENT ; ENTRIES IN THIS DIRECTORY?
					bcc DCRENTH ; MAYBE, CHECK HI COUNT.
					bne LOOKFIL2 ; NO, READ NEXT DIRECTORY BLOCK
					cmp ENTCNTH ; HAS THE LAST ENTRY BEEN LOOKED AT (ACC=0)
					beq ERRFNF ; YES, GIVE 'FILE NOT FOUND' ERROR.
					bne LOOKFIL2 ; BRANCH ALWAYS.
DCRENTH DEC ENTCNTH ; SHOULD BE AT LEAST 1
					bpl LOOKFIL2 ; (THIS SHOULD BE BRANCH ALWAYS...)
ERRDIR				lda #DIRERR ; REPORT DIRECTORY MESSED UP.
FNDERR SEC ; INDICATE ERROR HAS BEEN ENCOUNTERED.
					rts
NAMFOJMP JMP NAMFOUND ; AVOID BRANCH OUT OF RANGE
*
*PAGE
LOOKFIL2				sta ENTCNTL ; KEEP RUNNING COUNT
					lda #GBUF/256 ; RESET INDIRECT POINTER
					sta DRBUFPH
					lda GBUF+2 ; GET LINK TO NEXT DIRECTORY BLOCK
					bne NXTDIR0 ; (IF THERE IS ONE)
					cmp GBUF+3 ; ARE BOTH ZERO, I.E. NO LINK?

					beq ERRDIR ; IF SO, THEN NOT ALL ENTRIES WERE ACCOUNTED FOR.
NXTDIR0				sta BLOKNML
					lda GBUF+3
					sta BLOKNMH
					jsr RDGBUF ; GO READ THE NEXT LINKED DIRECTORY IN.
					bcc LOOKFIL1 ; BRANCH IF NO ERROR.
					rts; RETURN ERROR (IN ACCUMULATOR).
TELFREEX JMP TELFREE
*
FNF0X JMP FNF0 ; AVOID BRANCH OUT OF RANGE
*
CFLAG DS 1 ; AM I CREATING?
TTSAVE DS 2 ; CURRENT BLOCK ADDR
BLOKSAVE DS 2 ; PARENT DIR ADDR
*
ERRFNF				lda NOFREE ; WAS ANY FREE ENTRY FOUND?
					bne FNF0X
					lda GBUF+2 ; TEST LINK
					bne TELFREEX
					cmp GBUF+3 ; IF BOTH ARE ZERO, THEN GIVE UP
					bne TELFREEX ; BRANCH IF NOT LAST DIR BLOCK
					lda CFLAG ; DOING A CREATE?
					beq FNF0X ; NO, SIMPLY REPORT NOT FOUND
*
* EXTEND THE DIRECTORY BY A BLOCK
*
					lda BLOKSAVE ; BUT NOT
					ora BLOKSAVE+1 ; IF A ROOT DIRECTORY!
					beq FNF0X ; FORU BLOCKS HARD CODED
					lda TTLINK ; FETCH CURRENT DIRECTORY
					sta TLINK ; ADDR (GBUF)
					lda TTLINK+1 ; AND ALLLOCATE A NEW
					sta TLINK+1 ; BY LINKING TO CURRENT
					jsr DIRWRT
					bcs FNF0 ; RATS! NO SPACE SAY "DIRFULL"
*
* SAVE CURRENT BLOCK ADDR
*
					lda TTLINK
					sta TTSAVE
					lda TTLINK+1
					sta TTSAVE+1
*
* FETCH DESCENDENT
*
					lda GBUF+2
					sta BLOKNML
					lda GBUF+3
					sta BLOKNMH
					jsr ZERGBUF ; INIT THE NEW DIR BLOCK
*
* AND INSERT BACK POINTER
* TO "CURRENT BLOCK"
*
					lda TTSAVE
					sta GBUF
					lda TTSAVE+1
					sta GBUF+1
					jsr WRTGBUF
					bcs ERTS
*
* UPDATE DIR'S HEADER IN PARENT
*
					lda BLOKSAVE
					sta BLOKNML ; PREPARE TO READ PARENT
					ldx BLOKSAVE+1
					stx BLOKNMH
					jsr RDGBUF ; FETCH PARENT
					ldy #D.USAGE ; BUMP BLOCKS USED BY HEADER
					lda (DEBUPTR),Y
					clc
					adc #0 ; BY JUST ONE BLOCK
					sta (DEBUPTR),Y
					iny
					lda (DEBUPTR),Y ; TWO BYTE BLOCKS USED
					adc #0
					sta (DEBUPTR),Y
					ldy #D.EOF+1 ; INCREASE EOF BY $200
					lda (DEBUPTR),Y
					clc
					adc #2

					sta (DEBUPTR),Y
					iny
					lda (DEBUPTR),Y
					adc #0
					sta (DEBUPTR),Y
					jsr WRTGBUF ; REWRITE PARENT DIR BLOCK
					lda TTSAVE+1 ; REFETCH CURRENT DIR BLOCK
					sta BLOKNMH
					lda TTSAVE
					sta BLOKNML
					jsr RDGBUF ; BACK FROM THE SHADOWS AGAIN
					jmp ERRFNF ; VOILA! WE HAVE EXTENDED THE DIRECTORY!
*
TELFREE				sta D.ENTBLK
					lda GBUF+3
					sta D.ENTBLK+1 ; ASSUME FIRST ENTRY OF NEXT BLOCK
					lda #1 ; IS FREE FOR USE.
					sta D.ENTNUM
					sta NOFREE ; MARK D.ENTNUM AS VALID (FOR CREATE)
FNF0 LDY #0 ; TEST FOR 'FILE NOT FOUND' VERSUS 'PATH NOT FOUND'
					lda (PATHNML),Y
					tay
					iny
					lda (PATHNML),Y ; IF NON-ZERO THEN 'PATH NOT FOUND'
ERRPATH1 SEC ; IN EITHER CASE, INDICATE ERROR.
					beq FNF1
					lda #PATHNOTFND ; REPORT NO SUCH PATH.
ERTS RTS
FNF1				lda #FNFERR ; REPORT FILE NOT FOUND.
					rts
*PAGE
*
NAMFOUND				lda (PATHNML),Y ; (Y=0)
					clc
					adc PATHNML ; TEST FOR LAST NAME IN PATH
					tay ; IF ZERO, THEN THAT WAS LAST NAME
					clc ; TO INDICATE SUCCESS
					lda PATHBUF,Y
					beq FILFOUND
*NOW CHANGE THE PATHNAME POINTER TO POINT AT THE NEXT NAME IN THE PATH
					sty PATHNML
					lda DRBUFPL ; SAVE PARENTS
					sta DEBUPTR ; ENTRY POINTER
					lda DRBUFPH
					sta DEBUPTR+1 ; IN CASE ENTRY ON PAGE 2
					lda BLOKNML ; ADDRESS (DIR EXTEND)
					sta BLOKSAVE
					lda BLOKNMH
					sta BLOKSAVE+1
					ldy #D.STOR ; BE SURE THIS IS A DIRECTORY ENTRY
					lda (DRBUFPL),Y ; HIGH NIBBLE WILL TELL
					and #$F0
					cmp #DIRTYP*16 ; IS IT A SUB-DIRECTORY?
					bne ERRPATH1 ; REPORT THE USER'S MISTAKE
					ldy #D.FRST ; GET ADDRESS OF FIRST SUB-DIRECTORY BLOCK
					lda (DRBUFPL),Y
					sta BLOKNML ; (NO CHECKING IS DONE HERE FOR A VALID
					iny ; BLOCK NUMBER... )
					sta D.HEAD ; SAVE AS FILE'S HEADER BLOCK TOO.
					lda (DRBUFPL),Y
					sta BLOKNMH
					sta D.HEAD+1
					jsr RDGBUF ; READ SUB-DIRECTORY INTO GBUF
					bcs FNDERR1 ; RETURN IMMEDIATELY ANY ERROR ENCOUNTERED.
					lda GBUF+HCENT+4 ; GET THE NUMBER OF FILES
					sta ENTCNTL ; CONTAINED IN THIS DIRECTORY
					lda GBUF+HCENT+5
					sta ENTCNTH
					lda GBUF+HCMP+4 ; TEST BACKWARD COMPATIBILITY
					beq MOVHEAD
ERRCOMP				lda #CPTERR ; TELL THEM THIS DIRECTORY IS NOT COMPATABLE
NONAME .eq *
FNDERR1 SEC
					rts
MOVHEAD				jsr MOVHED0 ; MOVE INFO ABOUT THIS DIRECTORY
					jmp LOOKFIL0 ; DO NEXT LOCAL PATHNAME
*
MOVHED0				ldx #$A ; MOVE INFO ABOUT THIS DIRECTORY
MOVHED1				lda GBUF+HCRDT+4,X
					sta H.CREDT,X
					dex

					bpl MOVHED1
					rts
*
*PAGE
*
*
FILFOUND .eq *
ENTADR				lda H.MAXENT ; FIGURE OUT WHICH IS ENTRY NUMBER THIS IS.
					clc
					sbc CNTENT ; MAX ENTRIES - COUNT ENTRIES + 1 = ENTRY NUMBER
					adc #0 ; (CARRY IS/WAS SET)
					sta D.ENTNUM
					lda BLOKNML
					sta D.ENTBLK
					lda BLOKNMH ; AND INDICATE BLOCK NUMBER OF THIS DIRECTORY.
					sta D.ENTBLK+1
					clc
					rts
*
LOOKNAM				lda H.MAXENT ; RESET COUNT OF FILES PER BLOCK
					sta CNTENT
					lda #GBUF/256
					sta DRBUFPH
					lda #4
LOKNAM1				sta DRBUFPL ; RESET INDIRECT POINTER TO GBUF
					bcs LOKNAM2 ; BRANCH IF THIS BLOCK CONTAINS A HEADER
					ldy #D.STOR
					lda (DRBUFPL),Y ; GET LENGTH OF NAME IN DIRECTORY
					bne ISNAME ; BRANCH IF THERE IS A NAME.
					lda NOFREE ; TEST TO SEE IF A FREE ENTRY HAS BEEN DECLARED.
					bne LOKNAM2 ; YES BUMP TO NEXT ENTRY
					jsr ENTADR ; SET ADDRESS FOR CURRENT ENTRY
					inc NOFREE ; INDICATE A FREE SPOT HAS BEEN FOUND
					bne LOKNAM2 ; BRANCH ALWAYS.
*
ISNAME AND #$F ; STRIP TYPE (THIS IS CHECKED BY 'FILFOUND')
					inc TOTENT ; (BUMP COUNT OF VALID FILES FOUND)
					cmp (PATHNML),Y ; ARE BOTH NAMES OF THE SAME LENGTH?
					bne LOKNAM2 ; NO, BUMP TO NEXT ENTRY
					tay
CMPNAME				lda (DRBUFPL),Y ; COMPARE NAMES LETTER BY LETTER
					cmp (PATHNML),Y
					bne LOKNAM2
					dey ; HAVE ALL LETTERS BEEN COMPARED?
					bne CMPNAME ; NO, CONTINUE..
					clc ; BY GOLLY, WE GOT US A MATCH!
					rts
*
LOKNAM2 DEC CNTENT ; HAVE WE CHECKED ALL POSSIBLE ENTRIES IN THIS BLOCK?
					beq NONAME ; YES, GIVE UP.
					lda H.ENTLN ; ADD ENTRY LENGTH TO CURRENT POINTER
					clc
					adc DRBUFPL
					bcc LOKNAM1 ; BRANCH IF WE'RE STILL IN THE FIRST PAGE.
					inc DRBUFPH ; LOOK ON SECOND PAGE
					clc ; CARRY SHOULD ALWAYS BE CLEAR BEFORE LOOKING AT NEXT.
					bcc LOKNAM1 ; BRANCH ALWAYS...
*PAGE
*
*
PREPROOT				jsr FINDVOL ; FIND CORRECT VOLUME AND DEVICE NUMBER
					bcc ROOT1 ; BRANCH IF IT WAS FOUND.
ROOT0				jsr LOOKVOL ; OTHERWISE LOOK ON ALL DEVICES.
					bcs SRITZ ; CAN'T FIND IT.
ROOT1				lda #0 ; ZERO OUT DIRECTORY TEMPS
					ldy #42 ; (DECIMAL)
CLRDSP				sta D.DEV,Y
					dey
					bpl CLRDSP
					ldy #VCBDEV ; SET UP DEVICE NUMBER
					lda (VCBPTR),Y
					sta DEVNUM
					sta D.DEV ; FOR FUTURE REFERENCE
					iny
					lda (VCBPTR),Y ; GET CURRENT				staTUS OF THIS VOLUME
					sta V.STATUS
					ldy #VCBROOT ; GET BLOCK ADDRESS OF ROOT DIRECTORY TOO.
					lda (VCBPTR),Y
					sta BLOKNML
					sta D.HEAD ; PRESERVE AS HEADER
					iny

					lda (VCBPTR),Y
					sta BLOKNMH
					sta D.HEAD+1
					jsr RDGBUF ; GO READ IN ROOT
					bcc ROOT2 ; BRANCH IF NO ERROR
					pha; SAVE ERROR CODE
					ldy #VCBSTAT ; CHECK THIS BUGGER FOR AN OPEN FILE.
					lda (VCBPTR),Y
					asl A ; (SHIFT OPEN				staTUS INTO CARRY)
					pla ; GET ERROR CODE AGAIN
					bcs ROOTERR ; BRANCH IF ERROR NEEDS TO BE REPORTED
					bne ROOT0 ; OTHERWISE, LOOK ELSEWHERE (BRANCH ALWAYS).
*
ROOT2				jsr CHKROOT ; VERIFY ROOT NAME
					beq ROOT3 ; BRANCH IF MATCHED.
					ldy #VCBSTAT ; TEST FOR OPEN FILES ON THIS VOLUME BEFORE
					lda (VCBPTR),Y ; LOOKING FOR IT ELSEWHERE.
					bpl ROOT0
					jsr USRREQ ; REQUEST USER MOUNT VOLUME
					bcc ROOT1 ; USER SAID S/HE DID-- CHECK IT
					lda #VNFERR ; REPORT VOLUME NOT FOUND ERR IF REFUSE TO INSERT
SRITZ RTS
*
*PAGE
ROOT3 LDY #$F ; (NOTE: X CONTAINS THE LENGTH OF THE ROOT NAME)
ROOTINFO				lda GBUF+HCRDT+3,Y ; SAVE HEADER INFO.
					sta V.STATUS,Y
					dey
					bne ROOTINFO ; LOOP TIL ALL 15 BYTES MOVED
					lda H.FCNT
					sta ENTCNTL
					lda H.FCNT+1
					sta ENTCNTH
					txa ; NOW THAT ROOT IS IDENTIFIED, ADJUST
					clc ; PATH NAME POINTER TO NEXT NAME IN THE PATH
					adc PATHNML
					sta PATHNML
					clc ; INDICATE NO ERROR
ROOTERR RTS
*
*
CHKROOT LDY #0 ; GET LENGTH OF NAME
					lda (PATHNML),Y
					tay
					tax; SAVE IN X FOR LATTER ADJUSTMENT TO PATH POINTER
					eor GBUF+4
					and #$F ; DOES PATHNAME HAVE SAME LENGTH AS DIRECTORY NAME?
					bne NOTROOT ; BRANCH IF NOT
CKROOT1				lda (PATHNML),Y ; COMPARE CHARACTER BY CHARACTER
					cmp GBUF+4,Y
					bne NOTROOT
					dey
					bne CKROOT1 ; LOOP UNTIL ALL CHARACTERS MATCH
NOTROOT RTS
*
*PAGE
FINDVOL				lda #VCB/256 ; SEARCH VCB FOR VOLUME NAME
					sta VCBPTR+1
					lda #0
					sta D.DEV
					sta VCBPTR
FNDVOL1 PHA ; SAVE LAST SEARCH POSITION
					tax
					ldy #0 ; (INDEX TO PATHNAME POINTER)
					lda VCB,X ; GET LENGTH OF VOLUME NAME TO COMPARE
					beq NXTVCB ; BRANCH IF VCB ENTRY IS EMPTY
					cmp (PATHNML),Y ; ARE NAMES OF SAME LENGTH?
					bne NXTVCB ; NO, INDEX NEXT VCB
					clc ; SCAN NAME BACKWARDS
					tay
					txa
					adc VCB,X
					tax; NOW BOTH INDEXES POINT TO LAST CHARACTER OF THE NAMES TO COMPARE
VOLNAM				lda (PATHNML),Y
					cmp VCB,X
					bne NXTVCB
					dex
					dey
					bne VOLNAM ; CHECK ALL CHARACTERS
					pla ; SINCE A MATCH IS FOUND
					sta VCBPTR ; SET UP INDEX TO VCB ENTRY

					tax
					lda VCB+VCBSWAP,X ; BRANCH IF
					beq FOUNDVOL ; VOLUME NOT SWAPPED
					jsr SWAPIN ; IF USER REALLY WANTS IT, THEN BRING IN IF SWAPPED
					bcc FOUNDVOL ; BRANCH IF SUCCESS
					lda #XIOERROR ; USER REFUSES TO MOUNT
					rts
FOUNDVOL CLC ; INDICATE VOLUME FOUND
					rts
*
NXTVCB PLA ; GET CURRENT INDEX AGAIN.
					clc
					adc #VCBSIZE ; VCB ENTRY LENGTH.
					bcc FNDVOL1 ; BRANCH IF THER IS ANOTHER TO CHECK
					rts; RETURN WITH CARRY SET TO SHOW FAILURE.
*PAGE
*
*
LOOKVOL				ldx #12 ; (1) COUNT+(12)DEVICE LIST
LOOKVOL1				lda BLKDLST,X ; EXTRN
					sta SCRTCH,X ; MY CHANGEABLE COPY
					dex
					bpl LOOKVOL1 ; WORK BACKWARDS SO
					sta TOTDEVS ; ENTRY ZERO IS TOTAL DEVICES LISTED
					inx ; MAKE XREG = ZERO
LOKDEV1 INX
					stx SCRTCH
					lda SCRTCH,X
					cmp D.DEV
					beq NXTDEV ; DON'T LOOK AGAIN ON A DRIVE THAT HAS BEEN CHECKED
					sta DEVNUM ; CHECK FOR DEVICE ALREADY LOGGED IN A VCB
					jsr DEVVCB ; (CARRY CLEAR IF IT'S THERE)
					bcc LOKVOL1
					lda #0 ; FIND A FREE VCB TO LOG THIS GUY IN
ENTVCB TAX ; INDEX TO NEXT VCB ENTRY
					lda VCB,X
					beq FREEVCB ; FOUND A FREE SPOT.
					txa ; NOW INDEX TO NEXT, AND KEEP LOOKIN
					clc
					adc #VCBSIZE ; (EACH VCB ENTRY IS 32 BYTES)
					bcc ENTVCB ; BRANCH IF MORE TO FIND
					lda #0
ENTVCB2				.eq *; SEE IF WE CAN REPLACE A DEVICE
					tax
					lda VCB+VCBSTAT,X ; VCB HAS FILES OPEN?
					beq FREEVCB ; NO, USE IT!
					txa
					clc
					adc #VCBSIZE ; SEARCH NEXT VCB ENTRY
					bcc ENTVCB2
					rts; FAILED TO FIND A FREE VCB ENTRY
*
CHKVLOG LDY #0 ; MAKE SURE VOLUME WAS ACTUALLY LOGGED IN
					lda (VCBPTR),Y
					bne FOUNDVOL ; AH, MADE IT...
					lda #DUPVOL ; WELL, NOT QUITE, THIS VOLUME CAN'T BE LOGGED
					clc
					rts
*PAGE
*
FREEVCB STX VCBPTR ; NOW THIS IS THE POINTER TO A FREE VCB
					lda #2 ; ROOT DIRECTORIES ALWAYS AT BLOCK 2
					ldx #0
					beq GETROOT ; BRANCH ALWAYS
LOKVOL1 LDY #VCBSTAT ; MAKE SURE NO FILES ARE ACTIVE ON
					lda (VCBPTR),Y ; THE VOLUME BEFORE LOGGING IT IN.
					bmi SNSWIT ; BRANCH IF FILES ACTIVE
					ldy #VCBROOT+1 ; GET ADDRESS OF ROOT DIRECTORY
					lda (VCBPTR),Y ; HIGH FIRST.
					tax
					dey ; THEN LOW.
					lda (VCBPTR),Y
GETROOT				jsr GETROT0
					bcc LOKVOL2 ; BRANCH IF SUCCESSFULLY READ.
					lda #0 ; OTHERWISE, TAKE THIS DEVICE OUT OF VCB
					tay
					sta (VCBPTR),Y ; (VOLUME 'OFF LINE')
					beq NXTDEV ; BRANCH ALWAYS
*
LOKVOL2				jsr LOGVCB ; GO UPDATE VCB TO INCLUDE CURRENT VOLUME INFO
					bcs NXTDEV ; IF NOT A SOS DISKETTE, SKIP TO NEXT DEVICE

					jsr CHKROOT ; GO COMPARE TO SEE IF WE FOUND WHAT WE'RE
					beq CHKVLOG ; LOOKING FOR...
*
NXTDEV				ldx SCRTCH ; LOOK AT OTHER DEVICES?
					cpx TOTDEVS
					bcc LOKDEV1 ; YES.
					lda #VNFERR ; REPORT VOLUME NOT FOUND.
					rts
*
SNSWIT				.eq *; SENSE DSWITCH
					ldy #VCBDEV
					lda (VCBPTR),Y
					sta DEVNUM ; MAKE SURE DEVICE NUMBER IS CURRENT
					jsr TWRPROT1 ; USES DEVNUM
					lda DSWGLOB ; DISK SWITCH GLOBAL
					beq NXTDEV ; BRANCH IF NO DISK SWITCH
					jsr VERFYVOL ; COMPARES VCBPTR VS. DEVNUM CONTENTS
					bcc NXTDEV ; BRANCH IF DISK HAS NOT BEEN SWITCHED
					jsr CHKROOT ; COMPARES PATHNML VS. GBUF
					bne NXTDEV ; IGNORE IF NOT WHAT WE ARE LOOKING FOR
					ldx #0 ; LOOK FOR FREE
					jsr SNSWIT1
					bcs NXTDEV ; ANY ERRORS LOGGING IN THE NEW VOLUME
					jmp CHKVLOG ; MAKE SURE THE NEW VOLUME IS LOGGED
SNSWIT1				lda VCB,X ; VCB ENTRY
					beq SNSWIT2 ; BRANCH IF FOUND
					txa
					clc
					adc #VCBSIZE ; LOOK AT NEXT VCB AREA
					tax
					bcc SNSWIT1
					rts; CAN'T BE LOGGED IN!
SNSWIT2				lda #0
					sta DUPLFLAG ; TURN OFF DUPLICATE VOLUME FLAG
					stx VCBPTR
					jsr LOGVCB1 ; PARTIALLY LOG IN THE NEW VOLUME
					bcs NONSOS ; CS MEANS NONSOS ERROR
					lda DUPLFLAG ; WAS IT A DUPLICATE VOLUME?
					bne SNSWIT6 ; BRANCH IF YES
					ldy #VCBSWAP ; BY MAKING SWAP BYTE NON ZERO
					lda #1
					sta (VCBPTR),Y ; SO SWAPOUT WON'T AFFECT
					lda DEVNUM ; A REG PASSES DEVNUM TO SWAPOUT
					jsr SWAPOUT ; OLD ACTIVE MOUNT MUST BE SWAPPED
					bcc SNSWIT3
					lda #XIOERROR ; USER REFUSED TO REPLACE OLD VOLUME
					rts
SNSWIT3 LDY #VCBSWAP ; NOW LOG IN THE NEW ALL THE WAY
					lda #0
					sta (VCBPTR),Y
SNSWIT4				jsr VERFYVOL ; DON'T BOTHER TO ASK IF NEW VOLUME IS ALREADY MOUNTED
					bcc SNSWIT5 ; BRANCH IF NEW VOLUME ON LINE
					jsr USRREQ ; ASK USER TO REMOUNT NEW VOLUME
					bcc SNSWIT4 ; USER SAYS THEY DID: CHECK IT OUT
					lda #VNFERR
SNSWIT5 RTS
SNSWIT6				lda #DUPVOL
					clc
					rts
*PAGE
*
NONSOS				lda #NOTSOS ; TELL EM IT'S NOT A SOS DISK (COULD BE PASCAL)
					rts; CARRY SHOULD ALREADY BE SET
*
*
DEVVCB				lda #0 ; SCAN VCB FOR DEVICE SPECIFIED IN 'DEVNUM'
DVCB1 TAX ; FIRST TEST FOR VALID VCB.
					lda VCB,X
					beq DVCB2
					lda VCB+VCBSWAP,X ; SWAPPED VOLUMES DON'T COUNT
					bne DVCB2 ; AS LOGGED IN
					lda VCB+VCBDEV,X ; GET DEVICE NUMBER
					cmp DEVNUM ; TEST AGAINST REQUESTED DEVICE
					beq FOUNDEV ; YES, SET UP A POINTER TO IT
DVCB2				txa ; BUMP TO NEXT VCB
					clc
					adc #VCBSIZE
					bcc DVCB1 ; BRANCH IF MORE TO LOOK AT.
					rts; RETURN CARRY SET TO INDICATE NOT FOUND
*
TSTDUPVOL			ldx VCBPTR ; PRESERVE CURRENT ADDR OF FREE VCB

					lda #0 ; LOOK FOR A CURRENTLY LOGGED ON VOLUME OF THE SAME NAME.
TSDUPV1				sta VCBPTR
					jsr CMPVCB
					bcs TSDUPV2 ; BRANCH IF NO MATCH.
					ldy #VCBSTAT ; TEST FOR ANY OPEN FILES.
					lda (VCBPTR),Y
					bmi FOUNDDUP ; TELL THE SUCKER HE CAN'T LOOK AT THIS VOLUME!
					lda #0 ; TAKE DUPLICATE OFF LINE IF NO OPEN FILES.
					tay
					sta (VCBPTR),Y
					beq NODUPVOL ; RETURN THAT ALL IS OK TO LOG IN NEW.
TSDUPV2				lda VCBPTR
					clc
					adc #VCBSIZE ; BUMP TO NEXT ENTRY.
					bcc TSDUPV1
NODUPVOL .eq *
FOUNDEV CLC
FNDDUP1 STX VCBPTR
					rts
*
FOUNDDUP				sta DUPLFLAG ; A DUPLICATE HAS BEEN DETECTED.
					clc ; INDICATE ERROR
					lda VCBPTR ; SAVE ADDRESS OF DUPLICATE
					sta VCBENTRY
					bcs FNDDUP1 ; BRANCH ALWAYS TAKEN
*PAGE
*
*
LOGVCB LDY #VCBNML ; IS THIS A PREVIOUSLY LOGGED IN VOLUME
					lda (VCBPTR),Y ; (ACC=0?)
					beq LOGVCB1 ; NO, GO AHEAD AND PREPARE VCB.
					jsr CMPVCB ; DOES VCB MATCH VOLUME READ?
					bcc VCBLOGD ; YES, DON'T DISTURB IT.
LOGVCB1				lda #0 ; ZERO OUT VCB ENTRY
					ldy #VCBSIZE-1
ZERVCB				sta (VCBPTR),Y
					dey
					bpl ZERVCB
					jsr TSTSOS ; MAKE SURE IT'S A SOS DISKETTE.
					bcs VCBLOGD ; IF NOT, RETURN CARRY SET.
					jsr TSTDUPVOL ; FIND OUT IF A DUPLICATE WITH OPEN FILES ALREADY EXISTS
					bcs NOTLOG0
					lda GBUF+4 ; MOVE VOLUME NAME TO VCB
					and #$F ; STRIP ROOT MARKER
					tay
					pha
MOVOLNM				lda GBUF+4,Y
					sta (VCBPTR),Y
					dey
					bne MOVOLNM
					pla ; GET LENGTH AGAIN
					sta (VCBPTR),Y ; SAVE THAT TOO.
					ldy #VCBDEV ; SAVE DEVICE NUMBER ALSO.
					lda DEVNUM
					sta (VCBPTR),Y
					jsr CLEARBMS ; MARKS THIS DEVICES OLD BITMAPS AS INVALID (A REG PASSED)
					lda GBUF+VTBLK+4 ; AND TOTOL NUMBER OF BLOCKS ON THIS UNIT,
					ldy #VCBTBLK
					sta (VCBPTR),Y
					lda GBUF+VTBLK+5
					iny
					sta (VCBPTR),Y
					ldy #VCBROOT
					lda BLOKNML ; AND ADDRESS OF ROOT DIRECTORY
					sta (VCBPTR),Y
					iny
					lda BLOKNMH
					sta (VCBPTR),Y
					ldy #VCBDMAP
					lda GBUF+VBMAP+4 ; AND LASTLY, THE ADDRESS
					sta (VCBPTR),Y ; OF THE FIRST BITMAP
					lda GBUF+VBMAP+5
					iny
					sta (VCBPTR),Y
					clc ; INDICATE THAT IT WAS LOGGED IF POSIBLE.
VCBLOGD RTS
NOTLOG0 JMP NOTLOG1
*PAGE
CMPVCB				lda GBUF+4 ; COMPARE VOLUME NAME IN VCB
					and #$F
					ldy #VCBNML ; WITH NAME IN DIRECTORY

					cmp (VCBPTR),Y ; ARE THEY SAME LENGTH
					bne NOTSAME
					tay
VCBCMP1				lda GBUF+4,Y
					cmp (VCBPTR),Y
					bne NOTSAME
					dey
					bne VCBCMP1
					clc ; INDICATE MATCH.
					rts
*
VERFYVOL			ldx #0 ; READ IN ROOT DIRECTORY HEADER.
					lda #2
					jsr GETROT0
					bcs NOVRFY1 ; PASS BACK WHATEVER OTHER ERROR OCCURS.
					jsr CMPVCB ; TEST ROOT WITH VOLUME NAME IN VCB.
					bcc NOVRFY ; BRANCH IF ROOT MATCHES VCB
					lda #0 ; OTHERWISE, PASS BACK FOREIGN VOLUME ERROR (SOS OR UCSD)
NOVRFY RTS ; RETURN RESULTS IN CARRY.
NOVRFY1				lda #VNFERR ; NOTHING IN DRIVE
					rts
*
GETROT0				sta BLOKNML
					stx BLOKNMH ; STORE ADDRESS AND READ IN ROOT
					jsr RDGBUF
					bcc RETROT2 ; BRANCH IF SUCCESSFULLY READ.
NOTSAME .eq *
					clc ; INDICATE ERROR
RETROT2 RTS
*
NOTLOG1				ldx VCBPTR ; LOAD THE VCB ADDRESS
					lda VCBENTRY ; OF THE DUPLICATE VOLUME
					sta VCBPTR
					stx VCBENTRY ; AND SAVE THE FREE VCB SPACE ADDR
					ldy #VCBDEV ; IS DUPLICATE ON SAME DEVICE?
					lda DEVNUM
					cmp (VCBPTR),Y
					bne NOTLOG2 ; BRANCH IF NOT
					jsr SWAPIN ; SWAP IN IF NECESSARY
					lda #0
					sta DUPLFLAG ; NO MORE DUPLICATE VOLUME				staTUS
					lda VCBPTR ; MAKE CHKROOT WORK IN A MOMENT
					sta PATHNML ; THIS IS INCREDIBLY GROSS
; BUT IS A RESULT OF MAKING VOLUME A SPECIAL
; CASE OF SEARCHING ALL DEVICES FOR
; A KNOWN VOLUME
					clc
					rts
NOTLOG2				lda VCBENTRY ; REACH HERE IF REAL DUPLICATE VOLUME
					sta VCBPTR ; RESOTRE FREE VCB PTR
					clc
					rts; DUPLICATE VOLUME PRETENDS TO BE NO ERROR
*PAGE
*
TSFRBLK LDY #VCBTFRE+1
					lda (VCBPTR),Y ; FIND OUT IF ENOUGH FREE BLOCKS
					dey ; ARE AVAILABLE TO ACCOMODATE REQEST.
					ora (VCBPTR),Y ; BUT FIRST FIND OUT IF WE GOT A PROPER COUNT FOR THIS VOLUME.
					bne CMPFREB ; BRANCH IF COUNT IS NON-ZERO
					dey ; IF ZERO, THEN COUNT MUST BE TAKEN
					lda (VCBPTR),Y ; GET HIGH TOTAL BLKS
					tax; SAVE IT
					dey ; GET LOW
					lda (VCBPTR),Y ; TOTAL BLKS
					bne TSFR01
					dex ; ADJUST FOR BITMAP BLOCK BOUNDARY
TSFR01				txa
					lsr A ; DIVIDE BY 16. THE RESULT IS THE NUMBER
					lsr A ; OF BIT MAPS TO BE SEARCHED.
					lsr A
					lsr A
					sta BMCNT ; SAVE IT.
					lda #0 ;				staRT COUNT AT ZERO.
					sta SCRTCH
					sta SCRTCH+1
					lda #$FF ; MARK 'FIRST FREE' TEMP AS UNKNOWN
					sta NOFREE
					ldy #VCBDEV ; MAKE SURE BIT MAP IS UP TO DATE
					lda (VCBPTR),Y ; GET DEVICE NUMBER
					tax; PASS TO 'UPBMAP' IN X
					jsr UPBMAP ; (NOTHING HAPPENS IF IT DON'T HAFTA.)

					bcs TFBERR ; BRANCH IF WE GOT TROUBLE,
					ldy #VCBDMAP ; GET ADDRESS OF FIRST BIT MAP.
					lda (VCBPTR),Y
					sta BLOKNML
					iny ; (FOR HIGH ADDRESS)
					lda (VCBPTR),Y
					sta BLOKNMH
BMAPRD				jsr RDGBUF ; USE G(ENERAL)BUFF(ER) FOR TEMPORARY
					bcs TFBERR ; SPACE TO COUNT FREE BLOCKS (BITS)
					jsr COUNT ; GO COUNT EM
					dec BMCNT ; WAS THAT THE LAST BIT MAP?
					bmi CHGVCB ; IF SO, GO CHANGE FCB TO AVOID DOING THIS AGAIN!
					inc BLOKNML ; NOTE: THE ORGANIZATION OF THE BIT MAPS
					bne BMAPRD ; ARE CONTIGUOUS FOR SOS VERSION 0
					inc BLOKNMH ; IF SOME OTHER ORGANIZATION IS IMPLEMENTED, THIS CODE
					jmp BMAPRD ; MUST BE CHANGED!
*PAGE
*
CHGVCB LDY #VCBCMAP ; MARK WHICH BLOCK HAD FIRST FREE SPACE
					lda NOFREE
					bmi DSKFULL ; BRANCH IF NO FREE SPACE WAS FOUND.
					sta (VCBPTR),Y
					ldy #VCBTFRE+1 ; UPDATE THE FREE COUNT.
					lda SCRTCH+1 ; GET HIGH COUNT BYTE
					sta (VCBPTR),Y ; UPDATE VOLUME CONTROL BLOCK.
					dey
					lda SCRTCH
					sta (VCBPTR),Y ; AND LOW BYTE TOO...
CMPFREB				lda (VCBPTR),Y ; COMPARE TOTAL AVAILABLE
					clc
					sbc REQL ; FREE BLOCKS ON THIS VOLUME.
					iny
					lda (VCBPTR),Y
					sbc REQH
					bcc DSKFULL
					clc
					rts
DSKFULL				lda #OVRERR
					clc
TFBERR RTS
*PAGE
*
COUNT LDY #0 ; BEGIN AT THE BEGINNING.
FRCONT				lda GBUF,Y ; GET BIT PATTERN
					beq FRCNT1 ; DON'T BOTHER COUNTING NOTHIN'
					jsr CNTFREE
FRCNT1				lda GBUF+$100,Y ; DO BOTH PAGES WITH SAME LOOP
					beq FRCNT2
					jsr CNTFREE
FRCNT2 INY
					bne FRCONT ; LOOP TILL ALL 512 BYTES COUNTED
					bit NOFREE ; HAS FIRST BLOCK WITH FREE SPACE BEEN FOUND YET?
					bpl FRCNT3 ; BRANCH IF IT HAS.
					lda SCRTCH ; TEST TO SEE IF ANY BLOCKS WERE COUNTED
					ora SCRTCH+1
					beq FRCNT3 ; BRANCH IF NONE COUNTED.
					ldy #VCBTBLK+1
					lda (VCBPTR),Y ; SHOW THIS MAP IS FIRST WITH FREE SPACE
					clc ; CORRECT FOR EXACT MULTIPLES OF $1000
					sbc #$01
					lsr A
					lsr A
					lsr A
					lsr A
					clc ; SUBTRACT COUNTDOWN FROM TOTAL BIT MAPS
					sbc BMCNT
					sta NOFREE
FRCNT3 RTS
*
CNTFREE ASL A ; COUNT THE NUMBER OF BITS IN THIS BYTE.
					bcc CFREE1
					inc SCRTCH
					bne CFREE1
					inc SCRTCH+1
CFREE1 TAX
					bne CNTFREE ; LOOP UNTIL ALL BITS COUNTED.
					rts

CHN ALLOC,4,1

*************************************************************************

* END OF APPLE /// SOS 1.3 SOURCE CODE FILE: FNDFIL
*************************************************************************




================================================================================================
FILE: "SOS.INIT.SRC.TEXT"
================================================================================================
*************************************************************************
* APPLE /// SOS 1.3 SOURCE CODE FILE: INIT.SRC
*************************************************************************
* ASSEMBLER: APPLE ][ 6502 ASSEMBLER from APPLE COMPUTER TOOLKIT

*SBTL "SOS 1.1 INITIALIZATION"
*REL
					INCLUDE SOSORG,6,1,254
ORG ORGINIT
ZZORG .eq *
*MSB OFF
*REP 100
* COPYRIGHT (C) APPLE COMPUTER INC. 1981
* ALL RIGHTS RESERVED
*REP 100
*
* SOS INIT MODULE (VERSION = 1.1O )
* (DATE = 8/04/81)
*
*REP 100
*
*ENTRY INT.INIT
*ENTRY EVQ.INIT
*ENTRY CLK.INIT
*ENTRY MMGR.INIT
*ENTRY BMGR.INIT
*ENTRY DMGR.INIT
*ENTRY CFMGR.INIT
*ENTRY BFM.INIT
*
* EXTERNAL SUBROUTINES & DATA
*
*EXTRN SXPAGE
*EXTRN SYSDEATH
*
* INTERRUPT SYSTEM INITIALIZATION
*
*EXTRN COLDSTRT
*EXTRN IRQ.RCVR
*EXTRN NMI.RCVR
*EXTRN NMIFLAG
*EXTRN SIRTABLE
*EXTRN SIRTBLSIZ
*EXTRN ZPGSTACK
*EXTRN ZPGSTART
*
* EVENT QUEUE INITIALIZATION
*
*EXTRN EV.QUEUE
*EXTRN EVQ.LEN
*EXTRN EVQ.CNT
*EXTRN EVQ.SIZ
*EXTRN EVQ.FREE
*EXTRN EVQ.LINK
*
* CLOCK INITIALIZATION
*
*EXTRN PCLOCK
*
* CHARACTER FILE MANAGER INITIALIZATION
*
*EXTRN CFCB.MAX
*EXTRN CFCB.DEV
*
* DEVICE MANAGER INITIALIZATION
*
*EXTRN DMGR
*EXTRN MAX.DNUM
*
* BUFFER MANAGER INITIALIZATION
*
*EXTRN BUF.CNT
*EXTRN PGCT.T
*EXTRN XBYTE.T
*EXTRN BUFREF
*

* MEMORY MANAGER INITIALIZATION
*
*EXTRN ST.CNT
*EXTRN ST.ENTRY
*EXTRN ST.FREE
*EXTRN ST.FLINK
*EXTRN VRT.LIM
*EXTRN MEMSIZE
*EXTRN MEM2SML
*
* BLOCK FILE MANAGER INITIALIZATION
*
*EXTRN FCBZPP
*EXTRN PATHBUF
*EXTRN VCB
*EXTRN WORKSPC
*EXTRN PFIXPTR
*EXTRN FCBADDRH
*EXTRN BMAPAGE
*EXTRN BMBPAGE
*EXTRN BMAMADR
*EXTRN BMBMADR
*EXTRN BFMFCB1
*EXTRN BFMFCB2
*
* CONSTANT DECLARATIONS
*
TRUE .eq $80
FALSE .eq $00
					bitON6 .eq $40
					bitON7 .eq $80
*
* SYSTEM CONTROL REGISTERS
*
E.REG .eq $FFDF ;ENVIRONMENT REGISTER
Z.REG .eq $FFD0 ;ZERO PAGE REGISTER
*SBTL "INTERRUPT SYSTEM INITIALIZATION"
*
* 6522 REGISTERS
*
D.DDRB .eq $FFD2
D.DDRA .eq $FFD3
D.ACR .eq $FFDB
D.PCR .eq $FFDC
D.IFR .eq $FFDD
D.IER .eq $FFDE
E.IORB .eq $FFE0
E.DDRB .eq $FFE2
E.DDRA .eq $FFE3
E.ACR .eq $FFEB
E.PCR .eq $FFEC
E.IFR .eq $FFED
E.IER .eq $FFEE
ACIASTAT .eq $C0F1
*
*
*REP 60
*
* THIS SUBROUTINE INITIALIZES THE INTERRUPT SYSTEM.
* ALL HARDWARE INTERRUPTS ARE MASKED AND THE
* INTERRUPT ALLOCATION TABLE IS CLEARED.
*
*REP 60
*
*
INT.INIT .eq *
					sei ;DISABLE INTERRUPTS
					lda #>ZPGSTART ;SET UP MIH
					sta ZPGSTACK ; ZERO PAGE				staCK POINTER
*
					lda E.REG ;SELECT $C000 I/O SPACE
					pha; AND SET 1 MHZ
					ora #BITON7+BITON6
					sta E.REG
*
					sta ACIASTAT ;RESET ACIA
*
					lda #$FF ;SET UP 6522 D
					sta D.DDRB
					sta D.DDRA
					lda #$00

					sta D.ACR
					lda #$76
					sta D.PCR
					lda #$7F
					sta D.IFR
					sta D.IER
					lda #$82
					sta D.IER
*
					lda #$3F ;SET UP 6522 E
					sta E.DDRB
					lda #$0F
					sta E.DDRA
					lda #$00
					sta E.ACR
					lda #$63
					sta E.PCR
					lda #$7F
					sta E.IFR
					sta E.IER
*
					lda #$FF
					sta E.IORB ;SOUND PORT
					bit $C0D8 ;DISABLE GRAPHICS SCROLL
					bit $C0DA ;DISABLE CHARACTER DOWNLOAD
					bit $C0DC ;DISABLE ENSEL
					bit $C0DE ;SET ENSIO FOR INPUT
*
					pla ;RESTORE E REGISTER
					sta E.REG
*
					lda #FALSE
					sta NMIFLAG ;CLEAR NMI WAIT FLAG
					ldy #>SIRTBLSIZ-1
INTI010				sta SIRTABLE,Y ; ALLOCATION TABLE
					dey
					bpl INTI010
					lda #TRUE
					sta SIRTABLE+$0A ;LOCK DOWN ANY SLOT SIR
*
					ldx #$05
INTI020				lda RAMVECT,X ;SET UP VECTORS
					sta $FFFA,X ; AT $FFFA - $FFFF
					lda RAMJMPS,X ;SET UP JMP INSTRUCTIONS
					sta $FFCA,X ; AT $FFCA - $FFCF
					dex
					bpl INTI020
					rts
*
RAMVECT DW NMI.RCVR
DW COLDSTRT
DW IRQ.RCVR
RAMJMPS JMP NMI.RCVR
					jmp IRQ.RCVR
*SBTL "EVENT QUEUE INITIALIZATION"
*REP 60
*
* THIS SUBROUTINE INITIALIZES THE EVENT QUEUE. ALL ENTRIES
* ARE CLEARED AND LINKED INTO THE FREE LIST. THE ACTIVE
* LIST IS EMPTY.
*
*REP 60
*
*
EVQ.INIT .eq *
*
* CLEAR ALL ENTRIES
*
					ldy #>EVQ.LEN
					lda #0
EVQI010				sta EV.QUEUE-1,Y
					dey
					bne EVQI010
*
* SET UP FREE LIST
*
					ldx #>EVQ.CNT-2
					lda #>EVQ.SIZ
					sta EVQ.FREE
EVQI020 TAY
					clc

					adc #>EVQ.SIZ
					sta EVQ.LINK,Y
					dex
					bne EVQI020
					rts
*SBTL "PSEUDO CLOCK INITIALIZATION"
*REP 60
*
* THIS SUBROUTINE INITIALIZES THE PSEUDO CLOCK. IF THE
* RAM BEHIND THE "D" 6522 HAS THE PROPER CHECKSUM, IT
* IS USED TO INITIALIZE THE PSEUDO CLOCK. OTHERWISE,
* THE PSEUDO CLOCK IS SET TO ZERO.
*
* (ADDED 23 OCT 81)
* BOTH THE CLOCK AND PSEUDO CLOCK ARE
* ARE NOW INITIALIZED
*
*REP 60
*
PCLK .eq $F0
CKSUM .eq $F2
CLKICR .eq $11 ; CLOCK INTERRUPT CONTROL REG
CLKSTBY .eq $16 ; CLOCK				staNDBY INTERRUPT
CLOCK .eq $C070
*
CLK.INIT .eq *
					lda #$D0
					sta PCLK ;POINT (PCLK) TO 8F:FFD0
					lda #$FF
					sta PCLK+1
					lda #$8F
					sta SXPAGE+PCLK+1
					lda #$A5
					sta CKSUM ;INITIALIZE CHECKSUM
*
					ldy #$00
CLK010				lda (PCLK),Y ;COPY SAVED CLOCK DATA
					sta PCLOCK,Y ; TO PSEUDO CLOCK
					eor CKSUM
					sta CKSUM ;UPDATE CHECKSUM
					iny
					cpy #$0A
					bcc CLK010
*
					cmp (PCLK),Y ;TEST CHECKSUM
					beq CLK030
*
					lda #$00
CLK020 DEY
					sta PCLOCK,Y ;ZERO PSEUDO CLOCK
					bne CLK020
CLK030				lda E.REG
					pha
					ora #$80 ; SET 1 MHZ
					sta E.REG
					lda #$00
					ldy Z.REG
					ldx #CLKICR
					stx Z.REG
					sta CLOCK ; DISABLE CLOCK INTERRUPTS
					ldx #CLKSTBY
					stx Z.REG
					sta CLOCK ; DISABLE				staNDBY INTERRUPT
					sty Z.REG
					pla
					sta E.REG
					rts
*SBTL "CHARACTER FILE MANAGER INITIALIZATION"
*REP 60
*
* CHAR FILE MANAGER INITIALIZATION ROUTINE
*
* CFMGR.INIT INITIALIZES ALL ENTRIES IN THE CFCB TABLE TO
* THE "FREE"				staTE.
*
*REP 60
*
CFMGR.INIT .eq *
					lda #$80
					ldx #CFCB.MAX-1
CFINIT010				sta CFCB.DEV,X

					dex
					bpl CFINIT010
					rts
*SBTL "DEVICE MANAGER INITIALIZATION"
*REP 60
*
* DEVICE MANAGER INITIALIZATION ROUTINE
*
* INITIALIZES THE SYSTEM DEVICE TABLE (SDT) BY WALKING THE
* DEVICE INFORMATION BLOCK (DIB) LINKS. CALLED BY SYSLDR.
*
*REP 60
*
D.TPARMX .eq $C0
REQCODE .eq D.TPARMX+$00
DNUM .eq D.TPARMX+$01
DNUM.TEMP DS 1
*
*
DMGR.INIT .eq *
					ldx MAX.DNUM
					inc MAX.DNUM ; MAX.DNUM:=MAX DEV NUMBER IN SYSTEM+1
					stx DNUM.TEMP
DMI110				lda #8 ; INITIALIZE ALL DEVICES IN SYSTEM (D.INIT)
					sta REQCODE
					lda DNUM.TEMP
					sta DNUM
					jsr DMGR
					dec DNUM.TEMP
					bne DMI110
					rts; NORMAL EXIT
*SBTL "BUFFER MANAGER INITIALIZATION"
*REP 60
*
* BMGR.INIT
*
* THIS ROUTINE INITIALIZES THE BUFFER TABLE'S ENTRIES TO "FREE".
* CALLED DURING SYSTEM BOOT.
*
*REP 60
*
BMGR.INIT .eq *
					lda #$FF ; USED WHEN FINDING LOWEST BUFFER IN TBL (BUFCOMPACT)
					sta XBYTE.T
*
					ldx #BUF.CNT-1
					lda #$80
BUFI010				sta PGCT.T,X ;SET ALL ENTRIES "FREE"
					dex
					bne BUFI010
*
					stx BUFREF ;ZERO COUNT BYTE IN BUFFER REFERENCE TABLE
*
					clc
					rts
*SBTL "MEMORY MANAGER INITIALIZATION"
*REP 60
*
* MMGR.INIT
*
* THIS ROUTINE INITIALIZES THE MEMORY MANAGER'S SEGMENT TABLE
* TO FREE ENTRIES, AND DETERMINES THE MEMORY SIZE OF THE
* MACHINE (96K,128K,160K,192K,224K,256K,..,512K IN 32K STEPS).
*
*REP 60
*
MMGR.INIT .eq *
*
* INIT SEGMENT TABLE
*
					lda #0
					sta ST.ENTRY
					lda #$81
					sta ST.FREE
*
					ldy #ST.CNT-1
					lda #$80 ; SET LAST LINK TO NULL
					sta ST.FLINK,Y
MEMI010 TYA
					ora #$80
					dey

					sta ST.FLINK,Y
					bne MEMI010
*
* COMPUTE VIRTUAL LIMIT FROM MEMORY SIZE
* VRT.LIM := NUMBER OF PAGES IN BANK SWITCHED MEMORY - 1
* := (MEMSIZ-2)*64 - 1
* := (MEMSIZ-4)*64 + 127
*
					clc
					lda MEMSIZE
					sbc #4
					bcc MEMI.ERR
					lsr A
					lsr A
					sta VRT.LIM+1
					lda #$FE
					ror A
					sta VRT.LIM
					clc
					rts; NORMAL EXIT
*
MEMI.ERR				lda #MEM2SML ; FATAL ERR - MEM < 64K
					jsr SYSDEATH
*PAGE
*REP 60
*
* BLOCK FILE MANAGER INITIALIZATION
*
*REP 60
*
SISTER .eq $1400 ;BFM XPAGE
BFM.INIT .eq *
					lda #BFMFCB1 ; ADDRESS OF PAGE 1 OF FCB
					sta >FCBZPP+1
					lda #BFMFCB2 ; AND PAGE 2
					sta >FCBZPP+3
					lda #0
					sta >FCBZPP ; FCB PAGE ALIGNED
					sta >FCBZPP+2
					sta SISTER+FCBZPP+1 ; PREPARE PART OF EXTEND BYTE
					sta SISTER+FCBZPP+3
					tay ; MAKE ZERO INTO INDEX
CLRBUFFS .eq *
					sta PATHBUF,Y ; PATHNAME BUFFER PAGE
					sta VCB,Y ; VOLUME CONTROL BLOCK PAGE
					sta (>FCBZPP),Y ; BOTH FILE CONTROL BLOCK PAGES
					sta (>FCBZPP+2),Y
					iny
					bne CLRBUFFS
					ldx #$3F ; SIZE OF MY ZERO PAGE STUFF
CLRZWRK				sta 0,X ; ZERO PAGE ZEROED
					sta WORKSPC,X
					dex
					bpl CLRZWRK
					lda #<PATHBUF
					sta PFIXPTR+1
					lda #BFMFCB1
					sta FCBADDRH
					lda #BMAPAGE ; BIT MAP A PAGE NUMBER
					sta BMAMADR
					lda #BMBPAGE ; BIT MAP B PAGE NUMBER
					sta BMBMADR
					clc
					rts
*
*LST ON
ZZEND .eq *
ZZLEN .eq ZZEND-ZZORG
IFNE ZZLEN-LENINIT
FAIL 2,"SOSORG FILE IS INCORRECT FOR INIT"
FIN

*************************************************************************
* END OF APPLE /// SOS 1.3 SOURCE CODE FILE: INIT.SRC
*************************************************************************



================================================================================================
FILE: "SOS.IPL.SRC1.TEXT"
================================================================================================
*************************************************************************
* APPLE /// SOS 1.3 SOURCE CODE FILE: IPL.SRC1
*************************************************************************
* ASSEMBLER: APPLE ][ 6502 ASSEMBLER from APPLE COMPUTER TOOLKIT

*SBTL "SOS 1.1 INTRPTS. & PROC. LAUNCH"
*REL
					INCLUDE SOSORG,6,1,254
ORG ORGIPL
ZZORG .eq *
*MSB OFF
*REP 60
* COPYRIGHT (C) APPLE COMPUTER INC. 1980
* ALL RIGHTS RESERVED
*REP 60
*
* THIS MODULE IS RESPONSIBLE FOR FIELDING ALL INTERRUPTS
* AND RELAUNCHING THE INTERRUPTED CODE AFTER THE INTERRUPTS
* HAVE BEEN PROCESSED. THE MAJOR FUNCTIONAL AREAS ARE:
*
* GENERAL INTERRUPT RECEIVER
* NMI INTERRUPT RECEIVER
* DISPATCHER
* INTERRUPT ALLOCATION & DEALLOCATION
* EVENT QUEUE MANAGER
* TABLE INITIALIZATION
*
*REP 60
*
* SUBROUTINE ENTRY POINTS
*
*ENTRY IRQ.RCVR ;GENERAL INTERRUPT RECEIVER
*ENTRY NMI.RCVR ;NON-MASKABLE INTRPT RCVR
*ENTRY DISPATCH ;DISPATCHER
*ENTRY ALLOCSIR ;SIR ALLOCATION
*ENTRY DEALCSIR ;SIR DEALLOCATION
*ENTRY SELC800 ;SELECT I/O EXPANSION ROM
*ENTRY NMIDSBL ;DISABLE NMI
*ENTRY NMIENBL ;ENABLE NMI
*ENTRY NMIDBUG ;NMI DEBUG ENTRY
*ENTRY NMICONT ;NMI DEBUG CONTINUATION
*ENTRY QUEEVENT ;QUEUE AN EVENT
*
* EXTERNAL SUBROUTINES & DATA
*
*EXTRN SCMGR
*EXTRN CHKBUF
*
* SYSTEM DEATH ERRORS
*
*EXTRN SYSDEATH
*EXTRN BADBRK
*EXTRN BADINT1
*EXTRN BADINT2
*EXTRN NMIHANG
*EXTRN EVQOVFL
*EXTRN STKOVFL
*
* LINKAGE DATA FOR INITIALIZATION ROUTINES
*
*ENTRY EV.QUEUE
*ENTRY EVQ.CNT
*ENTRY EVQ.SIZ
*ENTRY EVQ.LEN
*ENTRY EVQ.FREE
*ENTRY EVQ.LINK
*ENTRY SIRTABLE
*ENTRY SIRTBLSIZ
*ENTRY ZPGSTACK
*ENTRY ZPGSTART
*
* SYSGLOB DATA
*
*EXTRN SERR
*EXTRN CEVPRI ;CALLER'S EVENT PRIORITY
*EXTRN SYSBANK ;SYSTEM BANK

*EXTRN KYBDNMI
*EXTRN NMISPSV
*EXTRN NMIFLAG ;NMI PENDING FLAG
*EXTRN SCRNMODE ;CURRENT SCREEN MODE
*EXTRN SIRTEMP ;FOR ALLOCSIR & DEALCSIR
*EXTRN SIRARGSIZ
*EXTRN IRQCNTR ;FLASE IRQ COUNTER
*EXTRN NMICNTR ;TWO BYTE COUNTER
*EXTRN QEVTEMP
*EXTRN QEV.THIS
*EXTRN QEV.LAST
*EXTRN BACKMASK
*
* CONSTANT DECLARATIONS
*
FALSE .eq $00
					bitON0 .eq $01
					bitON1 .eq $02
					bitON2 .eq $04
					bitON4 .eq $10
					bitON5 .eq $20
					bitON6 .eq $40
					bitON7 .eq $80
					bitOFF3 .eq $F7
					bitOFF4 .eq $EF
					bitOFF5 .eq $DF
					bitOFF6 .eq $BF
					bitOFF7 .eq $7F
BACKBIT .eq $20 ; BACKUP BIT MASK
*
* SYSTEM CONTROL REGISTERS
*
B.REG .eq $FFEF ;BANK REGISTER
E.REG .eq $FFDF ;ENVIRONMENT REGISTER
Z.REG .eq $FFD0 ;ZERO PAGE REGISTER
*
* 6522 REGISTERS
*
D.IFR .eq $FFDD
D.IER .eq $FFDE
E.IORB .eq $FFE0
E.IFR .eq $FFED
E.IER .eq $FFEE
E.IORA .eq $FFEF
*PAGE
*
* REGISTER PRESERVATION EQUATES
* FOR USE DURING INTERRUPT PROCESSING
*
A.SAVE .eq $103
S.SAVE .eq $104
SP.SAVE .eq $1FF
E.SAVE .eq $1FE
Z.SAVE .eq $1FD
B.SAVE .eq $1FC
EXPNSLOT DFB $00 ;CURRENT I/O EXPANSION SLOT
*
*				staTUS LOCATIONS FOR INTERRUPT POLLING
*
ACIASTAT .eq $C0F1
ANYSLOT DFB BITON1
SLOT1 .eq $C065
SLOT2 .eq $C064
SLOT3 DFB BITON5
SLOT4 DFB BITON4
*
* INTERRUPT ZERO PAGE STORAGE & EQUATES
*
SIRARGS .eq $F9 ;AND $FA
QEVARGS .eq $FB ;AND $FC
IRQADDR .eq $FD ;AND $FE
ZPGSP .eq $FF
ZPGSTART .eq $F8
ZPGSTOP .eq $28
ZPGSPACE .eq $20
ZPGSTACK DFB ZPGSTART
*
* SYSTEM INTERNAL RESOURCE
* TABLE STORAGE AND EQUATES
*
SIRTBLSIZ .eq $18

SIRTABLE DS SIRTBLSIZ
SIRADR.L DS SIRTBLSIZ
NMIADR.L DS 1 ;MUST PRECEED SIRADR.H
SIRADR.H DS SIRTBLSIZ
SIRADR.B DS SIRTBLSIZ
*
* EVENT QUEUE STORAGE AND EQUATES
*
EVQ.SIZ .eq 6 ;ENTRY SIZE
EVQ.CNT .eq $07 ;ENTRY COUNT
EVQ.LEN .eq $2A ;(EVQ.SIZ*EVQ.CNT)
EV.QUEUE DS EVQ.LEN
EVQ.FREE .eq EV.QUEUE+2 ;FIRST FREE ENTRY INDEX
EVQ.LINK .eq EV.QUEUE+0 ;NEXT ACTIVE ENTRY INDEX
EVQ.PRI .eq EV.QUEUE+1 ;EVENT PRIORITY
EVQ.ID .eq EV.QUEUE+2 ;EVENT IDENTIFICATION
EVQ.ADRL .eq EV.QUEUE+3 ;EVENT ADDRESS: LOW BYTE
EVQ.ADRH .eq EV.QUEUE+4 ;EVENT ADDRESS: HIGH BYTE
EVQ.BANK .eq EV.QUEUE+5 ;EVENT ADDRESS: BANK
*SBTL "GENERAL INTERRUPT RECEIVER"
*REP 60
*
* THIS IS THE GENERAL INTERRUPT RECEIVER. WHEN AN
* INTERRUPT OCCURS, THE CPU PASSES CONTROL TO THE GIR
* THROUGH THE IRQ VECTOR. THE GIR IS RESPONSIBLE FOR
* SAVING THE CURRENT ENVIRONMENT, SETTING UP THE SOS
* ENVIRONMENT, AND CALLING THE APPROPRIATE CODE MODULE.
* IF THE INTERRUPT WAS CAUSED BY A BRK, THE GIR CALLS
* THE SYSTEM CALL MANAGER. OTHERWISE, THE GIR POLLS THE
* I/O DEVICES AND CALLS THE APPROPRIATE MASTER INTERRUPT
* HANDLER. WHEN THE SCM OR MIH RETURNS, THE GIR PASSES
* CONTROL TO THE DISPATCHER.
*
*REP 60
*
IRQ.RCVR .eq *
*
* SAVE CPU REGISTERS A, X, & Y ON CURRENT				staCK
*
					pha
					txa
					pha
					tya
					pha
*
* CHECK FOR				staCK OVERFLOW AND
* SAVE INTERRUPTED				staTUS IN Y REGISTER.
*
TSX
					cpx #$FA
					bcc GIR005
					lda #>STKOVFL
					jsr SYSDEATH
GIR005 LDY S.SAVE,X
*
* SET UP INTERRUPT ENVIRONMENT:
* BINARY ARITHMETIC, 2 MHZ, I/O ENABLED,
* RAM WRITE ENABLED, PRIMARY				staCK,
* AND $F000 RAM SELECTED. PRESERVE
* USER				staTE OF SCREEN AND RESET LOCK.
*
CLD
					lda E.REG
					tax
					and #BITON5+BITON4
					ora #BITON6+BITON2
					sta E.REG
*
* IF NOT ALREADY ON PRIMARY				staCK, SAVE USER'S				staCK
* POINTER AND SET UP SOS				staCK POINTER.
*
					txa
					and #BITON2
					bne GIR010
					txa
TSX
					stx SP.SAVE
					ldx #>E.SAVE
TXS
					tax
*

* SAVE E, Z, B, & I/O EXPANSION SLOT ON SOS				staCK
* IF BRK THEN CALL SCMGR ELSE POLL I/O DEVICES
*
GIR010				txa
					pha
					lda Z.REG
					pha
					lda B.REG
					pha
					lda EXPNSLOT
					pha
					bit $CFFF
					bit $C020 ;RESET I/O SPACE
					lda #$00
					sta EXPNSLOT
					tya
					and #BITON4
					beq POLL.IO
*
* CALL SYSTEM CALL MANAGER; ON RETURN, PUT ERROR CODE IN
* USER'S A REGISTER AND SET RETURN				staTUS, THEN DISPATCH.
*
TSX ;CHECK FOR
					cpx #>B.SAVE-2 ; REENTRANT
					beq GIR020 ; SYSTEM CALL
					lda #>BADBRK
					jsr SYSDEATH
GIR020				lda E.REG ;SELECT $C000 RAM
					and #BITOFF6
					sta E.REG
CLI ;ENABLE INTERRUPTS
					jsr SCMGR ;CALL THE SYSTEM CALL MGR
					lda #BACKBIT ; GET THE MASK
					sta BACKMASK ; SET IT IN SYSGLOB
					jsr CHKBUF
					sei
					ldx SP.SAVE
					lda Z.SAVE
					eor #BITON0 ;SET ZERO PAGE TO
					sta Z.REG ; CALLER'S				staCK
					lda SERR
					sta >A.SAVE,X
					php
					lda >S.SAVE,X
					and #$7D
					sta >S.SAVE,X
					pla
					and #$82
					ora >S.SAVE,X
					sta >S.SAVE,X
					jmp DISPATCH
*PAGE
*
* SET INTERRUPT ZERO PAGE AND SOS BANK
* THEN POLL I/O DEVICES
*
POLL.IO BIT E.IORA ;VERIFY THAT 'IRQ IS LOW
					bpl PIO006
					inc IRQCNTR ;BUMP FALSE IRQ COUNTER
					bne PIO004
					inc IRQCNTR+1
PIO004 JMP DISPATCH
PIO006				lda #0 ;SET INTERRUPT ZERO PAGE
					sta Z.REG
					lda E.REG
					ora #BITON7 ;FORCE 1 MHZ FOR
					sta E.REG ; READING ACIA				staTUS
					and #BITOFF7
					ldx #$01
					ldy ACIASTAT ;ANY INTERRUPT ON ACIA?
					sta E.REG
					bmi PIO070
					lda E.IFR ;ANY INTERRUPT ON E-6522?
					bpl PIO020 ; NO
					and E.IER
					ldy #7
					ldx #$02
PIO010 LSR A ;CHECK FLAG BITS
					bcs PIO070
					inx
					dey

					bne PIO010
					beq PIO035
PIO020				lda D.IFR ;ANY INTERRUPT ON D-6522?
					bpl PIO035
					and D.IER
					bit ANYSLOT ;ANY SLOT INTERRUPT?
					bne PIO040 ; YES
					ldy #7
					ldx #$09
PIO030 LSR A ;CHECK FLAG BITS
					bcs PIO070
					inx
					dey
					bne PIO030
PIO035				ldx #$10 ;INTERRUPT NOT FOUND
					bne PIO050
PIO040				ldx #$11
					bit SLOT1 ;SLOT 1?
					bpl PIO070
					inx
					bit SLOT2 ;SLOT 2?
					bpl PIO070
					lda E.IORA
					inx
					bit SLOT3 ;SLOT 3?
					beq PIO070
					inx
					bit SLOT4 ;SLOT 4?
					beq PIO070
					ldx #$0A
*
* BAD INTERRUPT -- SYSTEM DEATH
*
PIO050				lda #>BADINT1 ;INTERRUPT NOT FOUND
					jsr SYSDEATH
PIO060				lda #>BADINT2 ;BAD ZERO PAGE ALLOCATION
					jsr SYSDEATH
*
* INTERRUPTING DEVICE FOUND
* ALLOCATE ZERO PAGE AND CALL MASTER INTERRUPT HANDLER
*
* NOTE:
* SINCE READING THE ACIA'S				staTUS REGISTER RESETS THE
* DSR AND DCD BITS, THE				staTUS READ BY THE POLLING
* ROUTINE MUST BE PASSED TO THE INTERRUPT HANDLER;
* THE Y REGISTER HAS BEEN SELECTED FOR THIS PURPOSE.
* THE CURRENT IMPLEMENTATION DOES NOT USE Y IN CALLING
* THE INTERRUPT HANDLER. IF SUBSEQUENT REVISIONS
* NEED TO USE Y, THE				staTUS MUST BE PRESERVED AND
* RESTORED BEFORE CALLING THE INTERRUPT HANDLER.
*
CALLMIH JMP (IRQADDR)
*
PIO070				lda SIRTABLE,X ;INTERRUPT ALLOCATED?
					bpl PIO050 ; NO
					lda SIRADR.L,X ;GET INTERRUPT ADDRESS
					sta IRQADDR
					ora SIRADR.H,X ;CHECK FOR ADDRESS = $00
					beq PIO050 ; BAD ADDRESS
					lda SIRADR.H,X
					sta IRQADDR+1
					lda SIRADR.B,X
					sta B.REG
					lda ZPGSTACK ;ALLOCATE MIH ZERO PAGE
					cmp #ZPGSTOP+ZPGSPACE
					bcc PIO060 ;TOO MANY NESTED INTERRUPTS
					sbc #ZPGSPACE
					sta ZPGSTACK
					sta ZPGSP
					tax
					jsr CALLMIH ;CALL INTERRUPT HANDLER
					sei
					lda #$00
					sta Z.REG
					clc
					lda ZPGSTACK ;DEALLOCATE MIH ZERO PAGE
					adc #ZPGSPACE
					sta ZPGSTACK
					sta ZPGSP
					lda #BITON1
					sta D.IFR ;CLEAR ANY SLOT INTERRUPT

					jmp DISPATCH
*SBTL "NON-MASKABLE INTERRUPT RECEIVER"
*REP 60
*
* THIS IS THE NON-MASKABLE INTERRUPT RECEIVER. WHEN AN
* NMI OCCURS, THE CPU PASSES CONTROL TO THE NMI RECEIVER
* THROUGH THE NMI VECTOR. THE OPERATION OF THE NMI
* RECEIVER IS ESSENTIALLY THE SAME AS THE GIR EXCEPT
* THAT IT IS NOT CONCERNED WITH BRK, AND THE ONLY VALID
* SOURCE OF AN NMI IS THE KEYBOARD OR THE I/O DEVICE THAT
* HAS ALLOCATED THE NMI RESOURCE.
*
*REP 60
*
*
NMI.RCVR .eq *
*
* SAVE CPU REGISTERS A, X, & Y ON CURRENT				staCK
*
					pha
					txa
					pha
					tya
					pha
*
* CHECK FOR				staCK OVERFLOW
*
TSX
					cpx #$FA
					bcc NMI005
					lda #>STKOVFL
					jsr SYSDEATH
*
* SET UP INTERRUPT ENVIRONMENT:
* BINARY ARITHMETIC, 2 MHZ, I/O ENABLED,
* RAM WRITE ENABLED, PRIMARY				staCK,
* AND $F000 RAM SELECTED. PRESERVE
* USER				staTE OF SCREEN AND RESET LOCK.
*
NMI005 CLD
					lda E.REG
					tax
					and #BITON5+BITON4
					ora #BITON6+BITON2
					sta E.REG
*
* IF NOT ALREADY ON PRIMARY				staCK, SAVE USER'S
*				staCK POINTER AND SET UP SOS				staCK POINTER.
*
					txa
					and #BITON2
					bne NMI010
					txa
TSX
					stx SP.SAVE
					ldx #>E.SAVE
TXS
					tax
*
* SAVE SYSTEM CONTROL REGISTERS E, Z, & B ON SOS				staCK
*
NMI010				txa
					pha
					lda Z.REG
					pha
					lda B.REG
					pha
					lda EXPNSLOT
					pha
					bit $CFFF
					bit $C020 ;RESET I/O SPACE
					lda #$00
					sta EXPNSLOT
*
* SET INTERRUPT ZERO PAGE
*
					lda #0
					sta Z.REG
*
* SEE IF NMI IS FROM KEYBOARD OR I/O DEVICE
*

					lda E.IORB
					bmi NMI030
*
* NMI IS FROM I/O DEVICE
*
					lda SIRTABLE ;NMI ALLOCATED?
					bpl NMI020
					jsr CALLNMI
					sei
					jmp DISPATCH
CALLNMI				lda SIRADR.L
					sta NMIADR.L
					lda SIRADR.B
					sta B.REG
					jmp (NMIADR.L)
*
* BAD INTERRUPT -- SYSTEM DEATH
*
NMI020				lda #>BADINT1 ;NMI NOT ALLOCATED
					jsr SYSDEATH
*
* NMI IS FROM THE KEYBOARD
*
NMI030				lda SYSBANK
					sta B.REG
					jsr KYBDNMI
					sei
					jmp DISPATCH
*SBTL "DISPATCHER"
*REP 60
*
* THIS IS THE DISPATCHER. UPON COMPLETION, ALL SOS CALLS
* AND INTERRUPT HANDLERS RETURN CONTROL TO THE DISPATCHER.
* ITS PURPOSE IS TO SET UP THE APPROPRIATE ENVIRONMENT AND
* PASS CONTROL TO WHATEVER CODE SHOULD RUN NEXT.
*
* WHEN SOS IS INTERRUPTED, CONTROL ALWAYS RETURNS TO THE
* INTERRUPTED CODE. HOWEVER, WHEN THE USER IS INTERRUPTED,
* BY EITHER A SOS CALL OR AN INTERRUPT, THE DISPATCHER
* MUST CHECK THE EVENT QUEUE. IF THERE IS AN ACTIVE EVENT
* WITH A PRIORITY HIGHER THAN THE CURRENT EVENT FENCE,
* CONTROL IS PASSED TO THE EVENT CODE. OTHERWISE, CONTROL
* RETURNS TO THE INTERRUPTED CODE.
*
*REP 60
*
DISPATCH .eq *
*
* DISABLE INTERRUPTS AND RESTORE
* SYSTEM CONTROL REGISTERS B & Z
*
					sei
					lda E.REG
					ora #BITON6 ;ENABLE I/O
					sta E.REG
					pla
					jsr SELC800 ;RESTORE I/O SPACE
					pla
					sta B.REG
					pla
					sta Z.REG
*
* CHECK SAVED ENVIRONMENT REGISTER
* IF RETURNING TO PRIMARY				staCK
* THEN RESTORE E REG AND RELAUNCH SOS
* ELSE RESET				staCK POINTER & RESTORE E REG
*
					pla
					ora #BITON5 ;SET SCREEN				staTE TO
					bit SCRNMODE ; CURRENT SCREEN MODE
					bmi DSP005
					and #BITOFF5
DSP005 TAY
					and #BITON2
					beq DSP010
					sty E.REG
					bne DSP030
DSP010 PLA
					tax
TXS
					sty E.REG

*
* CHECK FOR ACTIVE EVENT WITH PRIORITY > FENCE
*
DSP020				lda CEVPRI
					ldx EVQ.LINK
					cmp EVQ.PRI,X
					bcs DSP030
*
* PROCESS ACTIVE EVENT TRAP
* SAVE E, Z, B, & CALLER'S PRIORITY ON				staCK THEN CALL
* EVENT. UPON RETURN, RESTORE PRIORITY, B, Z, & E THEN
* CHECK FOR MORE EVENTS.
*
					lda E.REG
					pha
					lda Z.REG
					pha
					lda B.REG
					pha
					lda CEVPRI
					pha
					jsr DO.EVENT
					sei
					pla
					sta CEVPRI
					pla
					sta B.REG
					pla
					sta Z.REG
					pla
					ora #BITON5 ;SET SCREEN				staTE TO
					bit SCRNMODE ; CURRENT SCREEN MODE
					bmi DSP025
					and #BITOFF5
DSP025				sta E.REG
					jmp DSP020
*
* RESTORE CPU REGISTERS Y, X, & A AND LAUNCH
*
DSP030 PLA
					tay
					pla
					tax
					pla
RTI
*PAGE
*REP 60
*
* THIS SUBROUTINE CALLS THE HIGHEST PRIORITY ACTIVE EVENT.
* FIRST, IT DELINKS THE FIRST ENTRY ON THE ACTIVE LIST AND
* LINKS IT TO THE FREE LIST. THEN, IT SETS UP THE BANK,
* ADDRESS, ID, &				staTUS AND CALLS THE EVENT VIA AN RTI.
*
*REP 60
*
DO.EVENT .eq *
*
* WRITE ENABLE RAM
*
					ldy E.REG
					tya
					and #BITOFF3
					sta E.REG
*
* DELINK ENTRY FROM ACTIVE LIST AND RELINK IT TO FREE LIST
*
					ldx EVQ.LINK
					lda EVQ.LINK,X
					sta EVQ.LINK
					lda EVQ.FREE
					sta EVQ.LINK,X
					stx EVQ.FREE
*
* SET FENCE TO EVENT PRIORITY THEN RESTORE E REG
*
					lda EVQ.PRI,X
					sta CEVPRI
					sty E.REG
*
* SET UP B, Z, E, ADDRESS, ID, &				staTUS
*

					lda EVQ.BANK,X
					sta B.REG
					lda EVQ.ADRH,X
					pha
					lda EVQ.ADRL,X
					pha
					ldy EVQ.ID,X
					php
					pla
					and #$82
					pha
					tya
RTI

CHN IPL.SRC2

*************************************************************************
* END OF APPLE /// SOS 1.3 SOURCE CODE FILE: IPL.SRC1
*************************************************************************




================================================================================================
FILE: "SOS.IPL.SRC2.TEXT"
================================================================================================
*************************************************************************
* APPLE /// SOS 1.3 SOURCE CODE FILE: IPL.SRC2
*************************************************************************
* ASSEMBLER: APPLE ][ 6502 ASSEMBLER from APPLE COMPUTER TOOLKIT

*SBTL "SYSTEM INTERNAL RESOURCES"
*REP 60
*
* SYSTEM INTERNAL RESOURCE NUMBERS
*
*
* SIR RESOURCE
*
* 0 SOUND PORT / I/O NMI
* 1 ACIA
* 2 E.CA2 -- KEYBOARD
* 3 E.CA1 -- CLOCK
* 4 E.SR
* 5 E.CB2 -- VBL +
* 6 E.CB1 -- VBL -
* 7 E.T2
* 8 E.T1
* 9 D.CA2 -- CSP INPUT FLAG / INPUT SWITCH 1
* A D.CA1 -- ANY SLOT (RESERVED FOR SOS)
* B D.SR -- CSP DATA REGISTER
* C D.CB2 -- CSP DATA I/O / ENSIO
* D D.CB1 -- CSP CLOCK / ENSEL / A/D SELECT / INPUT SW3
* E D.T2
* F D.T1
* 10 DISK STEPPER / GRAPHICS SCROLL / CHARACTER DOWNLOAD
* 11 SLOT 1
* 12 SLOT 2
* 13 SLOT 3
* 14 SLOT 4
* 15 (UNASSIGNED)
* 16 (UNASSIGNED)
* 17 (UNASSIGNED)
*
*REP 60
*SBTL "RESOURCE ALLOCATION & DEALLOCATION"
*REP 60
*
* RESOURCE ALLOCATION AND DEALLOCATION
*
* SIRS ARE ALLOCATED AND DEALLOCATED BY THE SUBROUTINES
* 'ALLOCSIR' AND 'DEALCSIR'. THE RESOURCE PARAMETERS ARE
* PASSED IN A TABLE THAT CONTAINS ONE FIVE-BYTE ENTRY FOR
* EACH SIR THAT IS TO BE ALLOCATED OR DEALLOCATED. THE
* TABLE ENTRY FORMAT IS SHOWN BELOW:
*
* 0 1 2 3 4
* +-------+-------+-------+-------+-------+
* | SIR # | ID | ADR.L | ADR.H | ADR.B |
* +-------+-------+-------+-------+-------+
*
* SIR # -- SYSTEM INTERNAL RESOURCE NUMBER
* ID -- IDENTIFICATION BYTE
* SUPPLIED BY ALLOCSIR, CHECKED BY DEALCSIR
* ADR -- INTERRUPT ADDRESS (LOW, HIGH, BANK)
* ZERO IF NO INTERRUPT HANDLER
*
*
* ALLOCSIR -- ALLOCATE SYSTEM INTERNAL RESOURCES
*
* PARAMETERS:
* A: NUMBER OF BYTES IN TABLE
* X: TABLE ADDRESS (LOW BYTE)
* Y: TABLE ADDRESS (HIGH BYTE)
*
* NORMAL EXIT -- SIRS ALLOCATED
* CARRY: CLEAR
* A, X, Y: UNDEFINED
*
* ERROR EXIT -- SIRS NOT ALLOCATED
* CARRY: SET
* X: SIR NUMBER

* A, Y: UNDEFINED
*
*
* DEALCSIR -- DEALLOCATE SYSTEM INTERNAL RESOURCES
*
* PARAMETERS:
* A: NUMBER OF BYTES IN TABLE
* X: TABLE ADDRESS (LOW BYTE)
* Y: TABLE ADDRESS (HIGH BYTE)
*
* NORMAL EXIT -- SIRS DEALLOCATED
* CARRY: CLEAR
* A, X, Y: UNDEFINED
*
* ERROR EXIT -- SIRS NOT DEALLOCATED
* CARRY: SET
* X: SIR NUMBER
* A, Y: UNDEFINED
*
*REP 60
*PAGE
*
IDBYTE DFB $81
*
ALLOCSIR .eq *
					clc
					php
					sei
					sta SIRARGSIZ ;SAVE TABLE SIZE
					lda E.REG
					sta SIRTEMP
					ora #BITON2 ;FORCE PRIMARY				staCK
					and #BITOFF3 ; AND WRITE ENABLE
					sta E.REG
					lda SIRTEMP
					pha
					lda Z.REG
					pha
					lda #$00
					sta Z.REG ;SET ZERO PAGE := $00
					stx SIRARGS
					sty SIRARGS+1 ;SET POINTER TO TABLE
*
					ldy #$00
ASIR010				lda (SIRARGS),Y ;GET SIR NUMBER
					cmp #SIRTBLSIZ
					tax
					bcs ASIR020
					lda SIRTABLE,X ;CHECK ALLOCATION
					bmi ASIR020
					lda IDBYTE
					sta SIRTABLE,X ;ALLOCATE SIR
					iny
					sta (SIRARGS),Y ;RETURN ID BYTE
					iny
					lda (SIRARGS),Y
					sta SIRADR.L,X ;SAVE INTERRUPT ADDRESS
					iny
					lda (SIRARGS),Y
					sta SIRADR.H,X
					iny
					lda (SIRARGS),Y
					sta SIRADR.B,X
					iny
					cpy SIRARGSIZ
					bcc ASIR010
*
					clc
					inc IDBYTE ;BUMP ID BYTE
					bmi SIREXIT
					lda #$81
					sta IDBYTE
					bmi SIREXIT
*
ASIR020 STX SIRTEMP ;SAVE BAD SIR NUMBER
ASIR030 SEC
					tya
					sbc #5
					tay
					bcc ASIR040
					lda (SIRARGS),Y ;GET SIR NUMBER

					tax
					lda #FALSE
					sta SIRTABLE,X ;RELEASE ALLOCATED SIRS
					beq ASIR030
*
ASIR040				ldx SIRTEMP ;RETURN BAD SIR
					clc
*
*
*
SIREXIT PLA
					sta Z.REG ;RESTORE Z REGISTER
					pla
					sta E.REG ;RESTORE E REGISTER
					bcc SIREXIT1
					pla
					ora #BITON0
					pha
SIREXIT1 PLP
					rts
*
*
*
DEALCSIR .eq *
					clc
					php
					sei
					sta SIRARGSIZ ;SAVE TABLE SIZE
					lda E.REG
					sta SIRTEMP
					ora #BITON2 ;FORCE PRIMARY				staCK
					and #BITOFF3 ; AND WRITE ENABLE
					sta E.REG
					lda SIRTEMP
					pha
					lda Z.REG
					pha
					lda #$00
					sta Z.REG ;SET ZERO PAGE := $00
					stx SIRARGS
					sty SIRARGS+1 ;SET POINTER TO TABLE
*
					ldy #$00
DSIR010				lda (SIRARGS),Y ;GET SIR NUMBER
					tax
					cpx #SIRTBLSIZ
					bcs DSIR030
					iny
					lda SIRTABLE,X
					bpl DSIR030 ;VERIFY ALLOCATION
					cmp (SIRARGS),Y
					bne DSIR030
					iny
					iny
					iny
					iny
					cpy SIRARGSIZ
					bcc DSIR010
*
					ldy SIRARGSIZ
DSIR020 SEC
					tya
					sbc #5
					tay
					bcc SIREXIT
					lda (SIRARGS),Y ;GET SIR NUMBER
					tax
					lda #FALSE
					sta SIRTABLE,X
					beq DSIR020
*
DSIR030 SEC
					bcs SIREXIT
*SBTL "SELECT I/O EXPANSION ROM"
*REP 60
*
* SUBROUTINE 'SELC800' IS CALLED TO SELECT THE C800 I/O EX-
* PANSION ADDRESS SPACE FOR A PERIPHERAL SLOT. ON ENTRY,
* THE SLOT NUMBER IS PASSED IN THE ACCUMULATOR. IF NO
* ERROR OCCURS, CARRY IS CLEARED; OTHERWISE, CARRY IS SET
* AND THE PREVIOUS SLOT REMAINS SELECTED.

*
* PARAMETERS:
* A: SLOT NUMBER
*
* NORMAL EXIT -- NEW SLOT SELECTED
* CARRY: CLEAR
* A: UNDEFINED
* X, Y: UNCHANGED
*
* ERROR EXIT -- SLOT NOT CHANGED
* CARRY: SET
* A, X, Y: UNCHANGED
*
* WARNING !!!
* 'SELC800' USES SELF-MODIFYING CODE!
*
*REP 60
*
SELC800 .eq *
					cmp #$05 ;CHECK SLOT NUMBER
					bcs SC8EXIT ; INVALID
					php
					sei
					sta EXPNSLOT
					ora #$C0 ;MAKE SLOT INTO $CN00
					sta CNADDR+2 ; AND MODIFY BIT ADDRESS
					bit $C020
					bit $CFFF ;DESELECT PREVIOUS SLOT
CNADDR BIT $C0FF ; AND SELECT CURRENT SLOT
					plp
SC8EXIT RTS
*SBTL "NMI DISABLE / ENABLE"
*REP 60
*
* THE SUBROUTINES NMIDSBL AND NMIENBL ARE CALLED TO
* DISABLE AND ENABLE NMI, RESPECTIVELY. THERE ARE NO
* INPUT PARAMETERS. ON EXIT, THE REGISTERS ARE UN-
* DEFINED. NMIDSBL CLEARS THE CARRY FLAG IF NMI WAS
* SUCCESSFULLY DISABLED; OTHERWISE, CARRY IS SET.
*
*REP 60
*
NMIDSBL .eq *
					ldx E.REG
					bit NMIFLAG
					bpl NDS020
					txa
					ora #BITON7
					sta E.REG ;SET 1MHZ
					lda #$00
					sta NMICNTR
					sta NMICNTR+1
NDS010				bit NMIFLAG ;NMI PENDING?
					bpl NDS020 ; NO
					inc NMICNTR ;BUMP NMI COUNTER
					bne NDS010 ; AND RECHECK NMI FLAG
					inc NMICNTR+1
					bne NDS010
					lda #>NMIHANG ;CAN'T LOCK NMI
					jsr SYSDEATH
NDS020				rxa ;GET E.REG
					and #BITOFF4 ;DISABLE NMI
					sta E.REG
					rts
*
*
*
NMIENBL				.eq *
					lda E.REG
					ora #BITON4 ;ENABLE NMI
					sta E.REG
					rts
*SBTL "KEYBOARD NMI HANDLER"
*REP 60
*
* BY DEFAULT, KEYBOARD NMI IS IGNORED. THE USER MAY
* PROCESS NMI BY CHANGING THE ADDRESS IN SYSTEM GLOBAL.
*
*REP 60
*
NMIDBUG .eq *

TSX ;SAVE THE				staCK POINTER
					stx NMISPSV
					lda #$03 ;SELECT MONITOR'S ZERO PAGE
					sta Z.REG
					lda E.REG
					ora #$03 ;SELECT MONITOR ROM
					sta E.REG
					jsr $F901 ;CALL THE MONITOR
*
NMICONT .eq *
					lda E.REG
					ora #BITON2 ;FORCE PRIMARY				staCK
					sta E.REG
					ldx NMISPSV
TXS ;RESTORE				staCK POINTER
					rts
*SBTL "EVENT QUEUE MANAGER"
*REP 60
*
* THE EVENT QUEUE IS USED TO HOLD THE PARAMETERS OF EVENTS
* THAT HAVE BEEN DETECTED BUT NOT YET RECOGNIZED. EVENT
* QUEUE ENTRIES ARE ORGANIZED INTO TWO LINKED LISTS; A FREE
* LIST AND AN ACTIVE LIST. EACH ENTRY IS SIX BYTES LONG,
* WITH THE FIRST BYTE (BYTE 0) USED AS A LINK. THE LINK
* BYTE CONTAINS THE TABLE INDEX OF THE NEXT ENTRY IN THE
* LIST. BECAUSE OF THE INDEXING METHOD, THE EVENT QUEUE
* MUST NOT EXCEED 256 BYTES.
*
* ENTRY ZERO IS A SPECIAL ENTRY. BYTE 0 IS THE INDEX OF
* THE FIRST ACTIVE ENTRY; BYTE 1 CONTAINS A ZERO, ALLOWING
* ENTRY 0 TO BE USED AS THE ACTIVE EVENT LIST TERMINATER;
* BYTE 2 CONTAINS THE INDEX OF THE FIRST FREE ENTRY; AND
* BYTES 4 THROUGH 6 ARE UNUSED.
*
* THE FREE LIST IS LINKED LIFO. THE ONLY VALID BYTE IN A
* FREE ENTRY IS THE LINK BYTE; THE REMAINING BYTES ARE
* UNDEFINED. THE FREE LIST IS TERMINATED BY A LINK BYTE
* CONTAINING A ZERO.
*
* THE ACTIVE LIST IS LINKED IN DECREASING PRIORITY ORDER
* WITH ENTRIES OF EQUAL PRIORITY LINKED FIFO. BYTES 1
* THROUGH 5 CONTAIN THE EVENT PRIORITY, EVENT ID, LOW BYTE
* OF THE EVENT ADDRESS, HIGH BYTE OF THE EVENT ADDRESS, AND
* THE ADDRESS BANK. THE ACTIVE LIST IS TERMINATED BY AN
* ENTRY WITH AN EVENT PRIORITY OF ZERO.
*
*REP 60
*PAGE
*REP 60
*
* SUBROUTINE 'QUEEVENT' IS USED TO ENTER AN EVENT INTO THE
* EVENT QUEUE. ACTIVE EVENTS ARE LINKED IN DECREASING
* PRIORITY ORDER WITH EVENTS OF EQUAL PRIORITY LINKED FIFO.
* EVENTS ARE REMOVED FROM THE QUEUE AS THEY ARE RECOGNIZED
* BY THE DISPATCHER.
*
* PARAMETERS:
* X: EVENT PARAMETER ADDRESS (LOW BYTE)
* Y: EVENT PARAMETER ADDRESS (HIGH BYTE)
*
* EVENT 0 1 2 3 4
* PARMS: +-------+-------+-------+-------+-------+
* | PRI | ID | ADR.L | ADR.H | ADR.B |
* +-------+-------+-------+-------+-------+
* PRI: EVENT PRIORITY
* ID: EVENT ID BYTE
* ADR: EVENT ADDRESS (LOW, HIGH, BANK)
*
* EXIT CONDITIONS:
* CARRY: CLEAR
* A, X, Y: UNDEFINED
*
*REP 60
*
QUEEVENT .eq *
					clc
					php
					sei
					lda E.REG
					sta QEVTEMP
					ora #BITON2 ;FORCE PRIMARY				staCK

					and #BITOFF3 ; AND WRITE ENABLE
					sta E.REG
					lda QEVTEMP
					pha
					lda Z.REG
					pha
					lda #0
					sta Z.REG ;SET ZERO PAGE := 0
*
					stx QEVARGS
					sty QEVARGS+1 ;SET ARGUMENT POINTER
					ldy #0
					lda (QEVARGS),Y ;GET PRIORITY
					beq Q.EXIT ; IGNORE IF ZERO
*
					ldx EVQ.FREE
					beq Q.FULL
					stx QEV.THIS ;GET FIRST FREE ENTRY
					lda EVQ.LINK,X ; AND DELINK IT
					sta EVQ.FREE
*
					ldy #EVQ.SIZ-2
QEV010				lda (QEVARGS),Y ;COPY ARGUMENTS
					sta EVQ.BANK,X ; INTO NEW ENTRY
					dex
					dey
					bpl QEV010
*
					ldx QEV.THIS
					ldy #0
QEV020 STY QEV.LAST
					lda EVQ.LINK,Y
					tay
					lda EVQ.PRI,Y ;SCAN EVENT QUEUE
					cmp EVQ.PRI,X ; FOR PROPER POSITION
					bcs QEV020
*
					tya
					sta EVQ.LINK,X ;RELINK EVENT INTO QUEUE
					txa
					ldy QEV.LAST
					sta EVQ.LINK,Y
*
Q.EXIT PLA
					sta Z.REG ;RESTORE Z REGISTER
					pla
					sta E.REG ;RESTORE E REGISTER
					plp
					rts
*
Q.FULL				lda #>EVQOVFL ;EVENT QUEUE OVERFLOW
					jsr SYSDEATH
*LST ON

ZZEND .eq *
ZZLEN .eq ZZEND-ZZORG
IFNE ZZLEN-LENIPL
FAIL 2,"SOSORG FILE IS INCORRECT FOR IPL"
FIN

*************************************************************************
* END OF APPLE /// SOS 1.3 SOURCE CODE FILE: IPL.SRC2
*************************************************************************




================================================================================================
FILE: "SOS.LC.TEXT"
================================================================================================
*************************************************************************
* APPLE /// SOS 1.3 SOURCE CODE FILE: LC
*************************************************************************
* ASSEMBLER: APPLE ][ 6502 ASSEMBLER from APPLE COMPUTER TOOLKIT

IFNE ZZLEN-LEN????
FAIL 2,"SOSORG FILE IS INCORRECT FOR ??????"
FIN

*************************************************************************
* END OF APPLE /// SOS 1.3 SOURCE CODE FILE: LC
*************************************************************************



================================================================================================
FILE: "SOS.LCHK.TEXT"
================================================================================================
*************************************************************************
* APPLE /// SOS 1.3 SOURCE CODE FILE: LCHK
*************************************************************************
* ASSEMBLER: APPLE ][ 6502 ASSEMBLER from APPLE COMPUTER TOOLKIT

					INCLUDE SOSORG,6,1,254
ORG ???????
---------------------------------
IFNE ZZLEN-LEN????
FAIL 2,"SOSORG FILE IS INCORRECT FOR ??????"
FIN

*************************************************************************
* END OF APPLE /// SOS 1.3 SOURCE CODE FILE: LCHK
*************************************************************************



================================================================================================
FILE: "SOS.MEMMGR.A.SRC.TEXT"
================================================================================================
*************************************************************************
* APPLE /// SOS 1.3 SOURCE CODE FILE: MEMMGR.A.SRC
*************************************************************************
* ASSEMBLER: APPLE ][ 6502 ASSEMBLER from APPLE COMPUTER TOOLKIT

*SBTL "SOS 1.1 MEMORY MANAGER"
*REL
					INCLUDE SOSORG,6,1,254
ORG ORGMEMMG
ZZORG .eq *
*MSB OFF
*REP 60
* COPYRIGHT (C) APPLE COMPUTER INC. 1980
* ALL RIGHTS RESERVED
*REP 60
*
* MEMORY MANAGER (VERSION = 1.1O )
* (DATE = 8/04/81)
*
* THIS MODULE CONTAINS ALL OF THE MEMORY MANAGEMENT SYSTEM
* CALLS SUPPORTED BY THE SARA OPERATING SYSTEM. IT IS
* ALSO CALLED BY THE BUFFER MANAGER.
*
*REP 60
*
*ENTRY MMGR
*
*ENTRY ST.CNT
*ENTRY ST.ENTRY
*ENTRY ST.FREE
*ENTRY ST.FLINK
*ENTRY VRT.LIM
*
*EXTRN SYSERR
*EXTRN BADSCNUM
*EXTRN BADBKPG
*EXTRN SEGRQDN
*EXTRN SEGTBLFULL
*EXTRN BADSEGNUM
*EXTRN SEGNOTFND
*EXTRN BADSRCHMODE
*EXTRN BADCHGMODE
*EXTRN BADPGCNT
*PAGE
*REP 60
*
* SEGMENT TABLE
* (NOTE: ENTRY 0 IS NOT USED)
*
*REP 60
*
ST.FREE DS 1 ; PTR TO FIRST FREE SEG TABLE ENTRY
ST.ENTRY DS 1 ; PTR TO HIGHEST ALLOC SEG TABLE ENTRY
ST.SIZ .eq 7
ST.CNT .eq 32
ST.TBL DS ST.SIZ*ST.CNT
ST.BLINK .eq ST.TBL ; BACK LINK TO PREV ALLOC SEG ENTRY
ST.FLINK .eq ST.BLINK+ST.CNT ; FORWARD LINK "
ST.BASEL .eq ST.FLINK+ST.CNT ; BASE BANK/PAGE
ST.BASEH .eq ST.BASEL+ST.CNT
ST.LIML .eq ST.BASEH+ST.CNT ; LIMIT BANK/PAGE
ST.LIMH .eq ST.LIML+ST.CNT
ST.ID .eq ST.LIMH+ST.CNT ; SEG ID
*PAGE
*REP 60
*
* DATA DECLARATIONS
*
*REP 60
*
ZPAGE .eq $40 ; BEGINNING OF ZPAGE TEMP SPACE FOR MEMORY MANAGER
VRT.BASE .eq $0 ; INTERNAL BK/PG PTR TO LOWEST VIRT PAGE
VRT.LIM .eq ZPAGE+$0 ; &$1, INTERNAL BK/PG PTR TO HIGHEST VIRT PAGE
PHY1BASE .eq $0780 ; BANK "F",PAGE "0"
PHY1LIM .eq $079F ; BANK "F",PAGE "1F"
PHY2BASE .eq $0820 ; BANK "10",PAGE "A0"

PHY2LIM .eq $087F ; BANK "10",PAGE "FF"
*
* REQUEST.SEG DATA DECLARATIONS
*
M.TPARMX .eq $60 ; BEGINNING ADDRESS OF MMGR SOS CALL PARMS
M.RQCODE .eq M.TPARMX
RQ.BASE .eq M.TPARMX+1 ; BASE.BANK/PAGE
RQ.LIM .eq M.TPARMX+3 ; LIMIT.BANK/PAGE
RQ.ID .eq M.TPARMX+5
RQ.NUM .eq M.TPARMX+6
*
RQ.REGION .eq ZPAGE+$2 ;VRT(0),PHY0(1),PHY1(2)
*
* FIND.SEG DATA DECLARATIONS
*
SRCHMODE .eq M.TPARMX+1 ; SEARCH MODE (0,1,2)
F.ID .eq M.TPARMX+2 ; SEG ID
F.PGCT .eq M.TPARMX+3 ; PAGE COUNT (LO
FX.PGCT .eq ZPAGE+$3 ; &$4, INTERNAL PAGE COUNT
F.BASE .eq M.TPARMX+5 ; BASE.BANK/PAGE
F.LIM .eq M.TPARMX+7 ; LIMIT.BANK/PAGE
F.NUM .eq M.TPARMX+9 ; SEG NUM
F.ERR .eq ZPAGE+$5 ; ERROR FLAG
TRUE .eq $80
FALSE .eq $0
CFS.PGCT .eq ZPAGE+$6 ; &7, CURRENT FREE SEGMENT'S PAGE COUNT
CFS.BASE .eq ZPAGE+$8 ; &9, " BASE.BANK/PAGE
CFS.LIM .eq ZPAGE+$A ; &$B, " LIMIT.BANK/PAGE
CFS.BLINK .eq ZPAGE+$C ; " BACK LINK
CFS.BASE0 .eq ZPAGE+$D ; &$E, " BASE (SMODE=0)
CFS.BASE1 .eq ZPAGE+$F ; &$10, " BASE (SMODE=1)
CFS.NEXT .eq ZPAGE+$11 ; " NEXT ENTRY
CFS.PREV .eq ZPAGE+$12 ; " PREV ENTRY
CFS.PTR .eq ZPAGE+$13 ; &$14 " POINTER TO NXT FREE PG
BFS.PGCT .eq ZPAGE+$15 ; &$16, BIGGEST FREE SEGMENT'S PAGE COUNT
BFS.BASE .eq ZPAGE+$17 ; &$18 " BASE.BANK/PAGE
BFS.LIM .eq ZPAGE+$19 ; &$1A " LIMIT.BANK/PAGE
BFS.BLINK .eq ZPAGE+$1B ; " BACK LINK
*
* CHANGE.SEG DATA DECLARATIONS
*
CHG.NUM .eq M.TPARMX+1 ; SEGNUM PARM
CHG.MODE .eq M.TPARMX+2 ; CHANGE MODE PARM
CHG.PGCT .eq M.TPARMX+3 ; PAGE COUNT PARM
CHG.PGCTX .eq ZPAGE+$1C ; &$1D, INTERNAL STORE FOR PGCT
CHG.NEW .eq ZPAGE+$1E ; &$1F, BANK/PAGE OF SEG'S NEW LIMIT OR BASE
*
* GET.SEG.INFO DATA DECLARATIONS
*
GSI.NUM .eq M.TPARMX+1
GSI.BASE .eq M.TPARMX+2
GSI.LIM .eq M.TPARMX+4
GSI.PGCT .eq M.TPARMX+6
GSI.ID .eq M.TPARMX+8
*
* GET.SEG.NUM DATA DECLARATIONS
*
GSN.BKPG .eq M.TPARMX+1
GSN.NUM .eq M.TPARMX+3
*
* RELEASE.SEG DATA DECLARATIONS
*
RLS.NUM .eq M.TPARMX+1 ; SEG NUM
*
* REGION - DATA DECLARATIONS
*
RGN.BKPG DS 2 ; TEMP CONTAINER FOR BANK/PAGE
*PAGE
*REP 60
*
* MMGR
*
* THIS ROUTINE IS THE MAIN ENTRANCE TO THE MEMORY MANAGER
* MODULE. IT FUNCTIONS AS A SWITCH, BASED UPON THE RECEIVED
* REQUEST CODE, TO TRANSFER CONTROL TO THE ROUTINE THAT
* HANDLES THE SPECIFIC SYSTEM CALL.
*
*REP 60
*
MMGR .eq *
					lda M.RQCODE

					beq MMGR010 ; "REQ.SEG"
					cmp #1
					beq MMGR020 ; "FIND.SEG"
					cmp #2
					beq MMGR030 ; "CHANGE.SEG"
					cmp #3
					beq MMGR040 ; "GET.SEG.INFO"
					cmp #4
					beq MMGR050 ; "GET.SEG.NUM"
					cmp #5
					beq MMGR060 ; "RELEASE.SEG"
*
					lda #BADSCNUM
					jsr SYSERR
*
MMGR010 JMP REQ.SEG
MMGR020 JMP FIND.SEG
MMGR030 JMP CHG.SEG
MMGR040 JMP GET.SEG.INFO
MMGR050 JMP GET.SEG.NUM
MMGR060 JMP RELEASE.SEG
*PAGE
*REP 60
*
* REQUEST.SEG(IN.BASE.BANKPAGE,LIMIT.BANKPAGE,SEGID; OUT.SEGNUM)
*
*REP 60
*
REQ.SEG .eq *
*
* CONVERT CALLER'S BASE.BANK/PAGE TO INTERNAL FMT
*
					ldx RQ.BASE
					ldy RQ.BASE+1
					jsr CNVRT.IBP
					bcc RQ005
*
RQ.ERR RTS ; ERR EXIT - INVALID BANK/PAGE
*
RQ005 STX RQ.BASE
					sty RQ.BASE+1
					sta RQ.REGION
*
* CONVERT CALLER'S LIMIT.BANK/PAGE TO INTERNAL FMT
*
					ldx RQ.LIM
					ldy RQ.LIM+1
					jsr CNVRT.IBP
					bcs RQ.ERR ; ERR - INVALID BANK/PAGE
					stx RQ.LIM
					sty RQ.LIM+1
*
* IF BASE AND LIMIT ARE IN DIFFERENT REGIONS THEN ERR
*
					cmp RQ.REGION
					bne RQ.ERR1 ; ERR - INVALID BANK/PAGE PAIR
* IF CALLER'S BASE > LIMIT THEN ERR
*
					lda RQ.LIM
					cmp RQ.BASE
					lda RQ.LIM+1
					sbc RQ.BASE+1
					bcc RQ.ERR1 ; ERR - INVALID BANK/PAGE PAIR
*
* PREV SEGNUM:=NULL; NEXT SEGNUM:=FIRST ENTRY
*
					ldx #0
					ldy ST.ENTRY ; NOTE: PREV/NEXT CARRIED IN X & Y REGISTERS
*
* IF NO SEGS IN SEG TABLE THEN ALLOCATE REQUESTED SEG
*
					beq RQ030
*
* IF FIRST SEG IN SEG TABLE BELOW REQUESTED SEG
* THEN ALLOCATE SEG
*
					lda ST.LIML,Y
					cmp RQ.BASE
					lda ST.LIMH,Y
					sbc RQ.BASE+1
					bcc RQ030

*
* ADVANCE TO NEXT SEG ENTRY
*
RQ010 TYA
					tax
					lda ST.FLINK,Y
					tay
*
* IF THERE IS NO NEXT SEG ENTRY
* IF REQUESTED SEG IS BELOW PREV SEG
* THEN ALLOCATE REQ SEG
* ELSE ERR
*
					bne RQ020
					lda RQ.LIM
					cmp ST.BASEL,X
					lda RQ.LIM+1
					sbc ST.BASEH,X
					bcc RQ030
*
					bcs RQ.ERR2 ; ERR - SEGMENT REQUEST DENIED
*
* IF REQUESTED LIMIT >= PREV SEG'S BASE THEN ERR
*
RQ020				lda RQ.LIM
					cmp ST.BASEL,X
					lda RQ.LIM+1
					sbc ST.BASEH,X
					bcs RQ.ERR2 ; ERR - SEGMENT REQUEST DENIED
*
* IF REQUESTED BASE > NEXT SEG'S LIMIT
* THEN ALLOCATE REQUESTED SEGMENT
*
					lda ST.LIML,Y
					cmp RQ.BASE
					lda ST.LIMH,Y
					sbc RQ.BASE+1
					bcs RQ010 ; NO, ADVANCE TO NEXT SEGMENT
*
RQ030 TXA ; ALLOCATE REQUESTED SEGMENT
					jsr GET.FREE
					bcs RQ.ERR3 ; ERR - SEG TABLE FULL
*
* ENTER BASE,LIMIT AND ID IN NEW SEG ENTRY
*
					tax
					lda RQ.BASE
					sta ST.BASEL,X
					lda RQ.BASE+1
					sta ST.BASEH,X
*
					lda RQ.LIM
					sta ST.LIML,X
					lda RQ.LIM+1
					sta ST.LIMH,X
*
					lda RQ.ID
					sta ST.ID,X
*
* RETURN NEW SEG NUM TO CALLER AND RETURN
*
					ldy #0
					txa
					sta (RQ.NUM),Y
*
					clc
					rts; NORMAL EXIT
*
RQ.ERR1				lda #BADBKPG
					jsr SYSERR ; ERR EXIT
RQ.ERR2				lda #SEGRQDN
					jsr SYSERR ; ERR EXIT
*
RQ.ERR3				lda #SEGTBLFULL
					jsr SYSERR ; ERR EXIT
*PAGE
*REP 60
*
* FIND.SEG(IN.SRCHMODE,SEGID; INOUT.PAGECT;
* OUT.BASE.BKPG,LIMIT.BKPG,SEGNUM)
*

*REP 60
*
FIND.SEG .eq *
*
* RETRIEVE PAGE COUNT PARAMETER AND CLEAR ERR FLAG
*
					ldy #0
					lda (F.PGCT),Y
					sta FX.PGCT
					iny
					lda (F.PGCT),Y
					sta FX.PGCT+1
*
					bne FIND001
					lda FX.PGCT
					bne FIND001
					lda #BADPGCNT ; ERR, PAGECT=0, EXIT
					jsr SYSERR
*
FIND001				lda #FALSE
					sta F.ERR
*
* IF SEARCH MODE>2 THEN ERR
*
					lda SRCHMODE
					cmp #3
					bcc FIND005
					lda #BADSRCHMODE
					jsr SYSERR ; ERR EXIT
*
* INITIALIZE NEXT FREE SEGMENT SUBROUTINE,
* AND BIGGEST FREE SEGMENT PAGE COUNT
*
FIND005				jsr NXTFRSEG.I
					lda #0
					sta BFS.PGCT
					sta BFS.PGCT+1
*
* GET NEXT FREE SEGMENT
*
FIND010				jsr NXTFRSEG
					bcc FIND015 ; PROCESS FREE SEGMENT
*
* NO MORE FREE SEGMENTS LEFT
* RETURN BIGGEST FREE SEGMENT FOUND
* ALONG WITH ERR
*
					lda #TRUE
					sta F.ERR
					ldx #0 ; SEG#:=0
					jmp FIND070
*
* FREE SEGMENT FOUND.
* IF FREE SEGMENT > BIGGEST FREE SEGMENT THEN BFS:=CFS
*
FIND015				lda BFS.PGCT
					cmp CFS.PGCT
					lda BFS.PGCT+1
					sbc CFS.PGCT+1
					bcs FIND030
*
					ldx #6
FIND020				lda CFS.PGCT,X
					sta BFS.PGCT,X
					dex
					bpl FIND020
*
* IF BFS.PGCT<F.PGCT THEN GET NEXT FREE SEGMENT
*
FIND030				lda BFS.PGCT
					cmp FX.PGCT
					lda BFS.PGCT+1
					sbc FX.PGCT+1
					bcc FIND010
*
* BFS.BASE:=BFS.LIM-FX.PGCT+1
* BFS.PGCT:=FX.PGCT
*
					lda BFS.LIM
					sbc FX.PGCT
					sta BFS.BASE

					lda BFS.LIM+1
					sbc FX.PGCT+1
					sta BFS.BASE+1
					inc BFS.BASE
					bne FIND050
					inc BFS.BASE+1
*
FIND050				lda FX.PGCT
					sta BFS.PGCT
					lda FX.PGCT+1
					sta BFS.PGCT+1
*
* DELINK ENTRY FROM FREE LIST, AND LINK
* IT INTO SEGMENT LIST
*
					lda BFS.BLINK
					jsr GET.FREE
					bcc FIND060
					rts; ERR - SEG TABLE FULL
*
* ST.ID(NEW):=F.ID
* ST.BASE(NEW):=BFS.BASE
* ST.LIM(NEW):=BFS.LIM
*
FIND060 TAX
					lda F.ID
					sta ST.ID,X
*
					lda BFS.BASE
					sta ST.BASEL,X
					lda BFS.BASE+1
					sta ST.BASEH,X
*
					lda BFS.LIM
					sta ST.LIML,X
					lda BFS.LIM+1
					sta ST.LIMH,X
*
* RETURN SEGNUM, PAGE COUNT, BASE BANK/PAGE, AND LIMIT BANK/PAGE
* TO CALLER
FIND070 LDY #0
					txa
					sta (F.NUM),Y
*
					lda BFS.PGCT
					sta (F.PGCT),Y
					iny
					lda BFS.PGCT+1
					sta (F.PGCT),Y
*
					ldx BFS.BASE
					ldy BFS.BASE+1
					jsr CNVRT.XBP
					tya
					ldy #1
					sta (F.BASE),Y
					dey
					txa
					sta (F.BASE),Y
*
					ldx BFS.LIM
					ldy BFS.LIM+1
					jsr CNVRT.XBP
					tya
					ldy #1
					sta (F.LIM),Y
					dey
					txa
					sta (F.LIM),Y
*
					lda F.ERR ; IF ERR FLAG TRUE THEN REPORT IT.
					bne FIND.ERR
*
					clc
					rts; NORMAL EXIT
*
FIND.ERR				lda #SEGRQDN
					jsr SYSERR ; ERR EXIT

CHN MEMMGR.B.SRC


*************************************************************************
* END OF APPLE /// SOS 1.3 SOURCE CODE FILE: MEMMGR.A.SRC
*************************************************************************




================================================================================================
FILE: "SOS.MEMMGR.B.SRC.TEXT"
================================================================================================
*************************************************************************
* APPLE /// SOS 1.3 SOURCE CODE FILE: MEMMGR.B.SRC
*************************************************************************
* ASSEMBLER: APPLE ][ 6502 ASSEMBLER from APPLE COMPUTER TOOLKIT

*PAGE
*REP 60
*
* NEXT FREE SEGMENT - INITIALIZATION
*
* INPUT: SEGMENT TABLE
* OUTPUT: CFS.PTR "1ST FREE BANK/PAGE IN VIRTUAL MEMORY
* CFS.PREV "PREVIOUS SEGMENT EXAMINED"
* CFS.NEXT "SEGMENT FOLLOWING CFS.PREV"
* ERROR: NONE (IF NO FREE BK/PG FOUND, THEN CFS.PTR="FFFF")
*
*REP 60
*
NXTFRSEG.I .eq *
*
* CFS.PTR := VRT.LIM
* CFS.PREV := 0
* CFS.NEXT := ST.ENTRY
*
					lda >VRT.LIM
					sta CFS.PTR
					lda >VRT.LIM+1
					sta CFS.PTR+1
*
					lda #0
					sta CFS.PREV
*
					ldx ST.ENTRY
					stx CFS.NEXT
*
* L0: IF CFS.NEXT=0 THEN DONE
*
FRSGI010 BEQ FRSGI.EXIT
*
* IF ST.LIM(CFS.NEXT)<=VRT.LIM THEN GOTO L1
*
					lda >VRT.LIM
					cmp ST.LIML,X
					lda >VRT.LIM+1
					sbc ST.LIMH,X
					bcs FRSGI020
*
* CFS.PREV:=CFS.NEXT
* CFS.NEXT:=ST.FLINK(CFS.NEXT)
* GOTO L0
*
					stx CFS.PREV
					lda ST.FLINK,X
					tax
					stx CFS.NEXT
					jmp FRSGI010
*
* L1: IF ST.LIM(CFS.NEXT)<VRT.LIM THEN DONE
*
FRSGI020				lda ST.LIML,X
					cmp >VRT.LIM
					lda ST.LIMH,X
					sbc >VRT.LIM+1
					bcc FRSGI.EXIT
*
*
					jsr NXTFRPG
*
FRSGI.EXIT RTS ; NORMAL EXIT
*PAGE
*REP 60
*
* NEXT FREE SEGMENT
*
* INPUT: SEG TABLE
* OUTPUT: CFS.BLINK

* CFS.BASE
* CFS.LIMIT
* CFS.PGCT
* OWN: CFS.PREV
* CFS.NEXT
* CFS.PTR
*
* BUILDS A CANDIDATE FREE SEGMENT, WHOSE LIMIT BANK/PAGE =
* THE CURRENT FREE PAGE (CFS.PTR).
*
*REP 60
*
NXTFRSEG .eq *
*
* IF CFS.PTR="FFFF" THEN EXIT
*
					lda CFS.PTR+1
					bpl FRSG010
*
					clc
					rts; EXIT - NO MORE FREE SEGMENTS LEFT
*
* CFS.BLINK:=CFS.PREV
* CFS.LIM:=CFS.PTR
*
FRSG010				lda CFS.PREV
					sta CFS.BLINK
*
					lda CFS.PTR
					sta CFS.LIM
					lda CFS.PTR+1
					sta CFS.LIM+1
*
* IF CFS.NEXT=0 THEN CFS.BASE:=0
* ELSE CFS.BASE:=ST.LIM(CFS.NEXT)+1
*
					lda CFS.NEXT
					bne FRSG020
					lda #0
					sta CFS.BASE
					sta CFS.BASE+1
					beq FRSG030
*
FRSG020				ldx CFS.NEXT
					clc
					lda ST.LIML,X
					adc #1
					sta CFS.BASE
					lda ST.LIMH,X
					adc #0
					sta CFS.BASE+1
*
* CFS.BASE0:=CFS.LIM AND $FF80
*
FRSG030 LDY CFS.LIM+1
					sty CFS.BASE0+1
					lda CFS.LIM
					and #$80
					sta CFS.BASE0
*
* CFS.BASE1:=CFS.BASE0-32K
*
					clc
					sbc #$80
					sta CFS.BASE1
					tya
					sbc #0
					sta CFS.BASE1+1
					bcs FRSG035
					lda #0
					sta CFS.BASE1
					sta CFS.BASE1+1
*
* IF CFS.BASE>=CFS.BASE0 THEN GOTO L1
*
FRSG035				lda CFS.BASE
					cmp CFS.BASE0
					lda CFS.BASE+1
					sbc CFS.BASE0+1
					bcs FRSG050
*

* IF SEARCH MODE=0 THEN CFS.BASE:=CFS.BASE0
* GOTO L1
*
					lda SRCHMODE
					bne FRSG040
					lda CFS.BASE0
					sta CFS.BASE
					lda CFS.BASE0+1
					sta CFS.BASE+1
					jmp FRSG050
*
* IF CFS.BASE<CFS.BASE1 AND SEARCH MODE=1
* THEN CFS.BASE:=CFS.BASE1
*
FRSG040				lda CFS.BASE
					cmp CFS.BASE1
					lda CFS.BASE+1
					sbc CFS.BASE1+1
					bcs FRSG050
*
					lda SRCHMODE
					cmp #1
					bne FRSG050
*
					lda CFS.BASE1
					sta CFS.BASE
					lda CFS.BASE1+1
					sta CFS.BASE+1
*
* L1: CFS.PGCT:=CFS.LIM-CFS.BASE+1
*
FRSG050 SEC
					lda CFS.LIM
					sbc CFS.BASE
					sta CFS.PGCT
					lda CFS.LIM+1
					sbc CFS.BASE+1
					sta CFS.PGCT+1
					inc CFS.PGCT
					bne FRSG052
					inc CFS.PGCT+1
*
* ADVANCE FREE PAGE POINTER TO NEXT FREE PAGE
*
* IF SEARCH MODE<>1 THEN L2:
*
FRSG052				lda SRCHMODE
					cmp #1
					bne FRSG060
*
* IF CFS.BASE < CFS.BASE0 THEN CFS.PTR:=CFS.BASE0-1
*
					lda CFS.BASE
					cmp CFS.BASE0
					lda CFS.BASE+1
					sbc CFS.BASE0+1
					bcs FRSG060
*
					ldy CFS.BASE0+1
					ldx CFS.BASE0
					bne FRSG055
					dey
FRSG055 DEX
					stx CFS.PTR
					sty CFS.PTR+1
*
					jmp FRSG070 ; AND EXIT
* L2: CFS.PTR:=CFS.BASE-1
*
FRSG060 SEC
					lda CFS.BASE
					sbc #1
					sta CFS.PTR
					lda CFS.BASE+1
					sbc #0
					sta CFS.PTR+1
*
* IF CFS.PTR="FFFF" OR CFS.NEXT=0 THEN EXIT
*
					bcc FRSG070
					lda CFS.NEXT

					beq FRSG070
*
* IF CFS.PTR > ST.LIM(CFS.NEXT) THEN EXIT
*
					ldx CFS.NEXT
					lda ST.LIML,X
					cmp CFS.PTR
					lda ST.LIMH,X
					sbc CFS.PTR+1
					bcc FRSG070
*
* OTHERWISE, ADVANCE CFS PTR TO NEXT FREE PAGE BELOW NEXT
* SEGMENT IN SEGMENT LIST
*
					jsr NXTFRPG
*
FRSG070 CLC
					rts; EXIT - FREE SEGMENT FOUND
*PAGE
*REP 60
*
* NEXT FREE PAGE
*
* "WALKS" THE FREE PAGE PTR (CFS.PTR) TO THE NEXT FREE PAGE
* IMMEDIATELY BELOW THE CURRENT FREE SEGMENT.
*
*REP 60
*
NXTFRPG .eq *
*
* L0: CFS.PTR:=ST.BASE(CFS.NEXT)-1
* IF CFS.PTR="FFFF" THEN DONE
*
					ldx CFS.NEXT
					clc
					lda ST.BASEL,X
					sbc #1
					sta CFS.PTR
					lda ST.BASEH,X
					sbc #0
					sta CFS.PTR+1
					bcc NFRPG.EXIT
*
* CFS.PREV:=CFS.NEXT
* CFS.NEXT:=ST.FLINK(CFS.NEXT)
*
					stx CFS.PREV
					lda ST.FLINK,X
					tax
					stx CFS.NEXT
*
* IF CFS.NEXT=0 OR ST.LIM(CFS.NEXT)<CFS.PTR
* THEN DONE
* ELSE GOTO L0
*
					beq NFRPG.EXIT
					lda ST.LIML,X
					cmp CFS.PTR
					lda ST.LIMH,X
					sbc CFS.PTR+1
					bcs NXTFRPG
*
NFRPG.EXIT RTS ; NORMAL EXIT
*PAGE
*REP 60
*
* CHANGE.SEG(IN.SEGNUM,CHG.MODE; INOUT.PAGECT) SYSTEM CALL
*
*REP 60
*
CHG.SEG .eq *
*
* MOVE CALLER'S PAGE COUNT TO INTERNAL BUFFER
*
					ldy #0
					lda (CHG.PGCT),Y
					sta CHG.PGCTX
					iny
					lda (CHG.PGCT),Y
					sta CHG.PGCTX+1
*

* IF SEG# OUT OF RANGE OR ST.FLINK(SEG#)=FREE THEN ERR
*
					ldx CHG.NUM
					beq CHGS.ERR
					cpx #ST.CNT
					bcs CHGS.ERR
					lda ST.FLINK,X
					bpl CHGS005
*
CHGS.ERR				lda #BADSEGNUM
					jsr SYSERR ; ERR EXIT
*REP 35
* CASE OF CHANGE MODE
*REP 35
CHGS005 LDY CHG.MODE
					cpy #1
					bcc CHGS010
					beq CHGS020
					cpy #3
					bcc CHGS030
					beq CHGS040
*
					lda #BADCHGMODE
					jsr SYSERR ; ERR EXIT
*PAGE
*REP 35
* CHANGE MODE = 0(BASE UP)
*REP 35
* CHG.NEW:=ST.BASE(SEG#)+PGCT
*
CHGS010 CLC
					lda ST.BASEL,X
					adc CHG.PGCTX
					sta CHG.NEW
					lda ST.BASEH,X
					adc CHG.PGCTX+1
					sta CHG.NEW+1
*
					bcs CHGS014 ; OVERFLOW, PEG IT
*
* IF CHG.NEW <= ST.LIM(SEG#) THEN EXIT
*
					lda ST.LIML,X
					cmp CHG.NEW
					lda ST.LIMH,X
					sbc CHG.NEW+1
					bcs CHGS016
*
* OTHERWISE, CHG.NEW:=ST.LIM(SEG#)
*
CHGS014				lda ST.LIML,X
					sta CHG.NEW
					lda ST.LIMH,X
					sta CHG.NEW+1
*
CHGS016 JMP CHGS.EXIT
*REP 35
* CHANGE MODE = 1(BASE DOWN)
*REP 35
* CHG.NEW:=ST.BASE(SEG#)-PGCT
*
CHGS020 SEC
					lda ST.BASEL,X
					sbc CHG.PGCTX
					sta CHG.NEW
					lda ST.BASEH,X
					sbc CHG.PGCTX+1
					sta CHG.NEW+1
					bcs CHGS050
					bcc CHGS052 ; OVERFLOW, PEG IT
*REP 35
* CHANGE MODE = 2(LIMIT UP)
*REP 35
* CHG.NEW:=ST.LIM(SEG#)+PGCT
*
CHGS030 CLC
					lda ST.LIML,X
					adc CHG.PGCTX
					sta CHG.NEW
					lda ST.LIMH,X
					adc CHG.PGCTX+1

					sta CHG.NEW+1
					bcc CHGS050
					bcs CHGS052 ; OVERFLOW, PEG IT
*REP 35
* CHANGE MODE = 3(LIMIT DOWN)
*REP 35
* CHG.NEW:=ST.LIM(SEG#)-PGCT
*
CHGS040 SEC
					lda ST.LIML,X
					sbc CHG.PGCTX
					sta CHG.NEW
					lda ST.LIMH,X
					sbc CHG.PGCTX+1
					sta CHG.NEW+1
					bcc CHGS044 ; OVERFLOW, PEG IT
*
* IF CHG.NEW >= ST.BASE(SEG#) THEN EXIT
*
					lda CHG.NEW
					cmp ST.BASEL,X
					lda CHG.NEW+1
					sbc ST.BASEH,X
					bcs CHGS046
*
* OTHERWISE CHG.NEW:=ST.BASE(SEG#)
*
CHGS044				lda ST.BASEL,X
					sta CHG.NEW
					lda ST.BASEH,X
					sta CHG.NEW+1
*
CHGS046 JMP CHGS.EXIT
*
* DETERMINE NEW BANK/PAGE'S REGION,
* IF NEW BANK/PAGE IS INVALID THEN
* SET TO BASE OR LIMIT (CASE CHANGE MODE)
*
CHGS050				ldx CHG.NEW
					ldy CHG.NEW+1
					jsr REGION
					bcs CHGS052
					bne CHGS052
					beq CHGS100
CHGS052				lda CHG.MODE
					cmp #1
					bne CHGS054
					ldx #>VRT.BASE
					ldy #<VRT.BASE
					jmp CHGS056
CHGS054				ldx >VRT.LIM
					ldy >VRT.LIM+1
CHGS056 STX CHG.NEW
					sty CHG.NEW+1
*PAGE
*
* COMPUTE BANK/PAGE OF ADJACENT SEGMENT, IF ANY
* CASE CHANGE MODE
*
CHGS100				ldx CHG.NUM
					lda CHG.MODE
					cmp #1
					bne CHGS200
* "1" IF ST.FLINK(SEG#)=0 THEN EXIT
					lda ST.FLINK,X
					beq CHGS.EXIT
* X,Y:=ST.LIM(ST.FLINK(SEG#))+1
					tay
					lda ST.LIML,Y
					tax
					lda ST.LIMH,Y
					tay
					inx
					bne CHGS110
					iny
* IF CHG.NEW < X,Y THEN CHG.NEW:=X,Y
CHGS110 CPY CHG.NEW+1
					bcc CHGS.EXIT
					beq CHGS120
					bcs CHGS300
CHGS120 CPX CHG.NEW

					bcc CHGS.EXIT
					bcs CHGS300
* "2" IF ST.BLINK(SEG#)=0 THEN EXIT
CHGS200				lda ST.BLINK,X
					beq CHGS.EXIT
* X,Y:= ST.BASE(ST.BLINK(SEG#))-1
					tay
					lda ST.BASEL,Y
					tax
					lda ST.BASEH,Y
					tay
					txa
					bne CHGS210
					dey
CHGS210 DEX
* IF CHG.NEW > X,Y THEN CHG.NEW:=X,Y
					cpy CHG.NEW+1
					bcc CHGS300
					beq CHGS220
					bcs CHGS.EXIT
CHGS220 CPX CHG.NEW
					bcs CHGS.EXIT
*
CHGS300 STX CHG.NEW
					sty CHG.NEW+1
*PAGE
*REP 35
*
* COMPUTE DELTA PAGE COUNT AND RETURN IT TO CALLER
* (CASE OF CHG.MODE)
*
*REP 35
CHGS.EXIT				ldx CHG.NUM
					ldy #0
					lda CHG.MODE
					cmp #1
					bcc CHGS500
					beq CHGS510
					cmp #3
					bcc CHGS520
					beq CHGS530
*
* "0" -- PAGECOUNT:=NEW-BASE
*
CHGS500 SEC
					lda CHG.NEW
					sbc ST.BASEL,X
					sta (CHG.PGCT),Y
					lda CHG.NEW+1
					sbc ST.BASEH,X
					jmp CHGS600
*
* "1" -- PAGECOUNT:=BASE-NEW
*
CHGS510 SEC
					lda ST.BASEL,X
					sbc CHG.NEW
					sta (CHG.PGCT),Y
					lda ST.BASEH,X
					sbc CHG.NEW+1
					jmp CHGS600
*
* "2" -- PAGECOUNT:=NEW-LIM
*
CHGS520 SEC
					lda CHG.NEW
					sbc ST.LIML,X
					sta (CHG.PGCT),Y
					lda CHG.NEW+1
					sbc ST.LIMH,X
					jmp CHGS600
*
* "3" -- PAGECOUNT:=LIM-NEW
*
CHGS530 SEC
					lda ST.LIML,X
					sbc CHG.NEW
					sta (CHG.PGCT),Y
					lda ST.LIMH,X
					sbc CHG.NEW+1
*

CHGS600 INY
					sta (CHG.PGCT),Y
*
* IF NEW PAGE COUNT < REQUESTED PAGECOUNT THEN ERR
*
					tax
					dey
					lda (CHG.PGCT),Y
					cmp CHG.PGCTX
					txa
					sbc CHG.PGCTX+1
					bcs CHGS610
					lda #SEGRQDN
					jsr SYSERR ; ERR EXIT
*
* OTHERWISE, ENTER CHG.NEW IN SEGMENT TABLE AND EXIT
*
CHGS610				ldx CHG.NUM
					lda CHG.MODE
					cmp #2
					lda CHG.NEW
					ldy CHG.NEW+1
					bcs CHGS620
*
					sta ST.BASEL,X
					tya
					sta ST.BASEH,X
					clc
					rts; NORMAL EXIT
*
*
CHGS620				sta ST.LIML,X
					tya
					sta ST.LIMH,X
					clc
					rts; NORMAL EXIT

CHN MEMMGR.C.SRC

*************************************************************************
* END OF APPLE /// SOS 1.3 SOURCE CODE FILE: MEMMGR.B.SRC
*************************************************************************




================================================================================================
FILE: "SOS.MEMMGR.C.SRC.TEXT"
================================================================================================
*************************************************************************
* APPLE /// SOS 1.3 SOURCE CODE FILE: MEMMGR.C.SRC
*************************************************************************
* ASSEMBLER: APPLE ][ 6502 ASSEMBLER from APPLE COMPUTER TOOLKIT

*PAGE
*REP 60
*
* GET.SEG.INFO(IN.SEGNUM; OUT.BASE.BKPG,LIMIT.BKPG,PGCT,SEGID)
*
*REP 60
*
GET.SEG.INFO .eq *
*
* IF SEG# OUT OF BOUNDS OR ST.FLINK(SEG#)=ST.FREE THEN ERR
*
					ldx GSI.NUM
					beq GSI.ERR ; ERR - INVALID SEGNUM
					cpx #ST.CNT
					bcs GSI.ERR ; ERR - INVALID SEGNUM
					lda ST.FLINK,X
					bmi GSI.ERR ; ERR - INVALID SEGNUM
*
* RETURN BASE.BKPG TO CALLER
*
					ldy ST.BASEH,X
					lda ST.BASEL,X
					tax
					jsr CNVRT.XBP
					tya
					ldy #1
					sta (GSI.BASE),Y
					dey
					txa
					sta (GSI.BASE),Y
*
* RETURN LIMIT.BKPG TO CALLER
*
					ldx GSI.NUM
					ldy ST.LIMH,X
					lda ST.LIML,X
					tax
					jsr CNVRT.XBP
					tya
					ldy #1
					sta (GSI.LIM),Y
					dey
					txa
					sta (GSI.LIM),Y
*
* RETURN SEGID TO CALLER
*
					ldx GSI.NUM
					lda ST.ID,X
					sta (GSI.ID),Y
*
* COMPUTE PAGE COUNT
*
					clc
					lda ST.LIML,X
					sbc ST.BASEL,X
					tay
					lda ST.LIMH,X
					sbc ST.BASEH,X
					tax
					iny
					bne GSI010
					inx
*
* RETURN PAGE COUNT TO CALLER
*
GSI010 TYA
					ldy #0
					sta (GSI.PGCT),Y
					iny
					txa

					sta (GSI.PGCT),Y
*
					clc
					rts; NORMAL EXIT
*
GSI.ERR				lda #BADSEGNUM
					jsr SYSERR ; ERR EXIT
*PAGE
*REP 60
*
* GET.SEG.NUM(IN.BANKPAGE; OUT.SEGNUM) SYSTEM CALL
*
*
*REP 60
*
GET.SEG.NUM .eq *
*
* CONVERT BANKPAGE TO INTERNAL FORMAT
*
					ldx GSN.BKPG
					ldy GSN.BKPG+1
					jsr CNVRT.IBP
					bcs GSN.ERR ; ERR - INVALID BANK PAGE
					stx GSN.BKPG
					sty GSN.BKPG+1
*
* QUIT IF NO ENTRIES IN SEG TABLE
*
					lda ST.ENTRY
					beq GSN.ERR1 ; ERR - SEG NOT FOUND
*
* L1: IF BANKPAGE>ST.LIM(SEG#) THEN ERR
*
GSN010 TAX
					lda ST.LIML,X
					cmp GSN.BKPG
					lda ST.LIMH,X
					sbc GSN.BKPG+1
					bcc GSN.ERR1 ; ERR - SEG NOT FOUND
*
* IF BANKPAGE>=ST.BASE(SEG#) THEN FOUND!
*
					lda GSN.BKPG
					cmp ST.BASEL,X
					lda GSN.BKPG+1
					sbc ST.BASEH,X
					bcs GSN020
*
* SEG#:=ST.FLINK(SEG#); GOTO L1
*
					lda ST.FLINK,X
					beq GSN.ERR1 ; ERR - SEG NOT FOUND
					jmp GSN010
*
* RETURN SEG# TO CALLER
*
GSN020 LDY #0
					txa
					sta (GSN.NUM),Y
					clc
					rts; NORMAL EXIT
*
GSN.ERR RTS ; ERROR EXIT
*
GSN.ERR1				lda #SEGNOTFND
					jsr SYSERR ; ERROR EXIT
*PAGE
*REP 60
*
* RELEASE.SEG(IN.SEGNUM) SYSTEM CALL
*
*REP 60
*
RELEASE.SEG .eq *
*
* IF ST.FLINK(SEG#)=ST.FREE THEN ERR
*
					ldx RLS.NUM
					beq RLS.ALL ; RELEASE.SEG(SEG#=0)
					cpx #ST.CNT
					bcs RLS.ERR ; ERR - SEG# TOO LARGE

					lda ST.FLINK,X
					bmi RLS.ERR ; ERR - INVALID SEGNUM
					bpl REL.SEG ; RELEASE.SEG(SEG#>0)
*REP 35
*
* RELEASE ALL
*
*REP 35
RLS.ALL				ldx ST.ENTRY
					beq RLS0.EXIT
					stx RLS.NUM
*
RLS0.LOOP				lda ST.ID,X
					cmp #$10 ; CARRY SET/CLEARED HERE
*
					lda ST.FLINK,X
					pha
					bcc RLS006 ; IF ID=SYS SEG THEN SKIP
					jsr REL.SEG ; RELEASE ONE SEGMENT
RLS006 PLA
					beq RLS0.EXIT
					sta RLS.NUM
					tax
					bne RLS0.LOOP ; ALWAYS TAKEN
*
RLS0.EXIT CLC
					rts; NORMAL EXIT ; ALL NON SYSTEM SEGMENTS RELEASED.
*REP 35
*
* REL SEG
*
*REP 35
* Y:=ST.FLINK(SEG#)
* X:=ST.BLINK(SEG#)
*
REL.SEG TAY
					lda ST.BLINK,X
					tax
*
* IF X<>0 THEN ST.FLINK(X):=Y
* ELSE ST.ENTRY:=Y
*
					beq RLS010
					tya
					sta ST.FLINK,X
					jmp RLS020
RLS010 STY ST.ENTRY
*
* IF Y<>0 THEN ST.BLINK(Y):=X
*
					tya
RLS020 BEQ RLS030
					txa
					sta ST.BLINK,Y
*
* ST.FLINK(SEG#):=ST.FREE
* ST.FREE:=SEG# AND #$80
*
RLS030				lda ST.FREE
					ldx RLS.NUM
					sta ST.FLINK,X
					txa
					ora #$80
					sta ST.FREE
*
					clc
					rts; NORMAL EXIT
*
RLS.ERR				lda #BADSEGNUM
					jsr SYSERR ; ERR EXIT
*PAGE
*REP 60
*
* CONVERT INTERNAL BANK PAGE
*
* INPUT: EXTERNAL BANK (X)
* " PAGE (Y)
* OUTPUT: INTERNAL BKPG LOW (X)
* " BKPG HIGH (Y)
* REGION (A) 0=>VIRT BANK
* 1=>PHY BANK (0-$2000)

* 2=> " ($A000-$FFFF)
* ERROR: CARRY SET ("INVALID BANK PAGE")
*
*REP 60
*
CNVRT.IBP .eq *
*
* CONVERT FROM EXTERNAL TO INTERNAL FORMAT
*
* CASE OF BANK: ADD PAGE BIAS
*
					tya
					cpx #$F
					beq CNVI010
					bcs CNVI020
*
					cmp #$20 ; BANK < "F"
					bcc CNVI.ERR1
					cmp #$A0
					bcs CNVI.ERR1
					clc
					sbc #$20
					jmp CNVI030
*
CNVI010 CMP #$20 ; BANK = "F"
					bcs CNVI.ERR1
					clc
					adc #$80
					jmp CNVI030
*
CNVI020 CPX #$10 ; BANK = "10"
					bne CNVI.ERR1
					cmp #$A0
					bcc CNVI.ERR1
					clc
					sbc #$80
*
CNVI030 TAY ; SHIFT BANK RIGHT ONE BIT
					txa ; INTO HIGH BIT OF PAGE BYTE.
					lsr A
					tax
					tya
					bcc CNVI040
					ora #$80
*
* EXCHANGE X & Y
*
CNVI040 PHA
					txa
					tay
					pla
					tax
*
* COMPUTE REGION (VIRT=0,PHY1=1,PHY2=2)
*
					jsr REGION ; REGION RETURNED IN A REG.
					bcs CNVI.ERR1 ; ERR - INVALID BANK PAGE
*
					rts; NORMAL EXIT
*
CNVI.ERR1				lda #BADBKPG
					jsr SYSERR
*PAGE
*REP 60
*
* CONVERT EXTERNAL BANK PAGE
*
* INPUT: INTERNAL BKPG LOW (X)
* " HIGH (Y)
* OUTPUT: EXTERNAL BANK (X)
* " PAGE (Y)
* ERROR: NO ERROR CHECKING DONE. ASSUMES THAT INTERNAL #S
* ARE VALID.
*
*REP 60
*
CNVRT.XBP .eq *
*
* CONVERT FROM INTERNAL TO EXTERNAL FORMAT
*
					txa

					asl A
					txa
					and #$7F
					tax
					tya
					rol A
					tay
*
* CASE OF BANK: ADD PAGE BIAS
*
					txa
					cpy #$F
					beq CNVX020 ; BANK = "F"
					bcs CNVX010
*
					clc ; BANK < "F"
					adc #$20
					jmp CNVX020
*
CNVX010 CLC ; BANK = "10"
					adc #$80
*
* EXCHANGE X & Y
*
CNVX020 PHA
					tya
					tax
					pla
					tay
					rts; NORMAL EXIT
*PAGE
*REP 60
*
* REGION
*
* INPUT: INTERNAL BKPG LOW (X)
* " HIGH (Y)
* OUTPUT: REGION (A)
* INTERNAL BKPG LOW (X) UNCHANGED
* " HIGH (Y) "
* ERROR: CARRY SET ("INVALID BANK/PAGE")
*
*REP 60
*
REGION .eq *
					stx RGN.BKPG
					sty RGN.BKPG+1
*
* IF BANKPAGE>PHY2LIM THEN ERR
*
					lda #>PHY2LIM
					cmp RGN.BKPG
					lda #<PHY2LIM
					sbc RGN.BKPG+1
					bcc RGN.ERR ; ERR - INVALID BANK PAGE
*
* IF BANKPAGE>=PHY2BASE THEN REGION:=2
*
					lda RGN.BKPG
					cmp #>PHY2BASE
					lda RGN.BKPG+1
					sbc #<PHY2BASE
					bcc RGN010
					lda #2
					bne RGN040
*
* IF BANKPAGE>PHY1LIMIT THEN ERR
*
RGN010				lda #>PHY1LIM
					cmp RGN.BKPG
					lda #<PHY1LIM
					sbc RGN.BKPG+1
					bcc RGN.ERR ; ERR - INVALID BANK PAGE
*
* IF BANKPAGE>=PHY1BASE THEN REGION:=1
*
					lda RGN.BKPG
					cmp #>PHY1BASE
					lda RGN.BKPG+1
					sbc #<PHY1BASE
					bcc RGN020

					lda #1
					bne RGN040
*
* IF BANKPAGE>VIRTUAL LIMIT THEN ERR
*
RGN020				lda >VRT.LIM
					cmp RGN.BKPG
					lda >VRT.LIM+1
					sbc RGN.BKPG+1
					bcc RGN.ERR
					lda #0
*
RGN040 CLC ; "N" FLAG ALWAYS REFLECTS REGION VAL IN A REG!
					rts; NORMAL EXIT
*
RGN.ERR SEC ; INVALID BANK PAGE
					rts
*PAGE
*REP 60
*
* GET FREE
*
* INPUT: PREVIOUS SEG # (A)
* OUTPUT: NEW SEG # (A)
* ERROR: CARRY SET ("SEG TBL FULL")
*
*REP 60
*
GET.FREE .eq *
*
* SAVE PREV SEG # IN X
* NOTE: PREV SEG # CARRIED IN X
* NEW SEG # CARRIED IN Y
*
					tax
*
* IF NO FREE ENTRIES THEN ERR
*
					lda ST.FREE
					cmp #$80
					beq GTFR.ERR
*
* TURN OFF FREE FLAG (BIT7) AND DELINK FROM FREE LIST
*
					and #$7F
					tay
					lda ST.FLINK,Y
					sta ST.FREE
*
* IF PREV SEG # IS NULL THEN LINK NEW ENTRY TO				staRT
* OF SEGMENT LIST
*
					cpx #0
					bne GTFR010
					lda ST.ENTRY
					sta ST.FLINK,Y
					lda #0
					sta ST.BLINK,Y
					sty ST.ENTRY
					jmp GTFR020
*
* OTHERWISE LINK NEW ENTRY TO PREV SEG #
*
GTFR010				lda ST.FLINK,X
					sta ST.FLINK,Y
					txa
					sta ST.BLINK,Y
					tya
					sta ST.FLINK,X
*
* IF ST.FLINK(NEW)<>NULL THEN
* ST.BLINK(ST.FLINK(NEW)):=NEWSEG #
GTFR020				lda ST.FLINK,Y
					beq GTFR030
					lda ST.FLINK,Y
					tax
					tya
					sta ST.BLINK,X
*
* RETURN WITH NEW SEG #
*

GTFR030 TYA
					clc
					rts; NORMAL EXIT
*
GTFR.ERR				lda #SEGTBLFULL
					jsr SYSERR
*
*LST ON
ZZEND .eq *
ZZLEN .eq ZZEND-ZZORG
IFNE ZZLEN-LENMEMMG
FAIL 2,"SOSORG FILE IS INCORRECT FOR MEMMGR"
FIN

*************************************************************************
* END OF APPLE /// SOS 1.3 SOURCE CODE FILE: MEMMGR.C.SRC
*************************************************************************




================================================================================================
FILE: "SOS.OPRMSG.SRC.TEXT"
================================================================================================
*************************************************************************
* APPLE /// SOS 1.3 SOURCE CODE FILE: OPRMSG.SRC
*************************************************************************
* ASSEMBLER: APPLE ][ 6502 ASSEMBLER from APPLE COMPUTER TOOLKIT

*SBTL "SOS 1.1 OPERATOR MESSAGE/REPLY"
*REL
					INCLUDE SOSORG,6,1,254
ORG ORGOMSG
ZZORG .eq *
*MSB OFF
*REP 60
*
* COPYRIGHT (C) APPLE COMPUTER INC. 1981
* ALL RIGHTS RESERVED
*
*REP 60
*
* THIS MODULE CONTAINS THE BLOCK FILE MANAGERS'S OPERATOR
* INTERFACE. IT DISPLAYS A MESSAGE IN A FOUR LINE BY
* FOURTY COLUMN WINDOW, THEN WAITS FOR THE USER TO TOGGLE
* THE ALPHA-LOCK KEY BEFORE RETURNING.
*
* THE VERTICAL BLANKING FLAGS AND COMPOSITE BLANKING
* TIMER ARE USED TO MAINTAIN THE DISPLAY. MEMORY PAGE
* $02 IS USED FOR TEMPORARY STORAGE. ON EXIT, ALL
* RESOURCES ARE RESTORED TO THEIR PREVIOUS				staTES.
*
* ENTRY POINT: OPMSGRPLY
*
* PARAMETERS: X -- MESSAGE ADDRESS (LOW BYTE)
* Y -- MESSAGE ADDRESS (HIGH BYTE)
* (THE MESSAGE MUST RESIDE IN THE CURRENT BANK)
*
* RESULT: A -- RESPONSE KEYSTROKE
* X, Y -- UNDEFINED
*
*REP 60
*
*
*ENTRY OPMSGRPLY
*
*EXTRN SCRNMODE
*PAGE
*
* HARDWARE EQUATES
*
Z.REG .eq $FFD0
E.REG .eq $FFDF
*
KBPORT .eq $C008
*
BELL .eq $C040
*
VM0 .eq $C050
VM1 .eq $C052
VM2 .eq $C054
VM3 .eq $C056
*
E.T2 .eq $FFE8
E.ACR .eq $FFEB
E.PCR .eq $FFEC
E.IFR .eq $FFED
E.IER .eq $FFEE
*
* ZERO PAGE DECLARATIONS
*
DSECT
ZPBASE .eq $200
ORG $0000 ;ZERO PAGE DECLARATIONS
MSGPTR DS 2 ;MESSAGE POINTER
MSGIDX DS 1
*
SCRNIDX DS 1
SCRNPTR DS 2
DATAPTR DS 2

DATABUF DS 160
*
SV.ZREG DS 1
SV.EREG DS 1
SV.SMODE DS 1
SV.EACR DS 1
SV.EPCR DS 1
SV.EIER DS 1
*
FLAG DS 1
DEND
*PAGE
OPMSGRPLY .eq *
*
*
* SAVE CURRENT VALUES AND SET UP ZERO PAGE,
* ENVIRONMENT, SCREEN MODE, AND E.6522 REGISTERS.
*
					php
					sei
					lda Z.REG
					sta ZPBASE+SV.ZREG ;SAVE ZERO PAGE
					lda #<ZPBASE
					sta Z.REG
					stx MSGPTR ;SAVE MESSAGE ADDRESS
					sty MSGPTR+1
					lda E.REG
					sta SV.EREG ;SAVE ENVIRONMENT
					and #$5F
					ora #$40
					sta E.REG ;SCREEN OFF, I/O SPACE ON
					lda SCRNMODE
					sta SV.SMODE ;SAVE SCREEN MODE
					lda #$00
					sta SCRNMODE
					bit VM0 ;SET 40 COLUMN
					bit VM1 ; BLACK & WHITE TEXT
					bit VM2
					bit VM3
					ldx E.ACR
					txa
					and #$20
					sta SV.EACR ;SAVE AUXILIARY CONTROL REG
					txa
					ora #$20
					sta E.ACR ;SET UP BL TIMER
					ldx E.PCR
					txa
					and #$F0
					sta SV.EPCR ;SAVE PERIPHERAL CONTROL REG
					txa
					and #$0F
					ora #$60
					sta E.PCR ;SET UP VBL FLAGS
					lda E.IER
					and #$38
					sta E.IER ;MASK VBL & BL INTERRUPTS
					sta SV.EIER ;SAVE INTERRUPT MASKS
					plp
*
*
* SAVE SCREEN DATA AND CLEAR MESSAGE WINDOW
*
					ldx #3
OPR010				jsr SETPTRS
					ldy #39
OPR020				lda (SCRNPTR),Y ;SAVE SCREEN DATA
					sta (DATAPTR),Y
					lda #$A0
					sta (SCRNPTR),Y ;BLANK SCREEN
					dey
					bpl OPR020
					dex
					bpl OPR010
*
*
* MOVE MESSAGE TO WINDOW
*
					bit BELL
					ldx #$00
					stx MSGIDX

OPR100				jsr SETPTRS
					ldy #$00
					sty SCRNIDX
OPR110 LDY MSGIDX
					inc MSGIDX
					lda (MSGPTR),Y ;SET UP MESSAGE
					beq OPR110
					bmi OPR200
					cmp #$0D
					beq OPR120
					ldy SCRNIDX
					inc SCRNIDX
					ora #$80
					sta (SCRNPTR),Y
					cpy #39
					bcc OPR110
OPR120 INX
					cpx #4
					bcc OPR100
*
*
* DISPLAY MESSAGE UNTIL ALPHA-LOCK KEY TOGGLES
*
OPR200 LDY #2
					lda KBPORT
					and #$08
					sta FLAG
OPR210				jsr VIDEO
					lda KBPORT
					and #$08
					cmp FLAG
					beq OPR210
					sta FLAG
					dey
					bne OPR210
*
*
* RESTORE PREVIOUS CONTENTS OF WINDOW
*
					ldx #3
OPR400				jsr SETPTRS
					ldy #39
OPR410				lda (DATAPTR),Y
					sta (SCRNPTR),Y
					dey
					bpl OPR410
					dex
					bpl OPR400
*
*
* RESTORE E.6522, SCREEN MODE, ENVIRONMENT, & ZERO PAGE
* THEN RETURN TO CALLER
*
					php
					sei
					lda E.ACR
					and #$DF
					ora SV.EACR ;RESTORE AUXILIARY CONTROL REG
					sta E.ACR
					lda E.PCR
					and #$0F
					ora SV.EPCR ;RESTORE PERIPHERAL CONTROL REG
					sta E.PCR
					lda SV.EIER ;RESTORE INTERRUPT ENABLE REG
					ora #$80
					sta E.IER
					lda SV.SMODE ;RESTORE SCREEN MODE
					sta SCRNMODE
					lsr A
					bcc OPR500
					bit VM0+1 ;RESTORE VIDEO MODE
OPR500 LSR A
					bcc OPR510
					bit VM1+1
OPR510 LSR A
					bcc OPR520
					bit VM2+1
OPR520 BIT SCRNMODE
BVC OPR530
					bit VM3+1
OPR530				lda SV.EREG ;RESTORE ENVIRONMENT

					sta E.REG
					lda SV.ZREG ;RESTORE ZERO PAGE
					sta Z.REG
					plp
					rts
*PAGE
*REP 60
*
* SUBROUTINE VIDEO
*
* THIS SUBROUTINE POLLS THE VERTICAL-BLANKING AND
* COMPOSITE-BLANKING-TIMER FLAGS AND TURNS THE SCREEN
* OFF AND ON SO THAT ONLY THE MESSAGE WINDOW WILL BE
* DISPLAYED.
*
* THE E.6522 MUST BE INITIALIZED SO THAT E.CB2 FLAGS THE
* POSITIVE EDGE OF VBL AND E.T2 COUNTS BL PULSES. THE
* INTERRUPTS MUST BE MASKED AND THE PROPER COUNT MUST
* ALREADY BE STORED IN THE LOW ORDER BYTE OF E.T2.
*
* ENTRY: VIDEO
*
* PARAMETERS: INTERRUPT SYSTEM DISABLED
*
* EXIT: A -- UNDEFINED
* X, Y -- PRESERVED
*
*REP 60
*
VIDEO .eq *
					lda E.IFR
					and #$28 ;GET VBL & BL FLAGS
					beq VID030
					sta E.IFR ;CLEAR FLAGS
					and #$20 ;WHICH FLAG?
					bne VID010 ; BL
*
					lda #$1F
					sta E.T2 ;SET UP BL TIMER
					lda #$00
					sta E.T2+1
					lda E.REG
					ora #$20 ;SET UP FOR SCREEN ON
					clc
					bcs VID020
*
VID010				lda E.REG
					and #$DF ;SET UP FOR SCREEN OFF
					clc
*
VID020				sta E.REG
					lda #$00
					ror A
					sta SCRNMODE
VID030 RTS
*PAGE
*REP 60
*
* SUBROUTINE SETPTRS
*
* THIS SUBROUTINE SETS UP THE POINTERS TO THE MESSAGE
* WINDOW AND DATA SAVE AREA.
*
* ENTRY: SETPTRS
*
* PARAMETERS: X -- LINE NUMBER [0..3]
*
* EXIT: A -- UNDEFINED
* X, Y -- PRESERVED
*
*REP 60
*
SETPTRS .eq *
					txa
					lsr A
					ora #$04
					sta SCRNPTR+1
					lda #$00
					ror A
					sta SCRNPTR
					lda #<DATABUF

					sta DATAPTR+1
					lda DBUFADR,X
					sta DATAPTR
					rts
*
DBUFADR .eq *
DFB >0*40+DATABUF
DFB >1*40+DATABUF
DFB >2*40+DATABUF
DFB >3*40+DATABUF
*LST ON

ZZEND .eq *
ZZLEN .eq ZZEND-ZZORG
IFNE ZZLEN-LENOMSG
FAIL 2,"SOSORG FILE IS INCORRECT FOR OPRMSG"
FIN

*************************************************************************
* END OF APPLE /// SOS 1.3 SOURCE CODE FILE: OPRMSG.SRC
*************************************************************************




================================================================================================
FILE: "SOS.PATH.TEXT"
================================================================================================
*************************************************************************
* APPLE /// SOS 1.3 SOURCE CODE FILE: PATH
*************************************************************************
* ASSEMBLER: APPLE ][ 6502 ASSEMBLER from APPLE COMPUTER TOOLKIT

*PAGE
*
*
*
BFMGR				ldx COMMAND ; WHAT CALL?
*
*
*
					lda DISPTCH,X ; TRANSLATE INTO COMMAND ADDRESS
					asl A ; (BIT 7 INDICATES IT'S GOT A PATHNAME TO PREPROCESS)
					sta CMDTEMP
					and #$3F ; (BIT 6 IS REFNUM PREPROCESS, 5 IS FOR TIME, SO STRIP EM.)
					tax
					lda CMDTABLE,X ; MOVE ADDRESS FOR INDIRECT JUMP.
					sta CMDADR
					lda CMDTABLE+1,X ; (HIGH BYTE)
					sta CMDADR+1
					lda #<VCB
					sta VCBPTR+1 ; INSURE DEFAULT HI ADDRESS TO VCB BEFORE CALLS
					lda #BKBITVAL ; INIT "BACKUP BIT FLAG"
					sta BKBITFLG ; TO SAY "FILE MODIFIED"
					ldy #MAXTEMPS ; ZERO OUT SISTER PAGE FOR TEMPS
					lda #0
					sta SERR ; MAKE GLOBAL ERROR SAY "NONE"
					sta DSWGLOB ; "DISK SWITCH GLOBAL"
					sta DUPLFLAG ; "DUPLICATE VOLUME ON LINE"
					sta CFLAG ; SET "CREATE" TO NO
					sta BLOKSAVE
					sta BLOKSAVE+1 ; SET PARENT DIRECTORY TO NULL
CLRSIS				sta SISTEMPS,Y
					dey
					bpl CLRSIS ; CARRY IS UNDISTURBED BY THIS LOOP
					bcc NOPATH
					jsr SETPATH ; GO PROCESS PATHNAME BEFORE CALLING COMMAND
					bcs ERRORSYS ; BRANCH IF BAD NAME.
NOPATH ASL CMDTEMP ; TEST FOR REFNUM PREPROCESSING
					bcc NOPREREF
					jsr FINDFCB ; GO SET UP POINTERS TO FCB AND VCB OF THIS FILE.
					bcs ERRORSYS ; BRANCH IF ANY ERRORS ARE ENCOUNTERED.
NOPREREF ASL CMDTEMP ; LASTLY CHECK FOR NECESSITY OF TIME				staMP.
					bcc TSWVRFY
					ldx #DATELO ; PASS Z PAGE ADDRESS OF WHERE TO RETURN DATE/TIME
					jsr DATETIME ; (NO ERROR POSIBLE)
TSWVRFY				ldx COMMAND ; TEST FOR NECESSITY OF VOLUME VERIFICATION
					lda #PREPATH+PREREF+PRETIME ; TO ENSURE VCB IS SET
					and DISPTCH,X
					beq EXECUTE
					ldy #VCBSTAT
					lda (VCBPTR),Y
					and #DSWITCH ; WAS THE VOLUME PREVIOUSLY SWITCHED?
					beq EXECUTE
					dey ; GET DEVICE NUMBER
					lda (VCBPTR),Y
					sta DEVNUM
DVERIFY				jsr VERFYVOL ; SEE IF PROPER VOLUME NOW ON LINE
					bcc CLRDSWT ; BRANCH IF YES
					jsr USRREQ ; OTHERWISE REQUEST IT BE PUT ON LINE
					bcc DVERIFY ; USER SEZ S/HE DID: CHECK IT OUT
					lda #VNFERR ; VOLUME NOT FOUND IF USER REFUSES
					bne ERRORSYS ; REPORT ERROR (BRANCH ALWAYS)
CLRDSWT LDY #VCBSTAT ; GET VOLUME
					lda (VCBPTR),Y ;				staTUS
					and #$FF-DSWITCH ; TURN OFF DISK SWITCH
					sta (VCBPTR),Y ; SO WE WON'T VERIFY NEXT TIME
EXECUTE				jsr GOCMD ; EXECUTE COMMAND
					bcc GOODOP ; BRANCH IF SUCCESSFUL
					cmp #XDISKSW ; DISK SWITCH?
					bne ERRORSYS ; NO, REPORT SOME OTHER
					ldy #VCBSTAT ; MARK VCB WITH SWITCH
					lda (VCBPTR),Y
					and #$FF-DSWITCH ; TO ENSURE VOLUME VERIFIED

					bpl ERRCMD ; NO FILES OPEN SO DSWITCH CANT APPLY
					ora #DSWITCH
ERRCMD				sta (VCBPTR),Y
					jmp BFMGR ; TRY THE COMMAND AGAIN
*
ERRORSYS				jsr SYSERR
GOODOP RTS ; GOOD RETURN
*
GOCMD JMP (CMDADR)
*
*PAGE
*
CMDTABLE .eq *
DW CREATE
DW DESTROY
DW RENAME
DW SETINFO
DW GETINFO
DW VOLUME
DW SETPREFX
DW GETPREFX
DW OPEN
DW NEWLINE
DW READ
DW WRITE
DW CLOSE
DW FLUSH
DW SETMARK
DW GETMARK
DW SETEOF
DW GETEOF
*
DISPTCH .eq *
DFB PREPATH+PRETIME+0 ; CREATE
DFB PREPATH+PRETIME+1 ; DESTROY
DFB PREPATH+PRETIME+2 ; RENAME
DFB PREPATH+PRETIME+3 ; SETINFO
DFB PREPATH+4 ; GETINFO
DFB 5 ; VOLUME
DFB 6 ; SETPREFIX, PATHNAME MOVED TO PREFIX BUFFER
DFB 7 ; GETPREFIX
DFB PREPATH+8 ; OPEN
DFB PREREF+$9 ; NEWLINE
DFB PREREF+$A ; READ
DFB PREREF+$B ; WRITE
DFB PRETIME+$C ; CLOSE
DFB PRETIME+$D ; FLUSH, REFNUM MAY BE ZERO TO FLUSH ALL.
DFB PREREF+$E ; SETMARK
DFB PREREF+$F ; GETMARK
DFB PREREF+$10 ; SET EOF
DFB PREREF+$11 ; GET EOF
*
*PAGE
*
SETPATH				lda C.PATH ; FOR A REGULAR PATHNAME,
					sta TPATH ; SET UP TEMP POINTER TO PROCESS
					lda C.PATH+1 ; PATHNAME AND CHECK FOR SYNTAX ERRORS
					sta TPATH+1
					lda SISPATH
					sta SISTPATH ; (LEAVE CALL PARAMETERS ALONE!)
* DROP INTO 'SYNPATH'
*
SYNPATH				lda #>PATHBUF ; SET UP DEFAULT ADDRESS FOR
					sta PATHNML ; SYNTAXED PATHNAME -
					sta WRKPATH ; LENGTH, NAME, LENGTH, NAME, ETC...
					lda #<PATHBUF
					sta PATHNMH
					sta WRKPATH+1 ; (ASSUMES FULL PATHNAME, NO PREFIX).
					ldx #0 ; USE INDEXED INDIRECT FOR SOURCE PATHNAME
					txa ; SET BEGINNING OF PATH
					sta (PATHNML,X) ; TO ZERO TO INDICATE NOTHING PROCESSED.
					tay
					lda (TPATH,X) ; GET TOTAL LENGTH OF SOURCE PATHNAME
					bmi ERRSYN
					beq ERRSYN
					sta PATHCNT ; (THIS IS USED AS A 'COUNT-DOWN')
					jsr INCTPTH ; INCREMENT SOURCE POINTER
					lda (TPATH,X) ; GET FIRST CHARACTER OF PATHNAME
					cmp #DLIMIT ; IS IT A FULL PATHNAME (NO PREFIX)?
					beq BUMPATH ; YES, WE'RE READY TO DO IT.
					cmp #$2E ; IS IT A DRIVE NAME '.'?

					bne ADPREFIX ; NO, ADD PREFIX TO BEGINNING
DRIVENAM				lda (TPATH,X) ; MOVE DRIVE NAME FOR VOLUME CALL
					cmp #DLIMIT ; HAVE WE MOVED ENTIRE NAME?
					beq PREVOLM ; YES, PROCESS IT.
					iny ; (IF THIS IS THE FIRST, MAKE ROOM FOR LENGTH OF NAME)
					sta (WRKPATH),Y
					jsr INCTPTH ; BUMP POINTER TO GIVEN NAME.
					dec PATHCNT
					bne DRIVENAM
					beq PREVOLM1
*
*PAGE
PREVOLM				jsr INCTPTH ; MAKE IT SO POINTING PAST DELIMITER.
					dec PATHCNT
PREVOLM1 TYA ; SAVE LENGTH OF DRIVE NAME.
					sta (WRKPATH,X)
					lda #>PATHBUF ; POINT AT PATHNAME BUFFER FOR DEVICE ID CALL.
					sta DVNAMP
					lda #<PATHBUF
					sta DVNAMP+1
					lda #0 ; MAKE VIRTUAL POINT AT SWITCHED IN BANK.
					sta SISTER+DVNAMP+1
					jsr SRCHDEV ; GO IDENTIFY WHICH VOLUME
					bcc PREVOLM2 ; BRANCH IF NO ERROR
					cmp #VNFERR ; WAS IT REPORTED AS 'VOLUME NOT FOUND'?
					bne SPTHERR ; NO SOME OTHER ERROR WAS ENCOUNTERED.
					ldx DUPLFLAG ; YES, WAS IT NOT FOUND BECAUSE SOME OTHER 'OPEN' VOLUME HAS SAME NAME?
					beq SPTHERR ; NO, IT SIMPLY WASN'T FOUND.
					lda #DUPVOL ; (CARRY IS SET)
					rts
*
PREVOLM2 LDY #0 ; (X CONTAINS AN INDEX TO VCB)
					lda VCB,X ; GET VOLUME NAME LENGTH.
					sta PATHBUF,Y
SPATH2 INX ; MOVE VOLUME NAME INTO PATH NAME BUFFER IN
					iny ; PLACE OF DISK DEVICE NAME ('.D1' OR SIMULAR)
					lda VCB,X
					sta PATHBUF,Y
					cpy PATHBUF ; HAVE ALL CHARACTERS BEEN MOVED?
					bne SPATH2
					ldx #0 ; RESET X FOR INDEXING
					stx PATHNML
					lda #<PATHBUF
					sta PATHNMH
					lda PATHCNT ; IS THAT ALL THERE IS?
					bne SPATH3 ; NO, MORE TO COME...
					clc
					jmp ENDPATH
*
SPATH3 INY ; BUMP TO END OF NAME+1
					sty WRKPATH ; RESET WORKPATH POINTER TO CURRENT.
					lda #0 ; RESET PATHNAME BUFFER POINTER.
					ldy #<PATHBUF
					bne NOPREFX ; BRANCH ALWAYS...
*
ERRSYN				lda #BADPATH ; RETURN SYNTAX ERROR
SPTHERR SEC
					rts
*
ADPREFIX				lda PFIXPTR ; GET POINTER TO BEGINNING OF THE
					ldy PFIXPTR+1 ; PREFIX.
NOPREFX				sta PATHNML
					sty PATHNMH ; IF NO PRESET PREFIX, THIS IS THE SAME AS
					bne FRSTCHAR ; PATHBUF ADDRESS. (BRANCH ALWAYS TAKEN)
*
*PAGE
*
BUMPATH DEC PATHCNT ; FIRST ADJUST COUNT
					clc ; (JUST IN CASE OF LAST CHARACTER)
					beq ENDPATH ; (MUST OF HAD TRAILING SPACES)
					jsr INCTPTH
FRSTCHAR LDY #0 ; INIT COUNT FOR THIS PORTION OF THE
					tya ; PATHNAME. ALSO PRESET LENGTH TO ZERO IN
					sta (WRKPATH,X) ; CASE OF TRAILING SPACES.
					lda (TPATH,X) ; GET CHARACTER.
					and #$7F ; IGNORE HIGH BIT.
					cmp #$20 ; IS IT A LEADING SPACE?
					beq BUMPATH ; IF SO, IGNORE IT.
					cmp #$5B ; IS IT GREATER THAN (UPPER CASE) A 'Z'?
					bcc ALFA1 ; NO, MAKE SURE IT'S AN ALPHA CHARACTER
					and #$5F ; YES, ASSUME IT'S LOWER CASE, AND UPSHIFT

					cmp #$5B ; WAS IT TRULY LOWER CASE?
					bcs ERRSYN ; NO, GIVE ERROR.
*
ALFA1 CMP #$41 ; IS IT LESS THAN 'A'?
					bcc ERRSYN ; YES! IT'S CRAP...
					bcs SAVPATH ; NO, IT'S GOOD. SAVE IT.
*
NXTCHAR				lda (TPATH,X) ; GET THE NEXT CHARACTER.
					and #$7F ; THESE CHARACTERS MAY BE ALPHA, NUMERIC,
					cmp #$5B ; OR A PERIOD - ONLY THE FIRST HAD TO BE ALPHA
					bcc ALFA2 ; BRANCH IF LESS THAN 'Z'
					and #$5F ; UPSHIFT LOWER CASE.
					cmp #$5B ; NOW IS IT VALID?
					bcs ERRSYN ; NOPE.
*
ALFA2 CMP #$41 ; IS IT GREATER THAN 'A'?
					bcs SAVPATH ; YUP, IT IS WORTH SAVIN.
					cmp #$3A ; >9?
					bcs TSTDLIM ; YES
					cmp #$30 ; NO, <0?
					bcs SAVPATH ; NO, IT'S VALID NUMERIC.
TSTDLIM CMP #DLIMIT ; IS IT THE DELIMITER?
					beq ENDPATH ; YES. CARRY SET INDICATES MORE TO COME.
					cmp #$2E ; IS IT A '.' (PERIOD)?
					bne ERRSYN ; NO, IT'S AN ERROR (#@&##@!)
SAVPATH CLC
					iny ; BUMP NAME LENGTH
					sta (WRKPATH),Y
					dec PATHCNT ; IF ZERO, THAT WAS THE LAST CHARACTER
					beq ENDPATH ; (CARRY CLEAR INDICATES END OF PATH)
					inc TPATH ; BUMP POINTER TO SOURCE PATHNAME.
					bne NXTCHAR
					inc TPATH+1 ; HIGH ORDER, WHEN NECESSARY.
					bne NXTCHAR ; BRANCH ALWAYS.
*PAGE
*
ENDPATH TYA ; GET CURRENT NAME LENGTH
					sta (WRKPATH,X) ; AND PUT IT IN FRONT OF NAME
					bcc LSTNAME ; BRANCH IF THAT WAS THE LAST OF PATH
					cmp #$10 ; WAS THE NAME ILLEGALLY LONG?
					bcs ERRSYN1 ; YES, REPORT IT.
					ldy #0
					clc ; ADJUST WORK POINTER TO END OF PREVIOUS NAME.
					adc WRKPATH
					sta WRKPATH ; REPLACE OLD POINTER.
					bcc BUMPATH ; DO NEXT NAME.
					lda #TOOLONG ; THIS IS A NEVER ERROR!
					jsr SYSDEATH ; (NEVER RETURNS).
*
LSTNAME BEQ TSTVALD
					cmp #$10 ; MAKE SURE LAST ISN'T TOO LONG
					bcs ERRSYN1
					iny ; PUT A ZERO AT END OF PROCESSED PATHNAME
					lda #0
TSTVALD				sta (WRKPATH),Y
					lda (PATHNML,X) ; SURE THERE IS A PATHNAME
					beq ERRSYN1 ; IF NOT, REPORT ERROR.
					clc ; INDICATE NO ERROR.
					rts
*
ERRSYN1 JMP ERRSYN
*
					incTPTH INC TPATH ; POINT AT NEXT CHARACTER
					bne INCPTH1
					inc TPATH+1
					incPTH1 RTS
*
*PAGE
SETPREFX				jsr SETPATH ; CALL IS MADE HERE SO A 'NUL' PATH MAY BE DETECTED.
					bcc SETPRFX1 ; BRANCH IF PATHNAME OK
					tax; SAVE ERROR CODE
					ldy #0
					lda (C.PATH),Y ; TEST FOR A NUL PATHNAME
					beq RESETPFX ; BRANCH IF PREFIX TO BE RESET.
					txa ; RESTORE ERROR CODE
					rts
RESETPFX				sta PFIXPTR
					clc
					rts
SETPRFX1				lda PATHNML ; MAKE SURE NAME				staRTED WITH A '/' DELIMITER.
					bne ERRSYN1 ; BRANCH IF IT DID.

					ldy WRKPATH ; FIND THE END OF THE INPUT PREFIX
					clc ; ADD LAST LOCAL NAME LENGTH TO FIND TRUE END.
					lda (PATHNML),Y
					bne SETPRFX3
					dey
					tya
					bne SETPRFX4
SETPRFX3 ADC WRKPATH
					tay
SETPRFX4 EOR #$FF ; GET COMPLIMENT TO FIND BEGINNING ADDRESS.
					sta PFIXPTR ; OF NEW PREFIX IN THE PREFIX BUFFER
					sta WRKPATH ; (PREFIX ALWAYS ENDS AT THE LAST BYTE OF BUFFER)
MOVPRFX				lda (PATHNML),Y
					sta (WRKPATH),Y ; MOVE IN NEW PREFIX
					dey
					bpl MOVPRFX
					clc ; AND WE'RE FINISHED!
					rts; NO ERRORS POSIBLE FROM THIS ROUTINE.
*
*PAGE
*
GETPREFX CLC ; CALCULATE HOW BIG A BUFFER IS NEEDED TO
					lda PFIXPTR ; PASS THE PREFIX BACK TO THE USER.
					eor #$FF ; (EVEN IF NO PREFIX, 1 BYTE IS NEEDED TO SHOW 0 LENGTH)
					adc #2 ; ADD 2 FOR LEADING AND ENDING "/".
					cmp C.MAXPTH ; IS THERE ENOUGH SPACE IN USER'S BUFFER?
					bcc SENDPRFX ; BRANCH IF YES
					lda #BTSERR ; TELL USER BUFFER IS TOO SMALL.
					rts; (CARRY IS SET TO INDICATE ERROR.)
*
SENDPRFX LDY #0 ; SAVE TOTAL LENGTH OF STRING TO BE RETURNED
					sta (C.PATH),Y
					tay
					dey ; DISCOUNT TRAILING DELIMITER.
					beq NULPREFX ; BRANCH IF PREFIX IS SET TO NUL.
					iny
					ldx PFIXPTR ; GET BEGINNING ADDRESS OF PREFIX AGAIN
					dex
					stx WRKPATH
					lda #<PATHBUF
					sta WRKPATH+1
SNDLMIT				lda #DLIMIT ; PLACE DELIMITER BEFORE, BETWEEN, AND AFTER LOCAL NAMES.
					sta (C.PATH),Y
SNDPRFX1 DEY
					beq GOTPRFX ; BRANCH IF ALL OF PREFIX IS TRANSFERED.
					lda (WRKPATH),Y
					sta (C.PATH),Y ; ASSUME IT'S A CHARACTER.
					and #$F0 ; NOW TEST TO SEE IF IT WAS A LOCAL LENGTH.
					beq SNDLMIT ; BRANCH IF IT WAS.
					bne SNDPRFX1 ; GO MOVE NEXT CHAR IF IT WASN'T (ALWAYS TAKEN).
NULPREFX TYA ; RETURN NUL STRING.
					sta (C.PATH),Y
GOTPRFX CLC ; INDICATE NO ERROR.
					rts
*PAGE
*
FINDFCB				lda FCBADDRH ; INITIALIZE INDIRECT POINTER TO
					sta FCBPTR+1 ; FILE CONTROL BLOCK (ALLOCATED WHEN SYSTEM
					lda #0 ; WAS FIRST BOOTED).
					sta FCBPTR ; NOTE: ALWAYS				staRTS ON PAGE BOUNDARY.
					lda FCBANKNM ; SET SISTE PAGE BYTE TOO...
					sta SISFCBP
					ldy C.REFNUM ; GET REQUESTED REFERENCE
					bmi ERRNOTBLK ; BRANCH IF IT'S NOT A BLOCK DEVICE REFERENCE
					dey ; (SHOULD BE IN THE RANGE OF 1-16 BEFORE DECREMENT)
					cpy #$10 ; IS IT A VALID REFNUM?
					bcs REEFER ; NO, THE USER'S SMOKIN DOPE!
					tya ; TO FIND ASSOCIATED FILE CONTROL STUFF,
					asl A ; MULTIPLY (REFNUM-1) BY 32.
					asl A
					asl A
					asl A
					asl A
					bcc SVFCBLO ; BRANCH IF IT'S WITHIN FIRST HALF OF FCB
					inc FCBPTR+1 ; BUMP TO SECOND HAVE (REFNUM>8)
SVFCBLO				sta FCBPTR ; SAVE LOW ADDRESS OF REFERENCED FCB
					lda C.REFNUM ; NOW VERIFY THAT FILE IS OPEN.
					ldy #FCBREFN
					cmp (FCBPTR),Y ; SHOULD BE EQUAL!
					bne ERRNOREF ; BRANCH IF THEY'RE NOT
FNDFCBUF LDY #FCBBUFN ; IT'S A LEGAL FILE, NOW SET UP

					lda (FCBPTR),Y ; INDIRECT POINTERS TO DATA
GTBUFFRS				ldx #DATPTR ; (AND INDEX) BUFFER(S) IN ZERO PAGE
					jsr GETBUFADR ; GET BUFFER ADDRESS UNLESS
					bcs REEFER1 ; BOB HAS BEEN SMOKIN DOPE...
					lda #2 ; (ASSUME AN INDEX BLOCK BUFFER IS ALSO PRESENT)
					adc DATPTR+1
					sta TINDX+1
					lda DATPTR
					sta TINDX
					lda SISDATP
					sta SSTIDXH
					ldy #FCBDEVN
					lda (FCBPTR),Y ; MAKE SURE DEVICE
					sta D.DEV ; NUMBER TEMPS MATCH
					sta DEVNUM ; CURRENT FILE'S DEVICE
					lda #0 ; LOOK AT ALL VOLUMES LOGGED IN
FNDFVOL TAX
					lda VCB+VCBDEV,X ; GET VOLUMES DEVICE NUMBER
					cmp (FCBPTR),Y ; HVE WE FOUND A MATCH.
					bne FNDFV1
					ldy #FCBSWAP ; SWAP BYTES
					lda VCB+VCBSWAP,X ; MISMATCH
					cmp (FCBPTR),Y ; MEANS FILE BELONGS
					bne FNDFV.1 ; TO ANOTHER VOLUME
					lda VCB,X ; IS THIS AN OPEN DEVICE?
					beq FNDFV.1 ; NO, TRY ANOTHER VOLUME
					jsr FVOLFOUND ; YES, SAVE VCB ADDRESS
					lda VCB+VCBSWAP,X ; SWAPPED?
					beq REEFER1 ; NO, RETURN CALMLY TO USER
					jsr SWAPIN ; YES, SWAP ME IN
					bcc REEFER1 ; RETURN WITHOUT ERROR
					lda #XIOERROR ; USER REFUSED TO MOUNT PROPER VOLUME
					rts
*
FNDFV.1 LDY #FCBDEVN ; RELOAD Y WITH DEVICE INDEX
FNDFV1 TXA
					clc
					adc #VCBSIZE
					bcc FNDFVOL ; LOOP UNTIL FOUND
					lda #VCBERR ; OTHERWISE DIE A SYSTEM DEATH!
					jsr SYSDEATH
*PAGE
*
ERRNOREF				lda #0 ; DROP A ZERO INTO THIS FCB TO
					sta (FCBPTR),Y ; SHOW FREE FCB
*
REEFER				lda #BADREFNUM ; TELL USER THAT REQUESTED REFNUM
					clc ; IS ILLEGAL (OUT OF RANGE) FOR THIS CALL.
REEFER1 RTS
*
ERRNOTBLK				lda #NOTBLKDEV ; TELL USER THAT SPECIFIED DEVICE IS NOT A BLOCK DEVICE
					clc
					rts
*
SVCBADR .eq *
FVOLFOUND STX VCBPTR
					lda #VCB/256
					sta VCBPTR+1
					clc ; INDICATE LEGAL REFNUM
					rts
*PAGE
* NAME : GETDNUM
* FUNCTION: GET DEVICE NUMBER
* INPUT : DVNAMP SETUP
* OUTPUT : DEVNUM IN 'SCRTCH'
* : 'BPL' IF NOT BLOCK DEV
* : 'BCS' IF NO DEVICE
* VOLATILE: ALL REGS
*
GETDNUM .eq *
					lda #>SCRTCH+1 ; SET UP POINTER TO SCRATCH AREA
					sta DVDNUM ; TO RECIEVE DEVICE NUMBER.
					lda #SCRHIGH
					sta DVDNUM+1
					lda #0 ; PLACE A ZERO IN BANK BYTE SINCE
					sta SISTER+DVDNUM+1 ; IT'S NOT IN A BANK.
					sta VCBPTR+1
					lda #4 ; THE 'GET.DNUM' COMMAND.
					sta DHPCMD
					jsr RPEATIO0 ; CALL BOB FOR THE INFO.
					rts; RETURN WITH DEVMGR CC'S

*PAGE
*
* NAME : SRCHDEV
* FUNCTION: SEARCH FOR A VOLUME
*
SRCHDEV .eq *
					jsr GETDNUM ; GET DEVNUM
					bcs VOLERR1 ; BRANCH IF ANY ERROR OTHER THAN NOTBLOCKDEV
					bpl ERRNOTBLK ; BRANCH IF NOT A BLOCK DEVICE
					lda #0 ; NOW SEARCH FOR A VOL WITH THE
					sta NFOPEN ; INIT TEMP VCB POINTER
VOLOOK TAX ; SAME DEVNUM AS SCRTCH
					lda VCB+VCBSTAT,X ; ANY FILES OPEN?
					bne VLOOK00 ; BRANCH IF SOME FILE OPEN
					stx NFOPEN ; ELSE SAVE THE VCB ENTRY PTR
VLOOK00 .eq *
					lda VCB+VCBSWAP,X ; VOLUME SWAPPED OUT?
					bne VNOTEQ ; YES, CANT BE THE ACTIVE VOL
					lda VCB+VCBDEV,X
					eor SCRTCH+1
					beq VLOOK0 ; BRANCH IF MATCH.
VNOTEQ				lda VCB,X ; IS THIS A FREE VCB?
					bne VLOOK2 ; BRANCH IF NOT FREE, OTHEWISE TAKE NEXT BRANCH.
VLOOK0 EOR VCB,X ; TEST FOR A VOLUME NAME LENGTH
					beq VLOOK1 ; BRANCH IF VCB FREE
					jsr SVCBADR ; SAVE CURRENT ADDRESS OF VCB.
					lda VCB+VCBSTAT,X ; TEST FOR ANY OPEN FILES.
					bpl VLOOK3 ; LOG THE VOLUME IN JUST TO BE SURE
					lda SCRTCH+1 ; SET UP
					sta DEVNUM ; DEVICE NUMBER ARGUMENT
					txa ; SAVE PTR TO VCB
					pha; ON				staCK
					jsr VERFYVOL ; COMPARES VCBPTR TO DEVNUM CONTENTS
					bcc VNOSWIT
					cmp #VNFERR ; SEE IF NOTHING IN DRIVE
					beq VLOOK7 ; BRANCH IF NOTHING IN DRIVE
					jsr TSTSOS ; IS THE VOLUME AN UNRECOGNIZED SOS OR (UCSD OR DOS)?
					bcs KNOTSOS ; DEFINITELY NOT SOS FORMAT
					ldx #0 ;				staRT VCB SCAN AT BEGINNING
					jsr SNSWIT1 ; FIND A FREE VCB AND LOG IN THE NEW GUY
					bcs VNOSWIT1 ; CAN'T LOG IN NEW GUY--KEEP OLD
					pla
					ldx VCBPTR ; PASS BACK X AS NEW VCB
					rts
*
NFOPEN DS 1 ; TEMP VCB PTR FOR VCB W/ NO FILES OPEN
*
VNOSWIT CLC ; RETURN IT TO USER
					pla ; REMEMBER OLD VCB PTR
					tax; AND PASS BACK TO USER
					rts
; RETURN TO CALLER X=POINTER TO VCB.
*
VOLERR1 SEC ; RETURN SOME VOLUME ERROR
					rts
VNOSWIT1 CMP #DUPVOL
					bne VLOOK7 ; REPORT OTHER ERROR FROM LOGGING IN NEW VOL AS VNF
					tax
					pla ; MAKE				staCK CORRECT
					txa ; RESTORE ERROR CODE
					clc
					rts; IF DUPLICATE VOLUME ERROR, RETURN FACT TO USER
KNOTSOS PLA ; MAKE				staCK CORRECT
					lda #NOTSOS ; FOR THE PASCAL FOLK
					rts; NOTSOS MEANS UCSD OR DOS OR BAD SOS VOLUME
*
VLOOK7 PLA ; THROW AWAY OLD VCB PTR
					jmp NOVOLM ; AND REPORT VOLUME NOT FOUND
*
VLOOK1				jsr SVCBADR ; SAVE ADDRESS OF FREE VCB.
VLOOK2 TXA ; BUMP TO NEXT VOLUME ENTRY.
					clc
					adc #VCBSIZE
					bcc VOLOOK ; BRANCH IF MORE TO CHECK.
					ldx VCBPTR+1 ; FREE VCB YET FOUND?
					bne VLOOK3 ; BRANCH IF YES
					ldx NFOPEN ; SAVE POSSIBLE FREE VCB
					jsr SVCBADR ; AND SAVE PTR PERMANENTLY
VLOOK3				lda VCBPTR+1 ; WAS A FREE VCB FOUND?
					beq NOVOLM ; BRANCH IF VOLUME CAN'T BE LOGGED IN.
					lda SCRTCH+1 ; GET DEVICE NUMBER

					sta DEVNUM ; SAVE DEVICE NUMBER.
					lda #1 ; FAKE OUT 'LOKVOL'
					sta SCRTCH ; TO THINK TO LOOK ONLY ONCE.
					sta TOTDEVS
					lda #<VCB
					sta VCBPTR+1
					sta PATHNMH ; (TO MAKE HARMLESS)
					lda #0
					sta SISTER+PATHNMH
					ldx VCBPTR
					stx PATHNML
					sta VCB,X ; FORCE CURRENT VOLUME OFF LINE, THEN LOG WHATS THERE.
					jsr FREEVCB ; GO READ ROOT DIRECTORY.
					bcs RTVOLNAM ; RETURN ANY ERRORS
					ldx VCBPTR ; MAKE SURE VOLUME WAS LOGGED IN
					lda VCB,X
					beq NOVOLM ; RETURN ERROR
					rts; ELSE RETURN NORMALLY
NOVOLM				lda #VNFERR ; TELL USER 'NO VOLUME'
					clc
RTVOLNAM TAX ; SAVE REAL ERROR WHILE DUPLICATE IS CHECKED
					lda DUPLFLAG
					beq RTV1 ; BRANCH IF NOT DUPLICATE
					ldx #DUPVOL
RTV1 TXA ; RECALL ERROR
					rts

CHN VOLUME,4,1

*************************************************************************
* END OF APPLE /// SOS 1.3 SOURCE CODE FILE: PATH
*************************************************************************




================================================================================================
FILE: "SOS.POSN.OPEN.TEXT"
================================================================================================
*************************************************************************
* APPLE /// SOS 1.3 SOURCE CODE FILE: POSN.OPEN
*************************************************************************
* ASSEMBLER: APPLE ][ 6502 ASSEMBLER from APPLE COMPUTER TOOLKIT

*PAGE
GETMARK LDY #FCBMARK ; MOVE CURRENT POSITION MARKER TO
GMARK1				lda (FCBPTR),Y ; USER'S 4 BYTE BUFFER POINTED TO BY
					pha; C.MRKPTR IN SOS ZPAGE
					iny
					cpy #FCBMARK+3 ; USE				staCK AS TEMPORARY STORAGE FOR THREE BYTE
					bne GMARK1 ; POSITION VALUE.
					lda #0 ; THE FOURTH (HIGHEST ORDER) BYTE IS ALWAYS ZERO.
					ldy #3
					pha
MOVMRK PLA
					sta (C.MRKPTR),Y ; MOVE TO USER'S SPACE
					dey ; IS THERE ANOTHER TO PULL FROM				staCK?
					bpl MOVMRK ; YES, GET NEXT LOWER BYTE FROM				staCK.
					clc ; INDICATE NO ERROR.
					rts
*
SETMARK				jsr ADJMARK ; MAKE ADJUSTMENTS TO REQUESTED MARK ACCORDING TO BASE.
					bcc SMARK1 ; BRANCH IF ADJUSTMENT WAS VALID.
					rts
SMARK1				ldx #2 ; NOW COMPARE END OF FILE WITH NEW
					ldy #FCBEOF+2 ; POSITION TO BE SURE IT'S WITHIN
CMPEOF				lda TPOSLL,X ; THE BOUNDS OF CURRENTLY DEFINED
					cmp (FCBPTR),Y ; LIMITS.
					bcc CKSAMBLK ; BRANCH IF MARK<EOF
					bne ERRMEOF ; RETURN ERROR IF MARK>= EOF
					dey
					dex
					bpl CMPEOF
					bmi CKSAMBLK ; BRANCH ALWAYS
ERRMEOF				lda #POSNERR ; TELL USER MARK IS OUT OF RANGE.
					rts; (CARRY IS SET TO INDICATE ERROR)
*
ADJMARK				lda C.MARK+3 ; MAKE SURE FOURTH BYTE OF DISPLACE IS ZIP
					bne ERRPOSN ; BRANCH TO ERR IF NOT
					ldx #$FD ; ANTICIPATE OTHER THAN BASE OF ZERO
					ldy #FCBMARK ; FURTHER ASSUME IT'S A BASE OFFSET FROM CURRENT POSITION
					lda C.BASE ; NOW FIND OUT WHAT IT REALLY IS.
					lsr A ; (CARRY SET=SUBTRACT, NON ZERO REMAINDER= OFFSET FROM EOF)
					bcs SUBMARK
					beq ADJMRK ; BRANCH IF MARK IS FROM BEGINNING OF FILE
ADDPOSN				lda (FCBPTR),Y ; ADD USER QUANTITY TO CURRENT
					adc C.MARK+3,X ; POSITION TO FORM NEW POSITION.
					sta >TPOSLL-$FD,X ; (NOTE: ZERO PAGE REFERENCE WRAPS AROUND IN Z-PAGE)
					iny
					inx
					bne ADDPOSN ; ADD ALL THREE BYTES
					bcs ERRPOSN ; BRANCH IF OVERFLOW
					beq ADJMRK1 ; BRANCH ALWAYS
*
*PAGE
SUBMARK BNE SUBPOSN ; BRANCH IF IT'S AN OFFSET FROM CURRENT POSITION
					ldy #FCBEOF ; OTHERWISE ASSUME OFFSET FROM END OF FILE.
SUBPOSN				lda (FCBPTR),Y ; SUBTRACT USER QUANTITY TO FORM
					sbc C.MARK+3,X ; NEW POSITION. IF FINAL
					sta >TPOSLL-$FD,X ; RESULT IS L.T. ZERO, THEN REPORT
					iny ; POSITION ERROR...
					inx
					bne SUBPOSN
					bcs ADJMRK1 ; BRANCH IF LEGAL POSITION CALCULATED.
ERRPOSN				lda #POSNERR
					clc ; INDICATE ERROR
					rts
*
ADJMRK				ldx #2 ; FIRST SET UP POSITION TEMPS USED
ADJMRK0				lda C.MARK,X ; BY BOTH POSITION ROUTINES
					sta TPOSLL,X
					dex
					bpl ADJMRK0
ADJMRK1 CLC ; NO ERRORS
					rts

*
*
RDPOSN .eq *
CKSAMBLK .eq *
					ldy #FCBMARK+1 ; FIRST TEST TO SEE IF NEW POSITION IS
					lda (FCBPTR),Y ; WITHIN THE SAME (CURRENT) DATA BLOCK.
					and #$FE
					sta SCRTCH
					iny ; BUMP TO ACCESS HIGHEST ORDER ADDRESS BYTE
					lda TPOSLH ; GET MIDDLE BYTE OF NEW POSITION
					clc
					sbc SCRTCH
					sta SCRTCH
					bcc TYPMARK ; BRANCH IF POSSIBLY L.T. CURRENT POSITION
					cmp #2 ; MUST BE WITHIN 512 BYTES OF BEGINNING OF CURRENT
					bcs TYPMARK
					lda TPOSHI ; NOW MAKE SURE WERE TALKIN ABOUT
					cmp (FCBPTR),Y ; THE SAME 64K CHUNK!
					bne TYPMARK ; BRANCH IF WE AREN'T.
					jmp SVMARK ; IF WE IS, ADJUST FCB AND POSPTR AND RETURN.
*
TYPMARK LDY #FCBSTYP ; NOW FIND OUT WHICH TYPE
					lda (FCBPTR),Y ; OF FILE WE'RE POSITIONING ON.
					beq FERRTYP ; THERE IS NO SUCH TYPE AS ZERO, BRANCH NEVER!
					cmp #4 ; IS IT A TREE CLASS FILE?
					bcc CHKDSKSW ; YES, GO POSITION
					jmp DIRMARK ; NO, TEST FOR DIRECTORY TYPE.
*
CHKDSKSW			.eq *; MAKE SURE S/HE HASN'T MOVED THE VOLUME
					ldy #FCBDEVN
					lda (FCBPTR),Y
					sta DEVNUM ; MAKE SURE DEVICE NUMBER PARM IS CURRENT
					jsr TWRPROT1 ; PASSES DEVNUM (CHECK DISK SWITCH)
					lda DSWGLOB ; DISK SWITCH GLOBAL
					beq TREPOS ; BRANCH IF NONE DETECTED
CHKDSKS1				jsr VERFYVOL ; MATCHES VCBPTR VS. DEVNUM
					bcc TREPOS ; BRANCH IF DISK HASN'T SWITCHED
					jsr USRREQ ; POLITELY ASK USER TO MOUNT
					bcc CHKDSKS1 ; SAID HE DID, CHECK AGAIN
					lda #VNFERR ; REFUSES TO MOUNT
					rts
*
FERRTYP LDY #FCBREFN ; CLEAR ILLEGALLY TYPED FCB ENTRY
					sta (FCBPTR),Y
					lda #BADREFNUM ; TELL EM THERE IS NO SUCH FILE
					clc
					rts
*
*PAGE
TREPOS LDY #FCBSTYP ; USE STORAGE TYPE AS NUMBER
					lda (FCBPTR),Y ; OF LEVELS (SINCE 1=SEED, 2=SAPLING, AND 3=TREE)
					sta LEVELS
					ldy #FCBSTAT ; SINCE IT'S A DIFFERENT DATA
					lda (FCBPTR),Y ; BLOCK, MUST NOT FORGET PREVIOUS DATA.
					and #DATMOD ; THEREFORE, SEE IF PREVIOUS DATA WAS MODIFIED
					beq POSNEW1 ; THEN DISK MUST BE UPDATED.
					jsr WFCBDAT ; GO WRITE CURRENT DATA BLOCK.
					bcs POSERR ; RETURN ANY ERROR ENCOUNTERED.
*
POSNEW1 LDY #FCBMARK+2 ; TEST TO SEE IF CURRENT
					lda (FCBPTR),Y ; INDEX BLOCK IS GOING TO BE USABLE...
					and #$FE ; OR IN OTHER WORDS-
					sta SCRTCH ; IS NEW POSITION WITHIN 128K OF THE BEGINNING
					lda TPOSHI ; OF CURRENT SAPLING LEVEL CHUNK.
					clc
					sbc SCRTCH
					bcc POSNEW2 ; BRANCH IF A NEW INDEX BLOCK IS ALSO NEEDED
					cmp #2 ; NEW POSITION IS > THAN BEGINING OF OLD. IS IT WITHIN 128K?
					bcs POSNEW2 ; BRANCH IF NOT.
					ldx LEVELS ; IS THE FILE WE'RE DEALING WITH A SEED?
					dex
					bne DATLEVEL ; NO, USE CURRENT INDEXES.
TSTINY				lda TPOSLH ; IS NEW POSITION UNDER 512?
					lsr A
					ora TPOSHI
					bne NOIDXDAT ; NO, MARK BOTH DATA AND INDEX BLOCK AS UN-ALLOCATED.
					ldy #FCBFRST
					lda (FCBPTR),Y ; FIRST BLOCK IS ONLY BLOCK AND IT'S DATA!
					sta BLOKNML
					iny
					lda (FCBPTR),Y ; (HIGH BLOCK ADDRESS)

					jmp RNEWPOS ; GO READ IN BLOCK AND SET APPROPRIATE				staTUSES.
*
*PAGE
POSNEW2 LDY #FCBSTAT ; GOTA CHECK TO SEE IF PREVIOUS
					lda (FCBPTR),Y ; INDEX BLOCK WAS MODIFIED.
					and #IDXMOD
					beq POSNIDX ; READ IN OVER IT IF CURRENT IS UP TO DATE.
					jsr WFCBIDX ; GO UPDATE INDEX ON DISK (BLOCK ADDR IN FCB)
					bcs POSERR
POSNIDX				ldx LEVELS ; BEFORE READING IN TOP INDEX, CHECK TO BE SURE
					cpx #3 ; THAT THERE IS A TOP INDEX...
					beq POSINDEX ; BRANCH IF FILE IS FULL BLOWN TREE.
					lda TPOSHI ; IS NEW POSITION WITHIN RANGE OF A
					lsr A ; SAPLING FILE (L.T. 128K)?
					php ; ANTICIPATE NO GOOD.
					lda #TOPALC+IDXALC+DATALC ; (TO INDICATE NO LEVEL IS ALLOCATED FOR NEW POSITION.)
					plp ; Z FLAG TELLS ALL...
					bne NODATA ; GO MARK 'EM ALL DUMMY.
					jsr CLRSTATS ; GO CLEAR				staTUS BITS 0,1,2 (INDEX/DATA ALLOC				staTUS).
					dex ; (UNAFFECTED SINCE LOADED ABOVE) CHECK FOR SEED
					beq TSTINY ; IF SEED, CHECK FOR POSITION L.T. 512...
					jsr RFCBFST ; GO GET ONLY INDEX BLOCK
					bcs POSERR ; BRANCH IF ERROR
					ldy #FCBIDXB ; SAVE NEWLY LOADED INDEX BLOCK'S ADDRESS
					lda BLOKNML
					sta (FCBPTR),Y
					iny
					lda BLOKNMH
					sta (FCBPTR),Y
					bcc DATLEVEL ; BRANCH ALWAYS...
POSERR SEC
					rts
*
POSINDEX				jsr CLRSTATS ; CLEAR ALL ALLOCATION REQUIREMENTS FOR PREVIOUS POSITION
					jsr RFCBFST ; GET HIGHEST LEVEL INDEX BLOCK.
					bcs POSERR
					lda TPOSHI ; THEN TEST FOR A SAP LEVEL INDEX BLOCK
					lsr A
					tay
					lda (TINDX),Y
					inc TINDX+1
					cmp (TINDX),Y ; (BOTH HI AND LO WILL BE ZERO IF NO INDEX EXISTS)
					bne SAPLEVEL
					cmp #0 ; ARE BOTH BYTES ZERO?
					bne SAPLEVEL
					dec TINDX+1 ; DON'T LEAVE WRONG POINTERS LAYING AROUND!
NOIDXDAT				lda #IDXALC+DATALC ; SHOW NEITHER INDEX OR DATA BLOCK ALLOCATED.
					jmp NODATA
*
*PAGE
SAPLEVEL				sta BLOKNML ; READ IN NEXT LOWER INDEX BLOCK
					lda (TINDX),Y ; (HI ADDRESS)
					sta BLOKNMH
					dec TINDX+1
					jsr RFCBIDX ; READ IN SAPLING LEVEL
					bcs POSERR
DATLEVEL				lda TPOSHI ; NOW GET BLOCK ADDRESS OF DATA BLOCK
					lsr A
					lda TPOSLH ; ( IF THERE IS ONE )
					ror A
					tay
					lda (TINDX),Y ; DATA BLOCK ADDRESS LOW
					inc TINDX+1
					cmp (TINDX),Y
					bne POSNEW3
					cmp #0
					bne POSNEW3
					lda #DATALC ; SHOW DATA BLOCK AS NEVER BEEN ALLOCATED
					dec TINDX+1
*
NODATA LDY #FCBSTAT
					ora (FCBPTR),Y ; SET				staTUS TO SHOW WHATS MISSIN'
					sta (FCBPTR),Y
					lsr A ; THROW AWAY BIT THAT SAYS DATA BLOCK UN-ALLOCATED
					lsr A ; CUZ WE KNOW THAT. CARRY NOW INDICATES IF INDEX BLOCK
					jsr ZIPDATA ; ALSO IS INVALID AND NEEDS TO BE ZEROED (CARRY UNDISTURBED)
					bcc SVMARK ; BRANCH IF INDEX BLOCK DOESN'T NEED ZIPPIN.
ZIPIDX				sta (TINDX),Y
					iny
					bne ZIPIDX
					inc TINDX+1

ZPIDX1				sta (TINDX),Y
					iny
					bne ZPIDX1
					dec TINDX+1 ; RESTORE PROPER ADDRESS
					jmp SVMARK
*
ZIPDATA				lda #0 ; ALSO IS INVALID AND NEEDS TO BE ZEROED.
					tay
ZIPDAT0				sta (DATPTR),Y ; ZERO OUT DATA AREA
					iny
					bne ZIPDAT0
					inc DATPTR+1
ZPDAT1				sta (DATPTR),Y
					iny
					bne ZPDAT1
					dec DATPTR+1
					rts
*
*PAGE
*
POSNEW3				sta BLOKNML ; GET DATA BLOCK OF NEW POSITION
					lda (TINDX),Y ; (HI ADDRESS)
					dec TINDX+1
RNEWPOS				sta BLOKNMH
					jsr RFCBDAT
					bcs PRITZ ; RETURN ANY ERROR
					jsr CLRSTATS ; SHOW WHOLE CHAIN IS ALLOCATED
SVMARK LDY #FCBMARK+2 ; UPDATE POSITION IN FILE CONTROL BLOCK
					ldx #2
SVMRK1				lda (FCBPTR),Y ; REMEMBER OLDMARK IN CASE
					sta OLDMARK-FCBMARK,Y ; CALLING ROUTINE FAILS LATER
					lda TPOSLL,X
					sta (FCBPTR),Y
					dey
					dex ; MOVE 3 BYTE POSITION MARKER
					bpl SVMRK1
*
					clc ; LAST, BUT NOT LEAST, SET UP
					lda DATPTR ; INDIRECT ADDRESS TO BUFFER PAGE POINTED
					sta POSPTR ; TO BY THE CURRENT POSITION MARKER.
					lda TPOSLH
					and #1
					adc DATPTR+1
					sta POSPTR+1
					lda SISDATP
					sta SISPOSP ; SISTER PAGE BYTE ALSO.
					rts; CARRY SHOULD ALWAYS BE CLEAR
PRITZ SEC ; RANDOM ERROR
					rts; RETURN
*
*
CLRSTATS LDY #FCBSTAT ; CLEAR ALLOCATION				staTES FOR DATA BLOCK
					lda (FCBPTR),Y ; AND BOTH LEVELS OF INDEXES.
					and #$FF-TOPALC-IDXALC-DATALC
					sta (FCBPTR),Y ; THIS SAYS THAT EITHER THEY EXIST CURRENTLY
					rts; OR THAT THEY'RE UNNECESSARY FOR CURRENT POSITION.
*
*PAGE
*
DIRMARK CMP #DIRTYP ; IS IT A DIRECTORY?
					beq DIRPOS ; YES...
					lda #CPTERR ; NO, THERE IS A COMPATABLITY PROBLEM-
					jsr SYSERR ; THE DAMN THING SHOULD OF NEVER BEEN OPENED!
*
DIRPOS				lda SCRTCH ; RECOVER RESULTS OF PREVIOUS SUBTRACTION.
					lsr A ; USE DIFFERENCE AS COUNTER AS TO HOW MANY
					sta CNTENT ; BLOCKS MUST BE READ TO GET TO NEW POSITION.
					ldy #FCBMARK+1 ; TEST FOR POSITION DIRECTION.
					lda (FCBPTR),Y
					cmp TPOSLH ; CARRY INDICATES DIRECTION...
					bcc DIRFWRD ; IF SET, POSITION FORWARD.
DIRVRSE LDY #0 ; OTHERWISE, READ DIRECTORY FILE IN REVERSE ORDER.
					jsr DIRPOS1 ; READ PREVIOUS BLOCK.
					bcs DRPOSERR ; BRANCH IF ANYTHING GOES WRONG.
					inc CNTENT ; COUNT UP TO 128
					bpl DIRVRSE ; LOOP IF THERE IS MORE BLOCKS TO PASS OVER.
					bmi SVMARK ; BRANCH ALWAYS.
*
DIRFWRD LDY #2 ; POSITION IS FORWARD FROM CURRENT POSITION.
					jsr DIRPOS1 ; READ NEXT DIRECTORY BLOCK.
					bcs DRPOSERR

					dec CNTENT
					bne DIRFWRD ; LOOP IF POSITION NOT FOUND IN THIS BLOCK.
					beq SVMARK ; BRANCH ALWAYS.
*
DIRPOS1				lda (DATPTR),Y ; GET LINK ADDRESS OF PREVIOUS OR
					sta BLOKNML ; NEXT DIRECTORY BLOCK.
					iny ; BUT FIRST BE SURE THERE IS A LINK.
					cmp (DATPTR),Y
					bne DIRPOS2 ; BRANCH IF CERTAIN LINK EXISTS
					cmp #0 ; ARE BOTHE LINK BYTES 0?
					bne DIRPOS2 ; NOPE, JUST HAPPEN TO BE THE SAME VALUE.
					lda #EOFERR ; SOMETHING IS WRONG WITH THIS DIRECTORY FILE!
DRPOSERR SEC ; INDICATE ERROR
					rts
*
DIRPOS2				lda (DATPTR),Y ; (HIGH ORDER BLOCK ADDRESS)
					sta BLOKNMH
* DROP INTO 'RFCBDAT' (READ FILE'S DATA BLOCK)
*
* NOTE: FOR DIRECTORY POSITIONING NO OPTIMIZATION HAS BEEN
* DONE SINCE DIRECTORY FILES WILL ALMOST ALWAYS BE LESS
* THAN 6 BLOCKS. IF MORE SPEED IS REQUIRED OR DIRECTORY
* TYPE FILES ARE TO BE USED FOR OTHER PURPOSES REQUIRING
* MORE BLOCKS, THEN THE RECOMMENDED METHOD IS TO CALL
* 'RFCBDAT' FOR THE FIRST BLOCK AND GO DIRECTLY TO
* DEVICE (VIA JMP (IOUNITL)) HANDLER FOR SUBSEQUENT
* ACCESSES.
* ALSO NOTE THAT NO CHECKING IS DONE FOR READ/WRITE
* ENABLE SINCE A DIRECTORY FILE CAN ONLY BE OPENED
* FOR READ ACCESS.
*
*PAGE
*
RFCBDAT				lda #RDCMD ; SET READ COMMAND.
					sta DHPCMD
					ldx #DATPTR ; USE X TO POINT AT ADDRESS OF DATA BUFFER
					jsr FILEIO1 ; GO DO FILE INPUT.
					ldy #FCBDATB ; SAVE BLOCK NUMBER JUST READ IN FCB.
					bcc FCBLOKNM ; BRANCH IF NO ERRORS HAPPENED.
					rts; RETURN ERROR
*
RFCBIDX				lda #RDCMD ; PREPARE TO READ IN INDEX BLOCK.
					sta DHPCMD
					ldx #TINDX ; POINT AT ADDRESS OF CURRENT INDEX BUFFER
					jsr FILEIO1 ; GO READ INDEX BLOCK.
					bcs RDFCBERR ; REPORT ERROR
					ldy #FCBIDXB ; SAVE BLOCK ADDRESS OF THIS INDEX IN FCB.
FCBLOKNM				lda BLOKNML
					sta (FCBPTR),Y
					iny
					lda BLOKNMH
					sta (FCBPTR),Y
					clc
RDFCBERR RTS
*
RFCBFST				ldx #TINDX ; POINT AT ADDRESS OF INDEX BUFFER
					ldy #FCBFRST ; AND BLOCK ADDRESS OF FIRST FILE BLOCK IN FCB
					lda #RDCMD ; AND LASTLY, MAKE IT A READ!
* DROP INTO DOFILEIO
*
DOFILEIO				sta DHPCMD ; SAVE COMMAND.
					lda (FCBPTR),Y ; GET DISK BLOCK ADDRESS FROM FCB.
					sta BLOKNML
					iny ; BLOCK ZERO NOT LEGAL.
					cmp (FCBPTR),Y
					bne FILEIO
					cmp #0 ; ARE BOTH BYTES ZERO?
					bne FILEIO ; NO, CONTINUE WITH REQUEST.
					lda #ALCERR ; OTHERWISE REPORT ALLOCATION ERROR.
					jsr SYSDEATH ; NEVER RETURNS...
*
*PAGE
FILEIO				lda (FCBPTR),Y ; GET HIGH ADDRESS OF DISK BLOCK
					sta BLOKNMH
FILEIO1				lda 0,X ; GET MEMORY ADDRESS OF BUFFER FROM
					sta DBUFPL ; S.O.S. ZERO PAGE POINTED TO BY
					jsr WRAPADJ ;GO ADJUST FOR BANK CROSSING <SRS 82.162>
					lda 1,X
					sta DBUFPH ; SET HI BYTE
					lda SISTER+1,X ; AND BANK PAIR BYTE. <SRS 82.162>
					sta SISBPH

					ldy #FCBDEVN
					lda (FCBPTR),Y ; OF COURSE HAVING THE DEVICE NUMBER
					sta DEVNUM ; WOULD MAKE THE WHOLE OPERATION MORE MEANINGFUL...
FILEIO2				lda #2 ; ALSO, SET UP BYTE COUNT TO 512 AND
					sta RQCNTH ; SET 'BYTES READ' POINTER TO
					sta IOACCESS ; (INTERUPT! SET TO INDICATE REG CALL MADE TO DEV HANDLER. RETURN
INTERUPT!)
					lda #>TRASH ; A PLACE TO THROW BYTES READ AWAY
					sta BRDPTR
					lda #<TRASH ; LOCALLY DEFINED
					sta BRDPTR+1
					lda #0 ; SO THAT IT DOESN'T MESS UP ANY OTHER DATA.
					sta RQCNTL
					sta SSBRDPH ; ('BYTES READ' IS THROWN AWAY)
RPEATIO1				lda DEVNUM ; TRANSFER THE DEVICE NUMBER FOR DISPATCHER TO CONVERT TO UNIT NUMBER.
					sta UNITNUM
RPEATIO0 LDY #$9 ; PREPARE TO SAVE DEVICE PARMS
SAVPRMS				lda DEVICE,Y ; MOVE FROM Z PAGE
					sta RPTBLOK,Y ; TO MY OWN SPACE
					dey ; FROM $C9 THROUGH $C0
					bpl SAVPRMS
DMGRGO				.eq *; CALL EXTERNAL DEVICE MANAGER
					lda #0
					sta SERR ; CLEAR GLOBAL ERROR VALUE
					jsr DMGR ; CALL THE DRIVER
					bcc RRITZ ; RTS IF NO ERRORS
					cmp #XDISKSW ; DISKSWITCH ITERATES
					beq RPEATIO2 ; BRANCH IF DISK SWITCH AND REPEAT I/O REQUEST
					clc ; REPORT ERROR
RRITZ RTS
RPEATIO2 LDY #$9 ; LENGTH OF PARM BLOCK
GETPRMS				lda RPTBLOK,Y
					sta DEVICE,Y ; RESTORE POSSIBLY DISTURBED PARM BLOCK
					dey
					bpl GETPRMS
					jmp DMGRGO ; AND TRY THE I/O AGAIN
*
*
TRASH DS 2 ; ONLY USED TO PUT BYTES READ TO SLEEP
RPTBLOK DS 10 ; DMGR PARM SAVE BLOCK
*
*
WFCBFST LDY #FCBDEVN ; FETCH THE
					lda (FCBPTR),Y ; DEVICE NUMBER
					tax; AND UPDATE
					jsr UPBMAP ; ITS BITMAP
					ldx #TINDX ; POINT AT ADDRESS OF INDEX BLOCK
					ldy #FCBFRST ; AND THE DISK ADDRESS OF FILE'S FIRST BLOCK IN FCB
					lda #WRTCMD ; LASTLY, MAKE IT A WRITE REQUEST.
					jmp DOFILEIO ; AND GO DO IT!
*
WFCBDAT				ldx #DATPTR
					ldy #FCBDATB ; POINT AT MEMORY ADDRESS WITH X AND DISK ADDRESS WITH Y.
					lda #WRTCMD ; WRITE DATA BLOCK.
					jsr DOFILEIO
					bcs FILIOERR ; REPORT ANY ERRORS
					lda #$FF-DATMOD ; MARK DATA				staTUS AS CURRENT.
					jmp FCBUPDAT
*
WFCBIDX LDY #FCBDEVN ; MAKE SURE
					lda (FCBPTR),Y ; THE BITMAP
					tax; FOR THIS DEVICE ("X")
					jsr UPBMAP ; IS UPDATED
					ldx #TINDX ; POINT AT ADDRESS OF INDEX BUFFER
					ldy #FCBIDXB ; AND BLOCK ADDRESS OF THAT INDEX BLOCK.
					lda #WRTCMD
					jsr DOFILEIO ; GO WRITE OUT INDEX BLOCK.
					bcs FILIOERR ; REPORT ANY ERRORS
					lda #$FF-IDXMOD ; MARK INDEX				staTUS AS CURRENT.
FCBUPDAT LDY #FCBSTAT ; CHANGE				staTUS BYTE TO
					and (FCBPTR),Y ; REFLECT SUCCESSFUL DISK FILE UPDATE.
					sta (FCBPTR),Y ; (CARRY IS UNAFFECTED)
FILIOERR RTS
*
*
*PAGE
OPEN				jsr FINDFILE ; FIRST OF ALL LOOK UP THE FILE...
					bcc OPEN0
					cmp #BADPATH ; IS AN ATTEMPT TO OPEN A ROOT DIRECTORY?
					bne ERROPN ; NO, PASS BACK ERROR
*

OPEN0				jsr TSTOPEN ; FIND OUT IF ANY OTHER FILES ARE WRITING
					bcc OPEN1 ; TO THIS SAME FILE. (BRANCH IF NOT)
ERRBUSY				lda #FILBUSY ; REPORT SHARED ACCESS NOT ALLOWED.
ERROPN SEC
					rts; RETURN ERROR.
*
OPEN1				lda DATPTR ; GET ADDRESS OF FIRST FREE FCB FOUND
					sta FCBPTR ; DURING TEST OPEN SEQUENCE AND USE
					lda DATPTR+1 ; IT AS FILE CONTROL AREA. IF HIGH BYTE OF
					sta FCBPTR+1 ; POINTER IS ZERO, THEN NO FCB
					bne ASGNFCB ; IS AVAILABLE FOR USE.
					lda #FCBFULL ; REPORT FCB FULL ERROR.
					clc
					rts
*
ASGNFCB LDY #$1F ; ASSIGN FCB, BUT FIRST
					lda #0 ; CLEAN OUT ANY OLD RUBBISH LEFT AROUND...
CLRFCB				sta (FCBPTR),Y
					dey
					bpl CLRFCB
					ldy #FCBENTN ; NOW BEGIN CLAIM BY MOVING IN FILE
FCBOWNR				lda D.DEV-1,Y ; OWNERSHIP INFORMATION.
					sta (FCBPTR),Y ; NOTE: THIS CODE DEPENDS UPON THE DEFINED
					dey ; ORDER OF BOTH THE FCB AND DIRECTORY ENTRY
					bne FCBOWNR ; BUFFER (D.). BEWARE OF CHANGES!!! *************
					lda DFIL+D.STOR ; GET STORAGE TYPE.
					lsr A ; STRIP OFF FILE NAME LENGTH.
					lsr A
					lsr A ; (BY DIVIDING BY 16)
					lsr A
					tax; SAVE IN X FOR LATER TYPE COMPARISON
					ldy #FCBSTYP
					sta (FCBPTR),Y ; SAVE STORAGE TYPE.
					lda C.OPLSTLN ; IS THERE AN OPEN LIST?
					beq DEFOPEN ; NO, USE DEFAULT REQUST ACCESS...
					ldy #0 ; YES, FIND OUT WHAT ACCESS IS REQUESTED.
					lda (C.OPLIST),Y ; IF REQ-ACCESS IS ZERO, THEN
					beq DEFOPEN ; USE DEFAULTS...
					and DFIL+D.ATTR ; CHECK REQUEST AGAINST ATTRIBUTES.
					cmp (C.OPLIST),Y ; WERE ALL ACCESS REQUESTS SATISFIED?
					beq SVATTRB ; YES, SAVE ATTRIBUTES.
					lda #ACCSERR ; REPORT ACCESS REQUEST CAN'T BE MET.
					clc
					rts
*PAGE
DEFOPEN				lda DFIL+D.ATTR ; GET FILES ATTRIBUTES AND
					and #READEN+WRITEN ; USE IT AS A DEFAULT ACCESS REQUEST.
SVATTRB LDY #FCBATTR
					cpx #DIRTYP ; IF DIRECTORY, DON'T ALLOW WRITE ENABLE
					bne SVATTR1
					and #READEN
SVATTR1				sta (FCBPTR),Y
					and #WRITEN ; CHECK FOR WRITE ENABLED REQUESTED.
					beq OPEN2 ; BRANCH IF READ ONLY OPEN.
					lda TOTENT ; OTHERWISE, BE SURE NO ONE ELSE IS READING SAME
					bne ERRBUSY ; FILE (SET UP BY TSTOPEN).
OPEN2				lda DFIL+D.COMP ; OH, BY THE WAY... IS THIS FILE
					beq OPEN3 ; COMPATABLE WITH VERSION 0000? ***************
ERRCMPAT				lda #CPTERR ; REPORT FILE IS INCOMPATABLE!
					clc
					rts
*
OPEN3 CPX #TRETYP+1 ; IS IT A TREE TYPE FILE?
					bcc OPEN4 ; TEST FOR FURTHER COMPATABLITY. IT MUST
					cpx #DIRTYP ; BE EITHER A TREE OR A DIRECTORY.
					bne ERRCMPAT ; REPORT INCOMPATABLE.
OPEN4 LDY #FCBFRST ; MOVE ADDRESS OF FIRST BLOCK OF FILE
					lda DFIL+D.FRST ; INTO FCB. NO CHECKING IS DONE FOR VALIDITY.
					sta (FCBPTR),Y
					sta BLOKNML
					iny
					lda DFIL+D.FRST+1
					sta (FCBPTR),Y ; NOTE: THE FCB HAS NOT BEEN OFFICIALLY
					sta BLOKNMH ; CLAIMED YET. TO DO THIS, THE FIRST BYTE
					ldy #FCBEOF ; MUST CONTAIN A VALID REFERENCE NUMBER.
EOFCBMV				lda DFIL+D.EOF-FCBEOF,Y ; MOVE CURRENT END OF FILE
					sta (FCBPTR),Y ; TO FCB.
					iny
					cpy #FCBEOF+3
					bne EOFCBMV
					lda DFIL+D.USAGE

					sta (FCBPTR),Y ; AND CURRENT BLOCK COUNT OF FILE.
					iny
					lda DFIL+D.USAGE+1
					sta (FCBPTR),Y
					lda C.OPLSTLN ; NOW THAT WE'VE COME THIS FAR, FIND
					beq DEFBUFR ; OUT WHICH TYPE OF BUFFER AND ALLOCATE IT!
					cmp #1 ; WAS IT ONLY TO SET ATTRIBUTES?
					beq DEFBUFR
					cmp #4 ; IS A FULL ADDRESS INCLUDED?
					beq UBUFSPEC
					lda #BADLSTCNT
					clc
					rts
*
*PAGE
UBUFSPEC LDY #1 ; (INDEX TO 'PAGECNT' OF OPEN LIST)
					lda (C.OPLIST),Y ; IS USER SPECIFING THE BUFFER?
					beq DEFBUFR ; NO, USE DEFAULT BUFFER (DYNAMIC)
					cpx #TRETYP+1 ; IF TREE TYPE FILE, THEN AT LEAS 4 PAGES ARE NEEDED.
					bcc ONEKTST ; BRANCH IF TREE TYPE.
					cmp #2 ; DID USER GIVE AT LEAST 2 PAGES FOR DIRECTORY TYPE?
					bcs FIXDBUF ; YES, LOG IT WITH BUFFER MANAGER
ERRBTS				lda #BTSERR ; REPORT NOT ENOUGH BUFFER SPACE.
					clc
					rts
*
ONEKTST CMP #4 ; IS THERE AT LEAST ONE KILOBYTE BUFFER FOR TREES?
					bcc ERRBTS ; NO, THEN TO HELL WITH IT!.
FIXDBUF				jsr REQFXBUF ; CALL BOB AND ASK FOR HIM TO FIX IT...
					bcc FCBUFFER ; GO SAVE BUFFER NUMBER.
ERROPN1 RTS ; RETURN ANY ERROR ENCOUNTERED.
*
DEFBUFR				lda #4 ; ASSUME TREE FILE (4 PAGES REQUIRED)
					cpx #TRETYP+1
					bcc BUFREQST ; BRANCH IF IT IS A TREE.
					lda #2 ; OTHERWIZE, WE JUST NEED TWO PAGES.
BUFREQST				jsr REQBUF ; CALL BOB TO ALLOCATE A DYNAMIC BUFFER.
					bcs ERROPN1 ; REPORT ANY ERRORS.
FCBUFFER LDY #FCBBUFN ; SAVE BUFFER NUMBER AND THEN
					sta (FCBPTR),Y ; FIND OUT WHERE IT IS.
					jsr GTBUFFRS ; HAVE BOB RETURN ADDRESS IN DATA & INDEX POINTERS.
					bcs ERROPEN2 ; IF ERROR, FREE BUFFER BEFOR RETURNING.
					ldy #FCBREFN ; NOW CLAIM FCB FOR THIS FILE.
					lda CNTENT ; THIS WAS SET UP BY 'TSTOPEN'.............
					sta (FCBPTR),Y
					ldy #FCBLEVL ; MARK LEVEL
					lda LEVEL ; AT WHICH
					sta (FCBPTR),Y ; FILE WAS OPENED
					ldy #FCBSTYP ; GET STORAGE TYPE AGAIN.
					lda (FCBPTR),Y ; FILE MUST BE POSITIONED TO BEGINNING.
					cmp #TRETYP+1 ; IS IT A TREE FILE?
					bcs OPNDIR ; NO, ASSUME IT'S A DIRECTORY.
					lda #$FF ; FOOL THE POSITION ROUTINE INTO GIVING
					ldy #FCBMARK ; A VALID POSITION WITH PRELOADED DATA, ETC.
OPNPOS				sta (FCBPTR),Y
					iny
					cpy #FCBMARK+3
					bne OPNPOS
					ldy #2 ; SET DESIRED POSITION TO ZERO.
					lda #0
OPNPOS1				sta TPOSLL,Y
					dey
					bpl OPNPOS1
					jsr RDPOSN ; LET TREE POSITION ROUTINE DO THE REST.
					bcc OPENDONE ; BRANCH IF SUCCESSFUL.
*
*PAGE
ERROPEN2 PHA ; SAVE ERROR CODE.
					ldy #FCBBUFN ; SINCE ERROR WAS ENCOUNTERED BEFORE FILE
					lda (FCBPTR),Y ; WAS SUCCESSFULLY OPENED, THEN
					jsr RELBUF ; IT'S NECESSARY TO FREE THE BUFFER AND
					ldy #FCBREFN ; FILE CONTROL BLOCK.
					lda #0
					sta (FCBPTR),Y
					pla
					clc
					rts
*
OPNDIR				jsr RFCBDAT ; READ IN FIRST BLOCK OF DIRECTORY FILE.
					bcs ERROPEN2 ; RETURN ANY ERROR AFTER FREEING BUFFER & FCB
OPENDONE LDY #VCBOPNC ; INCREMENT OPEN COUNT FOR THIS

					lda (VCBPTR),Y ; VOLUME. ALSO MARK				staTUS.
					clc
					adc #1
					sta (VCBPTR),Y
					ldy #VCBSTAT ; HI BIT INDICATES VOLUME BUSY
					lda (VCBPTR),Y
					ora #$80
					sta (VCBPTR),Y ; DOESN'T MATTER HOW MANY, JUST BE SURE IT'S SET.
					ldy #FCBREFN ; PASS USER HIS REFERENCE NUMBER
					lda (FCBPTR),Y
					ldy #0
					sta (C.OUTREF),Y
					clc
					rts
*
*PAGE
*
TSTOPEN				lda FCBADDRH ; TEST FOR SHARED ACCESS FILES WITH WRITE ENABLED.
					sta FCBPTR+1
					lda FCBANKNM
					sta SISFCBP
					lda #0
					sta DATPTR+1 ; MARK AS NO FREE FOUND.
					sta CNTENT
					sta TOTENT ; ALSO, INIT COUNT OF MATCHING FILES
TSTOPN1				sta FCBPTR ; SAVE NEW LOW ORDER ADDRESS
					ldx DATPTR+1 ; FIND OUT IF A FREE SPOT HAS BEEN FOUND YET.
					bne TSTOPN2 ; YES, DON'T INCREMENT REFNUM (CNTENT).
					inc CNTENT ; BUMP REFNUM
TSTOPN2 LDY #FCBREFN ; TEST FOR IN USE FCB
					lda (FCBPTR),Y ; (NON ZERO)
					bne CHKACTV ; THIS FCB IS IN USE, COPARE OWNERSHIP.
					txa ; TEST AGAIN FOR FREE FCB
					bne TSNXFCB ; BRANCH IF A FREE SPOT HAS ALREADY BEEN FOUND.
					lda FCBPTR ; TRANSFER CURRENT POINTER SO IT MAY BE
					sta DATPTR ; USED AS A FREE FCB BY OPEN.
					lda FCBPTR+1 ; HIGH BYTE ALWAYS NON ZERO.
					sta DATPTR+1
					jmp TSNXFCB
*
CHKACTV				.eq *; IF MATCHING FILE IS SWAPPED, IT DOESNT COUNT
					ldy #FCBSWAP
					lda (FCBPTR),Y
					bne TSNXFCB ; BRANCH IF SWAPPED
					ldy #FCBENTN ; NOTE: THIS CODE DEPENDS ON THE
WHOWNS				lda (FCBPTR),Y ; DEFINED ORDER OF FCB AND DIRECTORY
					cmp D.DEV-1,Y ; *****************************
					bne TSNXFCB ; BRANCH IF THIS ONE HAS A DIFFERENT OWNER.
					dey
					bne WHOWNS
					inc TOTENT ; REPORT THIS ONE AS A CO-OWNER.
					ldy #FCBATTR ; NOW FIND OUT IF THIS ONE WANTS TO WRITE.
					lda (FCBPTR),Y
					and #WRITEN ; IF WRITE IS NOT ENABLED THEN CONTINUE.
					beq TSNXFCB
					clc ; OTHERWISE, JUST SET THE CARRY TO SHOW
					rts; THAT THE FILE CAN'T BE SHARED.
*
TSNXFCB				lda FCBPTR ; CALCULATE NEXT FCB AREA (+$20)
					clc
					adc #$20
					bcc TSTOPN1 ; LOOP IF NO PAGE CROSS.
					ldx FCBPTR+1
					inc FCBPTR+1
					cpx FCBADDRH ; HAVE WE LOOKED AT BOTH PAGES?
					beq TSTOPN1 ; NOPE, LOOK AT PAGE TWO.
					clc ; INDICATE NO FILES THAT SHARE HAVE WRITE ENABLED,
					rts
*
CHN READ/WRITE,4,2

*************************************************************************
* END OF APPLE /// SOS 1.3 SOURCE CODE FILE: POSN.OPEN
*************************************************************************




================================================================================================
FILE: "SOS.PRINT.TEXT"
================================================================================================
*************************************************************************
* APPLE /// SOS 1.3 SOURCE CODE FILE: PRINT
*************************************************************************
* ASSEMBLER: APPLE ][ 6502 ASSEMBLER from APPLE COMPUTER TOOLKIT

*SBTL 'SOS 1.1 BLOCK FILE MANAGER' L
* 01-FEB-82
*REL
IBUFSIZ 1
SBUFSIZ 40
					INCLUDE SOSORG,6,1,254
ORG ORGBFM ; BITMAPS $B800-$BBFF
ZZORG .eq *
*REP 60
* (C) COPYRIGHT 1981 BY APPLE COMPUTER INC.
* ALL RIGHTS RESERVED
*REP 60
*MSB OFF
*LST VSYM
CHN EQUATES,4,1
CHN ALLOC
					INCLUDE POSN/OPEN
					INCLUDE READ/WRITE,2,,4
					INCLUDE CLOSE/EOF,2,,4
					INCLUDE DESTROY,2,,4
					INCLUDE SWAPOUT/IN,2,,4

*************************************************************************
* END OF APPLE /// SOS 1.3 SOURCE CODE FILE: PRINT
*************************************************************************



================================================================================================
FILE: "SOS.PUBLICRELEASE.TEXT"
================================================================================================
*************************************************************************
* APPLE /// SOS 1.3 SOURCE CODE FILE: PUBLICRELEASE
*************************************************************************
* ASSEMBLER: APPLE ][ 6502 ASSEMBLER from APPLE COMPUTER TOOLKIT

:T 15,19,32
::PR#1,L58 132N
::SL4:DR1:ASM PRINT,BFM.OBJ,S6,D1
::END

*************************************************************************
* END OF APPLE /// SOS 1.3 SOURCE CODE FILE: PUBLICRELEASE
*************************************************************************


================================================================================================
FILE: "SOS.READ.WRITE.TEXT"
================================================================================================
*************************************************************************
* APPLE /// SOS 1.3 SOURCE CODE FILE: READ.WRITE
*************************************************************************
* ASSEMBLER: APPLE ][ 6502 ASSEMBLER from APPLE COMPUTER TOOLKIT

*PAGE
READ CLC ; FIRST DETERMINE IF REQESTED
					ldy #FCBATTR ; READ IS LEGAL
					lda (FCBPTR),Y
					and #READEN ; IS READ ENABLED?
					bne READ1 ; YES, CONTINUE...
					lda #ACCSERR ; REPORT ILLEGAL ACCESS.
					clc
					rts
*
READ1 LDY #FCBMARK ; GET CURRENT MARK INTO 'TPOS' AND
					lda (FCBPTR),Y ; DETERMINE IF RESULTING POSITION
					sta TPOSLL ; EXCEEDS CURRENT END OF FILE.
					adc C.BYTES
					sta SCRTCH
					iny
					lda (FCBPTR),Y
					sta TPOSLH
					adc C.BYTES+1 ; (THIS WAS DONE STRAIT-LINE SINCE
					sta SCRTCH+1 ; WE'RE ADDING A TWO BYTE TO A THREE
					iny ; BYTE QUANTITY)
					lda (FCBPTR),Y
					sta TPOSHI
					adc #0 ; ADD IN REMAINING CARRY.
					sta SCRTCH+2
					ldy #FCBEOF+2 ; NOW TEST EOF AGAINST POSITION GENERATED
EOFTEST				lda SCRTCH-FCBEOF,Y
					cmp (FCBPTR),Y ; IS NEW POSITION > EOF?
					bcc READ2 ; NO, PROCEED.
					bne ADJSTCNT ; YES, ADJUST 'C.BYTES' REQUEST
					dey
					cpy #FCBEOF-1 ; HAVE WE COMPARED ALL TREE BYTES?
					bne EOFTEST ; NO, TEST NEXT LOWEST.
ADJSTCNT			.eq *; ADJUST REQUEST TO READ UP TO (BUT
					ldy #FCBEOF ; NOT INCLUDING) END OF FILE.
					lda (FCBPTR),Y ; RESULT= (EOF-1)-POSITION
					sbc TPOSLL
					sta C.BYTES
					iny
					lda (FCBPTR),Y
					sbc TPOSLH
					sta C.BYTES+1
					ora C.BYTES ; IF BOTH BYTES ARE ZERO, REPORT EOF ERROR.
					bne READ2
					lda #EOFERR
					jsr SYSERR
READ2				lda C.BYTES
					sta RWREQL
					bne READ3 ; BRANCH IF READ REQUEST DEFINITELY NON-ZERO.
					cmp C.BYTES+1
					bne READ3 ; BRANCH IF READ REQUEST<>ZERO
					sta RWREQH
GORDDNE JMP READONE ; DO NOTHING.
*PAGE
*
READ3				lda C.BYTES+1
					sta RWREQH
					lda C.OUTBUF ; MOVE POINTER TO USERS BUFFER TO BFM
					sta USRBUF ; Z-PAGE AREA.
					ldx #C.OUTBUF ; <SRS 82.162>
					jsr WRAPADJ ; ADJUST FOR BANK CROSSING. <SRS 82.162>
					sta USRBUF+1
					sty SISUSRBF ; SAVE VALID USER BUFFER ADDRESS (THAT WILL NOT CROSS BANKS)
					ldy #FCBSTYP ; NOW FIND OUT IF IT'S A TREE READ OR OTHER.
					lda (FCBPTR),Y
					cmp #TRETYP+1
					bcc TREAD ; BRANCH IF A TREE FILE.
					jmp DREAD ; OTHEWISE ASSUME IT'S A DIRECTORY.
*
TREAD				jsr RDPOSN ; GET DATA POINTER SET UP.
					bcc TREAD0 ; REPORT ANY ERRORS

					jmp ERRFIX1
TREAD0				jsr PREPRW ; TEST FOR NEWLINE, SETS UP FOR PARTIAL READ.
					jsr READPART ; MOVE CURRENT DATA BUFFER CONTENTS TO USER AREA
BVS GORDDNE ; BRANCH IF REQUEST IS SATISFIED.
					bcs TREAD ; CARRY SET INDICATES NEWLINE IS SET.
					lda RWREQH ; FIND OUT HOW MANY BLOCKS ARE TO BE READ
					lsr A ; IF LESS THAN TWO, THEN DO IT THE SLOW WAY.
					beq TREAD
					sta BULKCNT ; SAVE BULK BLOCK COUNT.
					ldy #FCBSTAT ; MAKE SURE CURRENT DATA AREA
					lda (FCBPTR),Y ; DOESN'T NEED TO BE WRITTEN BEFORE
					and #DATMOD ; RESETTING POINTER TO READ DIRECTLY INTO
					bne TREAD ; USER'S AREA. BRANCH IF DATA NEED TO BE WRITTEN
					sta IOACCESS ; TO FORCE FIRST CALL THRU ALL DEVICE HANDLER CHECKING.
					lda USRBUF ; MAKE THE DATA BUFFER THE USER'S SPACE.
					sta DATPTR
					lda USRBUF+1
					sta DATPTR+1
					lda SISUSRBF
					sta SISDATP
*
*PAGE
RDFAST				jsr RDPOSN ; GET NEXT BLOCK DIRECTLY INTO USER SPACE.
					bcs ERRFIX ; BRANCH ON ANY ERROR.
RDFAST0 INC DATPTR+1 ; BUMP ALL POINTERS BY 512 (ONE BLOCK)
					inc DATPTR+1
					dec RWREQH
					dec RWREQH
					inc TPOSLH
					inc TPOSLH
					bne RDFAST1 ; BRANCH IF POSITION DOES NOT GET TO A 64K BOUNDARY.
					inc TPOSHI ; OTHERWISE, MUST CHECK FOR A 128K BOUNDARY
					lda TPOSHI ; SET CARRY IF MOD 128K HAS BEEN REACHED
					eor #1
					lsr A
RDFAST1 DEC BULKCNT ; HAVE WE READ ALL WE CAN FAST?
					bne RDFAST2 ; BRANCH IF MORE TO READ.
					jsr FXDATPTR ; GO FIX UP DATA POINTER TO SOS BUFFER.
					lda RWREQL ; TEST FOR END OF READ.
					ora RWREQH ; ARE BOTH ZERO?
					beq READONE
					bne TREAD ; NO, READ LAST PARTIAL BLOCK.
*
RDFAST2 BCS RDFAST
					lda TPOSHI ; GET INDEX TO NEXT BLOCK ADDRESS
					lsr A
					lda TPOSLH
					ror A
					tay ; INDEX TO ADDRESS IS INT(POS/512)
					lda (TINDX),Y ; GET LOW ADDRESS
					sta BLOKNML
					inc TINDX+1
					cmp (TINDX),Y ; ARE BOTH HI AND LOW ADDRESS THE SAME?
					bne REALRD ; NO, IT'S A REAL BLOCK ADDRESS.
					cmp #0 ; ARE BOTH BYTES ZERO?
					bne REALRD ; NOPE -- MUST BE REAL DATA
					sta IOACCESS ; DON'T DO REPEATIO JUST AFTER SPARSE
					beq NOSTUF ; BRANCH ALWAYS (CARRY SET)
REALRD				lda (TINDX),Y ; GET HIGH ADDRESS BYTE
					clc
NOSTUF DEC TINDX+1
					bcs RDFAST ; BRANCH IF NO BLOCK TO READ
					sta BLOKNMH
					lda IOACCESS ; HAS FIRST CALL GONE TO DEVICE YET?
					beq RDFAST ; NOPE, GO THRU NORMAL ROUTE...
					lda DATPTR+1 ; RESET HI BUFFER ADDRESS FOR DEVICE HANDLER
					sta DBUFPH
					jsr REPEATIO
					bcc RDFAST0 ; BRANCH IF NO ERRORS.
*PAGE
ERRFIX PHA ; SAVE ERROR CODE
					jsr FXDATPTR ; GO RESTORE DATA POINTERS, ETC...
					pla
ERRFIX1 PHA ; SAVE ERROR CODE
					jsr READONE ; PASS BACK NUMBER OF BYTES ACTUALLY READ.
					pla
					clc ; REPORT ERROR
					rts
*
READONE LDY #0 ; RETURN TOTAL NUMBER OF BYTES ACTUALLY READ
					clc ; THIS IS DERIVED FROM C.BYTES-RWREQ

					lda C.BYTES
					sbc RWREQL
					sta (C.OUTCNT),Y
					iny
					lda C.BYTES+1
					sbc RWREQH
					sta (C.OUTCNT),Y
					jmp RDPOSN ; LEAVE WITH VALID POSITION IN FCB.
*
PREPRW SEC ; ADJUST POINTER TO USER'S BUFFER TO
					lda USRBUF ; MAKE THE TRANSFER
					sbc TPOSLL
					sta USRBUF
					bcs PREPRW1 ; BRANCH IF NO ADJUSTMENT TO HI ADDR. NEEDED.
					dec USRBUF+1 ; NOTE: SARA ALLOWS INDIRECT FROM $101 UP
PREPRW1 LDY #FCBATTR ; AS LONG AS ACTUAL RESULTING ADDRESS IS >=$200
					lda (FCBPTR),Y ; TEST FOR NEW LINE ENABLED
					and #NLINEN ; SET CARRY IF IT IS.
					clc
					beq NONEWLIN ; BRANCH IF NEWLINE IS NOT ENABLED
					clc
					ldy #FCBNEWL
					lda (FCBPTR),Y ; MOVE NEWLINE CHARACTER TO MORE
					sta NLCHAR ; ACCESSABLE SPOT.
NONEWLIN LDY TPOSLL ; GET INDEX TO FIRST DATA
					lda DATPTR ; RESET LOW ORDER OF POSPTR TO BEGINNING OF PAGE.
					sta POSPTR
					ldx RWREQL ; AND LASTLY GET LOW ORDER COUNT OF REQUESTED BYTES.
					rts; RETURN				staTUSES...
*
READPART TXA
					bne RDPART0 ; BRANCH IF REQUEST IS NOT A EVEN PAGES
					lda RWREQH ; A CALL OF ZERO BYTES SHOULD NEVER GET HERE!
					beq SETRDNE ; BRANCH IF NOTHIN' TO DO.
					dec RWREQH
RDPART0 DEX
RDPART				lda (POSPTR),Y ; MOVE DATA TO USER'S BUFFER
					sta (USRBUF),Y ; ONE BYTE AT A TIME.
					txa ; NOTE: THIS ROUTINE IS CODED TO BE
					beq ENDRQCHK ; FASTEST WHEN NEWLINE IS DISABLED.
RDPART1 BCS TSTNEWL ; BRANCH IF NEW LINE NEEDS TO BE TESTED.
RDPART2 DEX
					iny ; PAGE CROSSED?
					bne RDPART ; NO. MOVE NEXT BYTE.
					lda POSPTR+1 ; TEST FOR END OF BUFFER
					inc USRBUF+1 ; BUT FIRST ADJUST USER BUFFER POINTER
					inc TPOSLH ; AND POSITION.
					bne RDPART3
					inc TPOSHI
RDPART3 INC POSPTR+1 ; AND SOS BUFFER HIGH ADDRESS.
					eor DATPTR+1 ; (CARRY HAS BEEN CLEVERLY UNDISTURBED.)
					beq RDPART ; BRANCH IF MORE TO READ IN BUFFER.
CLV ; INDICATE NOT FINISHED.
BVC RDPRTDNE ; BRANCH ALWAYS.
*
ENDRQCHK				lda RWREQH
					beq RDRQDNE ; BRANCH IF REQEST SATISFIED.
					iny ; DONE WITH THIS BLOCK OF DATA?
					bne ENDRCHK1 ; NO, ADJUST HIGH BYTE OF REQUEST.
					lda POSPTR+1 ; MAYBE- CHECK FOR END OF BLOCK BUFFER.
					eor DATPTR+1 ; (DON'T DISTURB CARRY)
					bne ENDRCHK2 ; BRANCH IF HI COUNT CAN BE DEALT WITH NEXT TIME.
ENDRCHK1 DEC RWREQH
ENDRCHK2 DEY ; RESTORE PROPER VALUE TO 'Y'
					jmp RDPART1
*
TSTNEWL				lda (POSPTR),Y ; GET LAST BYTE TRANSFERED AGAIN.
					eor NLCHAR ; HAVE WE MATCHED NEWLINE CHARACTER?
					bne RDPART2 ; NO, READ NEXT.
RDRQDNE INY ; ADJUST POSITION.
					bne SETRDNE
					inc USRBUF+1 ; BUMP POINTERS.
					inc TPOSLH
					bne SETRDNE
					inc TPOSHI
SETRDNE BIT SETVFLG ; (SET V FLAG)
RDPRTDNE STY TPOSLL ; SAVE LOW POSITION
BVS RDONE1
					inx ; LEAVE REQUEST AS +1 FOR NEXT CALL
RDONE1 STX RWREQL ; AND REMAINDER OF REQUEST COUNT.
					php ; SAVE				staTUSES

					clc ; ADJUST USER'S LOW BUFFER ADDRESS
					tya
					adc USRBUF
					sta USRBUF
					bcc RDPART4
					inc USRBUF+1 ; ADJUST HI ADDRESS AS NEEDED.
RDPART4 PLP ; RESTORE RETURN				staTUSES
SETVFLG RTS ; (THIS BYTE <$60> IS USED TO SET V FLAG)
*
FXDATPTR				lda DATPTR ; PUT CURRENT USER BUFFER
					sta USRBUF ; ADDRESS BACK TO NORMAL
					lda DATPTR+1
					sta USRBUF+1 ; BANK PAIR BYTE SHOULD BE MOVED ALSO.
					lda SISDATP
					sta SISUSRBF
					ldy #FCBBUFN ; RESTORE BUFFER ADDRESS
					lda (FCBPTR),Y
					ldx #DATPTR
					jmp GETBUFADR ; END VIA CALL TO BOB'S CODE.
*
*PAGE
*
* READ DIRECTORY FILE...
*
DREAD				jsr RDPOSN
					bcs ERRDRD ; PASS BACK ANY ERRORS
					jsr PREPRW ; PREPARE FOR TRANSFER.
					jsr READPART ; MOVE DATA TO USER'S BUFFER
BVC DREAD ; REPEAT UNTIL REQUEST IS SATISFIED.
					jsr READONE ; UPDATE FCB AS TO NEW POSITION.
					bcc DREDONE ; BRANCH IF ALL IS WELL.
					cmp #EOFERR ; WAS LAST READ TO END OF FILE?
					clc ; ANTICIPATE SOME OTHER PROBLEM
					bne DREDERR ; BRANCH IF NOT EOF ERROR.
					jsr SVMARK
					jsr ZIPDATA ; CLEAR OUT DATA BLOCK.
					ldy #FCBDATB+1 ; PROVIDE DUMMY BACK POINTER FOR FUTURE RE-POSITION
					lda (FCBPTR),Y ; GET HI BYTE OF LAST BLOCK.
					pha
					dey
					lda (FCBPTR),Y ; AND LOW BYTE.
					pha
					lda #0 ; NOW MARK CURRENT BLOCK AS IMPOSIBLE.
					sta (FCBPTR),Y
					iny
					sta (FCBPTR),Y
					tay ; NOW MOVE LAST BLOCK ADDRESS TO DATA BUFFER AS BACK POINTER.
					pla
					sta (DATPTR),Y
					pla
					iny
					sta (DATPTR),Y
DREDONE CLC ; INDICATE NO ERROR
DREDERR RTS
*
ERRDRD JMP ERRFIX1 ; REPORT HOW MUCH WE COULD TRANSFER BEFORE ERROR.
*
*PAGE
WRITE CLC ; FIRST DETERMINE IF REQESTED
					ldy #FCBATTR ; WRITE IS LEGAL
					lda (FCBPTR),Y
					and #WRITEN ; IS WRITE ENABLED?
					bne WRITE1 ; YES, CONTINUE...
ERRACCS				lda #ACCSERR ; REPORT ILLEGAL ACCESS.
					clc
WPERROR RTS
*
WRITE1				jsr TSTWPROT ; OTHERWISE, MAKE SURE DEVICE IS NOT WRITE PROTECTED.
					bcs WPERROR ; REPORT WRITE PROTECTED AND ABORT OPERATION.
*
					ldy #FCBMARK ; GET CURRENT MARK INTO 'TPOS' AND
					lda (FCBPTR),Y ; DETERMINE IF RESULTING POSITION
					sta TPOSLL ; EXCEEDS CURRENT END OF FILE.
					adc C.BYTES
					sta SCRTCH
					iny
					lda (FCBPTR),Y
					sta TPOSLH
					adc C.BYTES+1 ; (THIS WAS DONE STRAIGHT-LINE SINCE
					sta SCRTCH+1 ; WE'RE ADDING A TWO BYTE TO A THREE
					iny ; BYTE QUANTITY)

					lda (FCBPTR),Y
					sta TPOSHI
					adc #0 ; ADD IN REMAINING CARRY.
					sta SCRTCH+2
					ldy #FCBEOF+2 ; NOW TEST EOF AGAINST POSITION GENERATED
WEOFTST				lda SCRTCH-FCBEOF,Y
					cmp (FCBPTR),Y ; IS NEW POSITION > EOF?
					bcc WRITE2 ; NO, PROCEED.
					bne WADJEOF ; YES, ADJUST END OF FILE
					dey
					cpy #FCBEOF-1 ; HAVE WE COMPARED ALL TREE BYTES?
					bne WEOFTST ; NO, TEST NEXT LOWEST.
WADJEOF CLC ; ADJUST REQUEST TO WRITE UP TO (BUT
					ldy #FCBEOF ; NOT INCLUDING) END OF FILE.
WRTADJEOF				lda (FCBPTR),Y ; SAVE OLD EOF IN CASE OF LATER ERROR
					sta OLDEOF-FCBEOF,Y
					lda SCRTCH-FCBEOF,Y ; RESULT=EOF
*
					sta (FCBPTR),Y
					iny
					cpy #FCBEOF+3
					bne WRTADJEOF
WRITE2				lda C.BYTES
					sta RWREQL
					bne WRITE3 ; BRANCH IF WRITE REQUEST DEFINITELY NON-ZERO.
					cmp C.BYTES+1
					bne WRITE3 ; BRANCH IF WRITE REQUEST<>ZERO
					sta RWREQH
					jmp WRITDONE ; DO NOTHING.
*
*PAGE
WRITE3				lda C.BYTES+1
					sta RWREQH
					lda C.OUTBUF ; MOVE POINTER TO USERS BUFFER TO BFM
					sta USRBUF ; Z-PAGE AREA.
					lda C.OUTBUF+1
					sta USRBUF+1 ; (SO IT MAY BE ADJUSTED WITHOUT LOOSING
					lda SISOUTBF ; ORIGINAL ADDRESS.)
					sta SISUSRBF
					ldy #FCBSTYP ; NOW FIND OUT IF IT'S A TREE WRITE OR OTHER.
					lda (FCBPTR),Y
					cmp #TRETYP+1
					bcc TWRITE ; BRANCH IF A TREE FILE.
					jmp ERRACCS ; OTHEWISE RETURN AN ACCESS ERROR!
TWRITE				jsr RDPOSN ; READ BLOCK WE'RE
					bcs WRITERROR
					ldy #FCBSTAT
					lda (FCBPTR),Y
					and #DATALC+IDXALC+TOPALC
					beq TREWRT1
					ldy #0 ; FIND OUT IF ENOUGH DISK SPACE IS AVAILABLE FOR
TWRTALC INY ; INDEXES AND DATA BLOCK
					lsr A
					bne TWRTALC
					sty REQL
					sta REQH
					jsr TSFRBLK
					bcs WRITERROR ; PASS BACK ANY ERRORS.
					ldy #FCBSTAT
					lda (FCBPTR),Y ; NOW GET MORE SPECIFIC.
					and #TOPALC ; ARE WE LACKING A TREE TOP?
					beq TSTSAPWR ; NO, TEST FOR LACK OF SAPLING LEVEL INDEX.
					jsr TOPDOWN ; GO ALLOCATE TREE TOP AND ADJUST FILE TYPE.
					bcc DBLOKALC ; CONTINUE WITH ALLOCATION OF DATA BLOCK.
WRITERROR PHA ; SAVE ERROR
					ldy #FCBEOF
WRITERR01				lda OLDEOF-FCBEOF,Y
					sta (FCBPTR),Y ; RESTORE OLD EOF UPON ERR
					iny
					cpy #FCBEOF+3
					bne WRITERR01
					ldy #FCBMARK
WRITERR02				lda OLDMARK-FCBMARK,Y
					sta (FCBPTR),Y ; AND RESTORE OLD MARK!
					iny
					cpy #FCBMARK+3
					bne WRITERR02
					pla
					clc
					rts; ERROR RETURN
*

TWRITEGO BVC TWRITE ; A PIGGY-BACK BACKWARD BRANCH
*
*PAGE
TSTSAPWR				lda (FCBPTR),Y ; GET				staTUS BYTE AGAIN.
					and #IDXALC ; DO WE NEED A SAPLING LEVEL INDEX BLOCK?
					beq DBLOKALC ; NO, ASSUME IT'S JUST A DATA BLOCK NEEDED.
					jsr SAPDOWN ; GO ALLOCATE AN INDEX BLOCK AND UPDATE TREE TOP.
					bcs WRITERROR ; RETURN ANY ERRORS.
DBLOKALC				jsr ALCWBLK ; GO ALLOCATE FOR DATA BLOCK.
					bcs WRITERROR
					lda TPOSHI ; CALCULATE POSITION WITHIN INDEX BLOCK.
					lsr A
					lda TPOSLH
					ror A
					tay ; NOW PUT BLOCK ADDRESS INTO INDEX BLOCK
					inc TINDX+1 ; HIGH BYTE FIRST.
					lda SCRTCH+1
					tax
					sta (TINDX),Y
					dec TINDX+1 ; (RESTORE POINTER TO LOWER PAGE OF INDEX BLOCK)
					lda SCRTCH ; GET LOW BLOCK ADDRESS
					sta (TINDX),Y ; NOW STORE LOW ADDRESS.
					ldy #FCBDATB ; ALSO UPDATE FILE CONTROL BLOCK TO INDICATE
					sta (FCBPTR),Y ; THAT THIS BLOCK IS ALLOCATED.
					iny
					txa ; GET HIGH ADDRESS AGAIN.
					sta (FCBPTR),Y
					ldy #FCBSTAT
					lda (FCBPTR),Y
					ora #IDXMOD
					and #$FF-DATALC-IDXALC-TOPALC ; CLEAR ALLOCATION REQUIREMENT BITS.
					sta (FCBPTR),Y
TREWRT1				ldx #USRBUF ; LOCATE POINTER TO ADJUST <SRS 82.162>
					jsr WRAPADJ ; ADJUST FOR BANK CROSSING <SRS 82.162>
					jsr PREPRW ; WRITE ON
					jsr WRTPART
BVC TWRITEGO
WRITDONE JMP RDPOSN ; UPDATE FCB WITH NEW POSITION.
*
*PAGE
WRTPART TXA
					bne WRPART ; BRANCH IF REQUEST IS NOT A EVEN PAGES
					lda RWREQH ; A CALL OF ZERO BYTES SHOULD NEVER GET HERE!
					beq SETWRDNE ; DO NOTHING!
*
					dec RWREQH
WRPART DEX
					lda (USRBUF),Y ; MOVE DATA FROM USER'S BUFFER
					sta (POSPTR),Y ; ONE BYTE AT A TIME.
					txa
					beq ENDWQCHK
WRPART2 INY ; PAGE CROSSED?
					bne WRPART ; NO. MOVE NEXT BYTE.
					lda POSPTR+1 ; TEST FOR END OF BUFFER
					inc USRBUF+1 ; BUT FIRST ADJUST USER BUFFER POINTER
					inc TPOSLH ; AND POSITION.
					bne WRPART3
					inc TPOSHI
WRPART3 INC POSPTR+1 ; AND SOS BUFFER HIGH ADDRESS.
					eor DATPTR+1 ; (CARRY HAS BEEN CLEVERLY UNDISTURBED.)
					beq WRPART ; BRANCH IF MORE TO WRITE TO BUFFER.
CLV ; INDICATE NOT FINISHED.
BVC WRPRTDNE ; BRANCH ALWAYS.
*
ENDWQCHK				lda RWREQH
					beq WRTRQDNE ; BRANCH IF REQEST SATISFIED.
					iny ; ARE WE DONE WITH THIS BLOCK OF DATA?
					bne ENDWCHK1 ; BRANCH IF NOT.
					lda POSPTR+1
					eor DATPTR+1 ; WHILE THIS IS REDUNDANT, IT'S NECESSARY FOR
					bne ENDWCHK2 ; PROPER ADJUSTMENT OF REQUEST COUNT.
ENDWCHK1 DEC RWREQH ; (NOT FINISHED- OK TO ADJUST HI BYTE.)
ENDWCHK2 DEY ; RESET MODIFIED Y
					jmp WRPART2
*
WRTRQDNE INY ; AND POSITION.
					bne SETWRDNE
					inc USRBUF+1 ; BUMP POINTERS.
					inc TPOSLH
					bne SETWRDNE
					inc TPOSHI

SETWRDNE BIT SETVFLG ; (SET V FLAG)
WRPRTDNE STY TPOSLL ; SAVE LOW POSITION
					stx RWREQL ; AND REMAINDER OF REQUEST COUNT.
					php ; SAVE				staTUSES
					ldy #FCBSTAT
					lda (FCBPTR),Y
					ora #DATMOD+USEMOD
					sta (FCBPTR),Y
					clc ; ADJUST USER'S LOW BUFFER ADDRESS
					lda TPOSLL
					adc USRBUF
					sta USRBUF
					bcc WRPART4
					inc USRBUF+1 ; ADJUST HI ADDRESS AS NEEDED.
WRPART4				jsr FCBUSED ; SET DIRECTORY FLUSH BIT
					plp ; RESTORE RETURN				staTUSES
					rts
*PAGE
TOPDOWN				jsr SWAPDOWN ; FIRST MAKE CURRENT 1ST BLOCK AN ENTRY IN NEW TOP.
					bcs TPDWNERR ; RETURN ANY ERRORS
					ldy #FCBSTYP ; FIND OUT IF STORAGE TYPE HAS BEEN CHANGED TO 'TREE'.
					lda (FCBPTR),Y ; (IF NOT, ASSUME IT WAS ORIGINALLY A SEED AND
					cmp #TRETYP ; BOTH LEVELS NEED TO BE BUILT.
					beq TOPDWN1 ; OTHERWISE, ONLY AN INDEX NEED BE ALLOCATED)
					jsr SWAPDOWN ; MAKE PREVIOUS SWAP A SAP LEVEL INDEX BLOCK.
					bcs TPDWNERR
TOPDWN1				jsr ALCWBLK ; GET ANOTHER BLOCK ADDRESS FOR THE SAP LEVEL INDEX.
					bcs TPDWNERR
					lda TPOSHI ; CALCULATE POSITION OF NEW INDEX BLOCK
					lsr A ; IN THE TOP OF THE TREE.
					tay
					lda SCRTCH ; GET ADDRESS OF NEWLY ALOCATED INDEX BLOCK AGAIN
					tax
					sta (TINDX),Y
					inc TINDX+1
					lda SCRTCH+1
					sta (TINDX),Y ; SAVE HI ADDRESS
					dec TINDX+1
					ldy #FCBIDXB+1 ; MAKE NEWLY ALLOCATED BLOCK THE CURRENT INDEX BLOCK.
					sta (FCBPTR),Y
					txa
					dey
					sta (FCBPTR),Y
					jsr WFCBFST ; SAVE NEW TOP OF TREE.
					bcs TPDWNERR
					jmp ZTMPIDX ; END BY RE-CLEARING CURRENT (NEW) INDEX BLOCK.
*
SAPDOWN LDY #FCBSTYP ; FIND OUT IF WE'RE DEALING WITH A TREE
					lda (FCBPTR),Y ; OR A SIMPLE SEED.
					cmp #SEEDTYP ; IF SEED THEN AN ADJUSTMENT TO FILE TYPE IS NECESSARY.
					beq SAPDWN1 ; BRANCH IF SEED.
					jsr RFCBFST ; OTHERWISE READ IN TOP OF TREE.
					bcc TOPDWN1 ; BRANCH IF NO ERROR.
TPDWNERR RTS ; RETURN ERRORS
*
*PAGE
SAPDWN1				.eq *; MAKE CURRENT SEED INTO A SAPLING
*
SWAPDOWN				jsr ALCWBLK ; ALLOCATE A BLOCK BEFORE SWAP
					bcs SWAPERR ; RETURN ERRORS IMMEDIATELY.
					ldy #FCBFRST ; GET PREVIOUS FIRST BLOCK
					lda (FCBPTR),Y ; ADDRESS INTO INDEX BLOCK.
					pha; SAVE TEMPORARLY WHILE SWAPPING IN NEW TOP INDEX
					lda SCRTCH ; GET NEW BLOCK ADDRESS (LOW)
					tax
					sta (FCBPTR),Y
					iny
					lda (FCBPTR),Y
					pha
					lda SCRTCH+1 ; AND HIGH ADDRESS TOO.
					sta (FCBPTR),Y
					ldy #FCBIDXB+1 ; MAKE NEW TOP ALSO THE CURRENT INDEX IN MEMORY.
					sta (FCBPTR),Y
					txa ; GET LOW ADDRESS AGAIN
					dey
					sta (FCBPTR),Y
					ldy #0 ; MAKE PREVIOUS THE FIRST ENTRY IN SUB INDEX
					inc TINDX+1
					pla
					sta (TINDX),Y
					dec TINDX+1

					pla
					sta (TINDX),Y
					jsr WFCBFST ; SAVE NEW FILE TOP.
					bcs SWAPERR
					ldy #FCBSTYP ; NOW ADJUST STORAGE TYPE
					lda #1 ; BY ADDING 1 (THUS SEED BECOMES SAPLING BECOMES TREE)
					adc (FCBPTR),Y
					sta (FCBPTR),Y
					ldy #FCBSTAT
					lda (FCBPTR),Y ; MARK STORAGE TYPE MODIFIED.
					ora #STPMOD
					sta (FCBPTR),Y
					clc ; RETURN 'NO ERROR'				staTUS.
SWAPERR RTS
*
*PAGE
ALCWBLK				jsr ALC1BLK
					bcs ALUSERR
					ldy #FCBUSE
					lda (FCBPTR),Y ; BUMP CURRENT USAGE COUNT BY 1.
					clc
					adc #1
					sta (FCBPTR),Y
					bcc INCUSG1
					iny
					lda (FCBPTR),Y
					adc #0
					sta (FCBPTR),Y
					incUSG1 LDY #FCBSTAT ; MARK USAGE AS MODIFIED.
					lda (FCBPTR),Y
					ora #USEMOD
					sta (FCBPTR),Y
					clc ; INDICATE NO ERROR
ALUSERR RTS ; ALL DONE
*
TSTWPROT LDY #FCBSTAT ; CHECK FOR A 'NEVER BEEN MODIFIED' CONDITION
					lda (FCBPTR),Y ; GET				staTUS BYTE
					and #USEMOD+DATMOD+IDXMOD+EOFMOD
					clc ; ANTICIPATE WRITE OK
					bne ALUSERR ; ORDINARY RTS
					ldy #FCBDEVN ; GET FILE'S DEVICE NUMBER
					lda (FCBPTR),Y
					sta DEVNUM ; GET CURRENT				staTUS OF BLOCK DEVICE
TWRPROT1				lda #STATCMD
					sta DHPCMD
					lda #STATSUB ; STORE SUB COMMAND OF				staTUS CALL
					sta DSTATREQ
					lda #>TWRCODE
					sta DSTATBFL ; FETCH RETURN CODE IN SCRATCH AREA
					lda #<TWRCODE
					sta DSTATBFH
					lda #0 ; MAKE SURE REGULAR RAM IS SELECTED (NO BANKS)
					sta SISDSTAT
					sta SERR ; CLEAR GLOBAL ERROR FLAG
					lda DEVNUM ; SET UP LAST PARM
					sta UNITNUM ; FOR DEVICE CALL
					jsr DMGR ; MAKE THE EXTERNAL CALL
					bcs WPROTRET ; RETURN ANY SPECIFIC ERRORS
					lda TWRCODE ; GET				staTUS BYTE
					lsr A ; SHIFT WRITE PROTECT				staTE INTO CARRY
					lsr A
					lda #XNOWRITE ; ANTICIPATE WRITE PROTECTED.
					rts; CARRY IS INDETERMINATE
WPROTRET .eq *
					cmp #XDISKSW ; IF EXPLICITLY DISK SWITCH
					bne WPROT1 ; BRANCH IF XNODRIVE OR XNOWRITE
					sta DSWGLOB ; IF DISKSW, FLAG UNTIL ENTIRE OPERATION IS COMPLETE
					clc
					rts; DISKSWITCH DOESNT SET CARRY
WPROT1 SEC
					rts
DSWGLOB DS 1 ; DISK SWITCH GLOBAL
TWRCODE DS 1 ; A RARE EMBEDDED TEMP STORE
*
*PAGE
*
* MEMORY 'WRAP-AROUND' ADJUST ROUTINE. THIS ROUTINE ADJUSTS
* ADDRESSES THAT CROSS BANK PAIR BOUNDARIES. ON ENTRY, X CONTAINS
* THE OFFSET OF THE ZERO PAGE EXTENDED POINTER TO BE ADJUSTED.
* ON EXIT, THE POINTER WILL HAVE BEEN ADJUSTED, IF NECESSARY,
* AND THE ASSOCIATED X-BYTE WILL ALSO HAVE BEEN ADJUSTED.

* ONLY ADDRESSES IN THE RANGE $8200-$8E00 WILL BE ADJUSTED.
*
* UPON EXIT, A CONTAINS HIGH BYTE OF ADDRESS & Y CONTAINS UPDATED X-BYTE.
* THIS ROUTINE LEAVES X UNCHANGED.
*
WRAPADJ				lda 1,X ; GET HIGH ADDRESS BYTE <SRS 82.162>
					ldy SISTER+1,X ; CHECK X-BYTE <SRS 82.162>
					bpl WRAPDNE ; NOT AN EXTENDED ADDRESS. <SRS 82.162>
					cmp #$82 ; DOES IT NEED UPDATING? <SRS 82.162>
					bcc WRAPDNE ; NO <SRS 82.162>
					cpy #$8F ; SPECIAL BANK? <SRS 82.162>
					bcs WRAPDNE ; NO <SRS 82.162>
					and #$7F ; ADJUST THE ADDRESS <SRS 82.162>
					sta 1,X ; UPDATE <SRS 82.162>
					inc SISTER+1,X ; INCREMENT X-BYTE <SRS 82.162>
					iny ; UPDATE Y ALSO <SRS 82.162>
*
WRAPDNE RTS ; RETURN VALID HIGH ADDRESS AND BANK BYTE.

CHN CLOSE/EOF,4,2

*************************************************************************
* END OF APPLE /// SOS 1.3 SOURCE CODE FILE: READ.WRITE
*************************************************************************




================================================================================================
FILE: "SOS.SCMGR.SRC.TEXT"
================================================================================================
*************************************************************************
* APPLE /// SOS 1.3 SOURCE CODE FILE: SCMGR.SRC
*************************************************************************
* ASSEMBLER: APPLE ][ 6502 ASSEMBLER from APPLE COMPUTER TOOLKIT

*SBTL "SOS 1.1 SYSTEM CALL MANAGER"
*REL
					INCLUDE SOSORG,6,1,254
ORG ORGSCMGR
ZZORG .eq *
*MSB OFF
*REP 60
* COPYRIGHT (C) APPLE COMPUTER INC. 1980
* ALL RIGHTS RESERVED
*REP 60
*
* SYSTEM CALL MANAGER (VERSION = 1.1O )
* (DATE = 8/04/81)
*
* THE SYSTEM CALL MANAGER:
* (1) RETRIEVE THE SYSCALL #,
* (2) DETERMINE THE LOCATION OF THE SYSTEM CALL PARMS AND
* MOVE THEM TO THE SOS ZPAGE,
* (3) TRANSFER CONTROL TO THE APPROPRIATE INTERFACE MANAGER,
* (FILE,DEVICE,UTILITY,MEMORY)
*
*REP 60
*
*ENTRY SCMGR
*
*EXTRN FMGR
*EXTRN DMGR
*EXTRN UMGR
*EXTRN MMGR
*EXTRN DBUGBRK
*
*EXTRN SYSERR
*EXTRN SERR
*EXTRN BADSCNUM
*EXTRN BADCZPAGE
*EXTRN BADXBYTE
*EXTRN BADSCPCNT
*EXTRN BADSCBNDS
*
*EXTRN SZPAGE
*EXTRN SXPAGE
*EXTRN CZPAGE
*EXTRN CXPAGE
*EXTRN CSPAGE
*PAGE
*REP 60
*
* SYSTEM CALL PARAMETER DEFINITION TABLES
*
* EACH ENTRY IS FOUR BYTES LONG. THE FIRST BYTE CONTAINS THE
* NUMBER OF PARMS IN THE CALL. THE REMAINING SIX NIBBLES, EACH
* DEFINE A PARAMETER IN THE CALL. THE FIRST BIT OF THE
* NIBBLE DEFINES WHETHER THE PARM IS INPUT (0) OR OUTPUT (1).
* THE NEXT BIT DEFINES WHETHER THE PARM IS BY VALUE (0)
* OR BY REFERENCE (1). THE FINAL TWO BITS SPECIFY THE
* PARM LENGTH IN BYTES (E.G. 0=LENGTH OF 1, 3=LENGTH OF 4 BYTES)
*
*REP 60
*
* FILE SYSTEM CALL DEFINITIONS
*
FSC.CNT .eq $13
FSC.TBL .eq *
DFB $3,$5D,$00,$00 ; SCNUM=$C0 - CREATE
DFB $1,$50,$00,$00 ; " =$C1 - DESTROY
DFB $2,$55,$00,$00 ; " =$C2 - RENAME
DFB $3,$5D,$00,$00 ; " =$C3 - SET.FILE.INFO
DFB $3,$5D,$00,$00 ; " =$C4 - GET.FILE.INFO
DFB $4,$55,$99,$00 ; " =$C5 - VOLUME
DFB $1,$50,$00,$00 ; " =$C6 - SET.PREFIX
DFB $2,$50,$00,$00 ; " =$C7 - GET.PREFIX

DFB $4,$58,$D0,$00 ; " =$C8 - OPEN
DFB $3,$00,$00,$00 ; " =$C9 - NEW.LINE
DFB $4,$05,$19,$00 ; " =$CA - READ
DFB $3,$05,$10,$00 ; " =$CB - WRITE
DFB $1,$00,$00,$00 ; " =$CC - CLOSE
DFB $1,$00,$00,$00 ; " =$CD - FLUSH
DFB $3,$00,$30,$00 ; " =$CE - SET.MARK
DFB $2,$0B,$00,$00 ; " =$CF - GET.MARK
DFB $3,$00,$30,$00 ; " =$D0 - SET.EOF
DFB $2,$0B,$00,$00 ; " =$D1 - GET.EOF
DFB $1,$00,$00,$00 ; " =$D2 - SET.LEVEL
DFB $1,$80,$00,$00 ; " =$D3 - GET.LEVEL
*PAGE
*
* DEVICE SYSTEM CALL DEFINITIONS
*
DSC.CNT .eq 5
DSC.TBL .eq *
DFB $5,$05,$11,$90 ; SCNUM=$80 - D.READ
DFB $4,$05,$11,$00 ; " =$81 - D.WRITE
DFB $3,$00,$50,$00 ; " =$82 - D.STATUS
DFB $3,$00,$50,$00 ; " =$83 - D.CONTROL
DFB $2,$58,$00,$00 ; " =$84 - GET.DEV.NUM
DFB $4,$05,$D0,$00 ; " =$85 - D.INFO
*
* UTILITY SYSTEM CALL DEFINITIONS
*
USC.CNT .eq 5
USC.TBL .eq *
DFB $1,$00,$00,$00 ; SCNUM=$60 - SET.FENCE
DFB $1,$80,$00,$00 ; " =$61 - GET.FENCE
DFB $1,$50,$00,$00 ; " =$62 - SET.TIME
DFB $1,$50,$00,$00 ; " =$63 - GET.TIME
DFB $2,$0B,$00,$00 ; " =$64 - JOYSTICK
DFB $0,$00,$00,$00 ; " =$65 - COLD.START
*
* MEMORY SYSTEM CALL DEFINITIONS
*
MSC.CNT .eq 5
MSC.TBL .eq *
DFB $4,$11,$08,$00 ; SCNUM=$40 - REQUEST.SEG
DFB $6,$00,$99,$98 ; " =$41 - FIND.SEG
DFB $3,$00,$90,$00 ; " =$42 - CHANGE.SEG
DFB $5,$09,$99,$80 ; " =$43 - GET.SEG.INFO
DFB $2,$18,$00,$00 ; " =$44 - GET.SEG.NUM
DFB $1,$00,$00,$00 ; " =$45 - RELEASE.SEG
*
* DEBUG SYSTEM CALL DEFINITION
*
DBUG .eq $FE
*PAGE
*REP 60
*
* DATA DECLARATIONS
*
*REP 60
Z.REG .eq $FFD0
SP.SAVE .eq $01FF
Z.SAVE .eq $01FD
B.SAVE .eq $01FC
*
ADR.LOW .eq $2000 ; LOW ADDRESS (BOUNDS CHECKING)
ADR.HIGH .eq $B800 ; HIGH ADDRESS
ADR.MID .eq $A000 ; MIDDLE ADDRESS
*
* SCMGR'S VARIABLES
*
SCM.VARS .eq $E0
SCNUM .eq SCM.VARS+0 ; SYSTEM CALL NUMBER
SCRNUM .eq SCM.VARS+0 ; SYSTEM CALL REQUEST NUMBER
SCPTR .eq SCM.VARS+1 ;&2 SYSTEM CALL POINTER
MOVE.VARS .eq SCPTR+2 ; !! (LOOKOUT) !!
*
*
F.TPARMX .eq $A0 ; FILE SYS CALL PARM				staRT LOC
D.TPARMX .eq $C0 ; DEVICE SYS CALL PARM				staRT LOC
U.TPARMX .eq $C0 ; UTILITY SYS CALL PARM				staRT LOC
M.TPARMX .eq $60 ; MEMORY SYS CALL PARM				staRT LOC
*
* MOVE.PARM'S VARIABLES
*

TPARMX .eq MOVE.VARS+0 ; TARGET ADR OF SYS CALL PARMS
DFN.PTR .eq MOVE.VARS+1 ;&2
DFN.PTRX .eq MOVE.VARS+3
SCPTRX .eq MOVE.VARS+4
RGHT.NIB .eq MOVE.VARS+5
SCT.DFN .eq MOVE.VARS+6
SCT.DCNT .eq MOVE.VARS+7
PARM.CNT .eq MOVE.VARS+8
*PAGE
*REP 60
*
* SYSTEM CALL MANAGER
*
*REP 60
*
SCMGR .eq *
					lda #<SZPAGE ; SET Z REG TO SOS ZPAGE
					sta Z.REG
*
* SET SYSTEM X BYTES TO ABSOLUTE ADDRESS MODE.
*
					lda #0
					sta SXPAGE+SCPTR+1
					sta SERR ; AND INIT SYSTEM ERR CODE
*
* CALLER'S Z REG MUST BE $1A !!
* (B REG NOT CHECKED)
*
					lda Z.SAVE
					cmp #<CZPAGE
					beq SCM005
					lda #>BADCZPAGE
					jsr SYSERR ; EXIT TO DISPATCHER
*
* RETRIEVE CALLER'S PC ON HIS				staCK
*
SCM005				ldx SP.SAVE
					lda CSPAGE+6,X
					sta SCPTR+1
					lda CSPAGE+5,X
					sta SCPTR
					bne SCM010 ; AND POINT IT TO SYS CALL NUM
					dec SCPTR+1
SCM010 DEC SCPTR
*
* ADVANCE CALLER'S PC ON HIS				staCK.
*
					clc
					lda CSPAGE+5,X
					adc #2
					sta CSPAGE+5,X
					bcc SCM020
					inc CSPAGE+6,X
*
* RETRIEVE SYSTEM CALL NUMBER
*
SCM020 LDY #0
					lda (SCPTR),Y
					cmp #DBUG
					bne SCM025
					jsr DBUGBRK ; DEBUG SYSTEM CALL
SCM025				sta SCNUM
*
* RETRIEVE SYSTEM CALL PARAMETER ADDRESS
*
					iny
					ldx #>SCPTR
					jsr POINTER
					bcc SCM030
					rts; ERROR EXIT
*
* CASE INTERFACE CODE OF SYSTEM CALL NUMBER
* (INTERFACE CODE STRIPPED, LEAVING REQUEST CODE)
*
SCM030				lda #$20
					bit SCNUM
					bpl SCM050
					lda SCNUM
					and #$3F
					sta SCRNUM
BVC SCM040

*
					lda #F.TPARMX ; "11XXXXXX" - JMP TO FILE MANAGER.
					sta TPARMX
					ldx #>FSC.TBL
					ldy #<FSC.TBL
					lda #FSC.CNT
					jsr MOVE.PARMS
					bcs SCM.ERR1 ; ERR EXIT
					jmp FMGR
*
SCM040				lda #D.TPARMX ; "10XXXXXX" - JMP TO DEVICE MANAGER.
					sta TPARMX
					ldx #>DSC.TBL
					ldy #<DSC.TBL
					lda #DSC.CNT
					jsr MOVE.PARMS
					bcs SCM.ERR1 ; ERR EXIT
					jmp DMGR
*
SCM050 BVC SCM.ERR
					php
					lda SCNUM
					and #$1F
					sta SCRNUM
					plp
					beq SCM060
*
					lda #U.TPARMX ; "011XXXXX" - JMP TO UTILITY MANAGER.
					sta TPARMX
					ldx #>USC.TBL
					ldy #<USC.TBL
					lda #USC.CNT
					jsr MOVE.PARMS
					bcs SCM.ERR1 ; ERR EXIT
					jmp UMGR
*
SCM060				lda #M.TPARMX ; "010XXXXX" - JMP TO MEMORY MANAGER.
					sta TPARMX
					ldx #>MSC.TBL
					ldy #<MSC.TBL
					lda #MSC.CNT
					jsr MOVE.PARMS
					bcs SCM.ERR1 ; ERR EXIT
					jmp MMGR
*
SCM.ERR				lda #>BADSCNUM ; ERROR, INVALID SYSTEM CALL NUMBER.
SCM.ERR1				jsr SYSERR ; EXIT TO DISPATCHER ON ERROR
*PAGE
*REP 60
*
* MOVE.PARMS
*
* MOVES THE CALLER'S PARAMETERS TO THE OPERATING SYSTEM'S
* ZERO PAGE, ACCORDING TO THE SPECIFICATIONS CONTAINED
* IN THE SPECIFIED SYS CALL DFN TABLE.
*
* INPUT: (A) = MAX # ENTRIES IN PARM DFN TABLE
* (X) = PARM DFN TBL ADR (LO)
* (Y) = " (HI)
* SCPTR = ADR OF CALLER'S SYS CALL PARMS
* ERROR: CARRY SET (SYSERR)
*
*REP 60
*
MOVE.PARMS .eq *
					stx DFN.PTR ; SAVE ADR OF DEFINITION TABLE
					sty DFN.PTR+1
*
* IF REQ NUM > MAX REQ NUM (A REG)
*
					cmp SCRNUM
					bcs MOVE010
*
* THEN ERR(BAD SYS CALL NUM)
*
					lda #>BADSCNUM
					bcc SYSERR1 ;BRANCH ALWAYS TAKEN
*
* CALCULATE DEFINITION TABLE INDEX
* AND INIT SYS CALL PARM INDEX
*

MOVE010				lda SCRNUM
					asl A
					asl A
					sta DFN.PTRX
					lda #0
					sta SXPAGE+DFN.PTR+1 ; AND X BYTE
					sta SCPTRX
*
* IF SCPTR(SCPTRX)<>DFN.PTR(DFN.PTRX) THEN ERR
*
					tay
					lda (SCPTR),Y
					ldy DFN.PTRX
					cmp (DFN.PTR),Y
					beq INITLOOPCT
*
					lda #>BADSCPCNT ; ERR, CALLER'S PARM COUNT INVALID
SYSERR1				jsr SYSERR ; EXIT
*
* INIT LOOP CTR(PARM.CNT) TO # OF PARMS IN SYS CALL
*
INITLOOPCT				sta PARM.CNT
*
* ADVANCE PTRS
*
*
					inc SCPTRX
					inc DFN.PTRX
*
* MOVE REQ CODE TO SYS ZPAGE PARM LIST
* AND ADVANCE SYS ZPAGE PTR (X=TPARMX)
*
					lda SCRNUM
					ldx TPARMX
					sta 0,X
					inx
*
* INIT NIBBLE FLAG TO "RIGHT" NIBBLE
* ZERO				staTE="LEFT" NIBBLE
*
					lda #$FF
					sta RGHT.NIB
*REP 60
*
* BEGIN PARAMETER PROCESSING LOOP
*
PARMLOOP				lda RGHT.NIB
					eor #$FF ; COMPLEMENT NIBBLE FLAG
					sta RGHT.NIB
*
* IF "LEFT" NIBBLE
*
					bne ELSE.RNIB
*
* THEN FETCH SYS CALL PARM DFN
* AND # OF BYTES IN PARM WITHIN IT
*
					ldy DFN.PTRX
					lda (DFN.PTR),Y
					sta SCT.DFN
					and #$30
					lsr A
					lsr A
					lsr A
					lsr A
					sta SCT.DCNT
					bpl VALUE ;BRANCH ALWAYS
*
* ELSE FETCH SYS CALL PARM DFN
* AND # OF BYTES IN PARM WITHIN IT
* FROM "RIGHT" NIBBLE OF DFN BYTE
*
ELSE.RNIB				lda SCT.DFN
					tay
					and #$03
					sta SCT.DCNT
					tya
					asl A
					asl A
					asl A
					asl A

					sta SCT.DFN
					inc DFN.PTRX ; ADVANCE SYS CALL DFN PTR
*REP 60
*
* PARAMETER PASSED BY VALUE
*
*REP 60
VALUE BIT SCT.DFN
BVS REFERENCE
					bmi VAL.OUT
*
* INPUT BY VALUE
*
					ldy SCPTRX ; MOVE BYTES TO ZPAGE
VAL.IN				lda (SCPTR),Y
					sta 0,X
					iny
					inx
					dec SCT.DCNT
					bpl VAL.IN
					sty SCPTRX
					jmp ENDLOOP1
*
* OUTPUT BY VALUE
*
VAL.OUT CLC ; BUILD PTR TO PARM ON ZPAGE
					lda SCPTR
					adc SCPTRX
					sta 0,X
					inx
					lda SCPTR+1
					adc #0
					sta 0,X
*
					clc ; ADVANCE INDEX TO NEXT PARM
					lda SCPTRX
					adc SCT.DCNT
					sta SCPTRX
*
					lda SXPAGE+SCPTR+1 ; INCLUDE X BYTE
					sta SXPAGE,X
					jmp ENDLOOP2
*REP 60
*
* PARAMETER PASSED BY REFERENCE
*
*REP 60
REFERENCE BPL REF1
*
* "LIST" PTR FOUND, CHK IF "LENGTH" PARM = 0
*
					ldy SCPTRX
					iny
					iny
					lda (SCPTR),Y
					beq ENDLOOP0 ; "LENGTH" PARM=0, SKIP "LIST" PARM
*
REF1 LDY SCPTRX ; MOVE PTR TO ZPAGE
					jsr POINTER
					bcs PARM.ERR ; ERROR EXIT
*
* ADVANCE SYSTEM ZPAGE POINTER (X), CALLER'S PARM PTR.
* DECREMENT PARM CTR AND CHECK IF LAST PARM PROCESSED.
*
ENDLOOP0 INX
					inc SCPTRX
ENDLOOP2 INX
					inc SCPTRX
ENDLOOP1 DEC PARM.CNT
					beq PARM.EXIT
					bmi PARM.EXIT ;SPECIAL FOR 'COLD				staRT'
					jmp PARMLOOP
*
* END OF PARAMETER PROCESSING LOOP
*
*REP 60
*
PARM.EXIT CLC ; NO ERRORS
PARM.ERR RTS ; RETURN TO SYS CALL MANAGER
*PAGE
*REP 60

*
* POINTER
*
* INPUT: SRC ADR (SCPTR),Y & (SCPTR),Y+1
* DEST ADR (X)
*
* OUTPUT: SCPTR UNCHANGED
* X REG "
* A,Y REGS FLATTENED
*
* ERROR: CARRY SET (SYSERR)
*
* POINTER. RETRIEVES THE CALLER'S POINTER PARAMETER IN
* (SCPTR),Y, PERFORMS ADDRESS COMPENSATION, IF NECESSARY
* AND PLACES THE RESULTING POINTER AT X, X+1 AND SXPAGE+1,X.
*
*REP 60
*
POINTER .eq *
					lda (SCPTR),Y
					pha
					iny
					lda (SCPTR),Y
					beq INDIRECT
*
					sta 1,X ; DIRECT POINTER
					pla
					sta 0,X
					ldy #0
					beq PTR010
*
INDIRECT PLA ; INDIRECT POINTER
					tay
					lda CZPAGE,Y
					sta 0,X
					lda CZPAGE+1,Y
					sta 1,X
					lda CXPAGE+1,Y
					tay
*
PTR010				lda 1,X
*
* CHECK BOUNDS OF CALLER'S POINTER PARAMETER
*
					cpy #$8F
					bcc PTR.X808E
					beq PTR.X8F
					bcs PTR.ERR1 ; ERROR, INVALID X BYTE
PTR.X8F CMP #<ADR.LOW
					bcc PTR.ERR
					cmp #<ADR.HIGH
					bcs PTR.ERR
					bcc PTR.EXIT
*
* X BYTE = 80..8E
*
PTR.X808E CPY #$80
					bcc PTR.X0
					cmp #0
					beq PTR.ERR
					cmp #$FF
					bne PATCH
					iny ; $8N:FFXX --> $8N+1:7FXX
					lda #$7F
					bne PTR.EXIT
*
* X BYTE = 0
*
PTR.X0 CPY #0
					bne PTR.ERR1
					cmp #<ADR.LOW
					bcc PTR.ERR
					cmp #<ADR.HIGH
					bcs PTR.ERR
					cmp #<ADR.MID
					bcs PTR.EXIT
*
					pha
					lda B.SAVE
					and #$0F
					bne PTR030

					pla ; $B=0:2000..9FFF --> $8F:2000.9FFF
					ldy #$8F
					bne PTR.EXIT
*
PTR030 ORA #$80 ; $B<>0:2000..9FFF --> $8B:0000..7FFF
					tay
					pla
					clc
					sbc #$20
					bne PATCH
					dey ; $8B:00XX --> $8B-1:80XX
					lda #$80
*
PATCH CPY #$80 ; KLUDGE FOR BFM: $8N:01XX --> $8N-1:81XX
					bcc PTR.EXIT
					cmp #1
					bne PTR.EXIT
					cpy #$80
					beq PTR.ERR ; ERROR, $80:01XX NOT ALLOWED
					dey
					lda #$81
*
PTR.EXIT				sta 1,X
					tya
					sta SXPAGE+1,X
					clc
					rts
*
*
PTR.ERR				lda #>BADSCBNDS
					jsr SYSERR
PTR.ERR1				lda #>BADXBYTE
					jsr SYSERR
*
*LST ON
ZZEND .eq *
ZZLEN .eq ZZEND-ZZORG
IFNE ZZLEN-LENSCMGR
FAIL 2,"SOSORG FILE IS INCORRECT FOR SCMGR"
FIN

*************************************************************************
* END OF APPLE /// SOS 1.3 SOURCE CODE FILE: SCMGR.SRC
*************************************************************************



================================================================================================
FILE: "SOS.SOS.BLOAD.TEXT"
================================================================================================
*************************************************************************
* APPLE /// SOS 1.3 SOURCE CODE FILE: SOS.BLOAD
*************************************************************************
* ASSEMBLER: APPLE ][ 6502 ASSEMBLER from APPLE COMPUTER TOOLKIT

MON I
CALL-151
1600:0
1601<1600.93FEM
3D0G
MON I
BLOAD SOSLDR.ABS,A$2000
BLOAD INIT.ABS,A$2AF8
BLOAD SYSGLOB.ABS,A$2CF8
BLOAD BFM.INIT2.ABS,A$2E00
BLOAD BFM.ABS,A$3200
BLOAD OPRMSG.ABS,A$5466
BLOAD IPL.ABS,A$55C0
BLOAD UMGR.ABS,A$5A8B
BLOAD DISK3.ABS,A$5E99
BLOAD SYSERR.ABS,A$6404
BLOAD DEVMGR.ABS,A$64D9
BLOAD SCMGR.ABS,A$665E
BLOAD FMGR.ABS,A$68F4
BLOAD CFMGR.ABS,A$6955
BLOAD BUFMGR.ABS,A$6B52
BLOAD MEMMGR.ABS,A$6E6E
NOMON I

*************************************************************************
* END OF APPLE /// SOS 1.3 SOURCE CODE FILE: SOS.BLOAD
*************************************************************************



================================================================================================
FILE: "SOS.SOS.LINK.TEXT"
================================================================================================
*************************************************************************
* APPLE /// SOS 1.3 SOURCE CODE FILE: SOS.LINK
*************************************************************************
* ASSEMBLER: APPLE ][ 6502 ASSEMBLER from APPLE COMPUTER TOOLKIT

SOSLDR.OBJ
INIT.OBJ
SYSGLOB.OBJ
BFM.INIT2.OBJ
BFM.OBJ
OPRMSG.OBJ
IPL.OBJ
UMGR.OBJ
DISK3.OBJ
SYSERR.OBJ
SCMGR.OBJ
FMGR.OBJ
CFMGR.OBJ
DEVMGR.OBJ
BUFMGR.OBJ
MEMMGR.OBJ
END

*************************************************************************
* END OF APPLE /// SOS 1.3 SOURCE CODE FILE: SOS.LINK
*************************************************************************


================================================================================================
FILE: "SOS.SOS.RENAME.TEXT"
================================================================================================
*************************************************************************
* APPLE /// SOS 1.3 SOURCE CODE FILE: SOS.RENAME
*************************************************************************
* ASSEMBLER: APPLE ][ 6502 ASSEMBLER from APPLE COMPUTER TOOLKIT

MON I
RENAME SOSLDR.OBJ.ABS,SOSLDR.ABS
RENAME INIT.OBJ.ABS,INIT.ABS
RENAME SYSGLOB.OBJ.ABS,SYSGLOB.ABS
RENAME OPRMSG.OBJ.ABS,OPRMSG.ABS
RENAME BFM.OBJ.ABS,BFM.ABS
RENAME BFM.INIT2.OBJ.ABS,BFM.INIT2.ABS
RENAME IPL.OBJ.ABS,IPL.ABS
RENAME UMGR.OBJ.ABS,UMGR.ABS
RENAME DISK3.OBJ.ABS,DISK3.ABS
RENAME SYSERR.OBJ.ABS,SYSERR.ABS
RENAME SCMGR.OBJ.ABS,SCMGR.ABS
RENAME FMGR.OBJ.ABS,FMGR.ABS
RENAME CFMGR.OBJ.ABS,CFMGR.ABS
RENAME DEVMGR.OBJ.ABS,DEVMGR.ABS
RENAME BUFMGR.OBJ.ABS,BUFMGR.ABS
RENAME MEMMGR.OBJ.ABS,MEMMGR.ABS
NOMON I

*************************************************************************
* END OF APPLE /// SOS 1.3 SOURCE CODE FILE: SOS.RENAME
*************************************************************************


================================================================================================
FILE: "SOS.SOSLDR.A.SRC.TEXT"
================================================================================================
*************************************************************************
* APPLE /// SOS 1.3 SOURCE CODE FILE: SOSLDR.A.SRC
*************************************************************************
* ASSEMBLER: APPLE ][ 6502 ASSEMBLER from APPLE COMPUTER TOOLKIT

*PAGE
*REP 110
*
* $1E00 +---------------+
* ! SOSLDR !<-ENTRY SOS MEMORY MAP
* $1FFF +---------------+ ----- (128K APPLE ///)
*
* BANK 0 BANK 1 BANK 2
* $2000 +---------------+ +---------------+ +---------------+
* ! ! ! ! ! !
* ! ! ! ! ! SOSLDR !
* ! ! ! ! ! & !
* ! ! ! ! ! INIT MODULE !
* ! ! ! ! ! !
* ! ! ! ! ! - - - - - - - !
* ! ! ! ! ! GLOBALS !
* ! ! ! ! ! - - - - - - - !
* ! ! ! ! ! !
* ! ! ! ! ! !
* ! ! ! ! ! ! !
* ! ! ! ! ! ! !
* ! ! ! ! ! ! !
* ! ! ! ! ! ! !
* ! ! ! ! ! ! !
* ! ! ! ! ! ! !
* ! ! ! ! ! ! KERNEL !
* ! ! ! ! ! ! !
* ! ! ! ! ! ! !
* ! ! ! ! ! ! !
* ! ! ! ! ! ! !
* ! ! ! ! ! ! !
* ! ! ! ! ! ! !
* ! ! ! ! ! ! !
* ! ! ! ! ! ! !
* ! ! ! ! ! ! !
* ! ! ! ! ! !-- EOF --!
* ! ! ! ! ! ! !
* ! ! ! ! ! ! !
* ! ! ! ! ! ! !
* ! ! ! ! ! ! !
* ! ! ! ! ! ! !
* $9FFF +---------------+ +---------------+ +---------------+
*
*
* $A000 +---------------+
* . ! SOSBOOT !
* . +---------------+
*
*
* FIGURE 1. SOS KERNEL FILE READ INTO $2:1E00..9FFF BY SOS BOOT IN BLOCKS 0,1.
* SOS LOADER BEGINS EXECUTION AT THIS POINT.
*
*
*
*
*REP 110
*PAGE
*REP 110
*
* $1E00 +---------------+
* ! SOSLDR ! SOS MEMORY MAP
* $1FFF +---------------+ (128K APPLE ///)
*
* BANK 0 BANK 1 BANK 2
* $2000 +---------------+ +---------------+ +---------------+
* ! ! ! ! ! ! !
* ! SOSLDR ! ! ! ! !
* ! & ! ! ! ! !
* ! INIT MODULE ! ! ! ! !
* ! ! ! ! ! ! !
* LDREND ! - - - - - - - ! ! ! ! !

* ! FILE BUFFER ! ! ! ! !
* ! - - - - - - - ! ! ! ! !
* ! ! ! ! ! ! !
* ! ! ! ! ! ! !
* ! ! ! ! ! ! !
* ! ! ! ! ! ! !
* ! ! ! ! ! ! !
* ! ! ! ! ! ! !
* ! INTERPRETER ! ! INTERPRETER ! ! !
* ! FILE ! ! FILE ! ! !
* ! ! ! ! ! ! !
* ! ! ! ! ! ! !
* ! ! ! ! ! ! !
* ! ! ! ! ! ! !
* ! ! ! ! ! ! !
* ! ! ! ! ! ! !
* ! ! ! ! ! ! !
* ! ! ! ! ! ! !
* ! ! ! ! ! ! !
* ! ! ! ! ! ! !
* ! ! ! ! ! ! !
* ! ! ! ! ! ! !
* ! ! ! ! ! ! !
* ! ! ! ! ! ! !
* ! ! ! ! ! ! !
* ! ! !- - - EOF - - -! ! !
* $9FFF +---------------+ +---------------+ +---------------+
*
*
*
*
* FIGURE 2. SOS INTERPRETER FILE READ INTO BANKS 0 AND 1
* USING EXTENDED ADDRESSING (X=$80).
*
*
*
*
*
*REP 110

CHN SOSLDR.B.SRC

*************************************************************************
* END OF APPLE /// SOS 1.3 SOURCE CODE FILE: SOSLDR.A.SRC
*************************************************************************




================================================================================================
FILE: "SOS.SOSLDR.B.SRC.TEXT"
================================================================================================
*************************************************************************
* APPLE /// SOS 1.3 SOURCE CODE FILE: SOSLDR.B.SRC
*************************************************************************
* ASSEMBLER: APPLE ][ 6502 ASSEMBLER from APPLE COMPUTER TOOLKIT

.PAGE

;*******************************************************************************
;
; $1E00 +---------------+
; ! SOSLDR ! SOS MEMORY MAP
; $1FFF +---------------+ (128K APPLE ///)
;
; BANK 0 BANK 1 BANK 2
; $2000 +---------------+ +---------------+ +---------------+
; ! ! ! ! ! !
; ! SOSLDR ! ! ! ! !
; ! & ! ! ! ! !
; ! INIT MODULE ! ! ! ! !
; ! ! ! ! ! !
; ! - - - - - - - ! ! ! ! !
; ! FILE BUFFER ! ! ! ! !
; ! - - - - - - - ! ! ! ! !
; ! ! ! ! ! !
; ! ! ! ! ! ! !
; ! ! ! ! ! ! !
; ! ! ! ! ! ! !
; ! ! ! ! ! ! !
; ! ! ! ! ! ! !
; ! ! ! ! ! ! !
; ! ! ! ! ! ! !
; ! ! ! ! ! ! !
; ! ! ! ! ! ! !
; ! ! ! ! ! ! !
; ! ! ! ! ! ! !
; ! ! ! ! ! ! - - - - - - !
; ! DRIVER ! ! DRIVER ! ! !
; ! FILE ! ! FILE ! ! !
; ! ! ! ! ! ! !
; ! ! ! ! ! ! !
; ! ! ! ! ! ! INTERPRETER !
; ! ! ! ! ! ! CODE !
; ! ! ! ! ! ! !
; ! ! ! ! ! ! !
; ! ! ! ! ! ! !
; ! ! ! ! ! ! !
; ! ! !- - - EOF - - -! ! !
; $9FFF +---------------+ +---------------+ +---------------+
;
;
;
;
; FIGURE 3. SOS DRIVER FILE READ INTO BANKS 0 AND 1
; USING EXTENDED ADDRESSING (X=$80).
;
;
;
;
;*******************************************************************************

.PAGE

; ! ! ! ! ! ! !
; $9FFF +---------------+ +---------------+ ! +---------------+
; !
; !
; ! (SYSTEM DEVICE TABLE)
; !
; FIGURE 4. SOS LOADER FINISHED. JUMP TO DIB ADR BANK UNIT
; FIRST BYTE OF INTERPRETER'S CODE. !-----!-----!-----!-----!
; ! ! ! ! !
; ! ! ! ! !
; ! ! ! ! !
; ! ! ! ! !
; !-----!-----!-----!-----!
;

;
;
;*******************************************************************************

*************************************************************************
* END OF APPLE /// SOS 1.3 SOURCE CODE FILE: SOSLDR.B.SRC
*************************************************************************




================================================================================================
FILE: "SOS.SOSLDR.C.SRC.TEXT"
================================================================================================
*************************************************************************
* APPLE /// SOS 1.3 SOURCE CODE FILE: SOSLDR.C.SRC
*************************************************************************
* ASSEMBLER: APPLE ][ 6502 ASSEMBLER from APPLE COMPUTER TOOLKIT

*PAGE
*REP 100
*
* SUBROUTINES:
*
* SOSLDR "MAIN PROGRAM"
*
* SOSLDR1 "PROCESSES KERNEL/INTERPRETER/DRIVER FILES"
*
* (1) MOVE "MOVES SRC.P..SRC.P+CNT-1 TO DST.P..DST.P+CNT-1"
*
* INIT.KRNL "CALLS KERNEL INITIALIZATION MODULES"
*
* WELCOME "PRINTS WELCOME MESSAGE ("APPLE ///", VERSION, DATE/TIME, COPYRIGHT)
*
* ADVANCE "ADVANCES WRK.PTR TO NEXT INTERP/KERNEL MODULE. INITS SRC.P, DST.P, CNT FOR MOVE"
*
* REVERSE "REVERSES TITLE/CODE/RELOC COUNTS TO ALLOW DRIVER FILE TO BE PROCESSED FM BACK TO FRONT"
*
* DADVANCE "ADVANCES WORK.P TO NEXT DRIVER MODULE. INITS SRC.P, CNT, REL.P FOR MOVE"
*
* DADD "ADVANCES WORK.P TO NEXT DRIVER FIELD"
*
* FLAGS "PROCESSES "INACTIVE" & "PAGE ALIGN" FLAGS IN DRIVER MODULE'S DIBS"
*
* NEXT.DIB "ADVANCES TO NEXT DIB IN DRIVER MODULE"
*
* GETMEM "COMPUTES DESTINATION BASE ADDRESS FOR NEXT DRIVER MODULE"
*
* NEWDST "COMPUTES DESTINATION BASE ADDRESS, ALIGNING ON PAGE BOUNDARY IF REQUESTED"
*
* BUILD.DSEG "COMPUTES # OF PAGES TO ADD TO DRIVER SEGMENT AND WHETHER TO BEGIN A NEW SEGMENT"
*
* RELOC "RELOCATES DRIVER MODULE'S CODE FIELD USING RELOCATION FIELD"
*
* (1) LINK "LINKS FIRST DIB TO PREVIOUS DRIVER'S LAST "ACTIVE" DIB, AND ADDS SDT ENTRY"
*
* SET.DRIVES "INITIALIZES DIB LINKS IN KERNEL'S FLOPPY DRIVER"
*
* (1) ALLOC.DEV "ADDS A NEW ENTRY TO THE DEVICE MANAGER'S SYSTEM DEVICE TABLE (SDT)"
*
* ALLOC.SEG "ALLOCATES SEGMENTS FOR KERNEL, INTERPRETER AND SYSTEM WORK AREA"
*
* RSEG "CALLS MEMORY MANAGER TO ALLOCATE SEGMENTS FOR THE KERNEL AND INTERPRTER"
*
* ALLOC.DSEG "ALLOCATES SEGMENTS FOR DRIVER MODULES"
*
* ERROR "DISPLAYS ERROR MESSAGE, SOUNDS BELL AND LOOPS UNTIL CONTROL/RESET PRESSED"
*
* (1) - INDICATES THAT THE ROUTINE PERFORMS BANK SWITCHING AND MUST(!) BE OUTSIDE THE 32K RAM BANKS.
*REP 100
*PAGE
*REP 100
*
* SOS.KERNEL FILE FORMAT
*
* (8) LABEL <---+
* = "SOS KRNL" !
* !
* (2) HEADER COUNT !
* HEADER !
* = # OF FLOPPY DRIVES ! CONTAINED IN THIS LISTING
* = INTERPRETER PATHNAME !
* = DRIVER PATHNAME !
* !
* (4) ADR & COUNT !
* SOSLDR CODE <---+
*
* (4) ADR & COUNT
* GLOBALS
*

* (4) ADR & COUNT
* KERNEL CODE
*
*REP 100
*
* SOS.INTERP FILE FORMAT
*
* (8) LABEL
* = "SOS NTRP"
*
* (2) HEADER COUNT
*
* (4) ADR & COUNT
* INTERPRETER CODE
*
*REP 100
*
* SOS.DRIVER FILE FORMAT
*
* (8) LABEL
* = "SOS DRVR"
*
* (2) HEADER COUNT
* = # OF FLOPPY DRIVES
* = CHARACTER SET TABLE
* = KEYBOARD TABLE
* ...
* +---------------------------------------+
* (2) DM #N TITLE COUNT <---+ ! RELOCATION FIELD FORMAT !
* TITLE FIELD ! ! ----------------------- !
* (2) DM #N CODE COUNT ! DRIVER MODULE #N ! CONSISTS OF A LIST OF 2 BYTE POINTERS !
* CODE FIELD ! ! WHICH POINT TO THE LOW BYTE OF A TWO !
* (2) DM #N RELOC COUNT ! ! BYTE QUANTITY TO BE RELOCATED. !
* RELOC FIELD <---+ +---------------------------------------+
* ...
*
* $FFFF = THE END
*
*REP 100
*PAGE
*REP 100
*
* SOSLDR - EXTERNAL DECLARATIONS
*
*REP 100
*EXTRN SYSBANK
*EXTRN MEMSIZE
*EXTRN SCRNMODE
*EXTRN SOSVER
*EXTRN SOSVERL
*
*EXTRN INT.INIT ; (IPL) INTERRUPT INIT
*EXTRN EVQ.INIT ; (IPL) EVENT QUEUE INIT
*EXTRN DMGR.INIT ; DEVICE MANAGER INIT
*EXTRN MAX.DNUM ; "
*EXTRN SDT.SIZE
*EXTRN SDT.DIBL
*EXTRN SDT.DIBH
*EXTRN SDT.ADRL
*EXTRN SDT.ADRH
*EXTRN SDT.BANK
*EXTRN SDT.UNIT
*EXTRN BLKD.SIZE
*EXTRN BLKDLST
*EXTRN CFMGR.INIT ; CHAR FILE MANAGER INIT
*EXTRN MMGR.INIT ; MEMORY MANAGER INIT
*EXTRN BMGR.INIT ; BUFFER FILE MANAGER INIT
*EXTRN BFM.INIT ; BLOCK FILE MANAGER INIT
*EXTRN BFM.INIT2 ; BLOCK FILE MANAGER INIT2
*EXTRN CLK.INIT ; CLOCK SYSTEM CALL INIT
*
*EXTRN DIB1 ; ON BOARD DISK DRIVER'S DIBS (1-4)
*EXTRN DIB2
*EXTRN DIB3
*EXTRN DIB4
*
*ENTRY I.BASE.P ; USED BY BFM.INIT2 (HARDWIRED!)
*PAGE
*REP 100
*
* FILE DATA DECLARATIONS

*
*REP 100
* KERNEL FILE
*REP 100
K.FILE ASC "SOS KRNL"
K.HDR.CNT DW LDR.ADR-K.DRIVES
K.DRIVES DFB $1
K.FLAGS DFB $0 ; RESERVED FOR FUTURE USE
I.PATH DFB $E
ASC ".D1/SOS.INTERP"
DS $30-$F
D.PATH DFB $E
ASC ".D1/SOS.DRIVER"
DS $30-$F
LDR.ADR DW $0
LDR.CNT DW ZZEND-SOSLDR
*REP 100
* INTERPRETER/DRIVER FILES <--+
* ERROR MESSAGES ! DEFINED IN BACK OF THIS LISTING
* WELCOME MESSAGES <--+
*REP 100
*PAGE
*REP 100
*
* SOSLDR - DATA DECLARATIONS (1)
*
*REP 100
TRUE .eq $80
FALSE .eq $0
*
Z.REG .eq $FFD0
E.REG .eq $FFDF
B.REG .eq $FFEF
*
CZPAGE .eq $1A00
CSPAGE .eq $1B00
CXPAGE .eq $1600
SZPAGE .eq $1800
SXPAGE .eq $1400
SSPAGE .eq $0100
*
ROM.ADR .eq $F1B9
ROM.ID .eq $A0
*PAGE
*REP 100
*
* SOSLDR - DATA DECLARATIONS (2)
*
*REP 100
ZPAGE .eq $00
*
K.BASE .eq ZPAGE+$0 ; SOSLDR1 SUBROUTINE +--------------------------------------+
I.BASE.P .eq ZPAGE+$2 ; ! <VARNAME>.P ::= 3 BYTE ZPAGE POINTER !
RDBUF.P .eq ZPAGE+$4 ; +--------------------------------------+
SYSBUF.P .eq ZPAGE+$6
TEMP.BANK .eq ZPAGE+$8
TEMP.ADRH .eq ZPAGE+$9
WORK.P .eq ZPAGE+$A
*
REV.SAVE .eq ZPAGE+$C ; REVERSE SUBROUTINE
*
FIRST.ADIB .eq ZPAGE+$10 ; FLAGS SUBROUTINE
PREV.ADIB.P .eq ZPAGE+$12
DIB.P .eq ZPAGE+$14
PG.ALIGN .eq ZPAGE+$16
DIB.FLAGS .eq $14
DIB.DCB .eq $20
*
PREVBANK .eq ZPAGE+$18 ; GETMEM SUBROUTINE
PREVDST .eq ZPAGE+$19
*
CODE.P .eq ZPAGE+$1C ; RELOCATION SUBROUTINE
REL.P .eq ZPAGE+$1E
REL.END .eq ZPAGE+$20
*
SRC.P .eq ZPAGE+$22 ; MOVE SUBROUTINE
DST.P .eq ZPAGE+$24
CNT .eq ZPAGE+$26
*
DSTBANK .eq ZPAGE+$2A ; LINK SUBROUTINE
LINK.P .eq ZPAGE+$2C

*
DIB.ENTRY .eq 2 ; ALLOC.DEV SUBROUTINE
DIB.UNIT .eq 4+16+2
DIB.DTYPE .eq 4+16+3
*
ETEMP .eq ZPAGE+$2E ; ERROR SUBROUTINE
*
WTEMP .eq ZPAGE+$2F ; WELCOME SUBROUTINE

*************************************************************************
* END OF APPLE /// SOS 1.3 SOURCE CODE FILE: SOSLDR.C.SRC
*************************************************************************




================================================================================================
FILE: "SOS.SOSLDR.D.SRC.TEXT"
================================================================================================
*************************************************************************
* APPLE /// SOS 1.3 SOURCE CODE FILE: SOSLDR.D.SRC
*************************************************************************
* ASSEMBLER: APPLE ][ 6502 ASSEMBLER from APPLE COMPUTER TOOLKIT

*PAGE
*REP 100
*
* SOS LOADER -
*
* (MAIN PROGRAM)
*REP 100
SOSLDR				.eq *; +---------------+
					lda #0 ; ZERO SOS/USER X, Z AND				staCK PAGES ! SEE FIGURE 1. !
					tax; +---------------+
SLDR010				sta CZPAGE,X
					sta CXPAGE,X
					sta CSPAGE,X
					sta SZPAGE,X
					sta SXPAGE,X
					sta SSPAGE,X
					dex
					bne SLDR010
* ; SETUP SOS CALL ENVIRONMENT (WRITE PROTECT=OFF)
					lda #$30 ; E:=( 0.0.1.1:0.0.0.0 )
					sta E.REG ; ( 1.I.S.R:W.P.R.R )
*
					ldx #$FB ; CONSOLE 1.0 MODIFIES				staCK DURING D.INIT CALL
TXS
					lda #<CZPAGE ; ZREG:=CALLER'S Z PAGE
					sta Z.REG
* ; +--------------------------------+
					jsr SOSLDR1 ; ! PROCESS KRNL/INTERP/DRVR FILES !
* ; +--------------------------------+
					lda E.REG
					and #$10 ; SETUP SOS CALL ENVIRONMENT (WRITE PROTECT=ON)
					ora #$28 ; E:=( 0.0.1.X:1.0.0.0 )
					sta E.REG ; ( 1.I.S.R:W.P.R.R )
*
					ldx #$FF ;				staCK.REG:=$FF
TXS
					lda #<CZPAGE ; ZREG:=CALLER'S Z PAGE
					sta Z.REG
* +---------------+
					lda SYSBANK ; BREG:=SYSBANK ! SEE FIGURE 4. !
					sta B.REG ; +---------------+
					jmp (I.BASE.P) ; SOS LOAD COMPLETE - JMP TO INTERPRETER
*
*THE END.
*REP 100
*PAGE
*REP 100
*
* MOVE ( IN: SRC.P
* IN: DST.P
* IN: A="BANK"
* IN: CNT )
*
* LOCAL: END
* (MOVES SRC.P..SRC.P+CNT-1 TO DST.P..DST.P+CNT-1) "CNT PARM IS DESTROYED"
*REP 100
MOVE .eq *
					tax
					lda B.REG ; SAVE BANK REGISTER
					pha
					stx B.REG ; BREG:=A
					lda CNT+1 ; IF CNT <> 0
					ora CNT ; THEN
					beq MOVE.EXIT
					lda CNT ; CNT:=CNT-1
					bne MOVE010
					dec CNT+1
MOVE010 DEC CNT
					clc ; SRC.P:=SRC.P+PAGE.CNT
					lda SRC.P+1
					adc CNT+1

					sta SRC.P+1
					lda DST.P+1 ; DST.P:=DST.P+PAGE.CNT
					adc CNT+1
					sta DST.P+1
					inc CNT+1 ; PAGE.CNT:=PAGE.CNT+1
					ldy CNT ; Y:=BYTE.CNT
					beq MOVE020 ; IF Y=0 THEN M2
*
MOVE.PAGE				lda (SRC.P),Y ;M1: DO
					sta (DST.P),Y ; (DST.P),Y:=(SRC.P),Y
					dey ; Y:=Y-1
					bne MOVE.PAGE ; UNTIL Y=0
MOVE020				lda (SRC.P),Y ;M2: (DST.P),Y:=(SRC.P),Y
					sta (DST.P),Y
					dey ; Y:=Y-1
					dec SRC.P+1 ; SRC.P:=SRC.P-256
					dec DST.P+1 ; DST.P:=DST.P-256
					dec CNT+1 ; PAGE.CNT:=PAGE.CNT-1
					bne MOVE.PAGE ; IF PAGE.CNT <> 0 THEN M1
*
					inc SRC.P+1 ; RESTORE SRC.P
					inc DST.P+1 ; " DST.P
*
MOVE.EXIT PLA ; RESTORE BANK REGISTER
					sta B.REG
					rts
*PAGE
*REP 100
*
* LINK ( IN: DST.P
* IN: DSTBANK
* IN: PREVBANK
* IN: FIRST.ADIB
* I/O: SDT.TBL
* I/O: BLKDLST
* OUT: LINKED DRIVER MODULE )
*
* OWN: LINK.P
* (LINKS FIRST DIB TO PREVIOUS DRIVER'S LAST "ACTIVE" DIB, AND ADDS SDT ENTRY)
*REP 100
LINK .eq *
					clc ; FIRST.ADIB:=0:DST.P+FIRST.ADIB
					lda DST.P
					adc FIRST.ADIB
					sta FIRST.ADIB
					lda DST.P+1
					adc FIRST.ADIB+1
					sta FIRST.ADIB+1
					lda #0
					sta CXPAGE+FIRST.ADIB+1
					lda PREVBANK ; BREG:=PREVBANK
					sta B.REG
					ldy #0 ; (LINK.P):=FIRST.ADIB
					lda FIRST.ADIB
					sta (LINK.P),Y
					iny
					lda FIRST.ADIB+1
					sta (LINK.P),Y
					lda DSTBANK ; BREG:=DSTBANK
					sta B.REG
					lda FIRST.ADIB ; LINK.P:=FIRST.ADIB
					sta LINK.P
					lda FIRST.ADIB+1
					sta LINK.P+1
WALKLINKS				jsr ALLOC.DEV ; ALLOC.DEV(LINK.P BREG.IN, SDT.TBL BLKDLST.IO)
LINK010 LDY #0 ; WHILE (LINK.P) <> 0 AND (LINK.P) <> LINK.P
					lda (LINK.P),Y
					iny
					ora (LINK.P),Y
					beq LINK100
					lda (LINK.P),Y
					cmp LINK.P+1
					bne LINK030
					dey
					lda (LINK.P),Y
					cmp LINK.P
					beq LINK100
LINK030 LDY #0 ; DO LINK.P:=(LINK.P)
					lda (LINK.P),Y
					tax
					iny

					lda (LINK.P),Y
					stx LINK.P
					sta LINK.P+1
					jsr ALLOC.DEV ; " ALLOC.DEV(LINK.P BREG.IN, SDT.TBL BLKDLST.IO)
					jmp LINK010
*
LINK100 LDY #0 ; (LINK.P):=0
					tya
					sta (LINK.P),Y
					iny
					sta (LINK.P),Y
					dey ; BREG:=0
					sty B.REG
					rts
*
*
*
*
* LINK.INIT ( IN: A=# DRIVES
* IN: DIB1..4
* I/O: SDT.TBL
* I/O: BLKDLST )
*
LINK.INIT .eq *
					jsr SET.DRIVES ; SET.DRIVES(A=#DRIVES.IN, DIB1..4.IN)
					lda #0
					sta MAX.DNUM ; MAXDNUM:=0
					sta BLKDLST ; BLKDLST:=0
					sta CXPAGE+LINK.P+1 ; LINK.P:=0:DIB1
					lda #>DIB1
					sta LINK.P
					lda #<DIB1
					sta LINK.P+1
					jmp WALKLINKS
*PAGE
*REP 100
*
* ALLOC.DEV ( IN: LINK.P
* IN: B.REG
* I/O: SDT.TBL (SYSTEM DEVICE TABLE)
* IN: SDT.SIZE = CONSTANT
* IN: DIB.ENTRY = CONSTANT DEV DIB ADR BANK UNIT
* IN: DIB.UNIT = CONSTANT !-----!-----!-----!-----!
* IN: DIB.DTYPE = CONSTANT 1 ! ! ! ! !
* I/O: MAX.DNUM 2 ! ! ! ! !
* OUT: SDT.BANK . ! ! ! ! !
* OUT: SDT.DIB . ! ! ! ! !
* OUT: SDT.ADR . !-----!-----!-----!-----!
* OUT: SDT.UNIT MAX.DNUM
* I/O: BLKDLST
* IN: BLKD.SIZE = CONSTANT
* (ADDS A NEW ENTRY TO THE DEVICE MANAGER'S SYSTEM DEVICE TABLE (SDT))
*REP 100
ALLOC.DEV .eq *
					inc MAX.DNUM ; MAX.DNUM:=MAX.DNUM+1
					ldx MAX.DNUM ; IF MAX.DNUM >= SDT.SIZE
					cpx #>SDT.SIZE ; THEN
					bcc ADEV010
					ldx #ERR8X ; ERROR("TOO MANY DEVICES")
					ldy #ERR8L
					jsr ERROR
ADEV010				lda B.REG ; SDT.BANK,X:=BREG
					sta SDT.BANK,X
					clc ; SDT.DIB,X:=LINK.P+4
					lda LINK.P
					adc #4
					sta SDT.DIBL,X
					lda LINK.P+1
					adc #0
					sta SDT.DIBH,X
					clc ; SDT.ADR,X:=(LINK.P),DIB.ENTRY-1
					ldy #DIB.ENTRY
					lda (LINK.P),Y
					sbc #1
					sta SDT.ADRL,X
					iny
					lda (LINK.P),Y
					sbc #0
					sta SDT.ADRH,X
					ldy #DIB.UNIT ; SDT.UNIT,X:=(LINK.P),DIB.UNIT
					lda (LINK.P),Y

					sta SDT.UNIT,X
					ldy #DIB.DTYPE ; IF (LINK.P),DIB.DTYPE = "BLOCK DEVICE"
					lda (LINK.P),Y
					bpl ADEV.EXIT
					txa ; THEN
					inc BLKDLST ; BLKDLST:=BLKDLST+1
					ldx BLKDLST ; IF BLKDLST >= BLKD.SIZE
					cpx #>BLKD.SIZE ; THEN
					bcc ADEV020
					ldx #ERR9X ; ERROR("TOO MANY BLOCK DEVICES")
					ldy #ERR9L
					jsr ERROR
ADEV020				sta BLKDLST,X ; BLKDLST,X:=MAX.DNUM
ADEV.EXIT RTS ; RETURN
*PAGE
*REP 100
*
* SOSLDR1 ()
*
* (PROCESSES KERNEL/INTERPRETER/DRIVER FILES)
*REP 100
SOSLDR1 .eq *
					ldx #$1F ; COPY ROM'S DISK CORE ROUTINE ZPAGE VARS TO SOS ZPAGE
LDR010				lda $380,X
					sta SZPAGE,X
					dex
					bpl LDR010
*REP 100
* PROCESS KERNEL FILE
*REP 100
*
* MOVE AND INITIALIZE SOS GLOBALS
*
					lda #>LDR.ADR ; WORK.P:=0:LDR.ADR
					sta WORK.P
					lda #<LDR.ADR
					sta WORK.P+1
					jsr ADVANCE ; ADVANCE(WORK.P.IO, SRC.P DST.P CNT.OUT)
*
					lda B.REG ; MOVE(SRC.P DST.P A=BREG CNT.IN)
					jsr MOVE
*
					lda B.REG ; SYSBANK:=BREG
					and #$0F
					sta SYSBANK
					asl A ; MEMSIZ:=SYSBANK*2+4 "16K CHUNKS"
					clc
					adc #4
					sta MEMSIZE ; AND, MEMSIZE (SIZE IN 16K BYTE "CHUNKS")
*
* MOVE KERNAL CODE
*
					jsr ADVANCE ; ADVANCE(WORK.P.IO, SRC.P DST.P CNT.OUT)
*
					lda DST.P ; K.BASE:=DST.P
					sta K.BASE
					lda DST.P+1
					sta K.BASE+1
					lda B.REG ; MOVE(SRC.P DST.P A=BREG CNT.IN)
					jsr MOVE
*
* MOVE LOADER TO BANK 0 AND SWITCH FROM SYSTEM BANK TO BANK 0
*
					lda #>$2000 ; MOVE(SRC.P=0:2000 DST.P=8F:2000 A=BREG CNT=LDR.END-$2000)
					sta SRC.P
					sta DST.P
					lda #<$2000
					sta SRC.P+1
					sta DST.P+1
					lda #$8F
					sta CXPAGE+DST.P+1
					lda #>LDREND-$2000
					sta CNT
					lda #<LDREND-$2000
					sta CNT+1
					lda B.REG
					jsr MOVE
					lda #0 ; BREG:=0
					sta B.REG
*
* INITIALIZE SDT TABLE, KERNEL AND PRINT WELCOME MESSAGE

*
					lda K.DRIVES ; LINK.INIT(A=K.DRIVES DIB1..4.IN, SDT.TBL BLKDLST.IO)
					jsr LINK.INIT
					jsr INIT.KRNL ; INIT.KRNL()
					jsr WELCOME ; WELCOME()
*
					lda E.REG ; ENABLE ROM BANK
					ora #$03
					sta E.REG
					lda ROM.ADR ; IF MONITOR ROM <> NEW
					cmp #ROM.ID ; THEN
					beq LDR020
					ldx #ERR7X ; ERROR("ROM ERROR: PLEASE NOTIFY YOUR DEALER")
					ldy #ERR7L
					jsr ERROR
LDR020				lda E.REG ; DISABLE ROM BANK
					and #$F6
					sta E.REG
*REP 100
* PROCESS INTERPRETER FILE
*REP 100
*
* OPEN SOS INTERPRETER FILE (DEFAULT='SOS.INTERP')
*
					ldy I.PATH ; OPEN(PATHNAME:=I.PATH
LDR030				lda I.PATH,Y ; REFNUM=OPEN.REF
					sta PATH,Y ; SYSBUF.P:=80:LDREND-2000 )
					dey
					bpl LDR030
*
					lda #>LDREND-$2000
					sta SYSBUF.P
					lda #<LDREND-$2000
					sta SYSBUF.P+1
					lda #$80
					sta CXPAGE+SYSBUF.P+1
*
*
BRK
DFB OPEN
DW OPEN.PARMS
					beq LDR040
					ldx #ERR1X ; ERROR("INTERPRETER FILE NOT FOUND")
					ldy #ERR1L
					jsr ERROR
LDR040				lda OPEN.REF
					sta READ.REF
					sta CLOSE.REF
*
* READ IN ENTIRE INTERPRETER FILE
*
					lda #$80 ; READ(REFNUM=READ.REF
					sta CXPAGE+RDBUF.P+1 ; RDBUF.P:=80:FILE
					lda #>FILE ; BYTES=$FFFF-FILE+1
					sta RDBUF.P ; BYTESRD=I.BYTESRD )
					lda #<FILE
					sta RDBUF.P+1
*
BRK
DFB READ
DW READ.PARMS
					beq LDR050
					ldx #ERR0X ; ERROR("I/O ERROR")
					ldy #ERR0L
					jsr ERROR
* +---------------+
* CLOSE INTERPRETER FILE AND CHECK LABEL ! SEE FIGURE 2. !
* +---------------+
LDR050 BRK ; CLOSE(REFNUM=CLOSE.REF)
DFB CLOSE
DW CLOSE.PARMS
					ldy #7 ; CHECK LABEL
LDR051				lda (RDBUF.P),Y
					cmp I.LABEL,Y
					bne LDR052
					dey
					bpl LDR051
					bmi LDR053
LDR052				ldx #ERR2X ; ERROR("INVALID INTERPRETER FILE")
					ldy #ERR2L
					jsr ERROR

*
* MOVE INTERPRETER CODE
*
LDR053				lda #>I.HDR.CNT-2 ; WORK.P:=80:I.HDR.CNT-2
					sta WORK.P
					lda #<I.HDR.CNT-2
					sta WORK.P+1
					lda #$80
					sta CXPAGE+WORK.P+1
*
					jsr ADVANCE ; ADVANCE(WORK.P.IO, SRC.P DST.P CNT.OUT)
*
					lda DST.P ; I.BASE.P:=0:DST.P
					sta I.BASE.P
					lda DST.P+1
					sta I.BASE.P+1
					lda #0
					sta CXPAGE+I.BASE.P+1
*
					clc ; IF DST.P+CNT > K.BASE THEN ERROR
					lda CNT
					adc DST.P
					tax
					lda CNT+1
					adc DST.P+1
					cpx K.BASE
					sbc K.BASE+1
					beq LDR070
					bcc LDR070
					ldx #ERR3X ; ERROR("INCOMPATIBLE INTERPRETER")
					ldy #ERR3L
					jsr ERROR
*
LDR070				lda SYSBANK ; MOVE(SRC.P=RDBUF.P DST.P A=SYSBANK CNT.IN)
					jsr MOVE
*REP 100
* PROCESS DRIVER FILE
*REP 100
*
* OPEN SOS DRIVER FILE (DEFAULT='SOS.DRIVER')
*
					ldy D.PATH ; OPEN(PATHNAME:=D.PATH
LDR080				lda D.PATH,Y ; REFNUM=OPEN.REF
					sta PATH,Y ; SYSBUF.P:=80:LDREND-2000 )
					dey
					bpl LDR080
*
BRK
DFB OPEN
DW OPEN.PARMS
					beq LDR090
					ldx #ERR4X ; ERROR("DRIVER FILE NOT FOUND")
					ldy #ERR4L
					jsr ERROR
LDR090				lda OPEN.REF
					sta READ.REF
					sta CLOSE.REF
*
* READ IN ENTIRE DRIVER FILE INTO BANK 0
*
BRK ; READ(REFNUM=READ.REF
DFB READ ; RDBUF.P:=80:FILE
DW READ.PARMS ; BYTES=$FFFF-FILE+1
* ; BYTESRD=D.BYTESRD )
					beq LDR100
					ldx #ERR0X ; ERROR("I/O ERROR")
					ldy #ERR0L
					jsr ERROR
* +---------------+
* CLOSE THE DRIVER FILE AND CHECK LABEL ! SEE FIGURE 3. !
* +---------------+
LDR100 BRK ; CLOSE(REFNUM=CLOSE.REF)
DFB CLOSE
DW CLOSE.PARMS
					ldy #$7 ; CHECK LABEL
LDR101				lda (RDBUF.P),Y
					cmp D.LABEL,Y
					bne LDR102
					dey
					bpl LDR101
					bmi LDR103

LDR102				ldx #ERR5X ; ERROR("INVALID DRIVER FILE")
					ldy #ERR5L
					jsr ERROR
*
* MOVE CHARACTER SET TABLE
*
LDR103				lda #>D.CHRSET ; MOVE(SRC.P=D.CHRSET DST.P=$C00 A=0 CNT=$400)
					sta SRC.P
					lda #<D.CHRSET
					sta SRC.P+1
					lda #>$C00
					sta DST.P
					lda #<$C00
					sta DST.P+1
					lda #>$400
					sta CNT
					lda #<$400
					sta CNT+1
					lda #0
					jsr MOVE
*
* MOVE KEYBOARD TABLE
*
					lda #>D.KYBD ; MOVE(SRC.P=D.KYBD DST.P=$1700 A=0 CNT=$100.IN)
					sta SRC.P
					lda #<D.KYBD
					sta SRC.P+1
					lda #>$1700
					sta DST.P
					lda #<$1700
					sta DST.P+1
					lda #>$100
					sta CNT
					lda #<$100
					sta CNT+1
					lda #0
					jsr MOVE
*
* RE-INITIALIZE SDT TABLE
*
					ldy #>D.DRIVES-D.FILE ; LINK.INIT(A=D.DRIVES DIB1..4.IN, SDT.TBL BLKDLST.IO)
					lda (RDBUF.P),Y
					jsr LINK.INIT
*
					lda #0 ; DST.P:=0:I.BASE.P/256*256
					sta CXPAGE+DST.P+1
					sta DST.P
					lda I.BASE.P+1
					sta DST.P+1
					cmp #$A0 ; IF DST.P>=$A000 THEN DST.P:=$A000
					bcc LDR105
					lda #$A0
					sta DST.P+1
LDR105				lda SYSBANK ; DSTBANK:=SYSBANK
					sta DSTBANK
					jsr REVERSE ; REVERSE(D.HDR.CNT.IN, WORK.P.OUT)
*
* RELOCATE AND MOVE DRIVERS
*
NEXTDRIVER				jsr DADVANCE ; "NO DRIVERS LEFT":=DADVANCE(WORK.P.IO SRC.P CNT REL.P.OUT)
					bcs LDR140
					jsr FLAGS ; "INACTIVE":=FLAGS(SRC.P.IN, PG.ALIGN FIRST.ADIB.OUT)
BVS NEXTDRIVER
					jsr GETMEM ; GETMEM(PG.ALIGN CNT.IN, DST.P DSTBANK DSEGLIST.IO, PREVBANK.OUT)
					jsr RELOC ; RELOC(SRC.P REL.P DST.P.IN)
*
					lda DSTBANK ; IF DSTBANK < 0 OR DST.P < SRC.P THEN ERROR
					bmi LDR120
					lda CXPAGE+SRC.P+1 ; (CONVERT SRC.P TO BANK SWITCHED ADDRESS)
					and #$7F
					sta TEMP.BANK
					lda SRC.P+1
					bpl LDR110
					inc TEMP.BANK
LDR110 AND #$7F
					clc
					adc #<$2000
					sta TEMP.ADRH
					lda DST.P ; (NOW COMPARE)
					cmp SRC.P
					lda DST.P+1

					sbc TEMP.ADRH
					lda DSTBANK
					sbc TEMP.BANK
					bcs LDR130
LDR120				ldx #ERR6X ; ERROR("DRIVER FILE TOO LARGE")
					ldy #ERR6L
					jsr ERROR
*
LDR130				lda DSTBANK ; MOVE(SRC.P DST.P A=DSTBANK CNT.IN)
					jsr MOVE
					jsr LINK ; LINK(DST.P DSTBANK PREVBANK FIRST.ADIB.IN, SDT.TBL BLKDLST.IO)
					jmp NEXTDRIVER
*REP 100
* SETUP USER ENVIRONMENT
*REP 100
*
* RE-INITIALIZE KERNEL/DRIVERS, ALLOCATE SYSTEM SEGMENTS
*
LDR140				jsr INIT.KRNL ; INIT.KRNL()
					jsr ALLOC.SEG ; ALLOC.SEG(K.BASE I.BASE.P SYSBANK.IN)
					jsr ALLOC.DSEG ; ALLOC.DSEG(DSEGLIST.IN)
*
* SET PREFIX TO THE BOOT VOLUME
*
					lda #0 ; TURN VIDEO OFF - PREVENTS CHAR "GROWTH" DURING DOWNLOAD
					sta SCRNMODE
BRK ; SET.PREFIX(PREFIXPATH=".D1")
DFB SETPREFIX
DW PREFX.PARMS
*
* LAUNCH CHARACTER SET DOWNLOAD (CONSOLE) AND CLEAR SCREEN
*
CLI ; BEGIN CHARACTER SET DOWNLOAD (CONSOLE)
*
					lda #0 ; CLEAR TEXT SCREENS
					sta CXPAGE+SRC.P+1
					sta CXPAGE+DST.P+1
					lda #$04
					sta SRC.P+1
					sta DST.P+1
					lda #$00
					sta SRC.P
					lda #$80
					sta DST.P
					lda #$A0
					ldx #8
CLEAR0 LDY #$77
CLEAR1				sta (SRC.P),Y
					sta (DST.P),Y
					dey
					bpl CLEAR1
					inc SRC.P+1 ; NEXT PAGE
					inc DST.P+1 ; NEXT PAGE
					dex
					bne CLEAR0
*
WAIT INC SRC.P ; WAIT FOR DOWNLOAD TO COMPLETE
					bne WAIT
					inx
					bne WAIT
*
					lda #$80 ; TURN VIDEO ON
					sta SCRNMODE
					rts
*REP 100

CHN SOSLDR.E.SRC

*************************************************************************
* END OF APPLE /// SOS 1.3 SOURCE CODE FILE: SOSLDR.D.SRC
*************************************************************************




================================================================================================
FILE: "SOS.SOSLDR.E.SRC.TEXT"
================================================================================================
*************************************************************************
* APPLE /// SOS 1.3 SOURCE CODE FILE: SOSLDR.E.SRC
*************************************************************************
* ASSEMBLER: APPLE ][ 6502 ASSEMBLER from APPLE COMPUTER TOOLKIT

*PAGE
*REP 100
*
* SET.DRIVES ( IN: A=# DRIVES
* IN: DIB1..4 )
* (INITIALIZES DIB LINKS IN KERNEL'S FLOPPY DRIVER)
*REP 100
*
SET.DRIVES .eq *
					tay ; SAVE # OF DRIVES
					lda #>DIB2 ; DIB1:=ADR(DIB2)
					sta DIB1
					lda #<DIB2
					sta DIB1+1
					lda #>DIB3 ; DIB2:=ADR(DIB3)
					sta DIB2
					lda #<DIB3
					sta DIB2+1
					lda #>DIB4 ; DIB3:=ADR(DIB4)
					sta DIB3
					lda #<DIB4
					sta DIB3+1
*
					lda #0 ; CASE (Y=# OF DRIVES)
					cpy #2
					bcc STDR010
					beq STDR020
					cpy #4
					bcc STDR030
					bcs STDR040
*
STDR010				sta DIB1 ; 1: DIB1:=0
					sta DIB1+1
					rts
*
STDR020				sta DIB2 ; 2: DIB2:=0
					sta DIB2+1
					rts
*
STDR030				sta DIB3 ; 3: DIB3:=0
					sta DIB3+1
					rts
*
STDR040				sta DIB4 ; 4: DIB4:=0
					sta DIB4+1
					rts; RETURN
*PAGE
*REP 100
*
* INIT.KRNL ()
*
* (CALLS KERNEL INITIALIZATION MODULES)
*REP 100
*
INIT.KRNL .eq *
					lda E.REG ; SWITCH IN I/O BANK AND SELECT PRIMARY				staCK
					ora #$44 ; E:=( 0.1.1.X:0.1.0.0 )
					sta E.REG ; ( 1.I.S.R:W.P.R.R )
*
					lda #<SZPAGE ; SWITCH TO SOS ZPAGE
					sta Z.REG
*
					jsr INT.INIT ; CALL KERNEL INITIALIZATION ROUTINES
					jsr EVQ.INIT
					jsr BFM.INIT2
					bcs INITK.ERR
					jsr DMGR.INIT
					jsr CFMGR.INIT
					jsr MMGR.INIT
					jsr BMGR.INIT
					jsr BFM.INIT

					jsr CLK.INIT
*
					lda E.REG ; SWITCH OUT I/O BANK AND RETURN TO ALTERNATE				staCK
					and #$BB ; E:=( 0.0.1.X:0.0.0.0 )
					sta E.REG ; ( 1.I.S.R:W.P.R.R )
*
					lda #<CZPAGE ; SWITCH BACK TO USER ZPAGE
					sta Z.REG
*
					rts; RETURN
*
*
INITK.ERR				ldx #ERR0X ; ERROR("I/O ERROR")
					ldy #ERR0L
					jmp ERROR
*PAGE
*REP 100
*
* ADVANCE ( I/O: WORK.P
* OUT: SRC.P
* OUT: DST.P
* OUT: CNT )
* (ADVANCES WORK.P TO NEXT INTERP.KERNEL MODULE. INITS SRC.P, DST.P, CNT FOR MOVE)
*REP 100
*
ADVANCE .eq *
					clc
					ldy #2 ; Y:=0
					lda WORK.P ; WORK.P:=WORK.P+(WORK.P),Y + 4
					adc (WORK.P),Y
					tax
					iny
					lda WORK.P+1
					adc (WORK.P),Y
					pha
					txa
					adc #4
					sta WORK.P
					pla
					adc #0
					sta WORK.P+1
					clc ; SRC.P:=X:WORK.P+4
					lda WORK.P
					adc #>$0004
					sta SRC.P
					lda WORK.P+1
					adc #<$0004
					sta SRC.P+1
					lda CXPAGE+WORK.P+1
					sta CXPAGE+SRC.P+1
					ldy #0 ; DST.P:=0:(WORK.P)
					sty CXPAGE+DST.P+1
					lda (WORK.P),Y
					sta DST.P
					iny
					lda (WORK.P),Y
					sta DST.P+1
					iny ; Y:=2
					lda (WORK.P),Y ; CNT:=(WORK.P),Y
					sta CNT
					iny
					lda (WORK.P),Y
					sta CNT+1
					rts; RETURN
*PAGE
*REP 100
*
* REVERSE ( IN: D.HDR.CNT
* IN: SDT.SIZE = CONSTANT
* I/O: DRIVER FILE,
* OUT: WORK.P ) )
*
* LOCAL: REV.SAVE, REV.TEMP
* (REVERSES TITLE/CODE/RELOC COUNTS TO ALLOW DRIVER FILE TO BE PROCESSED FROM BACK TO FRONT)
*REP 100
REVERSE .eq *
					lda #>D.HDR.CNT ; WORK.P:=80:D.HDR.CNT
					sta WORK.P
					lda #<D.HDR.CNT
					sta WORK.P+1
					lda #$80

					sta CXPAGE+WORK.P+1
					clc ; WORK.P:=WORK.P+(WORK.P)+2
					ldy #0
					lda WORK.P
					adc (WORK.P),Y
					tax
					iny
					lda WORK.P+1
					adc (WORK.P),Y
					pha
					txa
					adc #2
					sta WORK.P
					pla
					adc #0
					sta WORK.P+1
					lda (WORK.P),Y ; IF (WORK.P)=$FFFF
					dey
					and (WORK.P),Y ; THEN
					cmp #$FF
					bne REV010
					ldx #ERR10X ; ERROR("EMPTY DRIVER FILE")
					ldy #ERR10L
					jsr ERROR
REV010				lda #$FF
					sta REV.SAVE
					sta REV.SAVE+1
*
REV020				lda REV.SAVE ;R1:				staCK:=REV.SAVE
					pha
					lda REV.SAVE+1
					pha
					ldy #0 ; REV.SAVE:=(WORK.P)
					lda (WORK.P),Y
					sta REV.SAVE
					iny
					lda (WORK.P),Y
					sta REV.SAVE+1
					pla ; (WORK.P):=STACK
					sta (WORK.P),Y
					dey
					pla
					sta (WORK.P),Y
					lda REV.SAVE ; IF REV.SAVE = $FFFF THEN EXIT
					and REV.SAVE+1
					cmp #$FF
					beq REV.EXIT
REV030 BIT REV.SAVE+1 ; IF REV.SAVE >= $8000 THEN ERROR
					bmi REV040
					clc ; WORK.P:=WORK.P+REV.SAVE+2
					lda WORK.P
					adc REV.SAVE
					tax
					lda WORK.P+1
					adc REV.SAVE+1
					pha
					bcs REV040
					txa
					adc #2
					sta WORK.P
					pla
					adc #0
					sta WORK.P+1
					bcc REV020 ; IF C=FALSE THEN R1
REV040				ldx #ERR5X ; ELSE ERROR("INVALID DRIVER FILE")
					ldy #ERR5L
					jsr ERROR
*
REV.EXIT RTS ; RETURN
*PAGE
*REP 100
*
* DADVANCE ( I/O: WORK.P
* OUT: C="NO DRIVERS LEFT"
* OUT: SRC.P
* OUT: CNT
* OUT: REL.P )
* (ADVANCES WORK.P TO NEXT DRIVER MODULE. INITS SRC.P, CNT, REL.P FOR RELOCATION AND MOVE)
*REP 100
DADVANCE .eq *
					ldy #0 ; IF (WORK.P)=$FFFF THEN EXIT "NO DRIVERS LEFT IN FILE"

					lda (WORK.P),Y
					iny
					and (WORK.P),Y
					cmp #$FF
					bne DADV010
					clc ; C:="NO DRIVERS LEFT"
					rts; RETURN
*
*
DADV010				lda WORK.P ; REL.P:=X:WORK.P
					sta REL.P
					lda WORK.P+1
					sta REL.P+1
					lda CXPAGE+WORK.P+1
					sta CXPAGE+REL.P+1
*
					jsr DADD ; ADVANCE TO CODE COUNT FIELD
*
					ldy #0 ; CNT:=(WORK.P)
					lda (WORK.P),Y
					sta CNT
					iny
					lda (WORK.P),Y
					sta CNT+1
*
					jsr DADD ; ADVANCE TO TITLE CNT FIELD
*
					clc ; SRC.P:=X:WORK.P+2
					lda WORK.P
					adc #2
					sta SRC.P
					lda WORK.P+1
					adc #0
					sta SRC.P+1
					lda CXPAGE+WORK.P+1
					sta CXPAGE+SRC.P+1
*
					jsr DADD ; ADVANCE TO RELOC FIELD OF NEXT DRIVER
					clc ; C:="DRIVERS LEFT"
					rts; RETURN
*PAGE
*REP 100
*
* DADD ( I/O: WORK.P )
*
* (ADVANCES WORK.P TO NEXT FIELD IN DRIVER MODULE)
*REP 100
DADD .eq *
					clc ; WORK.P:=WORK.P-(WORK.P)-2
					ldy #0
					lda WORK.P
					sbc (WORK.P),Y
					tax
					iny
					lda WORK.P+1
					sbc (WORK.P),Y
					pha
					txa
					sbc #2
					sta WORK.P
					pla
					sbc #0
					sta WORK.P+1
					rts; RETURN
*PAGE
*REP 100
*
* FLAGS ( IN: SRC.P
* OUT: PG.ALIGN
* OUT: FIRST.ADIB
* OUT: OV="ALL DIBS INACTIVE" )
*
* LOCAL: PREV.ADIB.P, DIB.P
* (PROCESSES "INACTIVE" & "PAGE ALIGN" FLAGS IN DRIVER MODULE'S DIBS"
*REP 100
FLAGS .eq *
					clc ; C="FIRST DIB"
FLAG010				jsr NEXT.DIB ; NEXT.DIB(SRC.P.IN, DIB.P PG.ALIGN C OV.OUT)
BVC FLAG015 ; IF OV <> "INACTIVE" THEN ACTIVE DIB FOUND
					bcc FLAG010 ; IF C <> "LAST DIB" THEN CHECK NEXT DIB
					rts; RETURN (OV:="ALL DIBS INACTIVE")

*
FLAG015 PHP ; PUSH				staTUS
					clc ; FIRST.ADIB:=DIB.P-SRC.P
					lda DIB.P
					sbc SRC.P
					sta FIRST.ADIB
					lda DIB.P+1
					sbc SRC.P+1
					sta FIRST.ADIB+1
					lda DIB.P ; PREV.ADIB.P:=X:DIB.P
					sta PREV.ADIB.P
					lda DIB.P+1
					sta PREV.ADIB.P+1
					lda CXPAGE+DIB.P+1
					sta CXPAGE+PREV.ADIB.P+1
					plp ; PULL				staTUS
					bcs FLAG100 ; IF C="LAST DIB" THEN EXIT
*
FLAG020				jsr NEXT.DIB ; NEXT.DIB(SRC.P.IN, DIB.P PG.ALIGN C OV.OUT)
					php ; PUSH				staTUS
					ldy #0 ; IF OV="INACTIVE DIB"
BVC FLAG025
					clc ; THEN
					lda PREV.ADIB.P ; (PREV.ADIB.P):=PREV.ADIB.P-SRC.P
					sbc SRC.P
					sta (PREV.ADIB.P),Y
					iny
					lda PREV.ADIB.P+1
					sbc SRC.P+1
					sta (PREV.ADIB.P),Y
					jmp FLAG050
*
FLAG025 SEC ; ELSE
					lda DIB.P ; (PREV.ADIB.P):=DIB.P-SRC.P
					sbc SRC.P
					sta (PREV.ADIB.P),Y
					iny
					lda DIB.P+1
					tax
					sbc SRC.P+1
					sta (PREV.ADIB.P),Y
					stx PREV.ADIB.P+1 ; PREV.ADIB.P:=DIB.P
					lda DIB.P
					sta PREV.ADIB.P
FLAG050 PLP ; PULL				staTUS
					bcc FLAG020 ; IF C <> "LAST DIB" THEN PROCESS NEXT DIB
*
FLAG100 CLV ; OV:="ACTIVE DIBS"
					rts; RETURN
*PAGE
*REP 100
*
* NEXT.DIB ( IN: C="FIRST DIB"
* IN: SRC.P
* OUT: DIB.P
* OUT: PG.ALIGN
* OUT: C="LAST DIB"
* OUT: OV="INACTIVE DIB" )
*
* LOCAL: DIB.FLAGS, DIB.DCB = CONSTANT
* (ADVANCES TO NEXT DIB IN DRIVER MODULE)
*REP 100
NEXT.DIB .eq *
					ldy #0
					bcc NXTD010 ; IF C = "FIRST DIB"
					sty PG.ALIGN ; THEN
					sty PG.ALIGN+1 ; PG.ALIGN:=0
					lda SRC.P ; DIB.P:=X:SRC.P
					sta DIB.P
					lda SRC.P+1
					sta DIB.P+1
					lda CXPAGE+SRC.P+1
					sta CXPAGE+DIB.P+1
					jmp NXTD020
NXTD010				lda SRC.P ; ELSE
					adc (DIB.P),Y ; DIB.P:=SRC.P+(DIB.P)
					tax
					iny
					lda SRC.P+1
					adc (DIB.P),Y
					sta DIB.P+1

					stx DIB.P
*
NXTD020 LDY #DIB.FLAGS ; IF (DIB.P),DIB.FLAGS.BIT7 = "INACTIVE"
					lda (DIB.P),Y
					bmi NXTD030
					bit NXTD999 ; THEN
BVS NXTD040 ; OV:="INACTIVE"
* ELSE
NXTD030 AND #$40 ; IF (DIB.P),DIB.FLAGS.BIT6 = "PAGE ALIGN"
					beq NXTD040
					clc ; THEN
					lda #DIB.DCB+2 ; PAGE.ALIGN:=DIB.DCB+2+(SRC.P),DIB.DCB
					tay
					dey
					dey
					adc (SRC.P),Y
					sta PG.ALIGN
					iny
					lda #0
					adc (SRC.P),Y
					sta PG.ALIGN+1
CLV ; OV:="ACTIVE"
*
NXTD040 LDY #0 ; IF (DIB.P) = 0
					lda (DIB.P),Y
					iny
					ora (DIB.P),Y
					bne NXTD998
					clc ; THEN C:="LAST DIB"
					bcs NXTD999
NXTD998 CLC ; ELSE C:=NOT "LAST DIB"
NXTD999 RTS ; RETURN
*REP 100

CHN SOSLDR.F.SRC

					rts; RETURN

*************************************************************************
* END OF APPLE /// SOS 1.3 SOURCE CODE FILE: SOSLDR.E.SRC
*************************************************************************



================================================================================================
FILE: "SOS.SOSLDR.F.SRC.TEXT"
================================================================================================
*************************************************************************
* APPLE /// SOS 1.3 SOURCE CODE FILE: SOSLDR.F.SRC
*************************************************************************
* ASSEMBLER: APPLE ][ 6502 ASSEMBLER from APPLE COMPUTER TOOLKIT

*PAGE
*REP 100
*
* GETMEM ( IN: PG.ALIGN
* IN: CNT
* I/O: DST.P
* I/O: DSTBANK
* I/O: DSEGLIST
* OUT: PREVBANK )
*
* LOCAL: PREVDST
* (COMPUTES # OF PAGES TO ADD TO DRIVER SEGMENT AND WHETHER TO BEGIN A NEW SEGMENT)
*REP 100
GETMEM .eq *
					lda DSTBANK ; PREVBANK:=DSTBANK
					sta PREVBANK
					lda DST.P ; PREVDST:=DST.P
					sta PREVDST
					lda DST.P+1
					sta PREVDST+1
					jsr NEWDST ; NEWDST(PG.ALIGN.IN, PREVDST.IN, CNT.IN, DST.P.OUT)
*
					lda DST.P+1 ; IF DST.P >= $2000
					cmp #$20
					bcc GETM010
					clc ; THEN
					lda PREVDST+1 ; A=PAGES:=PREVDST-DST.P
					sbc DST.P+1
					clc
					jsr BUILD.DSEG ; BUILD.DSEG(C="NEXT BANK".IN, A=PAGES.IN, DSEGLIST.IO)
					jmp GETM.EXIT
* ELSE
GETM010 DEC DSTBANK ; DSTBANK:=DSTBANK-1
					lda #>$A000 ; PREVDST:=$A000
					sta PREVDST
					lda #<$A000
					sta PREVDST+1
					jsr NEWDST ; NEWDST(PG.ALIGN.IN, PREVDST.IN, CNT.IN, DST.P.OUT)
					clc ; A="PAGES":=PREVDST-DST.P
					lda PREVDST+1
					sbc DST.P+1
					clc
					jsr BUILD.DSEG ; BUILD.DSEG(C="NEXTBANK".IN, A="PAGES".IN, DSEGLIST.IO)
*
GETM.EXIT RTS ; RETURN
*PAGE
*REP 100
*
* NEWDST ( IN: PG.ALIGN
* IN: PREVDST
* IN: CNT
* I/O: DST.P )
* (COMPUTES DESTINATION BASE ADDRESS, ALIGNING ON PAGE BOUNDARY IF REQUESTED)
*REP 100
NEWDST .eq *
					clc ; IF (PREVDST-$2000) < CNT
					lda PREVDST
					sbc #>$2000
					tax
					lda PREVDST+1
					sbc #<$2000
					cpx CNT
					sbc CNT+1
					bcs NEWD010
					lda #0 ; THEN
					sta DST.P ; DST.P:=0
					sta DST.P+1
					beq NEWD.EXIT
NEWD010 SEC ; ELSE
					lda PREVDST ; DST.P:=PREVDST-CNT
					sbc CNT

					sta DST.P
					lda PREVDST+1
					sbc CNT+1
					sta DST.P+1
					lda PG.ALIGN ; IF PG.ALIGN <> 0
					ora PG.ALIGN+1 ; THEN
					beq NEWD.EXIT
					clc ; DST.P:=(DST.P/256*256)-PG.ALIGN
					lda #0
					sbc PG.ALIGN
					sta DST.P
					lda DST.P+1
					sbc PG.ALIGN+1
					sta DST.P+1
NEWD.EXIT RTS ; RETURN
*PAGE
*REP 100
*
* BUILD.DSEG ( IN: C="NEXTBANK"
* IN: A="PAGES"
* I/O: DSEGLIST )
* (COMPUTES # OF PAGES TO ADD TO DRIVER SEGMENT AND WHETHER TO BEGIN A NEW SEGMENT)
*REP 100
BUILD.DSEG .eq *
					pha
					bcs BLDS010 ; IF ("NEXTBANK"=TRUE OR DSEGX=$FF)
					lda DSEGX ; THEN
					bpl BLDS020
BLDS010 INC DSEGX ; DSEGX:=DSEGX+1
BLDS020				ldx DSEGX
					clc ; DSEGLIST(DSEGX):=DSEGLIST(DSEGX)+"PAGES"
					pla
					adc DSEGLIST,X
					sta DSEGLIST,X
					rts; RETURN
*
*
*
DSEGX DFB $FF ; DRIVER SEGMENT LIST TABLE
DSEGLIST DFB $0 ; # PAGES FOR 1ST DRIVER SEGMENT (BANK N )
DFB $0 ; " 2ND " (BANK N-1)
DFB $0 ; " 3RD " (BANK N-2)
DFB $0 ; " 4TH " (BANK N-3)
*PAGE
*REP 100
*
* RELOC ( IN: SRC.P
* IN: REL.P
* IN: DST.P
* OUT: RELOCATED DRIVER MODULE )
*
* LOCAL: REL.END, CODE.P
* (RELOCATES DRIVER MODULE'S CODE FIELD USING RELOCATION FIELD)
*REP 100
RELOC .eq *
					clc ; REL.END:=REL.P-(REL.P)
					ldy #0
					lda REL.P
					sbc (REL.P),Y
					sta REL.END
					iny
					lda REL.P+1
					sbc (REL.P),Y
					sta REL.END+1
REL.LOOP SEC ; REL.P:=REL.P-2
					lda REL.P
					sbc #2
					sta REL.P
					lda REL.P+1
					sbc #0
					sta REL.P+1
					lda REL.P ; IF REL.P < REL.END THEN EXIT
					cmp REL.END
					lda REL.P+1
					sbc REL.END+1
					bcc REL.EXIT
					ldy #0 ; CODE.P:=X:SRC.P+(REL.P)
					clc
					lda SRC.P
					adc (REL.P),Y
					sta CODE.P

					iny
					lda SRC.P+1
					adc (REL.P),Y
					sta CODE.P+1
					lda CXPAGE+SRC.P+1
					sta CXPAGE+CODE.P+1
					ldy #0 ; (CODE.P):=(CODE.P)+DST.P
					clc
					lda (CODE.P),Y
					adc DST.P
					sta (CODE.P),Y
					iny
					lda (CODE.P),Y
					adc DST.P+1
					sta (CODE.P),Y
					jmp REL.LOOP ; GOTO REL.LOOP
*
REL.EXIT RTS ; RETURN
*PAGE
*REP 100
*
* ALLOC.SEG ( IN: K.BASE
* IN: I.BASE.P
* IN: SYSBANK )
* I.BASE.P
* D.BASE.PG
* (ALLOCATES SEGMENTS FOR KERNEL, INTERPRETER AND SYSTEM WORK AREA)
*REP 100
ALLOC.SEG .eq *
BRK ; REQ.SEG(BASE=(F,0), LIMIT=(F,1D), SEGID=0, SEGNUM)
DFB REQSEG
DW SEGMENT
*
					lda #$10 ; SET BASE/LIMIT BANKS
					sta SEGBASE
					sta SEGLIM
					lda #0 ; AND INIT BASE PAGE
					sta SEGBASE+1
*
					ldx K.BASE+1 ; KERNEL SEGMENT, ID=1
					jsr RSEG
*
					ldx I.BASE.P+1 ; INTERPRETER SEGMENT, ID=2
					jsr RSEG
					rts
*PAGE
*REP 100
*
* RSEG ( IN: X=BASE.PAGE OF SEGMENT )
*
*REP 100
RSEG .eq *
					inc SEGID ; SEGID:=SEGID+1
					ldy SEGBASE+1 ; LIMIT.PAGE:=BASE.PAGE-1
					dey
					sty SEGLIM+1
					stx SEGBASE+1 ; BASE.PAGE:=X
*
					cpx #$A0 ; IF BASE>=$A0 OR LIMIT<$A0 THEN
					bcs RSEG010 ; THEN
					lda SEGLIM+1 ; REQUEST ONLY ONE SEGMENT
					cmp #$A0
					bcc RSEG010
*
					txa ; ELSE
					pha; REQUEST TWO SEGMENTS
					ldx #$A0
					stx SEGBASE+1
*
BRK ; REQ.SEG(BASE, LIMIT, SEGID, SEGNUM)
DFB REQSEG
DW SEGMENT
*
					pla
					sta SEGBASE+1
					lda #$9F
					sta SEGLIM+1
					lda SYSBANK
					sta SEGBASE
					sta SEGLIM
*

*
RSEG010 BRK ; REQ.SEG(BASE, LIMIT, SEGID, SEGNUM)
DFB REQSEG
DW SEGMENT
*
					rts; RETURN
*PAGE
*REP 100
*
* ALLOC.DSEG ( IN: DSEGLIST )
*
* (ALLOCATES SEGMENTS FOR DRIVER MODULES"
*REP 100
ALLOC.DSEG .eq *
					inc DSEGX ; DSEGX:=DSEGX+1
					bne ALDS010 ; IF DSEGX=0
					ldx #ERR5X ; THEN ERROR("INVALID DRIVER FILE")
					ldy #ERR5L
					jsr ERROR
*
ALDS010 LDY #$FF ; Y:=-1
ALDS020 INY ; WHILE (Y:=Y+1) < DSEGX
					cpy DSEGX ; DO
					bcs ALDS.EXIT
					lda DSEGLIST,Y ; PAGECT:=DSEGLIST(Y)
					sta SEGPGCNT
BRK ; FINDSEG (SRCHMODE=0.IN, SEGID=3.IN
DFB FINDSEG ; PAGECT=DSEGLIST(Y)
DW SEGMENT1 ; BASE.OUT, LIMIT.OUT)
					jmp ALDS020
*
ALDS.EXIT RTS ; RETURN
*PAGE
*REP 100
*
* ERROR (IN: X=MESSAGE INDEX
* IN: Y=MESSAGE LENGTH
* (DISPLAYS ERROR MESSAGE, SOUNDS BELL AND LOOPS UNTIL CONTROL/RESET PRESSED)
*REP 100
ERROR .eq *
					sty ETEMP ; CENTER MSG (Y:=LEN/2+LEN)
					clc
					lda #40
					sbc ETEMP
					lsr A
					clc
					adc ETEMP
					tay
*
PRNT010				lda ERR,X ; MOVE MESSAGE TO SCREEN MEMORY
					sta EMSGADR-1,Y
					dex
					dey
					dec ETEMP
					bne PRNT010
*
					lda #$73 ; E:=( 0.1.1.1:0.0.1.1 )
					sta E.REG ; ( 1.I.S.R:W.P.R.S )
					lda $C040 ; SOUND BELL
					jmp * ; LOOP UNTIL REBOOT (CTRL/RESET)
*PAGE
*REP 100
*
* ERROR MESSAGES
*
*REP 100
EMSGADR .eq $7A8
*
ERR .eq *
ERR0 ASC "I/O ERROR"
ERR0L .eq *-ERR0
ERR0X .eq *-ERR-1
ERR1 ASC "INTERPRETER FILE NOT FOUND"
ERR1L .eq *-ERR1
ERR1X .eq *-ERR-1
ERR2 ASC "INVALID INTERPRETER FILE"
ERR2L .eq *-ERR2
ERR2X .eq *-ERR-1
ERR3 ASC "INCOMPATIBLE INTERPRETER"
ERR3L .eq *-ERR3
ERR3X .eq *-ERR-1

ERR4 ASC "DRIVER FILE NOT FOUND"
ERR4L .eq *-ERR4
ERR4X .eq *-ERR-1
ERR5 ASC "INVALID DRIVER FILE"
ERR5L .eq *-ERR5
ERR5X .eq *-ERR-1
ERR6 ASC "DRIVER FILE TOO LARGE"
ERR6L .eq *-ERR6
ERR6X .eq *-ERR-1
ERR7 ASC "ROM ERROR: PLEASE NOTIFY YOUR DEALER"
ERR7L .eq *-ERR7
ERR7X .eq *-ERR-1
ERR8 ASC "TOO MANY DEVICES"
ERR8L .eq *-ERR8
ERR8X .eq *-ERR-1
ERR9 ASC "TOO MANY BLOCK DEVICES"
ERR9L .eq *-ERR9
ERR9X .eq *-ERR-1
ERR10 ASC "EMPTY DRIVER FILE"
ERR10L .eq *-ERR10
ERR10X .eq *-ERR-1
*PAGE
*REP 100
*
* WELCOME ()
*
* (PRINTS WELCOME MESSAGE - "APPLE ///", VERSION, DATE/TIME, COPYRIGHT)
*REP 100
WELCOME .eq *
*
* PRINT "APPLE III" MESSAGE
*
					ldy #AMSGL
WAM010				lda AMSG-1,Y
					sta AMSGADR-1,Y
					dey
					bne WAM010
*
* PRINT SOS VERSION MESSAGE
*
					clc
					lda #40
					adc #>SOSVERL
					lsr A
					tax
					ldy #>SOSVERL
WSM010				lda SOSVER-1,Y
					ora #$80
					sta SMSGADR-1,X
					dex
					dey
					bne WSM010
*
* PRINT DATE AND TIME MESSAGE
*
BRK ; GET.TIME(TIME.OUT)
DFB GETTIME
DW DTPARMS
*
					lda DATETIME+8 ;SET UP WEEKDAY
					and #$0F
					beq WDM040 ;NO CLOCK
					sta WTEMP
					asl A
					adc WTEMP
					tax
					ldy #3
WDM010				lda DAYNAME-1,X
					sta DMSG-1,Y
					dex
					dey
					bne WDM010
*
					lda DATETIME+7 ;SET UP DATE
					ldx DATETIME+6
					sta DMSG+6
					stx DMSG+5
*
					lda DATETIME+5 ;SET UP MONTH
					and #$0F
					ldx DATETIME+4

					cpx #$31
					bcc WDM020
					adc #9
WDM020				sta WTEMP
					asl A
					adc WTEMP
					tax
					ldy #3
WDM030				lda MONNAME-1,X
					sta DMSG+7,Y
					dex
					dey
					bne WDM030
*
					lda DATETIME+3 ;SET UP YEAR
					ldx DATETIME+2
					sta DMSG+13
					stx DMSG+12
*
					lda DATETIME+10 ;SET UP HOUR
					ldx DATETIME+09
					sta DMSG+17
					stx DMSG+16
*
					lda DATETIME+12 ;SET UP MINUTE
					ldx DATETIME+11
					sta DMSG+20
					stx DMSG+19
*
					ldy #DMSGL ;PRINT DATE & TIME
WDM050				lda DMSG-1,Y
					ora #$80
					sta DMSGADR-1,Y
					dey
					bne WDM050
*
* PRINT COPYRIGHT MESSAGE
*
WDM040 LDY #CMSGL
WCM010				lda CMSG-1,Y
					sta CMSGADR-1,Y
					dey
					bne WCM010
					rts
*PAGE
*REP 100
*
* WELCOME () - DATA DECLARATIONS
*
*REP 100
*MSB ON
AMSG ASC "APPLE ///"
AMSGL .eq *-AMSG
AMSGADR .eq 40-AMSGL/2+$4A8
*MSB OFF
SMSGADR .eq $5A8
DMSG ASC "DAY, DD-MON-YY HH:MM"
DMSGL .eq *-DMSG
DMSGADR .eq 40-DMSGL/2+$6A8
DAYNAME ASC "SUNMONTUEWEDTHUFRISAT"
MONNAME ASC "JANFEBMARAPRMAYJUN"
ASC "JULAUGSEPOCTNOVDEC"
*MSB ON
CMSG ASC "(C)1980,1981,1982 BY APPLE COMPUTER INC."
CMSGL .eq *-CMSG
CMSGADR .eq 40-CMSGL/2+$7D0
*MSB OFF
*PAGE
*REP 100
*
* SOS SYSTEM CALLS (1)
*
*REP 100
* OPEN (PATHNAME.IN, REFNUM.OUT, OPENLIST.IN, OPENCNT.IN) ** (ACCESS.IN, PAGES.IN, SYSBUF.IN)
*REP 100
OPEN .eq $C8
*
OPEN.PARMS DFB $4
DW PATH
OPEN.REF DFB $0
DW OPEN.LIST

DFB $4
OPEN.LIST DFB $0,$4 ; PAGES:=4
DW SYSBUF.P
PATH DS $40 ; PATHNAME BUFFER
I.LABEL ASC "SOS NTRP" ; FILE LABELS
D.LABEL ASC "SOS DRVR"
*REP 100
* READ (REFNUM.IN, BUFFER.IN, BYTES.IN, BYTESREAD.OUT)
*REP 100
READ .eq $CA
*
READ.PARMS DFB $4
READ.REF DFB $0
READ.BUF DW RDBUF.P
READ.BYT DW $FFFF-FILE+1
READ.BYTRD DW $0
*REP 100
* CLOSE (REFNUM.IN)
*REP 100
CLOSE .eq $CC
*
CLOSE.PARMS DFB $1
CLOSE.REF DFB $0
*REP 100
* FIND.SEG (SRCHMODE.IN, PAGES.IN, SEGID.IN, BASE.OUT, LIMIT.OUT, SEGNUM.OUT)
*REP 100
FINDSEG .eq $41
*
SEGMENT1 DFB $6 ; FIND.SEG(SRCHMODE, SEGID, PAGECT, BASE, LIMIT, SEGNUM)
SEGSRCH DFB $0,$3
SEGPGCNT DW $0000
DW $0
DW $0
DFB $0
*PAGE
*REP 100
*
* SOS SYSTEM CALLS (2)
*
*REP 100
*REP 100
* REQUEST.SEG (BASE.IN, LIMIT.IN, SEGID.IN, SEGNUM.OUT)
*REP 100
REQSEG .eq $40
*
SEGMENT DFB $4 ; REQUEST SEG PARM LIST
SEGBASE DFB $F,$0
SEGLIM DFB $F,$1D
SEGID DFB $0,$0
*REP 100
* SET.PREFIX (PREFIXPATH.IN)
*REP 100
SETPREFIX .eq $C6
PREFX.PARMS DFB $1
DW PREFX.PATH
PREFX.PATH DFB $3
ASC '.D1'
*REP 100
* GETTIME (TIME.OUT)
*REP 100
GETTIME .eq $63
*
DTPARMS DFB 1
DW DATETIME
DATETIME ASC "YYYYMMDDWHHMMSSMMM"
*PAGE
*REP 100
*
* END OF SOSLDR CODE
*
*REP 100
SLOP .eq >$F8-*
DS SLOP ; +-----------------------------------+
INITMODULE DS $200 ; ! KERNEL'S INIT MODULE RESIDES HERE !
LDREND				.eq *; +-----------------------------------+
FILE .eq *-$2000+$400
*REP 100
* SOS INTERPRETER FILE
*REP 100
I.FILE .eq FILE
I.HDR.CNT .eq I.FILE+$8

*REP 100
* SOS DRIVER FILE
*REP 100
D.FILE .eq FILE
D.HDR.CNT .eq D.FILE+$8
D.DRIVES .eq D.HDR.CNT+$2
D.CHRSET .eq D.DRIVES+$2+$10
D.KYBD .eq D.CHRSET+$10+$400
*REP 100

*LST ON
ZZEND .eq *
ZZLEN .eq ZZEND-ZZORG
*
NE ZZLEN-LENLODR
FAIL 2,"SOSORG FILE IS INCORRECT FOR SOS LOADER"
FIN
*

*************************************************************************
* END OF APPLE /// SOS 1.3 SOURCE CODE FILE: SOSLDR.F.SRC
*************************************************************************



================================================================================================
FILE: "SOS.SOSLDR.SRC.TEXT"
================================================================================================
*************************************************************************
* APPLE /// SOS 1.3 SOURCE CODE FILE: SOSLDR.SRC
*************************************************************************
* ASSEMBLER: APPLE ][ 6502 ASSEMBLER from APPLE COMPUTER TOOLKIT

*SBTL "SOS 1.1 SOS LOADER"
*REL
ORG $1E00
ZZORG .eq *
*MSB OFF
*REP 100
* COPYRIGHT (C) APPLE COMPUTER INC. 1980
* ALL RIGHTS RESERVED
*REP 100
*
* SOS KERNEL LOAD & MEMORY POINTS
*
* MODULE				staRT END I/O ROM SOS BLOAD SIZE
*------------------------------------------------------
* SOSLDR 1E00 - 28F7 2000 0CF8
* INIT 28F8 - 2AA9 2AF8 [01B2]
* SYSGLOB 18FC - 1A03 2CF8
*
* BFM.INIT2 + BITMAPS
* B800 - BBFF 2E00 03FF
* BFM BC00 - DE62 3200 2263
* <PATCH> DE63 - DE6A 5463 0008
*
* OPRMSG DE6B - E48A X 546B 015A
* IPL DFC5 - E48F X X 55C5 04CB
* UMGR E490 - E89D X X 5A8B 040E
*
* DISK3 E899 - EE03 X X 5E99 056B
* SYSERR EE04 - EED8 X 64D9 00D5
* DEVMGR EED9 - F05D 64D9 0185
*
* SCMGR F05E - F2F3 665E 0296
* FMGR F2F4 - F354 68F4 0061
* CFMGGR F355 - F551 6955 01FD
*
* BUFMGR F552 - F86D 6B52 031C
* MEMMGR F86E - FFBE 6E6E 0751
* <END> FFBE
*
*REP 100
* SOS LOADER (VERSION = 1.1O )
* (DATE = 8/04/81)
*
* SOURCE FILES: SOSLDR.SRC, SOSLDR.A.SRC, SOSLDR.B.SRC, SOSLDR.C.SRC,
* SOSLDR.D.SRC, SOSLDR.E.SRC, SOSLDR.F.SRC
*
* FUNCTION:
* MOVES AND INITIALIZES SOS KERNEL, READS INTERPRETER FROM DISK, READS CHARACTER SET TABLE,
* KEYBOARD TABLE AND DRIVERS FROM DISK, INITIALIZES ALL DRIVERS AND THEN JUMPS TO INTERPRETER
* ENTRY POINT.
*
* CALLED BY:
* SOSBOOT 7.0 WITH KERNEL FILE LOADED AT $I:1E00.9FFF(MAX)
* WHERE: $I=INTERPRETER BANK (HIGHEST BANK IN SYSTEM)
*
* CALLS:
* INTERPRETER ENTRY POINT (FIRST BYTE OF INTERPRETER CODE)
*
* DOCUMENTS:
* SOS ERS APPENDICES - XX/XX/81
* APPLE III I/O SYSTEM PROGRAMMERS GUIDE - DEC-15-80
*
* CONSTRAINTS:
* INTERPRETER FILE: READ INTO BANK 0 BEGINNING AT $80:LDREND+$400(=BUFSIZE).
* INTERPRETER CODE DOES NOT CONTAIN RELOCATION INFORMATION.
* MAX = 38K ($I:2000..B7FF)
* MIN = .25K ($I:B700..B7FF)
*
* DRIVER FILE: READ INTO BANK 0 BEGINNING AT $80:LDREND+$400(=BUFSIZE).
* DRIVER MODULES ARE RELOCATED AND MOVED TO THE HIGHEST AVAILABLE 32K BANK USING
* A "FIRST FIT" ALGORITHM. MODULES ARE REMOVED FROM THE FILE BEGINNING AT THE BACK

* AND WORKING TOWARD THE FRONT. A DRIVER MODULE CANNOT SPAN A BANK BOUNDARY.
*
* DRIVER FILE: MAX = 60K (APPROX) DRIVER MODULE: MAX = 32K-1
* MIN = .25K MIN < .25K
*
*
* DATA STRUCTURES:
* SOS.KERNEL FILE FORMAT
* SOS.INTERP FILE FORMAT
* SOS.DRIVER FILE FORMAT
*
*REP 100
*PAGE
*REP 100
*
* NOTATION:
*
* A, X, Y ::= 6502 REGISTERS
*
* C, OV ::= CARRY, OVERFLOW FLAGS IN 6502				staTUS (P) REGISTER
* E, Z, B ::= ENVIRONMENT, ZERO PAGE, BANK REGISTERS (SYSTEM CONTROL REGISTERS)
*
* (1.I.S.R:W.P.R.R) ::= ENVIRONMENT REGISTER FLAGS. FROM LEFT TO RIGHT BITS 7..0
* (1MHZ, I/O ENABLE, SCREEN ENABLE, RESET ENABLE,
* WRITE PROTECT, PRIMARY				staCK, ROM1, ROM ENABLE)
*
* "POSITIVE LOGIC" ::= ALL LOGIC USED IS POSITIVE LOGIC. FOR EXAMPLE, C="NO DRIVERS LEFT"
* INDICATES THAT NO DRIVERS ARE LEFT WHEN CARRY = SET, AND THAT ONE OR
* MORE DRIVERS ARE LEFT WHEN CARRY = CLEAR.
*
* TRUE,FALSE ::= TRUE = SET = ON, WHILE FALSE = CLEAR = OFF.
*
*REP 100
*
* ABBREVIATIONS:
*
* DIB ::= DEVICE INFORMATION BLOCK. DEFINES A UNIQUE DEVICE THAT CAN BE LINKED
* INTO THE SYSTEM DEVICE TABLE. EACH DRIVER MODULE CONTAINS ONE OR MORE
* DIBS (DEVICES) EACH OF WHICH CAN BE "ACTIVE" OR "INACTIVE".
*
* ADIB ::= "ACTIVE DIB"
*
* <VARNAME>.P ::= POINTER. A 3 BYTE ZERO PAGE POINTER. DON'T FORGET THE X BYTE!
*
* SDT ::= SYSTEM DEVICE TABLE. CONTAINS THE ENTRY POINT AND DIB ADDRESS OF EACH
* DEVICE CONFIGURED INTO THE SYSTEM, (USED BY THE DEVICE MANAGER).
*REP 100

CHN SOSLDR.A.SRC

*************************************************************************
* END OF APPLE /// SOS 1.3 SOURCE CODE FILE: SOSLDR.SRC
*************************************************************************




================================================================================================
FILE: "SOS.SOSORG.TEXT"
================================================================================================
*************************************************************************
* APPLE /// SOS 1.3 SOURCE CODE FILE: SOSORG
*************************************************************************
* ASSEMBLER: APPLE ][ 6502 ASSEMBLER from APPLE COMPUTER TOOLKIT

*REP 100
* SOS KERNEL MODULE ORIGINS
ORGLODR .eq $1E00 ; ORIGIN OF SOS LOADER
ORGINIT .eq $28F8 ; ORIGIN OF INIT
ORGGLOB .eq $18FC ; ORIGIN OF SYSGLOB
ORGBFMI .eq $B800 ; ORIGIN OF BFM.INIT2 & BITMAPS
ORGBFM .eq $BC00 ; ORIGIN OF BFM
ORGPATCH .eq $DE66 ; ORIGIN OF PATCH AREA
ORGOMSG .eq $DE66 ; ORIGIN OF OPRMSG
ORGIPL .eq $DFC0 ; ORIGIN OF IPL
ORGUMGR .eq $E48B ; ORIGIN OF UMGR
ORGDISK3 .eq $E899 ; ORIGIN OF DISK3
ORGSERR .eq $EE04 ; ORIGIN OF SYSERR
ORGDMGR .eq $EED9 ; ORIGIN OF DEVMGR
ORGSCMGR .eq $F05E ; ORIGIN OF SCMGR
ORGFMGR .eq $F2F4 ; ORIGIN OF FMGR
ORGCFM .eq $F355 ; ORIGIN OF CFMGR
ORGBUFMG .eq $F552 ; ORIGIN OF BUFMGR
ORGMEMMG .eq $F86E ; ORIGIN OF MEMMGR
ORGEND .eq $FFBF ; END MARKER
*REP 100
* LENGTH OF SOS MODULES -- THIS MUST AGREE WITH ZZLEN FOR EACH MODULE
LENLODR .eq ORGINIT-ORGLODR ; LENGTH OF SOS LOADER
LENINIT .eq $01B2 ; LENGTH OF INIT
LENBFMI .eq ORGBFM-ORGBFMI ; LENGTH OF BFM.INIT2 & BITMAPS
LENBFM .eq ORGPATCH-ORGBFM ; LENGTH OF BFM
LENPATCH .eq ORGOMSG-ORGPATCH ; LENGTH OF PATCH AREA
LENOMSG .eq ORGIPL-ORGOMSG ; LENGTH OF OPRMSG
LENIPL .eq ORGUMGR-ORGIPL ; LENGTH OF IPL
LENUMGR .eq ORGDISK3-ORGUMGR ; LENGTH OF UMGR
LENDISK3 .eq ORGSERR-ORGDISK3 ; LENGTH OF DISK3
LENSERR .eq ORGDMGR-ORGSERR ; LENGTH OF SYSERR
LENDMGR .eq ORGSCMGR-ORGDMGR ; LENGTH OF DEVMGR
LENSCMGR .eq ORGFMGR-ORGSCMGR ; LENGTH OF SCMGR
LENFMGR .eq ORGCFM-ORGFMGR ; LENGTH OF FMGR
LENCFM .eq ORGBUFMG-ORGCFM ; ORIGIN OF CFMGR
LENBUFMG .eq ORGMEMMG-ORGBUFMG ; LENGTH OF BUFMGR
LENMEMMG .eq ORGEND-ORGMEMMG ; LENGTH OF MEMMGR
*REP 100
* SOS BLOAD ADDRESSES
BLALODR .eq $2000 ; BLOAD ADDRESS OF SOS LOADER
BLAINIT .eq BLALODR+LENLODR ; BLOAD ADDRESS OF INIT
BLAGLOB .eq $2CF8 ; BLOAD ADDRESS OF SYSGLOB
BLABFMI .eq $2E00 ; BLOAD ADDRESS OF BFM.INIT2 & BITMAPS
BLABFM .eq $3200 ; BLOAD ADDRESS OF BFM
BLAPATCH .eq BLABFM+LENBFM ; BLOAD ADDRESS OF PATCH AREA
BLAOMSG .eq BLAPATCH+LENPATCH ; BLOAD ADDRESS OF OPRMSG
BLAIPL .eq BLAOMSG+LENOMSG ; BLOAD ADDRESS OF IPL
BLAUMGR .eq BLAIPL+LENIPL ; BLOAD ADDRESS OF UMGR
BLADISK3 .eq BLAUMGR+LENUMGR ; BLOAD ADDRESS OF DISK3
BLASERR .eq BLADISK3+LENDISK3 ; BLOAD ADDRESS OF SYSERR
BLADMGR .eq BLASERR+LENSERR ; BLOAD ADDRESS OF DEVMGR
BLASCMGR .eq BLADMGR+LENDMGR ; BLOAD ADDRESS OF SCMGR
BLAFMGR .eq BLASCMGR+LENSCMGR ; BLOAD ADDRESS OF FMGR
BLACFM .eq BLAFMGR+LENFMGR ; BLOAD ADDRESS OF CFMGR
BLABUFMG .eq BLACFM+LENCFM ; BLOAD ADDRESS OF BUFMGR
BLAMEMMG .eq BLABUFMG+LENBUFMG ; BLOAD ADDRESS OF MEMMGR
*REP 100

*************************************************************************
* END OF APPLE /// SOS 1.3 SOURCE CODE FILE: SOSORG
*************************************************************************



================================================================================================
FILE: "SOS.SWAPOUT.IN.TEXT"
================================================================================================
*************************************************************************
* APPLE /// SOS 1.3 SOURCE CODE FILE: SWAPOUT.IN
*************************************************************************
* ASSEMBLER: APPLE ][ 6502 ASSEMBLER from APPLE COMPUTER TOOLKIT

SWAPOUT .eq *
*
* SWAP OUT A VOLUME LOGGED ON A DEVICE
* INPUT ARGUMENT: DEVICE NUMBER "A"
* (STORED AS "DEVNUM")
* OUTPUT ARGUMENT: NONE
* CONDITION CODE: CARRY SET USER DID NOT COMPLY WITH REQUEST
*
* SAVE VCBPTR, FCBPTR, DEVNUM ON				staCK
* 1) FIND UNSWAPPED VOLUME IN VCB
* 2) IF DIRTY BIT MAP FOR THIS VOLUME THEN DO
* IF NOT ONLINE, REQUEST USER TO INSERT
* IF REQUEST DENIED, UNCONDITIONALLY CLOSE ALL FILES ON THIS VOLUME AND RTS
* IF ONLINE, UPDATE AND RELEASE BIT MAP
* DOEND
* 3) SWAP IT (MARK VCBSWAP FIELD $80, MARK ALL FILES ON THIS VOLUME WITH SWAP MARK $8X WHERE X=VCB ENTRY)
* "VCB ENTRY" DEFINED AS: HIGH ORDER NIBBLE OF LOW ORDER BYTE OF ENTRIES VCB ADDRESS
* RESTORE VCBPTR, FCBPTR
* RTS
*
					tax; SAVE DEVICE NUMBER
					jsr SAVECBS
					stx DEVNUM ; PERMANENTLY
SWAPOUTX				jsr DEVVCB ; FIND MATCHING UNSWAPPED ACTIVE VCB ENTRY (BY DEVNUM)
					bcs SORTS ; NO FIND--RETURN WITHOUT ERROR
					ldy #VCBSTAT
					lda (VCBPTR),Y ; GET				staTUS OF FILES ON THIS VOLUME
					bpl UNLOG ; IF NO OPEN FILES, JUST THROW VOLUME AWAY
					lda DEVNUM ; DIRTY BM EXIST ON THIS VOLUME?
					ldx #0
					cmp BMADEV,X ; IN BIT MAP "A"?
					beq FDIRBM ; BRANCH IF YES
					ldx #6 ; BIT MAP HEADER TABLE SIZE
					cmp BMADEV,X ; IN BIT MAP "B"?
					beq FDIRBM ; BRANCH IF YES
					jmp MARKSWAP ; NO NEED TO WRITE BIT MAP
FDIRBM				lda BMASTAT,X ; IS BIT MAP DIRTY?
					bpl MARKSWAP ; BRANCH IF NOT
GETVOL				jsr VERFYVOL ; IS THE CORRECT VOLUME ON LINE NOW?
					bcc VONLINE ; BRANCH IF YES
					jsr USRREQ ; OTHERWISE, REQUEST USER INSERTION
					bcc GETVOL ; AND VERIFY IT AGAIN
					jsr CLOSEU ; USER SAID "NO": UNCONDITIONALLY CLOSE VOLUME
					jsr RESTCBS
					clc
					rts; ERROR RETURN TO CALLER
VONLINE				ldx DEVNUM ; UPDATE THE
					jsr UPBMAP ; DIRTY BIT MAP
MARKSWAP				lda VCBPTR ; CALCULATE
					lsr A ; SWAP BYTE
					lsr A ; AND
					lsr A ; MARK ALL FILES
					lsr A ; BELONGING TO THIS VOLUME
					clc ; AS SWAPPED OUT
					ora #$80
					pha; SAVE SWAP BYTE
					jsr FCBSCAN
					pla ; MARK VCBSWAP
					ldy #VCBSWAP ; BYTE
					sta (VCBPTR),Y
SORTS				jsr RESTCBS ; RESTORE FCBPTR, VCBPTR, DEVNUM
					clc
					rts; SUCCESSFUL SWAP OUT
UNLOG				lda #0
					sta VCB,X ; UNLOG VOLUME
					beq SORTS ; SWAP THE EASY WAY! (BRANCH ALWAYS)
*
*
*
SWAPIN .eq *
*

* UNSWAP A VOLUME AND ALL ITS FILES
*
* INPUT ARGUMENT: VOLUME NAME (VCBPTR)
* OUTPUT ARGUMENT: NONE
* CONDITION CODE: CARRY SET : USER DID NOT COMPLY WITH REQUEST
*
* SAVE VCBPTR, FCBPTR ON				staCK
* 1) FIND SWAPPED VOLUME IN VCB, IF NOT FOUND, THEN RTS.
* 2) IF ANOTHER UNSWAPPED VOLUME ON DEVICE, THEN SWAP IT
* 3) VERIFY UNSWAPPED VOLUME, IF NOT OK THEN REQUEST INSERTION
* 4) UNMARK VCB'S AND FCB'S
* RTS
					jsr SAVECBS ; SAVE FCB, VCB POINTERS, DEVNUM
					ldy #VCBNML ; MAKE SURE VOLUME
					lda (VCBPTR),Y ; IS AT LEAST OPEN
					beq USRTS ; BRANCH IF NOT RIGHT BACK TO CALLER
					ldy #VCBSWAP ; SEE IF
					lda (VCBPTR),Y ; CURRENTLY SWAPPED
					beq USRTS ; IF NOT, RETURN IMMEDIATELY TO CALLER
					ldy #VCBDEV ; SAVE DEVICE NUMBER
					lda (VCBPTR),Y
					sta DEVNUM
					pha; SAVE DEVNUM AGAIN (SWAPOUTX TRASHES DEVNUM ON RETURN)
					jsr SWAPOUTX ; AND MAKE SURE ANY CURRENT ACTIVE VOLUME IS SWAPPED OUT (NOTICE ENTRY
POINT)
					pla ; RECALL CURRENT DEVICE NUMBER
					sta DEVNUM ; AND SAVE IT TO ITS PROPER PLACE
SI1				jsr VERFYVOL ; VERIFY THE CURRENT VOLUME MOUNTED
					bcc UNMARK ; IF THE RIGHT ONE, GO MARK IT AS UNSWAPPED
					jsr USRREQ ; ELSE REQUEST USER TO INSERT
					bcc SI1 ; USER SAID 'OK'
					jsr CLOSEU ; OTHERWISE UNCONDITIONALLY CLOSE
					jsr RESTCBS
					clc
					rts
UNMARK LDY #VCBSWAP ; FETCH
					lda (VCBPTR),Y ; VOLUME
					pha; SWAP BYTE
					lda #0 ; BUT CLEAR
					sta (VCBPTR),Y ; VOLUME SWAP
					pla
					clc ; "UNSWAPPED"
					jsr FCBSCAN
					lda DEVNUM ; MAKE SURE BIT MAPS
					jsr CLEARBMS ; ARE MARKED AS INVALID ON THIS DEVICE
USRTS				jsr RESTCBS ; RESTORE VCB, FCB PTRS
					clc ; NO ERRORS
					rts
*
SAVEPTRS DS 5 ; A RARE EMBEDDED TEMP SAVE AREA, USED ONLY BY ...
*
*
SAVECBS				.eq *; SAVE FCBPTR, VCBPTR IN A TEMP SAVE AREA
					lda VCBPTR
					sta SAVEPTRS
					lda VCBPTR+1
					sta SAVEPTRS+1
					lda FCBPTR
					sta SAVEPTRS+2
					lda FCBPTR+1
					sta SAVEPTRS+3
					lda DEVNUM
					sta SAVEPTRS+4
					rts
*
RESTCBS				.eq *; RESTORE FCBPTR, VCBPTR
* NOTICE THERE EXISTS A SEQUENCE OF CALLS (SWAPIN, WHICH MAY CALL SWAPOUT) THAT				jsr'S TO SAVECBS ONCE BUT				jsr'S RESTCBS
TWICE.
					lda SAVEPTRS
					sta VCBPTR
					lda SAVEPTRS+1
					sta VCBPTR+1
					lda SAVEPTRS+2
					sta FCBPTR
					lda SAVEPTRS+3
					sta FCBPTR+1
					lda SAVEPTRS+4
					sta DEVNUM
					rts
*
*

* MARK ALL FILES BELONGING TO A VOLUME
* AS SWAPPED-IN OR SWAPPED-OUT.
*
* INPUT ARGS: DEVNUM -- DEVICE NUMBER OF MOUNTED VOLUME
* A REGISTER - SWAP BYTE
* CARRY -- CARRY FLAG SET MEANS SWAP OUT; ELSE SWAP IN
*
* OUTPUT ARGS: NONE
* GLOBALS AFFECTED: FCB, FCBPTR
* REGISTER				staTUS: SCRAMBLED
*
FCBSCAN				.eq *; MARK FILES BELONGING TO VOLUME AS SWAPPED OR UNSWAPPED
*
					tax; SAVE SWAP BYTE
					ldy FCBADDRH ; POINT TO
					sty FCBPTR+1 ; BEGINNING TO FCB
					ldy #0
					sty FCBPTR
					bcs FCBOUT ; SWAP OUT A VOLUMES FILES
FCBIN				.eq *; SWAPIN A VOLUMES FILES
					jsr FCBFETCH ; GET NEXT ACTIVE FCB CANDIDATE
					bcs FCBRTS ; NO MORE FILES TO PROCESS
					ldy #FCBSWAP
					txa
					cmp (FCBPTR),Y ; SWAP BYTES MATCH?
					bne FCBIN1 ; BRANCH IF NOT
					lda #0
					sta (FCBPTR),Y ; MARK FILE AS SWAPPED IN
FCBIN1				jsr NEXTFCB ; ADVANCE FCB POINTER
					bcs FCBRTS ; NO MORE TO LOOK AT
					jmp FCBIN ; AND LOOK AT NEXT FILE
*
FCBOUT				.eq *; SWAPPED OUT A VOLUMES FILES
					jsr FCBFETCH ; GET NEXT ACTIVE FILE IN FCB
					bcs FCBRTS ; NO MORE FILES -- RETURN TO USER
					ldy #FCBSWAP ; COMPARE
					lda (FCBPTR),Y
					bne FCBOUT1 ; ALREADY SWAPPED OUT
					txa
					sta (FCBPTR),Y ; MARK AS SWAPPED
FCBOUT1				jsr NEXTFCB ; ADVANCE FCB POINTER
					bcs FCBRTS
					jmp FCBOUT ; SWAP OUT NEXT FILE
*
FCBRTS RTS
FCBFETCH			.eq *; GET NEXT ACTIVE FILE FROM FCB
* X REGISTER MUST NOT BE DISTURBED
* USES FCBPTR
					ldy #FCBDEVN ; MAKE
					lda (FCBPTR),Y ; SURE DEVICE
					cmp DEVNUM ; MATCHES
					bne NEXTFCB
					ldy #FCBREFN ; MAKE SURE FILE IS ACTIVE
					lda (FCBPTR),Y
					beq NEXTFCB ; BRANCH IF NOT
					clc
					rts; RETURN WITH CARRY CLEAR SHOWING AN ACTIVE FILE
NEXTFCB				lda FCBPTR
					clc
					adc #$20 ; FCB ENTRY SIZE
					sta FCBPTR
					bcc FCBFETCH ; BRANCH IF NO PAGE CROSS
					lda FCBPTR+1
					inc FCBPTR+1 ; SECOND PAGE
					cmp FCBADDRH
					beq FCBFETCH ; LOOK AT PAGE TWO
NEXTEND SEC
					rts; SHOW NO MORE FILES TO LOOK AT
USRREQ				.eq *; OPERATOR CONSOLE MESSAGE INTERFACE
* PRODUCES A MESSAGE REQUESTING
* THE SYSTEM OPERATOR TO MOUNT THE VOLUME
* SPECIFIED BY "VCBPTR" ON DEVICE SPECIFIED
* BY DEVNUM. THIS MODULE INSISTS
* UPON THE CORRECT OPERATOR ACTION
* UPON THREE FAILURES TO COMPLY,
* THE MODULE WILL SIGNIFY FAILURE WITH
* CARRY SET. IF THE CORRECT ACTION IS TAKEN,
* CARRY WILL BE RETURNED CLEAR
*
* INPUT ARGS: VOLUME NAME (VCBPTR)
* DEVICE NUMBER (DEVNUM)

*
* OUTPUT ARGS: CC = OPERATOR COMPLIED WITH REQUESTED ACTION
* CS = OPERATOR COULDN'T/DIDN'T COMPLY
*
* GLOBALS AFFECTED: NONE
*
*				staTUS OF REGISTERS: UNCERTAIN
*
VNML .eq ZPGTEMP ; VOLUME NAME LENGTH
					ldy #VCBNML ; IF ILLEGAL VCB
					lda (VCBPTR),Y ; GET OUT QUICK
					beq NEXTEND ; BRANCH TO SEC RTS
					ldx #$E ; LENGTH OF NAMED AREA-1
					lda #$0 ; NULLS
UR1				sta MDEV,X ; BOTH CLEAR
					sta MVOL,X ; IN ONE LOOP
					dex
					bpl UR1
*
* DO A D-INFO TO FETCH THE DEVICE NAME
*
					lda #5 ; DO ALL
					sta $C0 ; NECESSARY
					lda DEVNUM ; HOUSKEEPING
					sta $C1 ; TO SET UP
					lda #>MDEV-1 ; A DEVICE MANAGER CALL
					sta $C2
					lda #<MDEV-1
					sta $C3
					lda #$8F ; EXTEND BYTE
					sta $14C3
					lda #0
					sta $14C2
					sta $C4
					sta $C5
					sta $C6 ; ZERO SUPERFLUOUS PARMS
					sta URDERR ; RESET FAILURE COUNT
					jsr RPEATIO0 ; GET INFO FROM BOBS CODE
					lda #$20 ; "SPACE" RESTORED
					sta MDEV-1 ; RESTORED
					ldy #VCBNML
					lda (VCBPTR),Y ; LENGTH OF VOLUME NAME
					sta VNML ; SAVED FOR WORK
					lda #0
					tax
					ldy #VCBNAM ; POINT TO BEGINNING OF VOLUME NAME
UR2				lda (VCBPTR),Y
					sta MVOL,X
					inx
					iny ; VOLUME NAME MOVED
					dec VNML ; TO MESSAGE BUFFER
					bne UR2 ; CHARACTER BY CHARACTER
URDU				ldx #>UMB ; PASS THE AREA'S ADDR
					ldy #<UMB ; IN X AND Y REGS,LOW, HIGH)
					jsr OPMSGRPLY ; HAVE MESSAGE SYSTEM PRINT IT
					jsr VERFYVOL ; DID THE USER COMPLY?
					bcs URDU1 ; BRANCH IF NOT
					rts; EXIT--CARRY IS CLEAR
URDU1 INC URDERR ; COLLECT USER ERRORS
					lda URDERR
					cmp #3 ; ONLY THREE TRIES ALLOWED
					bcc URDU ; RETRY MESSAGE IF LESS THAN THREE TRIES
					rts; OTHERWISE RETURN WITH CARRY SET
*
*
*
*
*
* CLOSE UNCONDITIONAL
*
* (USER HAS REPLIED 'N' TO A VOLUME MOUNT REQUEST
* CLOSE ALL FILES ON VOLUME/UNLOG VOLUME
*
* INPUT ARGUMENT: (VCBPTR)
* OUTPUT ARGUMENT: NONE
*
CLOSEU .eq *
VSWA .eq ZPGTEMP ; THE 'SWAP BYTE' STORED HERE
					ldy #VCBDEV ; FETCH
					lda (VCBPTR),Y ; THE DEVICE NUMBER
					sta DEVNUM ; OF THIS VOLUME & SAVE IT

					ldy #VCBSWAP ; FETCH THE
					lda (VCBPTR),Y ; SWAP BYTE
					sta VSWA ; SAVE FOR REFERENCE, TOO
					lda #0
					ldy #VCBNML ; UNLOG THE VOLUME
					sta (VCBPTR),Y ; BY SETTING LEN OF VOL NAME TO ZERO
					ldy #VCBSWAP
					sta (VCBPTR),Y ; TURN OFF SWAP FLAG
					ldy FCBADDRH ; SET UP FCB SCAN FROM BEGINNING OF FCB
					sty FCBPTR+1
					ldy #0
					sty FCBPTR
VFCBLOP LDY #FCBDEVN ; FETCH
					lda (FCBPTR),Y ; THE DEVICE
					cmp DEVNUM ; NUMBER AND SEE IF A MATCH
					bne VFCBNXT ; BRANCH IF NO MATCH
					ldy #FCBREFN ; SEE EVEN IF FILE OPEN
					lda (FCBPTR),Y
					beq VFCBNXT ; BRANCH IF NOT
					ldy #FCBSWAP ; CHECK TO SEE IF ATTACHED
					lda (FCBPTR),Y ; TO SAME VOLUME
					cmp VSWA
					bne VFCBNXT ; BRANCH IF NOT
					ldy #FCBBUFN ; RELEASE
					lda (FCBPTR),Y ; ANY
					jsr RELBUF ; BUFFERS ASSOCIATED
					ldy #FCBSWAP ; AND CLEAR
					lda #0 ; THE SWAP BYTE
					sta (FCBPTR),Y
					ldy #FCBREFN ; AND FINALLY
					sta (FCBPTR),Y ; SAY 'CLOSED'
VFCBNXT				lda FCBPTR
					clc
					adc #$20 ; FCB ENTRY SIZE
					sta FCBPTR
					bcc VFCBLOP
					lda FCBPTR+1
					inc FCBPTR+1 ; LOOK AT SECOND PAGE
					cmp FCBADDRH
					beq VFCBLOP ; CHECK PAGE TWO OF FCB
					rts; RETURN TO USER W/O ERROR
*
FCBUSED			.eq *; MARK AS FCB AS DIRTY SO
* THE DIRECTORY WILL BE FLUSHED ON 'FLUSH'
					sty ZPGTEMP
					pha; SAVE REGS
					ldy #FCBDIRTY
					lda (FCBPTR),Y ; FETCH CURRENT FCBDIRTY BYTE
					ora #FCBMOD ; MARK FCB AS DIRTY
					sta (FCBPTR),Y ; SAVE IT BACK
					pla
					ldy ZPGTEMP ; AND RESTORE REGS
					rts
*
URDERR DS 1 ; ERROR COUNT FOR USRREQ
*
*
UMB .eq *
DFB $49,$6E,$73,$65,$72,$74,$20
DFB $76,$6F,$6C,$75,$6D,$65
DFB $3A,$20 ; "INSERT VOLUME: "
MVOL DS 15
DFB $0D ; CR LINE TERMINATOR
DFB $20,$20,$20,$20,$69,$6E,$20
DFB $64,$65,$76,$69,$63,$65
DFB $3A,$20 ; " IN DEVICE: "
MDEV DS 15
DFB $0D ; CR LINE TERMINATOR
DFB $74,$68,$65,$6E,$20,$70,$72
DFB $65,$73,$73,$20,$74,$68,$65,$20
DFB $41,$4C,$50,$48,$41,$20,$4C
DFB $4F,$43,$4B,$20,$6B,$65,$79
DFB $20,$74,$77,$69,$63,$65
* "THEN PRESS THE ALPHA LOCK KEY TWICE"
* FOLLOWED WITH $FF MESSAGE TERMINATOR (HIGH BIT SIGNIFICANT)
DFB $FF ; MESSAGE TERMINATOR (HIGH BIT)
*
ZZLEN .eq *-ZZORG
ZZEND .eq *
IFNE ZZLEN-LENBFM
FAIL 2,"SOSORG FILE IS INCORRECT FORMBFM"

FIN

*************************************************************************
* END OF APPLE /// SOS 1.3 SOURCE CODE FILE: SWAPOUT.IN
*************************************************************************



================================================================================================
FILE: "SOS.SYSERR.SRC.TEXT"
================================================================================================
*************************************************************************
* APPLE /// SOS 1.3 SOURCE CODE FILE: SYSERR.SRC
*************************************************************************
* ASSEMBLER: APPLE ][ 6502 ASSEMBLER from APPLE COMPUTER TOOLKIT

*SBTL "SOS 1.1 SYSTEM ERROR ROUTINES"
*REL
					INCLUDE SOSORG,6,1,254
ORG ORGSERR
ZZORG .eq *
*MSB OFF
*REP 60
* COPYRIGHT (C) APPLE COMPUTER INC. 1980
* ALL RIGHTS RESERVED
*REP 60
*
* SYSTEM ERROR ROUTINES (VERSION = 1.1O )
* (DATE = 12/02/81)
*
* THIS MODULE CONTAINS THE SYSTEM ERROR AND SYSTEM FAILURE ROUTINES.
*
*REP 60
*
*ENTRY SYSERR
*ENTRY SYSDEATH
*
*EXTRN SERR
*EXTRN SDEATH.REGS
*EXTRN SCRNMODE
*PAGE
*REP 60
*
* DATA DECLARATIONS
*
*REP 60
*
E.REG .eq $FFDF
Z.REG .eq $FFD0
B.REG .eq $FFEF
*
S.SAVE .eq $09 ; REGISTER SAVE AREA
PCH.SAVE .eq $08
PCL.SAVE .eq $07
P.SAVE .eq $06
A.SAVE .eq $05
X.SAVE .eq $04
Y.SAVE .eq $03
E.SAVE .eq $02
Z.SAVE .eq $01
B.SAVE .eq $00
*
NMI.VECTOR .eq $FFFA
*
TXT.CLR .eq $C050
MIX.CLR .eq $C052
HIRES.CLR .eq $C056
*
PG2.CLR .eq $C054
*
MSGBASE .eq $7E4
MSGBASE2 .eq $BE4
MSG ASC ' SYSTEM FAILURE = $'
MSGLEN .eq *-MSG
*PAGE
*REP 60
*
* SYSTEM ERROR ROUTINE
*
* THIS ROUTINE IS CALLED WHEN AN ERROR CONDITION HAS BEEN
* ENCOUNTERED. THE ERROR NUMBER IS PASSED IN THE A REG
* AND THE CALL TO THIS ROUTINE MUST ALWAYS BE A				jsr.
*
*REP 60
SYSERR .eq *
*
					sta SERR

					pla
					sta SDEATH.REGS+PCL.SAVE
					pla
					sta SDEATH.REGS+PCH.SAVE
					clc
					lda SERR
					bne SERR.EXIT
					clc
SERR.EXIT RTS ; RETURNS ONE LEVEL BEYOND CALLER
*PAGE
*REP 60
*
* SYSTEM DEATH ROUTINE
*
* CALLED TO IMMEDIATELY TERMINATE EXECUTION OF THE MACHINE
* BECAUSE A FATAL ERROR HAS BEEN DETECTED BY THE OPERATING
* SYSTEM. THE ERROR CODE IS PASSED IN THE A REG. THE
* CALL TO THIS ROUTINE MUST ALWAYS BE A				jsr.
*
*REP 60
SYSDEATH .eq *
*
					sta SDEATH.REGS+A.SAVE ; SAVE REGISTERS
					stx SDEATH.REGS+X.SAVE
					sty SDEATH.REGS+Y.SAVE
					php
					pla
					sta SDEATH.REGS+P.SAVE
TSX
					stx SDEATH.REGS+S.SAVE
					lda E.REG
					sta SDEATH.REGS+E.SAVE
					lda Z.REG
					sta SDEATH.REGS+Z.SAVE
					lda B.REG
					sta SDEATH.REGS+B.SAVE
					pla
					sta SDEATH.REGS+PCL.SAVE
					pla
					sta SDEATH.REGS+PCH.SAVE
*
					sei ; TURN OFF INTERRUPTS
CLD
*
					ldx #0 ; SAVE SYSTEM				staCK PAGE IN PAGE $17
SD005				lda $100,X
					sta $1700,X
					dex
					bne SD005
*
					lda $C059 ; ENSURE SILENTYPE PORT SHUT DOWN
					lda $C0DD
					lda $C0DF
					lda $C05F
					lda $C05A
*
					lda $C040 ; SOUND BELL
*
					lda #$74 ; ENSURE RESET LOCK OFF & RAM SWITCHED IN.
					sta E.REG
*
					lda TXT.CLR ; SWITCH TO 40 COL B&W DISPLAY MODE
					lda MIX.CLR
					lda HIRES.CLR
					lda PG2.CLR ; & SELECT PAGE 1
*
					lda #$02
					bit SCRNMODE
BVS SD015 ; IF GRAPHICS MODE THEN KEEP 40 COL MODE
					beq SD015 ; IF 40 COL MODE THEN KEEP
					lda MIX.CLR+1 ; ELSE SWITCH TO 80 COL DISPLAY MODE
*
					ldx #MSGLEN+1 ; ENSURE BKGRND SET TO INVERSE SPACES
					lda #$20 ; SPACE CHAR W/INVERSE
SD010				sta MSGBASE2-1,X
					dex
					bpl SD010
*
SD015				ldx #0 ; MOVE MSG TO TEXT SCREEN
SD020				lda MSG,X
					sta MSGBASE-1,X

					inx
					cpx #MSGLEN
					bne SD020
*
					lda SDEATH.REGS+A.SAVE ; DISPLAY ERROR CODE (2 HEX DIGITS)
					clc
					lsr A
					lsr A
					lsr A
					lsr A
					jsr PRINT ; FIRST DIGIT
					inx
					lda SDEATH.REGS+A.SAVE
					and #$0F
					jsr PRINT ; SECOND DIGIT
*
					lda #>SD100
					sta NMI.VECTOR
					lda #<SD100
					sta NMI.VECTOR+1
*
*
					jmp * ; HANG UNTIL REBOOT (CTRL/RESET)
*REP 60
SD100 RTI ; NMI VECTOR POINT HERE TO MASK THEM OUT
*
*
* PRINT SUBROUTINE
*
PRINT .eq *
					cmp #$A
					bcs PRNT100
					adc #$30 ; "0"-"9"
					bcc PRNT110 ; ALWAYS TAKEN
PRNT100 ADC #$36 ; "A"-"F"
PRNT110				sta MSGBASE-1,X
					rts
*
*LST ON
ZZEND .eq *
ZZLEN .eq ZZEND-ZZORG
IFNE ZZLEN-LENSERR
FAIL 2,"SOSORG FILE IS INCORRECT FOR SYSERR"
FIN

*************************************************************************
* END OF APPLE /// SOS 1.3 SOURCE CODE FILE: SYSERR.SRC
*************************************************************************



================================================================================================
FILE: "SOS.SYSGLOB.SRC.TEXT"
================================================================================================
*************************************************************************
* APPLE /// SOS 1.3 SOURCE CODE FILE: SYSGLOB.SRC
*************************************************************************
* ASSEMBLER: APPLE ][ 6502 ASSEMBLER from APPLE COMPUTER TOOLKIT

*SBTL "SOS 1.1 GLOBAL EQUATES"
*REL
ORG $18FC
*MSB OFF
*REP 60
* COPYRIGHT (C) APPLE COMPUTER INC. 1980
* ALL RIGHTS RESERVED
*REP 60
*
* SOS SYSTEM GLOBAL DATA & EQUATES
*
* THIS MODULE CONTAINS THE SOS JUMP TABLE, AND ALL GLOBAL
* DATA AND EQUATES. THE JUMP TABLE, AND ALL DATA THAT IS
* TO BE REFERENCED BY DEVICE HANDLERS, ARE ASSIGNED FIXED
* ADDRESSES AT THE BEGINNING OF MEMORY PAGE $19. DATA
* THAT IS ONLY REFERENCED BY SOS BEGINS $1980, BUT MAY BE
* MOVED WHENEVER SOS IS RELINKED.
*
*REP 60
*
*EXTRN ALLOCSIR
*EXTRN DEALCSIR
*EXTRN NMIDSBL
*EXTRN NMIENBL
*EXTRN QUEEVENT
*EXTRN SELC800
*EXTRN SYSDEATH
*EXTRN SYSERR
*EXTRN REQBUF
*EXTRN GETBUFADR
*EXTRN RELBUF
*EXTRN NMIDBUG
*EXTRN NMICONT
*EXTRN COLDSTRT
*
*
*ENTRY MEMSIZE
*ENTRY SYSBANK
*ENTRY SUSPFLSH
*ENTRY NMIFLAG
*ENTRY SCRNMODE
*ENTRY GRSIZE
*
*ENTRY SERR
*ENTRY DBUGBRK
*ENTRY KYBDNMI
*ENTRY NMISPSV
*ENTRY SDEATH.REGS
*
*ENTRY SOSVER
*ENTRY SOSVERL
*
*ENTRY SZPAGE
*ENTRY SXPAGE
*ENTRY SSPAGE
*
*ENTRY CZPAGE
*ENTRY CXPAGE
*ENTRY CSPAGE
*ENTRY CEVPRI
*
*ENTRY SIRTEMP
*ENTRY SIRARGSIZ
*ENTRY IRQCNTR
*ENTRY NMICNTR
*ENTRY QEVTEMP
*ENTRY QEV.THIS
*ENTRY QEV.LAST
*
*ENTRY BADBRK
*ENTRY BADINT1

*ENTRY BADINT2
*ENTRY NMIHANG
*ENTRY EVQOVFL
*ENTRY STKOVFL
*ENTRY BADSYSCALL
*ENTRY DEV.OVFLOW
*ENTRY MEM2SML
*ENTRY VCBERR
*ENTRY FCBERR
*ENTRY ALCERR
*ENTRY DIRERR
*ENTRY TOOLONG
*ENTRY BADBUFNUM
*ENTRY BADBUFSIZ
*ENTRY BITMAPADR
*
*ENTRY BADSCNUM
*ENTRY BADCZPAGE
*ENTRY BADXBYTE
*ENTRY BADSCPCNT
*ENTRY BADSCBNDS
*
*ENTRY NODNAME
*ENTRY BADDNUM
*
*ENTRY BADPATH
*ENTRY CFCBFULL
*ENTRY FCBFULL
*ENTRY BADREFNUM
*ENTRY PATHNOTFND
*ENTRY VNFERR
*ENTRY FNFERR
*ENTRY DUPERR
*ENTRY OVRERR
*ENTRY DIRFULL
*ENTRY CPTERR
*ENTRY TYPERR
*ENTRY EOFERR
*ENTRY POSNERR
*ENTRY ACCSERR
*ENTRY BTSERR
*ENTRY FILBUSY
*ENTRY NOTSOS
*ENTRY BADLSTCNT
*ENTRY OUTOFMEM
*ENTRY BUFTBLFULL
*ENTRY BADSYSBUF
*ENTRY DUPVOL
*ENTRY NOTBLKDEV
*ENTRY LVLERR
*
*ENTRY BADJMODE
*
*ENTRY BADBKPG
*ENTRY SEGRQDN
*ENTRY SEGTBLFULL
*ENTRY BADSEGNUM
*ENTRY SEGNOTFND
*ENTRY BADSRCHMODE
*ENTRY BADCHGMODE
*ENTRY BADPGCNT
*
*ENTRY XREQCODE
*ENTRY XCTLCODE
*ENTRY XCTLPARM
*ENTRY XNOTOPEN
*ENTRY XNOTAVAIL
*ENTRY XNORESRC
*ENTRY XBADOP
*ENTRY XIOERROR
*ENTRY XNODRIVE
*ENTRY XNOWRITE
*ENTRY XBYTECNT
*ENTRY XBLKNUM
*ENTRY XDISKSW
*ENTRY BACKMASK ; MASK BYTE FOR BACKUP BIT.
*
*ENTRY E1908 ; DISK DRIVER IS READING/WRITING (SET) ELSE NOT (RESET)
*
*PAGE
DW SYSGLOB ;SYSGLOB TARGET ADDRESS

DW $0100 ; AND LENGTH
*
* SYSTEM GLOBAL DATA
* (ACCESSIBLE TO SOS AND DEVICE HANDLERS)
*
SYSGLOB .eq *
*
MEMSIZE DFB $08 ;MEMORY SIZE = 128K
SYSBANK DFB $02 ;SYSTEM BANK = 2
SUSPFLSH DFB $00 ;SYSOUT SUSPEND/FLUSH FLAG
NMIFLAG DFB $00 ;NMI PENDING FLAG
DW NMIEXIT ;DEFAULT NMI VECTOR
SCRNMODE DFB $80 ;CURRENT SCREEN MODE
GRSIZE DFB $00
*
*
* SOS JUMP TABLE
*
DS SYSGLOB+$10-*,$00 ; USED BY THE MOUSE DRIVER
USERNMI JMP NMIEXIT ;KEYBOARD NMI VECTOR
					jmp ALLOCSIR ;ALLOCATE A SIR
					jmp DEALCSIR ;DEALLOCATE A SIR
					jmp NMIDSBL ;DISABLE NMI
					jmp NMIENBL ;ENABLE NMI
					jmp QUEEVENT ;QUEUE AN EVENT
					jmp SELC800 ;SELECT I/O EXPANSION ROM
					jmp SYSDEATH ;SYSTEM DEATH
					jmp SYSERR ;SOS ERROR
					jmp REQBUF ;REQUEST BUFFER
					jmp GETBUFADR ;GET BUFFER'S ADDRESS
					jmp RELBUF ;RELEASE BUFFER
					jmp CLRBMASK ;VECTOR TO CLRBMASK
*PAGE
*
* SOS DATA AND EQUATES
* (ACCESSIBLE ONLY TO SOS)
*
DS SYSGLOB+$80-*,$00
SERR DFB $00 ;SYSTEM ERROR CODE
*
DBUGBRK NOP ;TO ENABLE DEBUG BREAK POINTS,
					pla ; PATCH THESE BYTES TO
					pla ; JMP TO THE DEBUGGER
					rts
*
KYBDNMI JMP USERNMI
					jmp NMIDBUG
NMISPSV DFB 0
					jmp NMICONT
NMIEXIT RTS
*
*
SOSVER ASC "SOS 1.3 01-DEC-82"
SOSVERL .eq *-SOSVER
*
ASC "(C) 1980, 1981 BY APPLE COMPUTER INC."
*
E1908 .eq $1908 ; ALLOCATED TO STEPHEN SMITH (MOUSE DRIVER)
* ABOVE SET AND RESET IN DISK DRIVER
SZPAGE .eq $1800 ;SYSTEM ZERO PAGE
SXPAGE .eq $1400 ;SYSTEM EXTEND PAGE
SSPAGE .eq $0100 ;SYSTEM				staCK PAGE
*
CZPAGE .eq $1A00 ;CALLER'S ZERO PAGE
CXPAGE .eq $1600 ;CALLER'S EXTEND PAGE
CSPAGE .eq $1B00 ;CALLER'S				staCK PAGE
CEVPRI DFB $00 ;CALLER'S EVENT PRIORITY
*
SIRTEMP DFB $00 ;TEMP FOR ALLOCSIR & DEALCSIR
SIRARGSIZ DFB $00 ;ARGUMENT COUNT FOR ALLOCSIR & DEALCSIR
IRQCNTR DW $0000 ;FALSE IRQ COUNTER
NMICNTR DW $0000 ;COUNTER FOR NMILOCK
QEVTEMP DFB $00 ;TEMP FOR QUEEVENT
QEV.THIS DFB $00 ;POINTER FOR QUEEVENT
QEV.LAST DFB $00 ;POINTER FOR QUEEVENT
*
SOSQUIT DS COLDSTRT
BACKMASK DFB BACKBIT ; MASK USED BY BFM TO UPDATE BACKUP BIT
*
* TO CLEAR THE BACKUP BIT, A PROGRAM MUST				jsr TO CLRBMASK THRU 1934 THEN DO A
* SET-FILE-INFO WITH NO INTERVENING SOS CALLS. ANY SOS CALL WILL

* SET BACKMASK AGAIN. THIS FEATURE IS INTENTIONALLY LEFT UNDOCUMENTED.
*
CLRBMASK AND #BACKBIT ; PURIFY
					sta BACKMASK ; SET THE MASK
					rts; AND BACK TO THE CALLER
*PAGE
*
* SYSTEM DEATH REGISTER SAVE AREA
* (SYSTEM				staCK MOVED TO $1700-$17FF)
*
DS SYSGLOB+$F6-*,$00
SDEATH.REGS .eq *
DFB $00 ;BANK
DFB $00 ;ZERO PAGE
DFB $00 ;ENVIRONMENT
DFB $00 ;Y
DFB $00 ;X
DFB $00 ;A
DFB $00 ;STATUS
DW $00 ;PROGRAM COUNTER
DFB $00 ;STACK POINTER
*
* SYSTEM DEATH ERROR NUMBERS
*
BADBRK .eq $01 ;BRK FROM SOS
BADINT1 .eq $02 ;INTERRUPT NOT FOUND
BADINT2 .eq $03 ;BAD ZERO PAGE ALLOCATION
NMIHANG .eq $04 ;UNABLE TO LOCK NMI
EVQOVFL .eq $05 ;EVENT QUEUE OVERFLOW
STKOVFL .eq $06 ;STACK OVERFLOW
*
BADSYSCALL .eq $07 ;DMGR DETECTED INVALID REQUEST CODE
DEV.OVFLOW .eq $08 ;DMGR - TOO MANY DEVICE HANDLERS
MEM2SML .eq $09 ;MEMORY SIZE < 64K
VCBERR .eq $0A ;VOLUME CONTROL BLOCK NOT USABLE (BFMGR)
FCBERR .eq $0B ;FILE CONTROL BLOCK CRASHED
ALCERR .eq $0C ;ALLOCATION BLOCKS INVALID
TOOLONG .eq $0E ;PATHNAME BUFFER OVERFLOW
BADBUFNUM .eq $0F ;INVALID BUFFER NUMBER
BADBUFSIZ .eq $10 ;INVALID BUFFER SIZE (=0 OR >16K)
*PAGE
*
* SYSTEM ERROR NUMBERS
*
* - SYSTEM CALL MANAGER
*
BADSCNUM .eq $01 ;BAD SYSTEM CALL NUMBER
BADCZPAGE .eq $02 ;BAD CALLER'S ZPAGE (MUST=$1A)
BADXBYTE .eq $03 ;BITS 6..4 <> 0
BADSCPCNT .eq $04 ;BAD SYSTEM CALL PARM COUNT
BADSCBNDS .eq $05 ;SYS CALL PARM ADR
*
* - DEVICE MANAGER
*
NODNAME .eq $10 ;DEVICE NAME NOT FOUND
BADDNUM .eq $11 ;INVALID DEV.NUM PARM
*
* - DEVICE HANDLERS (STANDARD ERRORS)
*
XREQCODE .eq $20 ;INVALID REQUEST CODE
XCTLCODE .eq $21 ;INVALID CONTROL/STATUS CODE
XCTLPARM .eq $22 ;INVALID CONTROL/STATUS PARM
XNOTOPEN .eq $23 ;DEVICE NOT OPEN
XNOTAVAIL .eq $24 ;DEVICE NOT AVAILABLE
XNORESRC .eq $25 ;UNABLE TO OBTAIN RESOURCE
XBADOP .eq $26 ;INVALID OPERATION
XIOERROR .eq $27 ;I/O ERROR
*
XNODRIVE .eq $28 ;NO DRIVE CONNECTED
XNOWRITE .eq $2B ;DEVICE WRITE PROTECTED
XBYTECNT .eq $2C ;BYTE COUNT <> A MULTIPLE OF 512
XBLKNUM .eq $2D ;BLOCK NUMBER TOO LARGE
XDISKSW .eq $2E ;DISK MEDIA HAS BEEN SWITCHED
*
* - NOTE: ERROR CODES $30-$3F HAVE BEEN RESERVED FOR DEVICE
* HANDLER SPECIFIC ERRORS
*
*
* - FILE MANAGER
*
BADPATH .eq $40 ;PATHNAME, INVALID SYNTAX

CFCBFULL .eq $41 ;CHAR FILE CTRL BLOCK TABLE FULL
FCBFULL .eq $42 ;BLOCK FILE CTRL BLOCK TABLE FULL
BADREFNUM .eq $43 ;INVALID REF.NUM PARM
PATHNOTFND .eq $44 ;PATHNAME NOT FOUND
VNFERR .eq $45 ;VOLUME NOT FOUND
FNFERR .eq $46 ;FILE NOT FOUND
DUPERR .eq $47 ;DUPLICATE FILE NAME ERROR
OVRERR .eq $48 ;NOT ENOUGH DISK SPACE FOR PREALLOCATION
DIRFULL .eq $49 ;DIRECTORY FULL ERROR
CPTERR .eq $4A ;FILE INCOMPATIBLE SOS VERSION
TYPERR .eq $4B ;NOT CURRENTLY SUPPORTED FILE TYPE
EOFERR .eq $4C ;POSITION ATTEMPTED BEYOND END OF FILE
POSNERR .eq $4D ;ILLEGAL POSITION (L.T. 0 OR G.T. $FFFFFF)
ACCSERR .eq $4E ;FILE ACCESS R/W REQUEST CONFLICTS WITH ATTRIBUTES
BTSERR .eq $4F ;USER SUPPLIED BUFFER TOO SMALL
FILBUSY .eq $50 ;EITHER WRITE WAS REQUESTED OR WRITE ACCESS ALREADY ALLOCATED
DIRERR .eq $51 ;DIRECTORY ERROR
NOTSOS .eq $52 ;NOT A SOS DISKETTE
BADLSTCNT .eq $53 ;INVALID VALUE IN LIST PARAMETER
OUTOFMEM .eq $54 ;OUT OF FREE MEMORY FOR BUFFER
BUFTBLFULL .eq $55 ;BUFFER TABLE FULL
BADSYSBUF .eq $56 ;INVALID SYSBUF PARAMETER
DUPVOL .eq $57 ;SON A BITCH GOT TWO VOLUMES OF SAME ROOT NAME!!!
NOTBLKDEV .eq $58
LVLERR .eq $59 ;INVALID FILE LEVEL
					bitMAPADR .eq $5A
BACKBIT .eq $20 ; MASK FOR BACKUP BIT
*
* - UTILITY MANAGER
*
BADJMODE .eq $70 ;INVALID JOYSTICK REQUEST
*
* - MEMORY MANAGER
*
BADBKPG .eq $E0 ;INVALID BANK/PAGE PAIR
SEGRQDN .eq $E1 ;SEGMENT REQUEST DENIED
SEGTBLFULL .eq $E2 ;SEGMENT TABLE FULL
BADSEGNUM .eq $E3 ;INVALID SEGMENT NUMBER
SEGNOTFND .eq $E4 ;SEGMENT NOT FOUND
BADSRCHMODE .eq $E5 ;INVALID SEARCH MODE PARM
BADCHGMODE .eq $E6 ;INVALID CHANGE MODE PARM
BADPGCNT .eq $E7 ;INVALID PAGE COUNT PARM
ORG SYSGLOB+$100
DW $B800 ;KERNEL TARGET ADDRESS
DW $47C0 ; AND LENGTH

*************************************************************************
* END OF APPLE /// SOS 1.3 SOURCE CODE FILE: SYSGLOB.SRC
*************************************************************************




================================================================================================
FILE: "SOS.TCOMP.SOS.TEXT"
================================================================================================
*************************************************************************
* APPLE /// SOS 1.3 SOURCE CODE FILE: TCOMP.SOS
*************************************************************************
* ASSEMBLER: APPLE ][ 6502 ASSEMBLER from APPLE COMPUTER TOOLKIT

:TABS 17,23,40
SL4:DR1:ASM IPL.SRC1,IPL.OBJ,6,1
SL4:DR1:ASM UMGR.SRC,UMGR.OBJ,6,1
SL4:DR2:ASM DISK3.SRC,DISK3.OBJ,6,1
SL4:DR2:ASM SYSERR.SRC,SYSERR.OBJ,6,1
SL4:DR2:ASM SCMGR.SRC,SCMGR.OBJ,6,1
SL4:DR2:ASM FMGR.SRC,FMGR.OBJ,6,1
SL4:DR2:ASM CFMGR.SRC,CFMGR.OBJ,6,1
SL4:DR2:ASM DEVMGR.SRC,DEVMGR.OBJ,6,1
SL4:DR2:ASM BUFMGR.SRC,BUFMGR.OBJ,6,1
SL4:DR2:ASM MEMMGR.A.SRC,MEMMGR.OBJ,6,1

*************************************************************************
* END OF APPLE /// SOS 1.3 SOURCE CODE FILE: TCOMP.SOS
*************************************************************************


================================================================================================
FILE: "SOS.UMGR.SRC.TEXT"
================================================================================================
*************************************************************************
* APPLE /// SOS 1.3 SOURCE CODE FILE: UMGR.SRC
*************************************************************************
* ASSEMBLER: APPLE ][ 6502 ASSEMBLER from APPLE COMPUTER TOOLKIT

*SBTL "SOS 1.1 UTILITY MANAGER"
*REL
					INCLUDE SOSORG,6,1,254
ORG ORGUMGR
ZZORG .eq *
*MSB OFF
*REP 60
* COPYRIGHT (C) APPLE COMPUTER INC. 1980
* ALL RIGHTS RESERVED
*REP 60
* UTILITY MANAGER
*
* THIS MODULE HANDLES THE FOLLOWING SOS CALLS:
* SET.FENCE, GET.FENCE
* SET.TIME, GET.TIME
* JOYSTICK, COLDSTRT
*
* IN ADDITION, IT CONTAINS THE ROUITNE DATETIME WHICH
* PROVIDES THE DATE AND TIME FOR THE BLOCK FILE MANAGER.
*
*REP 60
*
*ENTRY UMGR
*ENTRY DATETIME
*ENTRY BCDBIN
*ENTRY COLDSTRT
*
*ENTRY PCLOCK
*
*EXTRN SYSBANK
*EXTRN CEVPRI
*EXTRN SYSERR
*EXTRN BADSCNUM
*EXTRN BADJMODE
*EXTRN XNORESRC
*EXTRN ALLOCSIR
*EXTRN DEALCSIR
*
U.TPARMX .eq $C0
U.REQCODE .eq U.TPARMX
PRIORITY .eq U.TPARMX+1
J.MODE .eq U.TPARMX+1
J.VALUE .eq U.TPARMX+2
TIME .eq U.TPARMX+1
MEMORY .eq U.TPARMX+1
*
					bitON2 .eq $04
					bitON5 .eq $20
					bitON6 .eq $40
					bitON7 .eq $80
					bitOFF5 .eq $DF
*
Z.REG .eq $FFD0
E.REG .eq $FFDF
B.REG .eq $FFEF
*PAGE
*REP 35
*
* UTILITY SWITCH
*
*REP 35
*
*
UMGR				.eq *
					lda E.REG ;SELECT $C000 I/O SPACE
					ora #BITON6
					sta E.REG
*
					lda U.REQCODE
					cmp #USWCNT
					bcs UMGRERR

					asl A
					tax
					lda USWTBL+1,X
					pha
					lda USWTBL,X
					pha
					rts
*
UMGRERR				lda #>BADSCNUM
					jsr SYSERR
*
* UTILITY SWITCH TABLE
*
USWTBL .eq *
DW SET.FENCE-1
DW GET.FENCE-1
DW SET.TIME-1
DW GET.TIME-1
DW JOYSTICK-1
DW COLDSTRT-1
USWCNT .eq *-USWTBL/2
*PAGE
*REP 60
*
* SET.FENCE(IN.PRIORITY) SYSTEM CALL
*
* GET.FENCE(OUT.PRIORITY) SYSTEM CALL
*
* THESE TWO CALLS ALLOW THE CALLER TO EITHER RETRIEVE OR SET
* THE CURRENT SYSTEM EVENT PRIORITY THRESHOLD. BY RAISING
* THE FENCE, A USER MAY INHIBIT THE EXECUTION OF EVENTS WHOSE
* PRIORITY IS EQUAL TO OR LESS THAN THE VALUE OF THE SYSTEM
* FENCE.
*
*REP 60
*
*
SET.FENCE			.eq *
					lda PRIORITY
					sta CEVPRI
					rts; NORMAL EXIT
*
*
GET.FENCE			.eq *
					lda CEVPRI
					ldy #0
					sta (PRIORITY),Y
					rts; NORMAL EXIT
*PAGE
*REP 60
*
* SET.TIME(IN.TIME)
* GET.TIME(OUT.TIME)
*
* THESE SYSTEM CALLS ALLOW THE USER TO SET AND READ THE
* SYSTEM'S CLOCK. THE TIME IS EXPRESSED AS AN EIGHTEEN
* DIGIT ASCII STRING IN THE FORM "YYYYMMDDWHHMMSSMMM".
*
* YYYY YEAR [1900-1999]
* MM MONTH [01-12]
* DD DAY [01-31]
* W WEEKDAY [1-7] 1 => SUNDAY
* HH HOUR [00-23]
* MM MINUTE [00-59]
* SS SECOND [00-59]
* MMM MILLISECOND [000-999]
*
* THE CLOCK CHIP AUTOMATICALLY MAINTAINS THE TIME AND
* DATE FROM MILLISECONDS TO MONTHS. IT DOES NOT MAINTAIN
* THE YEAR, HOWEVER, NOR DOES IT RECOGNIZE 29 FEBRUARY
* IN LEAP YEARS. THE SOFTWARE SETS THE DAY AND MONTH
* LATCHES TO THE DON'T CARE				staTE AND USES THE REMAINING
* EIGHT BITS TO HOLD A TWO DIGIT BCD YEAR. THE CLOCK
* MUST BE RESET AT THE BEGINNING OF EACH YEAR AND ON
* 29 FEBRUARY IN LEAP YEARS.
*
* SET.TIME ASSUMES THAT THE DATE IS VALID AND CORRECT.
* THE CENTURY IS IGNORED AND MILLISECONDS ARE ALWAYS SET
* TO ZERO. GET.TIME ALWAYS SETS THE CENTURY TO 19.
*
*REP 60

*
*
* TEMPORARY ZERO PAGE
*
PCLK .eq $D0 ;POINTER TO SAVED PCLOCK
WKDAY .eq $D2
CKSUM .eq $D3
CLKTEMP .eq $18D4 ;THROUGH $18DD - ABSOLUTE
*
* CLOCK LOCAL DATA
*
PCLOCK DS $0A ;PSEUDO CLOCK REGISTERS
RETRY DS $01
*
* CLOCK HARDWARE ADDRESSES
*
CLOCK .eq $C070
CSEC .eq $02
CMIN .eq $03
CMON .eq $07
LDAY .eq $0E
CRESET .eq $12
STATUS .eq $14
*
WKMON DFB 8,11,11,7,9,12
DFB 7,10,13,8,11,13
*
*
SET.TIME .eq *
					ldx #$00
					ldy #$12
					lda #'0'
					bne STIM011
*
STIM010 INX
					lda (TIME),Y ;CONVERT TIME FROM
STIM011 AND #$0F ; ASCII TO BCD AND
					sta PCLOCK,X ; TRANSFER TO PCLOCK
					dey
					cpy #$07
					beq STIM010
					lda (TIME),Y
					asl A
					asl A
					asl A
					asl A
					ora PCLOCK,X
					sta PCLOCK,X
					dey
					bpl STIM010
*
					lda PCLOCK+7 ;CALCULATE WEEKDAY
					jsr BCDBIN
					tax
					lda PCLOCK+8
					jsr BCDBIN
					tay
					lsr A
					lsr A
					sta WKDAY
					tya
					and #$03
					bne STIM015
					cpx #3
					bcs STIM015 ; <SRS 82.162>
					dey
STIM015				clc
					tya
					adc WKDAY
					adc WKMON-1,X
					sta WKDAY
					lda PCLOCK+6
					jsr BCDBIN
					clc
					adc WKDAY
					clc
STIM016				sbc #7
					cmp #8
					bcs STIM016
					sta PCLOCK+5
*
					lda #$D0
					sta PCLK ;POINT (PCLK) TO 8F:FFD0
					lda #$FF
					sta PCLK+1
					lda #$8F
					sta $1401+PCLK
					lda #$A5
					sta CKSUM ;INITIALIZE CHECKSUM
					ldy #$00
*
STIM020				lda PCLOCK,Y ;SAVE PCLOCK
					sta (PCLK),Y ; BEHIND 6522
					eor CKSUM
					sta CKSUM
					iny
					cpy #$0A
					bcc STIM020
					sta (PCLK),Y ;SAVE CHECKSUM
*
					lda Z.REG
					pha;SAVE ZERO PAGE
					lda E.REG
					pha;SAVE ENVIRONMENT
					ora #BITON7 ; AND SET 1 MHZ
					sta E.REG
*
					ldy #STATUS
					sty Z.REG
					lda CLOCK ;DOES CLOCK EXIST?
					bmi STIM050 ; NO
*
					ldx #CRESET
					stx Z.REG
					lda #$FF ;RESET ALL COUNTERS
					sta CLOCK
					sta CLOCK
*
					ldx #CSEC-1
STIM030 INX
					php
					sei ;DISABLE INTERRUPTS
STIM040 STX Z.REG
					lda CLOCK ;(DUMMY READ FOR				staTUS)
					lda PCLOCK,X
					sta CLOCK ;SET CLOCK COUNTER
					lda CLOCK ;(DUMMY READ FOR				staTUS)
					sty Z.REG
					lda CLOCK ;CHECK				staTUS BIT
					bne STIM040
					plp ;RESTORE INTERRUPTS
					cpx #CMON
					bcc STIM030
*
					ldx #LDAY
					stx Z.REG
					lda PCLOCK+8
					ora #$CC ;STUFF YEAR INTO DAY
					sta CLOCK ; AND MONTH LATCHES
					inc Z.REG
					lda PCLOCK+8
					lsr A
					lsr A
					ora #$CC
					sta CLOCK
*
STIM050 PLA
					sta E.REG ;RESTORE ENVIRONMENT
					pla
					sta Z.REG ; AND ZERO PAGE
					rts
*PAGE
GET.TIME .eq *
					dda Z.REG ;SAVE ZERO PAGE
					pha
					lda E.REG ;SAVE ENVIRONMENT
					pha
					ora #BITON7
					sta E.REG ;SET 1 MHZ
*
					ldy #STATUS
					sty Z.REG

					lda CLOCK ;DOES CLOCK EXIST?
					bmi GTIM050 ; NO
*
					lda #$10 ;ALLOW $10 RETRYS
					sta RETRY
GTIM010				ldx #CMON+1
					php
					sei ;DISABLE INTERRUPTS
*
GTIM020 DEX
					bmi GTIM030 ;ALL DONE
					stx Z.REG
					lda CLOCK ;COPY CLOCK COUNTERS
					sta CLKTEMP,X ; TO TEMP REGISTERS
					sty Z.REG
					lda CLOCK ;CHECK				staTUS BIT
					beq GTIM020
*
					plp ;CLOCK READ ERROR
					dec RETRY
					bpl GTIM010 ;TRY AGAIN
					bmi GTIM050
*
GTIM030 PLP ;RESTORE INTERRUPTS
					ldx #LDAY+1
					stx Z.REG
					lda CLOCK ;READ YEAR FROM DAY
					clc ; AND MONTH LATCHES
					rol A
					rol A
					dec Z.REG
					and CLOCK
					sta CLKTEMP+8
*
					ldx #$09
GTIM040				lda CLKTEMP,X ;COPY CLOCK DATA
					sta PCLOCK,X ; TO PSEUDO CLOCK
					dex
					bpl GTIM040
*
GTIM050				lda #$19
					sta PCLOCK+9
*
					pla
					sta E.REG ;RESTORE ENVIRONMENT
					pla
					sta Z.REG ; AND ZERO PAGE
*
					ldy #$11
					ldx #$00
GTIM060				lda PCLOCK,X ;GET MOST SIGNIFICANT
					lsr A ; BCD DIGIT
					lsr A
					lsr A
					lsr A
					ora #$30 ;CONVERT TO ASCII
					sta (TIME),Y
					inx
					dey
					bmi GTIM080
GTIM070				lda PCLOCK,X ;GET LEAST SIGNIFICANT
					and #$0F ; BCD DIGIT
					ora #$30 ;CONVERT TO ASCII
					sta (TIME),Y
					dey
					cpy #$07
					bne GTIM060
					inx
					bne GTIM070
GTIM080 RTS
*PAGE
*REP 60
*
* SUBROUTINE DATETIME
*
* THIS SUBROUTINE READS THE CLOCK AND WRITES A DATE/TIME
*				staMP TO A FOUR BYTE BUFFER ON THE CALLER'S ZERO PAGE;
* THE DATA FORMAT IS SHOWN BELOW. ON ENTRY, X MUST POINT
* TO THE BUFFER. ON EXIT, ALL REGISTERS ARE CLOBBERED.
* IF AN ERROR OCCURS, CARRY IS SET AND THE BUFFER IS
* SET TO ZERO; OTHERWISE, CARRY IS CLEARED.

*
* BITS: 7 6 5 4 3 2 1 0
* X+0 M M M D D D D D
* X+1 Y Y Y Y Y Y Y M
* X+2 - MINUTE -
* X+3 - - HOUR - -
*
*REP 60
*
* TEMPORARY STORAGE
*
OFFSET DFB 0
ERRCNT DFB 0
CLKREGS DS 5
MIN .eq CLKREGS+0
HOUR .eq CLKREGS+1
DAY .eq CLKREGS+3
MON .eq CLKREGS+4
YEAR .eq CLKREGS+2
*
*
DATETIME .eq *
					stx OFFSET
					lda Z.REG
					pha;SAVE ZERO PAGE
					lda E.REG
					pha; AND ENVIRONMENT
					ora #BITON7+BITON6 ;SET 1 MHZ AND
					sta E.REG ; ENABLE I/O SPACE
*
					ldy #STATUS
					sty Z.REG
					lda CLOCK ;DOES CLOCK EXIST?
					bmi DT030 ; NO
*
					lda #8
					sta ERRCNT ;ALLOW 8 RETRYS
DT010				ldx #CMON+1
					php
					sei ;DISABLE INTERRUPTS
*
DT020				dex
					cpx #CMIN
					bcc DT050
					stx Z.REG
					lda CLOCK ;READ THE CLOCK
					sta CLKREGS-CMIN,X
					sty Z.REG
					lda CLOCK ;CHECK				staTUS
					beq DT020
*
					plp ;CLOCK READ ERROR
					dec ERRCNT
					bpl DT010
DT030				pla
					sta E.REG ;RESTORE ENVIRONMENT
					pla
					sta Z.REG ; AND ZERO PAGE
					ldx #CMON-CMIN
DT040				lda PCLOCK+CMIN,X
					sta CLKREGS,X
					dex
					bpl DT040
					ldx PCLOCK+8
					jmp DT060
*
DT050				plp ;READ YEAR FROM LATCHES
					lda #LDAY+1
					sta Z.REG
					lda CLOCK
					clc
					rol A
					rol A
					dec Z.REG
					and CLOCK
					tax
*
					pla
					sta E.REG ;RESTORE ENVIRONMENT
					pla
					sta Z.REG ; AND ZERO PAGE

*
DT060				txa
					jsr BCDBIN ;CONVERT YEAR TO BINARY
					sta YEAR
					lda MON ;CONVERT MONTH AND DAY
					jsr BCDBIN ; TO BINARY THEN
					asl A ; COMBINE WITH YEAR
					asl A ; TO FORM DATE				staMP
					asl A
					asl A
					asl A
					sta MON
					rol YEAR
					lda DAY
					jsr BCDBIN
					ora MON
					ldx OFFSET
					sta 0,X
					lda YEAR
					sta 1,X
					lda MIN ;CONVERT MINUTE
					jsr BCDBIN
					sta 2,X
					lda HOUR ;CONVERT HOUR
					jsr BCDBIN
					sta 3,X
					clc
					rts
*PAGE
*REP 60
*
* SUBROUTINE BCDBIN
*
* THIS SUBROUTINE CONVERTS A BYTE FROM BCD TO BINARY.
* THE BYTE IS PASSED AND RETURNED IN A. THERE IS NO
* ERROR CHECKING. Y IS DESTROYED AND X IS UNCHANGED.
*
*REP 60
*
BCDBIN				.eq *
					pha
					lsr A ;ISOLATE TENS DIGIT FOR
					lsr A ; INDEXING THE TABLE
					lsr A
					lsr A
					tay
					pla
					and #$0F ;GET UNITS
					clc
					adc TENS,Y ;ADD IN TENS
					rts
*
TENS DFB 00,10,20,30,40,50,60,70,80,90
*PAGE
*REP 60
*
* SOS CALL $64 -- JOYSTICK INPUT
* JOYSTICK(IN.J.MODE; OUT.J.VALUE)
*
*REP 60
*
*
AD.INPUT .eq $D0
AD.TEMP .eq $D1
*
PA.SW0 .eq $C061 ;PORT A, SWITCH 0
PA.SW1 .eq $C063 ;PORT A, SWITCH 1
PB.SW0 .eq $C062 ;PORT B, SWITCH 0
PB.SW1 .eq $C060 ;PORT B, SWITCH 1
*
AD.SEL0 .eq $C058 ;A/D SELECT CONTROLS
AD.SEL1 .eq $C05E
AD.SEL2 .eq $C05A
AD.CHRG .eq $C05C ;A/D RAMP CHARGE /
AD.STRT .eq $C05D ;				staRT TIMEOUT
AD.FLAG .eq $C066 ;A/D TIMEOUT FLAG
*
TCHARGE .eq 500 ;CHARGE TIME FOR A/D
TOFFSET .eq 360 ;OFFSET TIME TO A/D WINDOW
*
ANALOG .eq $F4A8 ;ROM ENTRY FOR ANALOG INPUT

ANLOG1 .eq $F4AB ; INTERRUPT REENTRY
D.T2 .eq $FFD8 ;TIMER
D.ACR .eq $FFDB ;AUXILIARY CONTROL REGISTER
D.IFR .eq $FFDD ;INTERRUPT FLAG REGISTER
*
ENSEL .eq $C0DC
ENSIO				.eq $C0DE
*
*
JOYSTICK			.eq *
					lda J.MODE ;VALIDATE J.MODE
					cmp #$08
					bcc JS010
					lda #>BADJMODE
JS.ERR				jsr SYSERR
*
JS010				jsr AD.SETUP ;SET UP RESOURCES
					bcs JS.ERR
					lda J.MODE ;READ PORT B OR PORT A?
					and #BITON2
					bne JS020
					lda PB.SW0 ;PORT B
					ldx PB.SW1
					ldy #$01
					bne JS030
JS020				lda PA.SW0 ;PORT A
					ldx PA.SW1
					ldy #$03
JS030				sty AD.INPUT ;SAVE INPUT SELECT
					and #BITON7
					beq JS040
					lda #$FF
JS040				ldy #$00
					sta (J.VALUE),Y ;RETURN SWITCH 0
					txa
					and #BITON7
					beq JS050
					lda #$FF
JS050				iny
					sta (J.VALUE),Y ;RETURN SWITCH 1
*
					lsr J.MODE
					bcc JS060
					lda AD.INPUT
					jsr AD.READ ;READ A/D
					ldy #$02
					sta (J.VALUE),Y ;RETURN X AXIS
JS060				inc AD.INPUT
					lsr J.MODE
					bcc JS070
					lda AD.INPUT
					jsr AD.READ ;READ A/D
					ldy #$03
					sta (J.VALUE),Y ;RETURN Y AXIS
*
JS070				jsr AD.CLNUP ;CLEAN UP
					rts; AND EXIT
*PAGE
*REP 60
*
* SUBROUTINE AD.SETUP
* THIS SUBROUTINE SETS UP THE ENVIRONMENT AND RESOURCES
* FOR READING THE JOYSTICKS. IF AN ERROR OCCURS, CARRY
* IS SET AND AN ERROR NUMBER IS RETURNED IN A.
* OTHERWISE, CARRY IS CLEARED.
*
*REP 60
AD.SETUP			.eq *
					lda #JOYSIRSIZ
					ldx #>JOYSIRTBL
					ldy #<JOYSIRTBL
					jsr ALLOCSIR ;ALLOCATE RESOURCES
					bcc ADS010
					lda #>XNORESRC
					rts
ADS010				lda E.REG
					and #$7F ;SET 2 MHZ,
					ora #$43 ; ENABLE ROM, & I/O SPACE
					sta E.REG
					php
					sei

					lda D.ACR
					and #BITOFF5 ;SET UP TIMER
					sta D.ACR
					plp
					bit ENSEL ;DISABLE ENSEL
					bit ENSIO ;SET ENSIO FOR INPUT
					rts
*
JOYSIRTBL			.eq *
DFB $0C,0,0,0,0 ;ENSIO
DFB $0D,0,0,0,0 ;ENSEL
DFB $0E,0,0,0,0 ;6522 D.T2
JOYSIRSIZ			.eq *-JOYSIRTBL
*REP 60
*
* SUBROUTINE AD.CLNUP
* THIS SUBROUTINE RESTORES THE ENVIRONMENT AND RELEASES
* THE RESOURCES AFTER READING THE JOYSTICKS.
*
*REP 60
AD.CLNUP			.eq *
					lda E.REG
					and #$3C ;RESTORE RAM AT $C000 & $F000
					sta E.REG
					lda #JOYSIRSIZ
					ldx #>JOYSIRTBL
					ldy #<JOYSIRTBL
					jsr DEALCSIR ;DEALLOCATE RESOURCES
					rts
*PAGE
*REP 60
*
* SUBROUTINE AD.READ
* THIS SUBROUTINE READS A SPECIFIED A/D INPUT AND RETURNS
* AN 8 BIT RESULT. IT ASSUMES THAT THE A/D RESOURCES HAVE
* BEEN ALLOCATED, THE I/O SPACE AND $F000 ROM HAVE BEEN
* SELECTED, AND THE SYSTEM IS RUNNING IN 2 MHZ MODE.
*
* PARAMETERS:
* A: A/D INPUT PORT (0-7)
*
* RETURN VALUE:
* A: RESULT (0 - 255)
* X, Y: UNDEFINED
*
*REP 60
*
AD.READ				.eq *
					lsr A ;SELECT THE APPROPRIATE
					bit AD.SEL0 ; A/D INPUT
					bcc ADR010
					bit AD.SEL0+1
ADR010				lsr A
					bit AD.SEL1
					bcc ADR020
					bit AD.SEL1+1
ADR020				lsr A
					bit AD.SEL2
					bcc ADR030
					bit AD.SEL2+1
ADR030				php
*
ADR040				cli
					bit AD.CHRG ;CHARGE A/D CAPACITOR
					lda #>TCHARGE
					sta D.T2
					lda #<TCHARGE
					sta D.T2+1
					lda #BITON5
ADR050				bit  D.IFR
					beq ADR050
*
					sei
					clc
					lda #>TOFFSET
					sta D.T2 ;SET UP TIMER
					lda #<TOFFSET
					bit AD.STRT ;START A/D TIMEOUT
					jsr ANALOG ;MEASURE CONVERSION TIME
					bcc ADR070
*

ADR060				cli ;PROCESS AN INTERRUPT
					sei
					bit AD.FLAG ;STILL TIMING?
					bpl ADR040 ; NO --				staRT OVER
					jsr ANLOG1 ; YES -- CONTINUE
					bcs ADR060
*
ADR070				plp
					eor #$FF ;NORMALIZE RESULT
					bmi ADR080 ;RESULT < 0
					sta AD.TEMP
					tya
					eor #$FF
					lsr AD.TEMP
					ror A
					lsr AD.TEMP
					ror A
					lsr AD.TEMP
					bne ADR090 ;RESULT > 255
					ror A
					adc #0
					rts
ADR080				lda #0
					rts
ADR090				lda #$FF
					rts
*PAGE
*REP 60
*
* SYSTEM COLD START
*
* THIS ROUTINE IS CALLED TO TELL THE USER TO REBOOT THE
* SYSTEM. IT CLEARS THE SCREEN, DISPLAYS A MESSAGE,
* OVERWRITES BANKED MEMORY, AND HANGS UNTIL THE USER
* PERFORMS A HARD RESET.
*
*REP 60
*
*
COLDSTRT .eq *
					sei ;SHUT DOWN INTERRUPTS
					lda #$40 ; AND IGNORE NMI
					sta $FFCA
					lda #$67
					sta E.REG ;DISABLE RESET
					lda #$00
					sta Z.REG ;USE PAGE ZERO
*
					ldx SYSBANK
					lda #$BF
					ldy #$00
					sty MEMORY
CS010				sta MEMORY+1
					stx B.REG
					lda #$A0
CS020				sta (MEMORY),Y ;SET MEMORY TO BLANKS
					dey
					bne CS020
					dec MEMORY+1
					bne CS020
					dex
					bpl CS010
*
					ldy #6
CS030				sta $C050,Y ;SELECT 40 COLUMN
					dey ; BLACK & WHITE TEXT
					bpl CS030
*
					ldy #BOOTLEN
CS040				lda BOOTMSG-1,Y ;PRINT BOOT MESSAGE
					sta BOOTADR-1,Y
					dey
					bne CS040
*
					lda #$77
					sta E.REG ;ENABLE RESET
					jmp * ;HANG UNTIL RESET
*PAGE
*MSB ON
BOOTMSG				asc "INSERT SYSTEM DISKETTE & REBOOT"
BOOTLEN				.eq *-BOOTMSG

BOOTADR				.eq 40-BOOTLEN/2+$628
*MSB OFF
*LST ON
ZZEND				.eq	*
ZZLEN				.eq ZZEND-ZZORG
IFNE ZZLEN-LENUMGR
FAIL 2,"SOSORG FILE IS INCORRECT FOR UMBR"
FIN

*************************************************************************
* END OF APPLE /// SOS 1.3 SOURCE CODE FILE: UMGR.SRC
*************************************************************************



================================================================================================
FILE: "SOS.VOLUME.TEXT"
================================================================================================
*************************************************************************
* APPLE /// SOS 1.3 SOURCE CODE FILE: VOLUME
*************************************************************************
* ASSEMBLER: APPLE ][ 6502 ASSEMBLER from APPLE COMPUTER TOOLKIT

*PAGE
*REP 40
* NAME : VOLUME
* FUNCTION: RETURN VOLUME INFO
* INPUT : DEVICE NAME
* OUTPUT : THE INFO
* VOLATILE: ALL REGS
*REP 40
*
VOLUME				.eq *
					lda C.DNAMP ; TRANSFER DEVICE NAME
					sta DVNAMP ; NAME FOR DMGR
					lda C.DNAMP+1
					sta DVNAMP+1
					lda SISTER+C.DNAMP+1 ; AND XTND
					sta SISTER+DVNAMP+1
					jsr GETDNUM ; GET DEVNUM
					bcc VOL7 ; =>SOME KINDA ERROR
					rts; RETURN ERROR
VOL7				bmi VOL2 ; =>IT'S GOOD...
					lda #NOTBLKDEV ; NOT BLOCKED
					jmp VOLERR ; =>RETURN THE ERROR
*
* UNCONDITIONALLY READ ROOT DIRECTORY:
*
VOL2				.eq *
					lda SCRTCH+1
					sta DEVNUM ; SETUP DEV NUMBER
					lda #2 ; BLKNUM=2
					ldx #0
					jsr GETROT0 ; GET IT PLEASE
					lda #VNFERR ; ERROR CODE
					bcc VOL8 ; BRANCH IF NO ERROR ON READ
					rts; =>ERROR, PASS IT ON.
*
VOL8				lda #>VCB ; SET VCBPTR TO THE
					sta VCBPTR ; FIRST OF THEM
					lda #<VCB
					sta VCBPTR+1
*
* IS THIS VOLUME SOS OR OTHER?
*
					jsr TSTSOS ; WHICH KIND?
					bcc VLOGGED ; =>IT'S SOS
					jmp VNOTSOS ; =>NOT SOS
*
* IS THIS SOS VOLUME LOGGED IN?
*
VLOGGED				.eq *
					jsr CMPVCB ; DOES VOLNAME MATCH?
					bcc VFOUND ; =>YES, WE KNOW ABOUT IT.
					jsr VNXTVCB ; BUMP TO NEXT
					bcc VLOGGED ; =>TRY 'EM ALL...
					bcs VNEW ; =>NOT FOUND, IT'S NEW (BRANCH ALWAYS)
*
*
* IT'S BEEN LOGGED IN BEFORE:
* IS IT SWAPPED IN OR OUT?
*
VFOUND 				.eq *
					ldy #VCBSWAP ; INDEX TO IT
					lda (VCBPTR),Y ; SWAPPED?
					bpl VFOUND1 ; =>IN. RETURN THE INFO
*
* SWAPPED OUT. BEFORE WE SWAP IT
* IN, MAKE SURE IT BELONGS ON
* THIS DEVICE!
*
					ldy #VCBDEV ; INDEX TO IT
					lda (VCBPTR),Y ; GET ITS DEVICE
					cmp DEVNUM ; CORRECT DEVICE?

					beq VSWAPIN ; =>YES
					lda #DUPVOL ; IF FOR ANOTHER DEV,
					jmp VOLERR ; THEN IT'S AN ERROR!
*
* NOW SWAP-IN THIS VOLUME:
*
VSWAPIN				.eq *
					jsr SWAPIN ; SWAP IT IN
					jmp VINFO ; AND RETURN THE INFO
*
VFOUND1				ldy #VCBDEV
					lda (VCBPTR),Y ; SAME DEVICES?
					cmp DEVNUM
					beq VINFO ; YES; RETURN THE INFORMATION
					ldy #VCBSTAT
					lda (VCBPTR),Y ; OPEN FILES?
					bpl VFOUND2 ; BRANCH IF NOT
					lda #DUPVOL
					bne VOLERR ; ELSE REPORT DUPLICATE VOLUME ERROR (BRANCH ALWAYS)
VFOUND2				ldy #VCBNML ; MOVE THE LOGIN TO THIS NEW DEVICE
					lda #0 ; BY UNLOGGING THE OLD
					sta (VCBPTR),Y ; AND LOGGING IN THE NEW (DROP INTO VNEW)
*REP 40
*
* IT'S A BRAND NEW VOLUME.
* GUESS WE'LL HAVE TO LOG IT IN:
*
VNEW				.eq *
					lda DEVNUM ; PASS A REG TO SWAPOUT
					jsr SWAPOUT ; SWAP ANY ACTIVE VOL ON THIS DEVICE
					bcc VNEW1 ; BRANCH ON NO ERROR
					lda #XIOERROR
					rts
VNEW1				lda #>VCB ; FIND AN EMPTY VCB
					sta VCBPTR
					lda #<VCB
					sta VCBPTR+1
VFREE				ldy #VCBNML
					lda (VCBPTR),Y ; EMPTY VCB?
					beq VLOGIN ; ITS FREE, USE IT
					ldy #VCBDEV
					lda (VCBPTR),Y ; OR ONE WITH SAME DEVICE
					cmp DEVNUM
					bne VFREEX ; BRANCH IF NO DEVICE MATCH
					ldy #VCBSTAT
					lda (VCBPTR),Y ; AND NO OPEN FILES
					bpl VLOGIN ; BRANCH IF OK TO REUSE THIS VCB
					lda DEVNUM ; THEN WE MUST SWAP OUT THIS VOLUME
					jsr SWAPOUT
					bcc VFREEX ; SWAPOUT PROCEEDED OK
					lda #XIOERROR ; ELSE REPORT ERROR
					rts
VFREEX				jsr VNXTVCB ; TRY NEXT
					bcc VFREE ; MORE TO COME
* RAN OUT OF MT'S ... FIND W/O FILES
VNFIL				ldy #VCBSTAT
					lda (VCBPTR),Y
					bpl VLOGIN
					jsr VNXTVCB
					bcc VNFIL
* ALL OPEN ... REPORT VCBFULL
					lda #FCBFULL
					bne VOLERR
VLOGIN.eq *
					jsr LOGVCB ; AND LOGIN THIS ONE
*REP 40
*
* RETURN ALL THE NICE INFO:
*
VINFO				.eq *
					lda #0
					ldy #VCBTFRE ; FETCH VOLUME FREE BLOCK COUNT
					sta (VCBPTR),Y ; FORCE RESCAN OF ALL
					iny ; BITMAPS
					sta (VCBPTR),Y ; TO MAKE SURE VCB INFO CURRENT
					sta REQL ; FREE BLOCKS
					sta REQH
					jsr TSFRBLK
*
					ldx VCBPTR ; GET VCB INDEX
					ldy #0

VINFO1				.eq *
					lda VCB+VCBTBLK,X ; MOVE TOTAL
					sta (C.OUTBLK),Y ; BLOCKS AVAIL
					inx
					iny
					cpy #4 ; AND FREE ONES TOO
					bne VINFO1
*
					ldy #0 ; NOW DO VOLNAME
					lda (VCBPTR),Y
					tay
VINFO2				.eq *
					lda (VCBPTR),Y
					sta (C.OUTVOL),Y
					dey
					bpl VINFO2
					clc
					bcc VOLRET ; =>DONE
*
VOLERR				.eq *
					clc
VOLRET				.eq *
					rts
*PAGE
*REP 40
* THIS ISN'T A SOS VOLUME. MARK
* THE ACTIVE VOL THIS DEVICE
* SO THAT IT GETS CHECKED LATER:
*
VNOTSOS				.eq *
					ldy #VCBDEV ; IS VCB FOR THIS
					lda (VCBPTR),Y ; DEVICE?
					cmp DEVNUM
					bne VNS2
					ldy #VCBSTAT ; INDEX TO IT
					lda (VCBPTR),Y ; GET				staTUS
					bpl VNS2 ; =>NOT ACTIVE.
					ora #DSWITCH ; SET 'SWITCHEROO'
					sta (VCBPTR),Y ; PUT IT BACK
*
VNS2				.eq	*
					jsr VNXTVCB ; GET NEXT VCB
					bcc VNOTSOS ; =>TRY 'EM ALL.
*
					lda #NOTSOS ; GIVE THE ERROR
					bne VOLERR ; (BRANCH ALWAYS)
*SKP 5
* NAME : VNXTVCB
* FUNCTION: BUMP VCBPTR TO NEXT VCB
* INPUT : NOTHING
* OUTPUT : VCBPTR UPDATED
* : 'BCC' IF MORE TO GO
* : 'BCS' IF DONE
* VOLATILE: AC
*
VNXTVCB				.eq *
					lda VCBPTR
					clc
					adc #VCBSIZE ; BUMP IT
					sta VCBPTR
					rts; CARRY SET IF END OF PAGE

CHN CREATE,4,1

*************************************************************************
* END OF APPLE /// SOS 1.3 SOURCE CODE FILE: VOLUME
*************************************************************************
