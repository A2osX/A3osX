NEW
  AUTO 3,1
*--------------------------------------
*************************************************************************  
* APPLE /// SOS 1.3 SOURCE CODE FILE: CREATE  
*************************************************************************  
* ASSEMBLER: APPLE ][ 6502 ASSEMBLER from APPLE COMPUTER TOOLKIT  
				 
PAGE			  
CREATE			 EQU *  
INC				 CFLAG ; SAY WE ARE IN CREATE (DIR EXTEND)  
JSR				 LOOKFILE ; CHECK FOR DUPLICATE / GET FREE ENTRY  
BCS				 TSTFNF ; ERROR CODE IN ACC MAY BE 'FILE NOT FOUND'  
LDA				 #DUPERR ; TELL EM A FILE OF THAT NAME ALREADY EXISTS  
CRERR1			 SEC ; INDICATE ERROR ENCOUNTERED  
RTS				 ; RETURN ERROR IN ACC.  
*  
TSTFNF			 CMP #FNFERR ; 'FILE NOT FOUND' IS WHAT WE WANT  
BNE				 CRERR1 ; PASS BACK OTHER ERROR.  
LDA				 NOFREE ; TEST FOR DIRECTORY SPACE  
BNE				 CREAT1 ; BRANCH IF VALID FREE ENTRY WAS FOUND.  
LDA				 #DIRFULL ; RETURN DIRECTORY FULL ERROR  
SEC				  
RTS				  
*  
CREAT1			 LDY #$9 ; SET UP DEFAULT PARAMETERS FOR CREATE  
LDA				 #0 ; IN THE SPACE DIRECTLY FOLLOWING THE  
ZERCALL			 STA C.FILID,Y ; CALL SPECIFCATION AND THEN  
DEY				 ; CHECK FOR ADDITIONAL PARAMETERS FROM  
BPL				 ZERCALL ; USER'S CALL SPEC VIA 'C.CLIST'  
LDA				 #SEEDTYP ; DEFAULT TYPE IS 'SEED' TREE INDEX  
STA				 C.STOR  
LDY				 C.XLEN ; GET THE LENGTH OF THE CALL XTENSION LIST  
BEQ				 CRENAM ; IF ZERO THEN USE DEFAULTS  
DEY				 ; (SINCE THE POINTER IS AT BYTE 0)  
CPY				 #$9 ; MAKE SURE WE DON'T HAVE TOO MANY PARAMETERS  
BCC				 MOVPARM ; MOVE 'EM IF REASONABLE COUNT.  
LDA				 #BADLSTCNT ; INVALID LIST COUNT  
RTS				 ; RETURN ERROR.  
*  
MOVPARM			 LDA (C.XLIST),Y ; MOVE IN THE USER SPECIFIED  
STA				 C.FILID,Y ; PARAMETERS. VALIDITY IS CHECKED  
DEY				 ; AT VARIOUS POINTS FURTHER ALONG IN  
BPL				 MOVPARM ; THIS PROCESS.  
CRENAM			 LDY #0 ; MOVE LOCAL FILE NAME TO ENTRY BUFFER.  
LDA				 (PATHNML),Y ; GET LENGTH OF LOCAL NAME  
TAY				  
CRENAM1			 LDA (PATHNML),Y  
STA				 DFIL+D.STOR,Y  
DEY				 ; (MOVE ALL, INCLUDING LENGTH BYTE.)  
BPL				 CRENAM1  
LDA				 C.FILID ; MOVE FILE AND AUX ID.  
STA				 DFIL+D.FILID  
LDA				 C.AUXID  
STA				 DFIL+D.AUXID  
LDA				 C.AUXID+1  
STA				 DFIL+D.AUXID+1  
LDA				 #READEN+WRITEN+RENAMEN+DSTROYEN  
STA				 DFIL+D.ATTR  
LDA				 D.HEAD ; SAVE FILE'S HEADER ADDRESS TOO.  
STA				 DFIL+D.DHDR  
LDA				 D.HEAD+1  
STA				 DFIL+D.DHDR+1  
JSR				 TWRPROT1 ; CAN WE WRITE TO THIS DISKETTE?  
BCS				 CRERR1  
LDA				 C.STOR ; NOW TEST STORAGE TYPE FOR TREE TYPE FILES  
CMP				 #4 ; NOTE: THIS IS HARD CODED SINCE ALL TREES ARE LESS THAN 4 ***********  
BCC				 SEED ; BRANCH IF SOME TYPE OF TREE (SEED, SAPLING...)  
JMP				 NOTREE ; GO TEST FOR SOME OTHER TYPE (SUCH AS DIRECTORY).  
PAGE			  
*  
SEED			 LDX #SEEDTYP ; START OUT ASSUMING A SEED FILE  
LDA				 C.EOFHH ; TEST FOR OUT OF RANGE PREALLOCATION  
BEQ				 SEED1 ; (HOPEFULLY BRANCH ALWAYS)  
OVFLOW			 LDA #OVRERR ; REPORT UNABLE TO SATISFY REQUEST.  
SEC				 ; INDICATE ERROR  
RTS				  
*  
SEED1			 LDA C.EOFHL ; CALCULATE THE NUMBER OF  
STA				 DFIL+D.EOF+2 ; BLOCKS NEEDED FOR PRE-ALLOCATION  
LSR				 A   
TAY				  ; Y HOLDS THE NUMBER OF INDEX BLOCKS NEEDED  
STA				 DATBLKH   
LDA				 C.EOFLH ; (CARRY UNDISTURBED FROM LAST SHIFT)  
STA				 DFIL+D.EOF+1   
ROR				 A ; WE NOW HAVE THE LOW ORDER COUNT OF NEEDED DATA BLOCKS  
STA				 DATBLKL   
LDA				 C.EOFLL   
STA				 DFIL+D.EOF ; (CARRY IN TACT FROM LOW COUNT)  
BNE				 INCDATA ; BUMP THE COUNT ON DATA BLOCKS IF REQUEST  
BCC				 TSTSAP ; IS NOT A MULTIPLE OF 512.  
INCDATA			 INC DATBLKL   
BNE				 TSTSAP   
INY				  ; MUST INCREASE NUMBER OF INDEXES ALSO.  
INC				 DATBLKH   
TSTSAP			 TYA  ; IF NON ZERO, THEN IT'S AT LEAST A SAPLING.  
BNE				 SAPLING   
LDA				 DATBLKL ; TO QUALIFY AS AN HONEST SEED,  
BNE				 TSTSEED ; THEN ONE OR LESS DATA BLOCKS REQUESTED  
INC				 DATBLKL ; (MUST BE AT LEAST ONE BLOCK ALLOCATED  
BNE				 CREALC ; TYPE IS SEED. BRANCH ALWAYS  
TSTSEED			 CMP #1 ; IF GREATER THAN ONE, IT'S NOT A SEED.  
BEQ				 CREALC ; IT IS A SEED. CONTINUE CREATION  
INX				  ; THE TYPE IS SAPLING.  
INY				  ; ONE INDEX BLOCK IS NEEDED.  
BNE				 CREALC ; BRANCH ALWAYS  
PAGE			    
*     
SAPLING			 INX  ; TYPE IS AT LEAST SAPLING.  
CMP				 #1 ; NO MORE THAN ONE INDEX BLOCK FOR A SAPLING  
BNE				 TREE   
LDA				 DATBLKL ; MUST BE SURE THIS IS REAL MAX SAPLING (128K FILE)  
BEQ				 CREALC ; BRANCH IF IT IS.  
TREE			 INY  ; ACCOUNT FOR ADDITIONAL 2ND LEVEL INDEX  
*     
INX				  ; TYPE IS TREE (2 LEVEL INDEX)  
INY				  ; ADD AN EXTRA INDEX BLOCK FOR TOP INDEX  
CREALC			 STY INDXBLK ; STORE INDEX BLOCK COUNT  
TXA				  ; PUT STORAGE TYPE IN DIRECTORY ENTRY  
ASL				 A   
ASL				 A   
ASL				 A   
ASL				 A   
ORA				 DFIL+D.STOR   
STA				 DFIL+D.STOR   
STX				 LEVELS ; SAVE NUMBER OF INDEX LEVELS FOR PREALLOCATION.  
TYA				  ; NOW FIGURE THE TOTAL NUMBER OF  
CLC				  ; BLOCKS NEEDED (DATA + INDEX BLOCKS)  
ADC				 DATBLKL   
STA				 DFIL+D.USAGE ; (MIGHT AS WELL RECORD IT IN DIR  
STA				 REQL ; WHILE WE'RE AT IT.)  
LDA				 DATBLKH   
ADC				 #0 ; UPDATE HI BYTE TOO  
STA				 DFIL+D.USAGE+1   
STA				 REQH   
LDX				 D.DEV ; PASS ALONG THE DEVICE WE'RE TALKIN ABOUT.  
JSR				 TSFRBLK ; 'TEST FREE BLOCKS' FINDS OUT IF ENOUGH FREE SPACE EXISTS  
BCS				 OVFLOW ; BRANCH IF NOT ENOUGH SPACE.  
JSR				 ALC1BLK ; GO ALLOCATE FIRST BLOCK  
BCS				 CRERR   
STA				 DFIL+D.FRST ; (RETURNS ACC=LOW Y=HIGH)  
STA				 IDXADRL ; SAVE AS ADDRESS FOR INCORE INDEX ALSO.  
STY				 DFIL+D.FRST+1   
STY				 IDXADRH   
JSR				 ZERGBUF ; GO CLEAN OUT GBUF  
JSR				 GTTINDX ; GET TEMPORARY SPACE FOR AN INDEX BLOCK  
JSR				 ZTMPIDX ; AND ZERO IT OUT.  
LDX				 LEVELS   
DEX				  ; TEST FOR NUMBER OF LEVELS NEEDED.  
BEQ				 ENDCRE ; BRANCH IF SEED FILE.  
DEX				  ; IS IT A SAPLING PRE-ALLOCATION.  
BEQ				 SAPFILE   
LDY				 INDXBLK ; LOAD NUMBER OF INDEX BLOCKS NEEDED  
DEY				  ; REMOVE THE ONE JUST ALLOCATED.  
STY				 REQL   
STY				 INDXBLK   
JSR				 ALCIDXS ; GO ALLOCATE INDEXES FOR LOWER INDEX BLOCKS.  
BCS				 CRERR   
JSR				 WRTDFRST ; GO WRITE TREE TOP INDEX BLOCK.  
BCS				 CRERR ; BRANCH IF UNABLE TO DO THIS.  
				LDA #0 ; INIT INDEX POINTER  
				STA TREPTR   
				PAGE    
FILLTREE		 LDY TREPTR   
				LDA (TINDX),Y ; GET ADDRESS OF LOWER BLOCK  
				STA IDXADRL   
				INC TINDX+1 ; BUMP TO PAGE 2 TO GET HI ADDRESS.  
				LDA (TINDX),Y ; GET HIGH ADDRESS.  
				STA IDXADRH   
				DEC TINDX+1 ; CLEAN UP AFTER SELF...  
				DEC INDXBLK ; IS THIS THE LAST BLOCK ALLOCATED?  
				BEQ LSTSAP ; YES, ALLOCATE PARTIAL FILLED INDEX BLOCK  
				LDA #0 ; ALLOCATE ALL 256 INDEXES  
				STA REQL   
				JSR SAPINDX ; AND WRITE ZEROED DATA BLOCKS.  
				BCS CRERR ; STOP IF ERROR ENCOUNTERED.  
				JSR WRTINDX ; WRITE INDEX BLOCK  
				BCS CRERR ; HOPEFULLY NEVER TAKEN.  
				INC TREPTR   
				JSR RDFRST ; READ IN TOP INDEX AGAIN.  
				BCC FILLTREE ; BRANCH IF NO ERROR.  
CRERR			 SEC  ; JUST IN CASE IT WAS CLEAR.  
				RTS  ; RETURN ERROR.  
*     
*     
SAPFILE			 EQU *   
LSTSAP			 LDA DATBLKL ; GET NUMBER OF DATA BLOCKS (LOW BYTE) REQUESTED.  
				STA REQL   
				JSR SAPINDX ; GO ALLOCATE DATA BLOCKS AND WRITE EM.  
				BCS CRERR   
ENDCRE			 JSR WRTINDX ; GO WRITE INDEX BLOCK. (FOR SEED THIS IS DATA.)  
				BCS CRERR   
				LDX #3 ; MOVE CREATION TIME FOR THIS ENTRY  
TRETIME			 LDA DATELO,X   
				STA DFIL+D.CREDT,X   
				DEX    
				BPL TRETIME   
ENDCRE0			 INC H.FCNT ; ADD ONE TO TOTAL NUMBER OF FILES IN SPECIFIED DIRECTORY.  
				BNE ENDCRE1   
				INC H.FCNT+1   
				LDX #3 ; ENSURE MOD  
ENDCRX			 LDA DATELO,X ; DATE/TIME  
				STA DFIL+D.MODDT,X ; IS  
				DEX  ; INITIALIZED  
				BPL ENDCRX   
ENDCRE1			 LDX D.DEV ; UPDATE APPROPRIATE BIT MAP  
				JSR UPBMAP   
				BCS CRERR2 ; BRANCH ON BITMAP UPDATE ERR  
				JSR DREVISE ; UPDATE DIRECTORY LAST  
				RTS  ; RETURN ERRORS OR OK RESULT  
*     
				PAGE    
SAPINDX			 JSR ZTMPIDX ; ZERO OUT ANY STUFF LEFT OVER.  
				LDA REQL ; PRESERVE REQUEST COUNT  
				STA TLINK   
				JSR ALCIDXS ; GO ALLOCATE REQUESTED NUMBER OF BLOCKS.  
				BCS CRERR   
				LDY #0 ; THEN WRITE ZEROS TO DATA BLOCKS.  
				STY SAPTR ; USE AS POINTER TO INDEX BLOCK  
				LDA (TINDX),Y ; GET DATA BLOCK ADDRESS (LOW BYTE).  
				STA BLOKNML   
				INC TINDX+1   
				LDA (TINDX),Y ; GET HIGH ADRRESS OF PRE-ALLOCATED DATA BLOCK.  
				STA BLOKNMH   
				DEC TINDX+1 ; (RESET BUFFER ADDRESS)  
				JSR WRTGBUF ; WRITE DATA BLOCK  
				BCS CRERR   
				LDA TLINK ; GET NUMBER REQUESTED AGAIN  
				STA REQL   
DATINIT			 LDY SAPTR ; GET POINTER TO INDEX BLOCK AGAIN.  
				INY  ; ANTICIPATE DOIN' THE NEXT DATA BLOCK  
				DEC REQL ; DO WE INDEED HAVE ANOTHER BLOCK TO WRITE.  
				BEQ DATDONE ; NO, ALL DONE (CARRY CLEAR).  
				STY SAPTR ; USE AS POINTER TO INDEX BLOCK  
				LDA (TINDX),Y ; GET DATA BLOCK ADDRESS (LOW BYTE).  
				STA BLOKNML   
				INC TINDX+1 ; BUMP HI ADDR OF INDEX BUFFER TO ACCESS HIGH ADDR.  
				TAX  ; WAS LOW ADDRESS A ZERO?  
				BNE DATIT1 ; IF NOT, NO NEED TO CHECK VALIDITH OF HI BYTE  
				CMP (TINDX),Y   
				BNE DATIT1 ; BOTH BYTES CAN'T BE ZERO.  
				LDA #ALCERR   
				JSR SYSDEATH   
DATIT1			 LDA (TINDX),Y ; GET HIGH ADRRESS OF PRE-ALLOCATED DATA BLOCK.  
				STA BLOKNMH   
				DEC TINDX+1 ; (RESET BUFFER ADDRESS)  
				LDA #GBUF/256   
				STA DBUFPH ; RESET TO ADDR TO GBUF JUST TO BE SURE.  
				JSR REPEATIO ; WRITE DATA BLOCK  
				BCC DATINIT   
DATDONE			 RTS  ; RETURN STATUS (CARRY SET IF ERROR)  
*     
REPEATIO		 EQU *   
				LDA #RPTCMD   
				STA DHPCMD   
				JMP RPEATIO1   
*     
ZERGBUF			 LDY #0 ; ZERO OUT THE GENERAL PURPOSE BUFFER  
				TYA    
ZGBUF			 STA GBUF,Y ; WIPE OUT BOTH PAGES  
				STA GBUF+$100,Y ; WITH SAME LOOP.  
				INY    
				BNE ZGBUF   
				RTS    
*     
*     
ZTMPIDX			 LDY #0 ; ZERO OUT TEMPORARY INDEX BLOCK  
				TYA    
ZINDX1			 STA (TINDX),Y ; THIS HAS TO BE DONE A  
				INY  ; TIME SINCE IT'S INDIRECT.  
				BNE ZINDX1   
				INC TINDX+1   
ZINDX2			 STA (TINDX),Y   
				INY    
				BNE ZINDX2   
				DEC TINDX+1 ; RESTORE PROPER ADDRESS  
CRERR2			 RTS    
				PAGE    
NOTREE			 CMP #DIRTYP ; IS A DIRECTORY TO BE CREATED?  
				BEQ ISDIR ; YES, DO SO...  
				JMP NOTDIR ; NO, TRY NEXT TYPE.  
*     
ISDIR			 LDA C.EOFHH ; CAN'T CREATE A DIRECTORY LARGER THAN  
				ORA C.EOFHL ; 127 BLOCKS (THAT'S HUGE!)  
				BEQ ISDIR1 ; BRANCH IF WITHIN LIMITS, OTHEWISE  
DIROVR			 LDA #OVRERR ; REQUESTED DIRECTORY SIZE CAN'T BE  
				SEC  ; CREATED. SET CARRY TO INDICATE ERROR.  
				RTS    
*     
ISDIR1			 LDA C.EOFLH ; CALCULATE HOW MANY BLOCKS WILL  
				LSR A ; BE NEEDED FOR THIS NEW DIRECTORY.  
				TAY  ; (SAVE INITIAL COUNT IN Y)  
				LDA C.EOFLL ; IF REQUESTED EOF IS NOT AN EVEN BLOCK  
				BNE DADD1 ; SIZE, THEN ROUND UP.  
				BCC TSDIRSZ ; BRANCH IF ROUNING UNNECESSARY.  
DADD1			 INY  ; ADD ONE TO BLOCK COUNT.  
TSDIRSZ			 TYA  ; TEST TO BE SURE SIZE IS GREATER THAN ZERO  
				BEQ DADD1 ; IF ZERO THEN SIZE=1  
				STA DFIL+D.USAGE ; SAVE NUMBER OF BLOCKS TO BE USED.  
				STA REQL   
				ASL A ; NOW SAVE ADJUSTED END OF FILE  
				STA DFIL+D.EOF+1   
				LDA #0   
				STA DFIL+D.EOF   
				STA DFIL+D.EOF+2   
				STA REQH ; REQUESTED NUMBER OF BLOCKS NEVER EXCEEDS 128.  
				JSR TSFRBLK ; TEST TO BE SURE ENOUGH DISK SPACE IS FREE.  
				BCS DIROVR ; BRANCH IF REQUEST TOO LARGE.  
				JSR ZERGBUF ; CLEAR CRAP FROM GBUF.  
				JSR ALC1BLK ; GET ADDRESS OF FIRST (HEADER) BLOCK.  
				BCS CRERR2   
				STA DFIL+D.FRST   
				STA TLINK   
				STY DFIL+D.FRST+1   
				STY TLINK+1 ; (TLINK IS FOR REVERSE LINKAGE.)  
				LDA SOSTMPL ; STORE SOS STAMP IN NEW DIRECTORY  
				STA GBUF   
				LDA SOSTMPH   
				STA GBUF+1   
				LDY #4 ; MOVE OTHER VARIOUS THINGS  
				BNE DRSTUF1 ; BRANCH ALWAYS  
DRSTUF			 LDA D.ENTBLK,Y ; MOVE OWNING ENTRY'S  
				STA GBUF+HRBLK+4,Y ; BLOCK ADDRESSES AND NUMBER TO NEW HEADER.  
DRSTUF1			 LDA SOSVER,Y ; MOVE VERSION, COMPATABLITY,  
				STA GBUF+HVER+4,Y ; ATTRIBUTES, AND ENTRY SIZE  
				DEY    
				BPL DRSTUF   
				LDA H.ENTLN ; OVER WRITE LAST BYTE MOVED IN ABOVE LOOP WITH  
				STA GBUF+HRELN+4 ; THE PARENT DIRECTORY ENTRY LENGTH.  
				LDA DFIL+D.STOR ; SET HEADER TYPE AND NAME  
				TAY    
				ORA #HEDTYP*16   
				STA GBUF+HNLEN+4   
				TYA  ; (AND WHILE WE'RE AT IT SET DIRECTORY TYPE)  
				ORA #DIRTYP*16   
				STA DFIL+D.STOR   
*     
MVHNAME			 LDA DFIL+D.STOR,Y   
				STA GBUF+HNLEN+4,Y ; MOVE HEADER NAME  
				DEY    
				BNE MVHNAME   
				LDX #3 ; GET CURRENT DATE.  
CRETIME			 LDA DATELO,X   
				STA GBUF+HCRDT+4,X ; SAVE AS HEADER CREATION TIME  
				STA DFIL+D.CREDT,X ; AND DATE OF FILE CREATE.  
				DEX    
				BPL CRETIME   
				LDA #$76   
				STA GBUF+HPENAB+4 ; DUMMY PASSWORD  
				DEC REQL ; TEST FOR ONE BLOCK DIRECTORY  
				BEQ DIRCREND ; IT IS, FINISH UP.  
				JSR DIRWRT ; GO WRITE FIRST DIRECTORY BLOCK AND ALLOCATE NEXT  
				BCS DERROR ; PASS BACK ERROR.  
				JSR ZERGBUF ; CLEAN OUT GENERAL BUFFER AGAIN.  
CRNXTDIR		 LDA TLINK ; MOVE LAST BLOCK ADDRESS  
				STA GBUF ; AS BACKWARD LINK.  
				LDA TLINK+1   
				STA GBUF+1   
				LDA FLINK ; MAKE FORWARD LINK INTO CURRENT ADDRESS  
				STA TLINK   
				LDA FLINK+1   
				STA TLINK+1   
				DEC REQL ; IS THIS THE LAST BLOCK?  
				BEQ DIRCREND   
				JSR DIRWRT ; WRITE THIS BLOCK AND ALLOCATE NEXT.  
				BCS DERROR   
				LDA #0 ; ZERO OUT FORWARD LINK  
				STA GBUF+2   
				STA GBUF+3   
				BEQ CRNXTDIR ; BRANCH ALWAYS  
*     
DIRCREND		 JSR DIRWRT1 ; WRITE LAST BLOCK OF THIS DIRECTORY  
				BCS DERROR   
				JMP ENDCRE0 ; FINISH UP WRITING OWNER DIRECTORY STUFF.  
*     
DIRWRT			 JSR ALC1BLK ; GET ADDRESS OF NEXT BLOCK.  
				BCS DERROR   
				STA GBUF+2   
				STY GBUF+3 ; SAVE LINK ADDRESS  
				STA FLINK   
				STY FLINK+1   
DIRWRT1			 LDA TLINK ; GET ADDRESS OF CURRENT BLOCK  
				STA BLOKNML   
				LDA TLINK+1   
				STA BLOKNMH   
				JMP WRTGBUF ; GO WRITE IT OUT  
				PAGE    
*     
ERRGBUF			 EQU *   
DERROR			 RTS    
*     
*     
SOSTMPL			 DFB $0 ; THE FOLLOWING TWO BYTES ARE THE 'SOS STAMP'  
SOSTMPH			 DFB $0   
*     
SOSVER			 DFB 0,0,0,$27,13   
*     
*     
RNDTAB			 EQU *   
ENTCALC			 LDA #GBUF/256 ; SET HIGH ADDRESS OF DIRECTORY ENTRY INDEX POINTER  
				STA DRBUFPH   
				LDA #4 ; CALCULATE ADDRESS OF ENTRY BASED  
				LDX D.ENTNUM ; ON THE ENTRY NUMBER  
ECALC0			 CLC   
ECALC1			 DEX  ; ADDR=GBUF+((ENTNUM-1)*ENTLEN)  
				BEQ ECALC2   
				ADC H.ENTLN   
				BCC ECALC1   
				INC DRBUFPH ; BUMP HI ADDRESS  
				BCS ECALC0 ; BRANCH ALWAYS.  
*     
ECALC2			 STA DRBUFPL ; SAVE NEWLY CALCULATED LOW ADDRESS  
				RTS    
				PAGE    
DERROR2			 RTS    
*     
DREVISE			 LDA DATELO ; IF NO CLOCK,  
				BEQ DREVISE1 ; THEN DON'T TOUCH MOD T/D  
				LDX #3 ; MOVE LAST MODIFICATION DATE/TIME TO ENTRY BEING UPDATED.  
MODTIME			 LDA DATELO,X   
				STA DFIL+D.MODDT,X   
				DEX    
				BPL MODTIME   
*     
DREVISE1		 LDA DFIL+D.ATTR ; MARK ENTRY AS BACKUPABLE  
				ORA BKBITFLG ; BIT 5 = BACKUP NEEDED BIT  
				STA DFIL+D.ATTR   
				LDA D.DEV ; GET DEVICE NUMBER OF DIRECTORY  
				STA DEVNUM ; TO BE REVISED.  
				LDA D.ENTBLK ; AND ADDRESS OF DIRECTORY BLOCK  
				STA BLOKNML ; THAT CONTAINS THE ENTRY.  
				LDA D.ENTBLK+1   
				STA BLOKNMH   
				JSR RDGBUF ; READ BLOCK INTO GENERAL PURPOSE BUFFER.  
				BCS ERRGBUF   
				JSR ENTCALC ; FIX UP POINTER TO ENTRY LOCATION WITHIN GBUF.  
				LDY H.ENTLN ; NOW MOVE 'D.' STUFF TO DIRECTORY.  
				DEY    
MVDENT			 LDA DFIL+D.STOR,Y   
				STA (DRBUFPL),Y   
				DEY    
				BPL MVDENT   
				LDA D.HEAD ; IS THE ENTRY BLOCK THE SAME AS THE  
				CMP BLOKNML ; ENTRY'S HEADER BLOCK?  
				BNE SVENTDIR ; NO, SAVE ENTRY BLOCK  
				LDA D.HEAD+1 ; MAYBE, TEST HIGH ADDRESSES  
				CMP BLOKNMH   
				BEQ UPHEAD ; BRANCH IF THEY ARE THE SAME BLOCK.  
SVENTDIR		 JSR WRTGBUF ; WRITE UPDATED DIRECTORY BLOCK  
				BCS DERROR2 ; RETURN ANY ERROR.  
				LDA D.HEAD ; GET ADDRESS OF HEADER BLOCK  
				STA BLOKNML   
				LDA D.HEAD+1   
				STA BLOKNMH   
				JSR RDGBUF ; READ IN HEADER BLOCK FOR MODIFICATION  
				BCS DERROR2   
UPHEAD			 LDY #1 ; UPDATE CURRENT NUMBER OF FILES IN THIS DIRECTORY  
UPHED1			 LDA H.FCNT,Y   
				STA GBUF+HCENT+4,Y ; (CURRENT ENTRY COUNT)  
				DEY    
				BPL UPHED1   
				LDA H.ATTR ; ALSO UPDATE HEADER'S ATTRIBUTES.  
				STA GBUF+HATTR+4   
				JSR WRTGBUF ; GO WRITE UPDATED HEADER  
DERROR1			 RTS  ; IMPLICITLY RETURN ANY ERRORS  
*     
				PAGE    
*     
NOTDIR			 LDA #TYPERR ; NOT TREE OR DIRECTORY- NOT A RECOGNIZED TYPE!  
TSTERR			 SEC    
				RTS  ; DO NOTHING.  
*     
*     
TSTSOS			 LDA GBUF ; TEST SOS STAMP  
				CMP SOSTMPL   
				BNE TSTERR   
				LDA GBUF+1   
				CMP SOSTMPH   
				BNE TSTERR   
				LDA GBUF+4 ; TEST FOR HEADER  
				AND #$E0   
				CMP #HEDTYP*16   
				BNE TSTERR ; BRANCH IF NOT SOS HEADER (NO ERROR NUMBER)  
				CLC  ; INDICATE NO ERROR  
				RTS    
*     
				CHN FNDFIL,4,1   
NE				 TSTERR    
				LDA GBUF+4 ; TEST FOR HEADER  
				AND #$E0   
				CMP #HEDTYP*16   
				BNE TSTERR ; BRANCH IF NOT SOS HEADER (NO ERROR NUMBER)  
				CLC  ; INDICATE NO ERROR  
				RTS    
*     
				CHN FNDFIL,4,1   
O				 ERROR    
				RTS    
*     
				CHN FNDFIL,4,1   
				ENTRY TOO.   
				LDY #D.MODDT+3   
RIPTIME			 LDA DATELO,X   
				STA (DRBUFPL),Y   
				DEY    
				DEX    
				BPL RIPTIME ;MOVE ALL FOR BYTES...  
RUPDATE			 JSR WRTGBUF ;WRITE UPDATED ENTRY BACK TO DISK. (ASSUMES BLOKNM UNDISTURBEDD)  
				BCS DERROR1 ;GIVE UP ON ANY ERROR.  
				LDY #D.DHDR ;NOW COMPARE CURRENT BLOCK NUMBER TO THIS  
				LDA (DRBUFPL),Y ; ENTRY'S HEADER BLOCK  
				INY    
				CMP BLOKNML ;ARE LOW ADDRESSES THE SAME?  
				STA BLOKNML ;(SAVE IT IN CASE IT'S NOT)  
				BNE RIPPLE2 ;BRANCH IF ENTRY DOES NOT RESIDE IN SAME BLOCK AS HEADER.  
				LDA (DRBUFPL),Y ;CHECK HIGH ADDRESS JUST TO BE SURE.  
				CMP BLOKNMH   
				BEQ RIPPLE ;THEY ARE THE SAME, CONTINUE RIPPLE TO ROOT DIRECTORY.  
RIPPLE2			 LDA (DRBUFPL),Y ;THEY AREN'T THE SAME, READ IN THIS DIRECTORY'S HEADER.  
				STA BLOKNMH   
				JSR RDGBUF   
				BCC RIPPLE ;CONTINUE IF READ WAS GOOD.  
DERROR1			 EQU *   
				RTS    
				PAGE    
*     
NOTDIR			 LDA #TYPERR ;NOT TREE OR DIRECTORY- NOT A RECOGNIZED TYPE!  
TSTERR			 SEC    
				RTS  ;DO NOTHING.  
*     
*     
TSTSOS			 LDA GBUF ;TEST SOS STAMP  
				CMP SOSTMPL   
				BNE TSTERR   
				LDA GBUF+1   
				CMP SOSTMPH   
				BNE TSTERR   
				LDA GBUF+4 ;TEST FOR HEADER  
				AND #$E0   
				CMP #HEDTYP*16   
				BNE TSTERR ;BRANCH IF NOT SOS HEADER (NO ERROR NUMBER)  
DRVISDNE		 CLC  ;INDICATE NO ERROR./  
				RTS    
*     
				CHN FNDFIL,4,1   
				    
				    
*************************************************************************  
* END OF APPLE /// SOS 1.3 SOURCE CODE FILE: CREATE  
*************************************************************************  
*--------------------------------------
MAN
SAVE /A3OSX.BUILD/SOS.13\sos.s.create.txt
LOAD /A3OSX.BUILD/SOS.13/sos.s
ASM
