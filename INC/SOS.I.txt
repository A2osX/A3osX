NEW
  AUTO 3,1
*--------------------------------------
				.LIST OFF
*--------------------------------------
REV0ROM			.EQ 0 					1=SUPPORT REV0 ROM
*--------------------------------------
TRUE			.EQ $80
FALSE			.EQ 0
*--------------------------------------
REQSEG			.EQ $40
FINDSEG			.EQ $41

GETTIME			.EQ $63
SETPREFIX		.EQ $C6

OPEN			.EQ $C8

READ			.EQ $CA
CLOSE			 .EQ $CC

*--------------------------------------
ZPAGE			.EQ $00
* SOSLDR1 SUBROUTINE 
K.BASE			.EQ ZPAGE+$0 ; +--------------------------------------+
I.BASE.P		.EQ ZPAGE+$2 ; ! <VARNAME>.P ::= 3 BYTE ZPAGE POINTER !
RDBUF.P			.EQ ZPAGE+$4 ; +--------------------------------------+
SYSBUF.P		.EQ ZPAGE+$6
TEMP.BANK		.EQ ZPAGE+$8
TEMP.ADRH		.EQ ZPAGE+$9
WORK.P			.EQ ZPAGE+$A

REV.SAVE		.EQ ZPAGE+$C ; REVERSE SUBROUTINE

FIRST.ADIB		.EQ ZPAGE+$10 ; FLAGS SUBROUTINE
PREV.ADIB.P		.EQ ZPAGE+$12
DIB.P			.EQ ZPAGE+$14
PG.ALIGN		.EQ ZPAGE+$16
DIB.FLAGS		.EQ $14
DIB.DCB			.EQ $20
*
PREVBANK		.EQ ZPAGE+$18 ; GETMEM SUBROUTINE
PREVDST			.EQ ZPAGE+$19
*
CODE.P			.EQ ZPAGE+$1C ; RELOCATION SUBROUTINE
REL.P			.EQ ZPAGE+$1E
REL.END			.EQ ZPAGE+$20
*
SRC.P			.EQ ZPAGE+$22 ; MOVE SUBROUTINE
DST.P			.EQ ZPAGE+$24
CNT				.EQ ZPAGE+$26
*
DSTBANK			.EQ ZPAGE+$2A ; LINK SUBROUTINE
LINK.P			.EQ ZPAGE+$2C
DIB.ENTRY		.EQ 2 ; ALLOC.DEV SUBROUTINE
DIB.UNIT		.EQ 4+16+2
DIB.DTYPE		.EQ 4+16+3
*
ETEMP			.EQ ZPAGE+$2E ; ERROR SUBROUTINE
*
WTEMP			.EQ ZPAGE+$2F ; WELCOME SUBROUTINE
*--------------------------------------
MEMMGR.ZPAGE	.EQ $40 				; BEGINNING OF ZPAGE TEMP SPACE FOR MEMORY MANAGER
VRT.BASE		.EQ $0 				; INTERNAL BK/PG PTR TO LOWEST VIRT PAGE
VRT.LIM			.EQ MEMMGR.ZPAGE+$0 	; &$1, INTERNAL BK/PG PTR TO HIGHEST VIRT PAGE
PHY1BASE		.EQ $0780 				; BANK "F",PAGE "0"
PHY1LIM			.EQ $079F 				; BANK "F",PAGE "1F"
PHY2BASE		.EQ $0820 				; BANK "10",PAGE "A0"
PHY2LIM			.EQ $087F 				; BANK "10",PAGE "FF"
*
* REQUEST.SEG DATA DECLARATIONS
*
M.TPARMX	 	.EQ $60 					; BEGINNING ADDRESS OF MMGR SOS CALL PARMS
M.RQCODE		.EQ M.TPARMX
RQ.BASE			.EQ M.TPARMX+1 		; BASE.BANK/PAGE
RQ.LIM			.EQ M.TPARMX+3 		; LIMIT.BANK/PAGE
RQ.ID			.EQ M.TPARMX+5
RQ.NUM			.EQ M.TPARMX+6
*
RQ.REGION		.EQ MEMMGR.ZPAGE+$2 	;VRT(0),PHY0(1),PHY1(2)
*
* FIND.SEG DATA DECLARATIONS
*
SRCHMODE		.EQ M.TPARMX+1 		; SEARCH MODE (0,1,2)
F.ID			.EQ M.TPARMX+2 		; SEG ID
F.PGCT			.EQ M.TPARMX+3 		; PAGE COUNT (LO
	
FX.PGCT			.EQ MEMMGR.ZPAGE+$3 	; &$4, INTERNAL PAGE COUNT
	
F.BASE			.EQ M.TPARMX+5 		; BASE.BANK/PAGE
F.LIM			.EQ M.TPARMX+7 		; LIMIT.BANK/PAGE
F.NUM			.EQ M.TPARMX+9 		; SEG NUM
	
F.ERR			.EQ MEMMGR.ZPAGE+$5 	; ERROR FLAG
	
CFS.PGCT		.EQ MEMMGR.ZPAGE+$6 	; &7, CURRENT FREE SEGMENT'S PAGE COUNT
CFS.BASE		.EQ MEMMGR.ZPAGE+$8 	; &9, " BASE.BANK/PAGE
CFS.LIM			.EQ MEMMGR.ZPAGE+$A 	; &$B, " LIMIT.BANK/PAGE
CFS.BLINK		.EQ MEMMGR.ZPAGE+$C 	; " BACK LINK
CFS.BASE0		.EQ MEMMGR.ZPAGE+$D 	; &$E, " BASE (SMODE=0)
CFS.BASE1		.EQ MEMMGR.ZPAGE+$F 	; &$10, " BASE (SMODE=1)
CFS.NEXT		.EQ MEMMGR.ZPAGE+$11 	; " NEXT ENTRY
CFS.PREV		.EQ MEMMGR.ZPAGE+$12 	; " PREV ENTRY
CFS.PTR			.EQ MEMMGR.ZPAGE+$13 	; &$14 " POINTER TO NXT FREE PG
BFS.PGCT		.EQ MEMMGR.ZPAGE+$15 	; &$16, BIGGEST FREE SEGMENT'S PAGE COUNT
BFS.BASE		.EQ MEMMGR.ZPAGE+$17 	; &$18 " BASE.BANK/PAGE
BFS.LIM			.EQ MEMMGR.ZPAGE+$19 	; &$1A " LIMIT.BANK/PAGE
BFS.BLINK		.EQ MEMMGR.ZPAGE+$1B 	; " BACK LINK
*
* CHANGE.SEG DATA DECLARATIONS
*
CHG.NUM			.EQ M.TPARMX+1 		; SEGNUM PARM
CHG.MODE		.EQ M.TPARMX+2 		; CHANGE MODE PARM
CHG.PGCT		.EQ M.TPARMX+3 		; PAGE COUNT PARM
CHG.PGCTX		.EQ MEMMGR.ZPAGE+$1C 	; &$1D, INTERNAL STORE FOR PGCT
CHG.NEW			.EQ MEMMGR.ZPAGE+$1E 	; &$1F, BANK/PAGE OF SEG'S NEW LIMIT OR BASE
*
* GET.SEG.INFO DATA DECLARATIONS
*
GSI.NUM			.EQ M.TPARMX+1
GSI.BASE		.EQ M.TPARMX+2
GSI.LIM			.EQ M.TPARMX+4
GSI.PGCT		.EQ M.TPARMX+6
GSI.ID			.EQ M.TPARMX+8
*
* GET.SEG.NUM DATA DECLARATIONS
*
GSN.BKPG		.EQ M.TPARMX+1
GSN.NUM			.EQ M.TPARMX+3
*
* RELEASE.SEG DATA DECLARATIONS
*
RLS.NUM			.EQ M.TPARMX+1 		; SEG NUM
*
*
* FILE CALL PARM LOCATIONS ON SOS ZPAGE
*
F.TPARMX		.EQ $A0
F.REQCODE		.EQ F.TPARMX
O.PATH			.EQ F.TPARMX+1 			; OPEN'S PATHNAME LOC
O.REFNUM		.EQ F.TPARMX+3 			; OPEN'S REFNUM LOC

REFNUM			.EQ F.TPARMX+1 			; REFNUM'S LOC IN OTHER CALLS

NL.ISNL			.EQ F.TPARMX+2 			; NEWLINE'S ISNEWLINE LOC
NL.NLCHR		.EQ F.TPARMX+3 			; NEWLINE'S NEWLINECHAR LOC

RW.BUF			.EQ F.TPARMX+2 			; READ/WRITE'S BUF LOC
RW.BYTES		.EQ F.TPARMX+4 			; READ/WRITE'S BYTES LOC
RD.BYTESRD		.EQ F.TPARMX+6 			; READ'S BYTESREAD LOC


D.TPARMX		.EQ $C0 				; DEVICE SYS CALL PARM START LOC
D.REQCODE		.EQ D.TPARMX
DNUM			.EQ D.TPARMX+1
U.TPARMX		.EQ $C0 				; UTILITY SYS CALL PARM START LOC
U.REQCODE		.EQ U.TPARMX
PRIORITY		.EQ U.TPARMX+1
J.MODE			.EQ U.TPARMX+1
J.VALUE			.EQ U.TPARMX+2
TIME			.EQ U.TPARMX+1
MEMORY			.EQ U.TPARMX+1

*--------------------------------------

B.SAVE			.EQ $01FC
Z.SAVE			.EQ $01FD
E.SAVE			.EQ $01FE
SP.SAVE			.EQ $01FF
*

*--------------------------------------
MAN
SAVE /A3OSX.BUILD/inc/sos.i
