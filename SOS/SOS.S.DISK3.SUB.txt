NEW
AUTO 3,1
*--------------------------------------

*************************************************************************
* APPLE /// SOS 1.3 SOURCE CODE FILE: DISK3.SUBS.SRC
*************************************************************************
* ASSEMBLER: APPLE ][ 6502 ASSEMBLER from APPLE COMPUTER TOOLKIT

* PAGE
* REP 40
* NAME : CHKDRV
* FUNCTION: CHECK IF MOTOR(S) RUNNING
* INPUT : NONE
* RETURNS : 'BNE' IF RUNNING
* : 'BEQ' IF NOT
* DESTROYS: AC,X
* REP 40
* NOTES: DUE TO A FLOATING PIN, THERE
* COULD BE A GLITCH WHICH CAUSES THE
* SHIFTER TO 'FLASH' ONTO THE BUS
* INSTEAD OF ALWAYS BEING TRISTATED.
* THIS COULD CAUSE CHKDRV TO THINK
* THAT THE MOTOR IS SPINNING WHEN IT
* IS NOT. THUS WE WILL SAMPLE THE SHIFTER
* FOR 40 US AT 6-US INTERVALS. IF, AFTER
* THREE (3) CONSECUTIVE PASSES, ANY OF
* THE PASSES SEES A 'LOCKED' SHIFTER,
* THEN WE SAY THE DRIVE IS STOPPED.
*
*
CHKDRV			.eq *
				ldx #3 ;CHECK SHIFTER SEVERAL TIMES
CHKD1			.eq *
				lda Q6L+$60 ;GET DATA
				cmp Q6L+$60 ;HAS IT CHANGED?
				bne CHANGED ;=>YES
				cmp Q6L+$60 ;HAS IT CHANGED?
				bne CHANGED ;=>YES
				cmp Q6L+$60 ;HAS IT CHANGED?
				bne CHANGED ;=>YES
				cmp Q6L+$60 ;HAS IT CHANGED?
				bne CHANGED ;=>YES
				cmp Q6L+$60 ;HAS IT CHANGED?
				bne CHANGED ;=>YES
				cmp Q6L+$60 ;HAS IT CHANGED?
				bne CHANGED ;=>YES
				cmp Q6L+$60 ;HAS IT CHANGED?
				bne CHANGED ;=>YES
				rts ;IF EVER LOCKED, IT'S STOPPED
*
CHANGED			.eq *
				dex 
				bne CHKD1 ;TRY SEVERAL TIMES
				dex ;SET CC=BNE
				rts ;RETURN ZFLAG APPROPRIATELY
* PAGE
* REP 40
* NAME : ADDTIME
* FUNCTION: ADD TO MOTOR UPTIME(S)
* INPUT : AC=NO. OF 25 MS INCREMENTS
* DESTROYS: Y
* REP 40
*
ADDTIME			.eq *
				pha ;PRESERVE AC
				ldy #4 ;TABLE INDEX/COUNT
ADD2			.eq *
				lda DRIVESEL-1,Y ;IS IT SELECTED?
				beq ADD3 ;=>NOPE
				pla 
				pha ;RECOVER DELTA-T
				clc 
				adc UPTIME-1,Y ;ADD TO MOTOR UPTIME
				cmp #T1SEC+2 ;IS IT AT MAX TIME?
				bcc ADD2A ;=>NO, STORE NEW TIME
				lda #T1SEC+1 ;YES, SET TO >1 SEC
ADD2A			.eq *
				sta UPTIME-1,Y
ADD3			.eq *

				dey 
				bne ADD2 ;=>DO ALL 4 DRIVES
*
				pla ;RESTORE AC
				rts 
* PAGE
* REP 40
* NAME : RECAL
* FUNCTION: RECALIBRATE DRIVE HEAD
* INPUT : NONE
* DESTROYS: ALL REGISTERS
* NOTE : A 'QUIET' RECALIBRATE IS DONE
* : USING TWO ITERATIONS. IF WE ARE
* : LOST, THEN SEEK 48-TRACKS
* : TOWARD TRACK ZERO. IF WE KNOW
* : WHAT TRACK WE'RE CURRENTLY
* : ON (+- 1/2 TRACK), THEN JUST
* : ADD A LITTLE EXTRA AND SEEK
* : TO TRACK ZERO. A 48-TRACK
* : SEEK WILL ALWAYS GET US BACK
* : ONTO THE MEDIA, EVEN IF WE
* : WERE "OFF THE CAM". FROM THAT
* : POINT, THE 2ND SEEK GETS US
* : BACK TO TRACK ZERO QUIETLY.
* REP 40
*
RECAL			.eq *
				lda #2 ;TWO ITERATIONS, PLEASE
RECAL1			.eq *
				pha ;SAVE LOOPCOUNT
				ldx #$60 ;SETUP SLOT FOR CORE RTNS
				jsr RDADR ;WHERE ARE WE?
				bcc RECAL2 ;=>NOW WE KNOW
				jsr RDADR ;GIVE SECOND SHOT
				bcc RECAL2 ;=>THAT GOT IT
				lda #48 ;LOST? TRY 48-TRACK SEEK
				jmp RECAL3
RECAL2			.eq *
				lda CSSTV+2 ;HERE'S WHERE WE ARE
				clc ;ADD SOME SO WE GET A
				adc #3 ; HARDER SEEK TO ZERO
RECAL3			.eq *
				ldy D.UNITNUM ;THIS IS NOW WHERE
				sta DRVTRACK,Y ; WE ARE
				jsr FIXIRQ ;ENABLE IRQ IF OK
*
				lda #0 ;DESTINATION TRACK IS 00
				sta MONTIMEH ;CLEAR MOTOR-UP TIME SO
				sta MONTIMEL ; SEEK KNOWS HOW LONG RECAL TAKES
				jsr MYSEEK ;=>SLAM IT BACK!
				pla ;HAVE WE DONE IT TWICE?
				tay 
				dey 
				tya 
				bne RECAL1 ;=>DO TWO ITERATIONS
				rts 
* PAGE
* REP 40
* NAME : SEEKDSK3
* FUNCTION: SEEK CURRENT DRIVE
* INPUT : AC=DESTINATION TRACK
* OUTPUT : NONE
* DESTROYS: ALL REGISTERS
* NOTE : MUST BE CALLED WHILE
* : MOTOR IS RUNNING, IN
* : 1MHZ+ROM+IO MODE
* REP 40
SEEKDSK3		.eq *
				ldy PREVUNIT ;GET DRIVENUM
				sty D.UNITNUM ;SET IT UP
				jsr MYSEEK ;MOVE IT!
				rts 
* REP 40
* NAME : MYSEEK
* FUNCTION: SEEK TO DESIRED TRACK
* INPUT : AC=DESTINATION TRACK
* DESTROYS: ALL REGISTERS
* REP 40
MYSEEK			.eq *
				sta TRKN ;TEMP HOLD OF AC
				ldy D.UNITNUM ;GET DRIVENUM

				lda DRVTRACK,Y ;SETUP CURRENT TRACK
				asl
				sta CURTRK ; FOR SEEK ROUTINE
				ldx #$60 ;SET UP SLOT FOR CORE RTNS
				lda MONTIMEH ;GET STARTING MOTOR TIME
				sta TEMP
*
* NOTE: IRQ'S WHICH SUSPEND SEEK MAY CAUSE A
* SEEK FAILURE. WE WILL HAVE TO RECALIBRATE
* SINCE WE WON'T BE ON-TRACK. WE CAN NOT GET
* ON A HALFTRACK SINCE SEEK ALLOWS SETTLING
* TIME OF THE PHASE. BECAUSE VBL IS A SERIOUS
* OFFENDER, WE INHIBIT HIM.
*
				php ;INHIBIT IRQ WHILE
				sei ; MESSING WITH VBL FLAGS
				lda E.IER
				and #$18
				sta VBLSAVE
				sta E.IER
				plp ;RESTORE IRQ STATUS
				lda TRKN ;RESTORE DESTINATION TRACK
				sta DRVTRACK,Y ;DEST IS NOW CURRENT
				asl
				jsr SEEK ;GO MOVE THE HEAD...
				lda VBLSAVE ;NOW ALLOW THAT
				ora #$80 ; NASTY
				sta E.IER ; VBL INTERRUPT
*
* COMPUTE THE TIME USED BY SEEK:
*
				lda MONTIMEH ;INCLUDE SEEKTIME IN
				sec 
				sbc TEMP
				jsr ADDTIME ; TOTAL MOTOR UPTIME(S)
				rts 
* PAGE
* REP 40
* NAME : BLK2SECT
* FUNCTION: COMPUTE TRACK/SECTOR FOR A BLOCK
* AND ADJUST BUFFER ADDRESS
* INPUT : D.BLOCK, D.BUF
* OUTPUT : TRACK, SECTOR, D.BUF
* DESTROYS: AC,Y
* REP 40
*
BLK2SECT		.eq *
				lda BLKTEMP+1 ;GET HI BLK HALF
				ror
				lda BLKTEMP ;GET LO HALF
				ror
				lsr
				lsr
				sta TRACK ;THAT'S THE TRACK
				lda BLKTEMP ;GET LO HALF AGAIN
				and #7
				tay 
				lda SECTABLE,Y ;GET START SECTOR
				sta SECTOR
*
* ADJUST BUFFER ADDRESS SO THAT I/O
* WON'T WRAPAROUND IN THE BANK:
* (THIS ALGORITHM RIPPED OFF FROM 1.0)
*
				lda BUFTEMP+1 ;GET BUFFER HI ADDRESS
				ldy $1400+BUFTEMP+1 ; AND XTND BYTE
				cmp #$82 ;IF RAM ADDR >=8200 THEN BUMP TO
				bcc NOADJ ; NEXT BANK PAIR
				cpy #$80
				bcc NOADJ ;=>NOT USING BANKPAIR
				cpy #$8F ;SPECIAL BANK 0?
				beq NOADJ ;=>YES
				and #$7F ;DROP HI ADDRESS AND
				sta BUFTEMP+1 ; BUMP BANK NUMBER
				inc $1400+BUFTEMP+1
*
NOADJ			.eq *
				lda BUFTEMP+1 ;COPY BUFFER ADDRESS
				sta BUF+1 ; FOR PRE & POSTNIB
				lda BUFTEMP
				sta BUF

				lda $1400+BUFTEMP+1
				sta $1400+BUF+1
				rts 
*
SECTABLE		.da 00,04,08,0C,01,05,09,0D
* PAGE
* REP 40
* NAME : MOREBLKS
* FUNCTION: SETUP TO DO NEXT BLOCK
* INPUT : NONE
* RETURNS : 'BNE' IF MORE TO DO
* : 'BEQ' IF NO MORE TO DO
* DESTROYS:NOTHING
* REP 40
*
MOREBLKS		.eq *
				inc BUFTEMP+1 ;BUMP BUFFER ADDRESS
				inc BUFTEMP+1
				inc BLKTEMP ;BUMP BLOCK NUMBER
				bne MORE2
				inc BLKTEMP+1
MORE2			.eq *
				dec BLKCOUNT ;MORE BLOCKS TO GO?
				rts ;RETURN RESULT OF DEC
* SKP 4
* REP 40
* NAME : FIXIRQ
* FUNCTION: ENABLE IRQ IF APPROPRIATE
* INPUT : NONE
* DESTROYS: NOTHING
* REP 40
*
FIXIRQ			.eq *
				pha 
				lda IRQMASK ;SHOULD IRQ BE ENABLED?
				bmi FIXRET ;=>NO, LEAVE IT ALONE
				cli ;ENABLE IRQ
FIXRET			.eq *
				pla 
				rts 

* CHN DISK3.DATA.SRC

*************************************************************************
* END OF APPLE /// SOS 1.3 SOURCE CODE FILE: DISK3.SUBS.SRC
*************************************************************************





*--------------------------------------
MAN
SAVE /A3OSX.BUILD/SOS/SOS.S.DISK3.SUB
LOAD /A3OSX.BUILD/SOS/SOS.S
ASM
