NEW
AUTO 3,1
*--------------------------------------

*************************************************************************
* APPLE /// SOS 1.3 SOURCE CODE FILE: ALLOC
*************************************************************************
* ASSEMBLER: APPLE ][ 6502 ASSEMBLER from APPLE COMPUTER TOOLKIT

*
DEALLOC			stx BMCNT ; SAVE HIGH ORDER ADDRESS OF BLOCK TO BE FREED.
				pha ; SAVE IT
				ldx VCBPTR ; WHILE THE BITMAP
				lda VCB+VCBTBLK+1,X ; DISK ADDRESS IS CHECKED
				cmp BMCNT ; TO SEE IF IT MAKES SENSE
				pla ; RESTORE
				bcc DEALERR1 ; BRANCH IF IMPOSSIBLE
				tax 
				and #$7 ; GET THE BIT TO BE OR-ED IN.
				tay 
				lda WHICHBIT,Y ; (SHIFTING TAKES 7 BYTES, BUT IS SLOWER)
				sta NOFREE ; SAVE BIT PATTERN
				txa ; GET LOW BLOCK ADDRESS AGAIN.
				lsr BMCNT
				ror
				lsr BMCNT ; THE BLOCK ADDRESS.
				ror
				lsr BMCNT
				ror
				sta BMPTR ; SAVE POINTER.
				lsr BMCNT ; NOW TRANSFER BIT WHICH SPECIFIES WHICH PAGE OF BITMAP.
				rol HALF
				ldx BMTAB ; (THIS POINTS TO THE TABLE FOR THE BITMAP BUFFER USED).
				lda BMACMAP,X ; WHAT IS THE CURRENT MAP
				cmp BMCNT ; IS IN CORE BIT MAP THE ONE WE WANT?
				beq DEALL1 ; BRANCH IF IN-CORE IS CORRECT.
				jsr BMAPUP ; PUT CURRENT MAP AWAY.
				bcs DEALERR ; PASS BACK ANY ERROR.
				lda BMCNT ; GET DESIRED MAP NUMBER.
				ldy #VCBCMAP
				sta (VCBPTR),Y ; AND MAKE IT CURRENT.
				ldx BMTAB
				lda BMADEV,X
				jsr GTBMAP ; READ IT INTO THE BUFFER,
				bcs DEALERR
DEALL1			ldy BMPTR ; INDEX TO BYTE.
				lsr HALF
				bcc DEALL2 ; BRANCH IF ON PAGE ONE OF BITMAP.
				inc BMADR+1
DEALL2			lda NOFREE ; THE INDIVIDUAL BIT.
				ora (BMADR),Y
				sta (BMADR),Y
				bcc DEALL3 ; BRANCH IF ADDRESS IS PROPER
				dec BMADR+1
DEALL3			ldx BMTAB ; MARK BITMAP AS MODIFIED.
				lda #$80
				ora BMASTAT,X
				sta BMASTAT,X
				clc 
DEALERR			rts
DEALERR1		lda #BITMAPADR ; BIT MAP BLOCK NUMBER IMPOSSIBLE
				sec ; SAY BIT MAP DISK ADDRESS WRONG
				rts ; (PROBABLY DATA MASQUERADING AS INDEX BLOCK)
*
WHICHBIT		.da 80,40,20,10
				.da 08,04,02,01
*
*
* PAGE
*
ALCIDXS			lda #0 ; ALLOCATION OF THE INDEXES ALWAYS FILLS IN
				sta SAPTR ; STARTING AT THE BEGINNING OF THE BLOCK.
				jsr ALC1BLK ; THIS GETS FIRST INDEX AND SETS UP A
				bcs ERRALC1 ; POINTER TO THE FREE BLOCKS (TO AVOID
ALIDX1			ldy SAPTR ; SCANNING THE WHOLE BLOCK EVERY TIME).
				sta (TINDX),Y ; SAVE INDEX BLOCK ADDRESS (LOW)
				inc TINDX+1
				lda SCRTCH+1 ; GET HIGH BYTE OF ADDRESS

				sta (TINDX),Y ; (AND SAVE IT)
				dec TINDX+1
				dec REQL ; HAS REQUEST BEEN SATIFIED?
				beq ALDXEND ; (CARRY IS CLEAR)
				inc SAPTR ; BUMP INDEX POINTER
				ldy BMPTR ; GET INDEX POINTER TO LAST ACCESSED BIT GROUP
				lda HALF ; WHICH HALF OF MAP? (BOTH BMPTR & HALF SET UP BY 'ALC1BLK')
				bne SECNDHAF
				jsr GETBITS1 ; GET NEXT FREE BLOCK ADDRESS.
				bcc ALIDX1 ; BRANCH IF NO ERROR
ERRALC1			rts
*
SECNDHAF		jsr GETBITS2 ; GET NEXT FREE BLOCK ADDRESS FROM SECOND HALF OF BIT MAP
				bcc ALIDX1 ; BRANCH IF NO ERROR.
ALDXEND			rts ; RETURN STATUS (CARRY SET INDICATES ERROR)
*
*
ALC1BLK			jsr FNDBMAP ; GET ADDRESS OF BIT MAP IN 'BMADR'
				bcs ERRALC1 ; BRANCH IF ERROR ENCOUNTERED
SRCHFRE			ldy #0 ; START SEARCH AT BEGINNING OF BIT MAP BLOCK
				sty HALF ; INDICATE WHICH HALF (PAGE) WE'RE SEARCHING.
GETBITS1		lda (BMADR),Y
				bne BITFOUND ; FREE BLOCKS ARE INDICATED BY 'ON' BITS
				iny 
				bne GETBITS1 ; CHECK ALL OF 'EM IN FIRST PAGE.
				inc BMADR+1 ; BUMP HIGH ADDRESS OF CURRENT BITMAP
				inc HALF ; INDICATE SEARCH HAS PROGRESSED TO PAGE 2
				inc BASVAL ; BASE VALUE= BASE ADDRESS/2048
GETBITS2		lda (BMADR),Y ; SEARCH SECOND HALF FOR FREE BLOCK
				bne BITFOUND
				iny 
				bne GETBITS2
				dec BMADR+1 ; RESET BIT MAP ADDRESS TO BEGINNING.
				inc BASVAL ; ADD 2048 OFFSET FOR NEXT PAGE
				jsr NXTBMAP ; GET NEXT BITMAP (IF IT EXISTS) AND UPDATE VCB.
				bcc SRCHFRE ; BRANCH IF NO ERROR ENCOUNTERED.
				rts ; RETURN ERROR.
* PAGE
*
BITFOUND		sty BMPTR ; SAVE INDX POINTER TO VALID BIT GROUP
				lda BASVAL ; SET UP FOR BLOCK ADDRESS CALCULATION
				sta SCRTCH+1
				tya ; GET ADDRESS OF BIT PATTERN
				asl
				rol SCRTCH+1
				asl
				rol SCRTCH+1
				asl
				rol SCRTCH+1
				tax ; NOW X= LOW ADDRESS WITHIN 7 OF ACTUAL ADDRESS.
				lda (BMADR),Y ; GET BIT PATTERN AGAIN
				sec ; MARK RIGHT END OF BYTE.
ADCALC			rol
				bcs BOUNCE ; BRANCH IF FOUND.
				inx ; ADJUST LOW ADDRESS
				bne ADCALC ; BRANCH ALWAYS
BOUNCE			lsr
				bcc BOUNCE ; LOOP UNTIL MARK (SET ABOVE) MOVES INTO CARRY
				sta (BMADR),Y ; UPDATE BITMAP TO SHOW ALLOCATED BLOCK IN USE.
				stx SCRTCH ; SAVE LOW ADDRESS.
				ldx BMTAB ; UPDATE BIT MAP BUFFER STATUS
				lda #$80 ; INDICATE MAP HAS BEEN MODIFIED
				ora BMASTAT,X ; (X IS EITHER 0 OR 6 FOR
				sta BMASTAT,X ; BUFFER 'A' OR 'B' RESPECTIVELY.)
				ldy #VCBTFRE ; SUBTRACT 1 FROM TOTAL FREE
				lda (VCBPTR),Y ; BLOCKS IN VCB TO ACCOUNT FOR NEWLY
				sbc #1 ; ALLOCATED BLOCK (CARRY IS SET FROM 'BOUNCE')
				sta (VCBPTR),Y
				bcs RET1BLK ; BRANCH IF HI FREE COUNT DOESN'T NEED ADJUSTMENT.
				iny 
				lda (VCBPTR),Y ; ADJUST HIGH COUNT.
				sbc #0 ; (CARRY IS CLEAR, SO ACC=ACC-1)
				sta (VCBPTR),Y
RET1BLK			clc ; INDICATE NO ERROR ENCOUNTERED
				lda SCRTCH ; GET ADDRESS LOW IN ACC.
				ldy SCRTCH+1 ; AND HIGH ADDRESS IN Y
				rts ; RETURN ADDRESS OF NEWLY ALLOCATED BLOCK.
*
* PAGE
*
GTTINDX			ldy #VCBDEV ; GET DEVICE NUMBER SO WE DON'T

				ldx #0 ; ANTICPATE USING BUFFER 'A'.
				lda (VCBPTR),Y ; USE THE BUFFER USED BY IT!
				cmp BMADEV ; IS IT IN BUFFER 'A'?
				beq FREEBE ; IF SO, FREE 'B'!
				cmp BMBDEV ; IF NOT, IS IT IN 'B'?
				beq FREEA ; IF SO, FREE UP BUFFER 'A'
				jsr FNDBMAP ; OTHERWISE, FORCE ALLOCATION FOR ONE OF THE BUFFERS
				bcc GTTINDX ; NOW TRY AGAIN.
				rts ; RETURN ERROR.
*
FREEBE			ldx #BMTABSZ ; DE-ALLOCATE BUFFER IF NECESSARY
FREEA			stx NOFREE ; SAVE WHICH BUFFER WE'RE LOOKIN AT.
				ldy BMASTAT,X ; DO WE NEED TO WRITE BUFFER TO FREE IT?
				bpl USEBUF ; NO, THEN USE IT.
				stx ZPGTEMP ; SAVE BM BUFFER ID FOR A BIT
				jsr WRTBMAP ; WRITE BM TO OWNING UNIT
				bcs SOMERR1 ; RETURN ANY ERROR (W/O RELEASING BM)
				ldx ZPGTEMP ; FETCH THE BM BUFFER ID
				lda #0
				sta BMASTAT,X ; AND MARK BM BUFFER AS FREE
USEBUF			ldx NOFREE ; GET INDEX TO BUFFER INFO
				lda #0 ; MARK STATUS OF BUFFER AS FREE.
				sta BMADEV,X ; (DEVICE 0 IS NOT ANY DEVICE)
				sta TINDX
				sta BMADR
				lda BMAMADR,X ; GET MEMORY ADDRESS OF FREE BUFFER.
				sta TINDX+1
				txa ; SET UP PROPER HI ADDRESS OF BIT MAP TOO...
				eor #BMTABSZ ; SELECT ALTERNATE BIT MAP TABLE.
				sta BMTAB ; (TO INDICATE WHICH IS BITMAP)
				tax 
				lda BMAMADR,X ; GET HIGH ADDRESS OF BIT MAP.
				sta BMADR+1
				lda BMBUFBNK ; AND BANK PAIR NUMBER.
				sta SSTIDXH
				sta SISBMADR
				clc ; INDICATE NO ERRORS
SOMERR1			rts
*
* PAGE
NXTBMAP			ldy #VCBTBLK+1 ; BEFORE BUMPING TO NEXT MAP,
				lda (VCBPTR),Y ; CHECK TO BE SURE THERE IS
				lsr
				lsr
				lsr
				lsr
				ldy #VCBCMAP
				cmp (VCBPTR),Y ; ARE THERE MORE MAPS?
				beq NOMORBIT ; BRANCH IF NO MORE TO LOOK AT.
				lda (VCBPTR),Y ; ADD 1 TO CURRENT MAP
				clc 
				adc #1
				sta (VCBPTR),Y
				ldy #VCBDEV
				lda (VCBPTR),Y
				tax ; GO WRITE OUT LAST MAP IF NECESSARY
				jsr UPBMAP
				jmp FNDBMAP ; READ NEXT BIT MAP INTO BUFFER
*
GETA.BUF		ldx #0
				beq FRESHMAP
*
GETB.BUF		ldx #BMTABSZ
				bne FRESHMAP ; BRANCH ALWAYS
*
*
FNDBMAP			ldy #VCBDEV ; GET DEVICE NUMBER
				lda (VCBPTR),Y
				ldx #0 ; START WITH MAP 'A'
FNDMAP1			cmp BMADEV,X
				bne TRYMAP2
FRESHMAP		stx BMTAB ; SAVE POINTER TO BIT MAP INFO TABLE
				ldy BMASTAT,X ; IS THIS ONE ALREADY MODIFIED?
				bmi BMFOUND ; YES, RETURN POINTER IN 'BMADR'
				jsr GTBMAP ; OTHERWISE READ IN FRESH BIT MAP
				bcc BMFOUND ; BRANCH IF SUCCESSFUL.
				rts ; OTHERWISE, RETURN ERROR.
*
TRYMAP2			dex ; WAS LAST FAILURE MAP 'A'
				bpl FRBMBUF ; NO, MUST FREE UP ONE OF THE BUFFERS
				ldx #BMTABSZ ; TRY BIT MAP BUFFER 'B'.

				jmp FNDMAP1
* PAGE
*
BMFOUND			ldx BMTAB ; WHICH TABLE?
				ldy #VCBCMAP
				lda (VCBPTR),Y
				asl
				sta BASVAL
				lda BMAMADR,X ; GET HIGH ADDRESS
				sta BMADR+1
				lda BMBUFBNK ; GET BANK NUMBER OF BUFFER BIT MAP BUFFERS
				sta SISBMADR
				lda #0 ; BUFFERS ALWAYS FALL ON A PAGE BOUNDARY
				sta BMADR
				clc ; INDICATE ALL IS VALID AND GOOD!
				rts 
*
NOMORBIT		lda #OVRERR ; INDICATE REQUEST CAN'T BE FILLED.
				sec ; INDICATE ERROR
				rts 
*
FRBMBUF			sec
				ldx BMTAB ; FIND OUT WHICH WAS LAST USED.
				beq CHKBMB ; IF 'A' WAS USED CHECK 'B' FIRST
				clc ; INDICATE 'A' IS CHECKED FIRST
				bit BMASTAT ; IS BUFFER 'A' FREE (UNMODIFIED)?
				bpl GETA.BUF ; YES, USE IT.
CHKBMB			bit BMBSTAT ; IS BUFFER 'B' FREE?
				bcc FREBUF1 ; BRANCH IF BOTH ARE USED
				bpl GETB.BUF ; YES...
				bit BMASTAT ; (CHECK 'A')
				bpl GETA.BUF
FREBUF1			ldx #0
				bcc FREBUFA ; BRANCH IF BUFFER 'A' HAS LEAST PRIORITY.
				ldx #BMTABSZ
FREBUFA			stx ZPGTEMP ; SAVE BM BUFF ID FOR A BIT
				jsr WRTBMAP ; XREG PASSES BM BUFF ID
				bcs NOGO ; ERROR ENCOUNTERED ON WRITING
				ldx ZPGTEMP ; FETCH BM BUFF ID
				lda #0
				sta BMASTAT,X ; AND MARK BM BUFFER AS FREE
				bcc FNDBMAP ; LOOK AGAIN FOR FRRE BIT MAP BUFFER SPACE
NOGO			rts ; RETURN ERROR ON WRITING BM
*
UPBMAP			cpx BMADEV ; UPDATE BIT MAP OF DEVICE X
				bne UPBM1
				clc ; FREE BUFFER 'A' IF NEEDED.
				bit BMASTAT
				bmi FREBUF1 ; (CARRY CLEAR FOR BUFFER 'A')
				rts 
* PAGE
*
UPBM1			cpx BMBDEV
				bne NOUPDAT ; DON'T UPDATE IF NOT NECESSARY.
				bit BMBSTAT
				bmi FREBUF1 ; (CARRY IS SET)
NOUPDAT			clc
				rts ; RETURN 'NO ERROR'
*
CLEARBMS		.eq * ; MAKE SURE ALL BIT MAPS ASSOCIATED
* WITH A DEVICE ARE MARKED INVALID
* IF A NEW VOLUME IS LOGGED IN ON IT.
* INPUT ARG: A REG = DEVNUM
* X REG PRESERVED
				ldy #0
				cmp BMADEV
				bne CLRBM1 ; BRANCH IF BIT MAP A NOT OWNED
				bit BMASTAT
				bmi CLRBM2 ; BRANCH IF BITMAP A BUSY
				sty BMADEV ; ELSE, CLEAR IT
CLRBM2			rts ; NEED ONLY CLEAR ONE
CLRBM1			cmp BMBDEV ; BIT MAP B?
				bne CLRBM2 ; BRANCH IF BIT MAP B NOT OWNED BY DEVNUM
				bit BMBSTAT
				bmi CLRBM2 ; BRANCH IF BITMAP B BUSY
				sty BMBDEV ; ELSE CLEAR IT
				rts ; AND RETURN TO CALLER (NO ERRORS)
*
GTBMAP			sta BMADEV,X ; SAVE ACC AS CURRENT DEVICE FOR BUFFER
				lda BMAMADR,X ; GET HIGH ORDER ADDRESS OF BUFFER
				sta BMADR+1 ; SELECTED BY X

				lda BMBUFBNK ; AND GET BANK PAIR NUMBER
				sta SISBMADR ; OF BOTH BIT MAP BUFFERS 'A' AND 'B'
				ldy #VCBCMAP ; GET LOWEST MAP NUMBER WITH FREE BLOCKS IN IT.
				lda (VCBPTR),Y
				sta BMACMAP,X ; ASSOCIATE THE OFFSET WITH THE BITMAP CONTROL BLOCK
				clc 
				ldy #VCBDMAP ; ADD THIS NUMBER TO THE BASE
				adc (VCBPTR),Y ; ADDRESS OF FIRST BIT MAP
				sta BMADADR,X ; SAVE LOW ADDRESS OF BIT MAP TO BE USED.
				iny ; NOW GET HIGH DISK ADDRESS OF MAP
				lda (VCBPTR),Y ; ADD TO THIS THE STATE OF THE CARRY
				adc #0
				sta BMADADR+1,X ; SAVE HIGH DISK ADDRESS TOO.
; DROP INTO 'RDBMAP'
*
* PAGE
*
				lda #RDCMD ; (X CONTAINS AN INDEX TO DETERMINE WHICH BUFFER)
DOBMAP			sta DHPCMD ; SAVE DEVICE COMMAND
				lda DEVNUM ; FIX THE 'BIT MAP TRASH BUG'
				pha ; BY NOT MUNGING DEVNUM
				lda BMADEV,X ; GET DEVICE NUMBER.
				sta DEVNUM
				lda BMADADR,X ; AND MAP'S DISK ADDRESS
				sta BLOKNML
				lda BMADADR+1,X
				sta BLOKNMH
				lda BMAMADR,X ; LASTLY GET THE ADDRESS OF THE BUFFER
				ldx BMBUFBNK ; AND BANK NUMBER.
				jsr DOBITMAP ; (NOTE: LOW ADDRESS IS FIXED TO ZERO AS THIS IS A BUFFER)
				pla ; RESTORE
				sta DEVNUM ; THE DEVNUM WE CAME IN WITH!
				rts 
*
WRTBMAP			lda #WRTCMD ; WRITE BIT MAP POINTED TO BY X
				jmp DOBMAP
*
WRTGBUF			lda #WRTCMD ; SET CALL FOR WRITE.
				bne SVGCMD ; BRANCH ALWAYS.
RDGBUF			lda #RDCMD ; SET CALL FOR READ.
SVGCMD			sta DHPCMD ; PASSED TO DEVICE HANDLER.
				lda BLOKNML ; SAVE CURRENT
				sta TTLINK ; GBUF BLOCK
				lda BLOKNMH ; ADDRESS
				sta TTLINK+1 ; FOR DIRECTORY EXTEND
				lda #GBUF/256 ; GET HIGH ADDRESS OF GENERAL BUFFER
				ldx #0 ; TO FORCE ACCESS TO NON BANK MEMORY.
DOBITMAP		.eq *
DOIDX			sta DBUFPH
				stx SISBPH ; SELECT BANK
				lda #0 ; GENERAL PURPOSE BUFFERS ALWAYS
				sta DBUFPL ; START ON A PAGE BOUNDARY.
				jmp FILEIO2 ; END VIA DEVICE DISPATCHER.
*
TTLINK			.bs 2 ; GBUF CURRENT ADDRESS
*
WRTINDX			lda #WRTCMD
				ldx IDXADRL ; GET BLOCK ADDRESS OF INDEX BLOCK
				ldy IDXADRH
DOFRST			sta DHPCMD ; (ENTRY USED BY RD/WRTDFRST)
				stx BLOKNML
				sty BLOKNMH
				lda TINDX+1 ; HIGH RAM ADDRESS OF INDEX BLOCK
				ldx SSTIDXH ; AND BANK NUMBER.
				jmp DOIDX ; AND GO DO REQUESTED OPERATION.
*
WRTDFRST		lda #WRTCMD ; WRITE FILE'S FIRST BLOCK (USED
				bne FADDR ; BY CREATE, SO ADDRESS IN 'D.' STUFF).
RDFRST			lda #RDCMD
FADDR			ldx DFIL+D.FRST ; (BUFFER ADDRESS IS IN 'TINDX')
				ldy DFIL+D.FRST+1
				jmp DOFRST
*
*
* CHN POSN/OPEN,4,2

*************************************************************************
* END OF APPLE /// SOS 1.3 SOURCE CODE FILE: ALLOC
*************************************************************************





*--------------------------------------
MAN
SAVE /A3OSX.BUILD/SOS/SOS.S.ALLOC
LOAD /A3OSX.BUILD/SOS/SOS.S
ASM
