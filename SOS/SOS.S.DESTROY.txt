NEW
AUTO 3,1
*--------------------------------------

*************************************************************************
* APPLE /// SOS 1.3 SOURCE CODE FILE: DESTROY
*************************************************************************
* ASSEMBLER: APPLE ][ 6502 ASSEMBLER from APPLE COMPUTER TOOLKIT

* PAGE
*
NEWLINE			ldy #FCBATTR ; ADJUST NEWLINE STATUS FOR OPEN FILE.
				lda C.ISNEWL ; ON OR OFF?
				bpl OFFNEWL ; BRANCH IF NEW LINE IS TO BE CLEARED.
				lda #NLINEN
				ora (FCBPTR),Y ; SET NEW LINE BIT IN ATTRIBUTES
				sta (FCBPTR),Y
				ldy #FCBNEWL ; AND MOVE IN NEW 'NEW-LINE' BYTE.
				lda C.NEWL
				sta (FCBPTR),Y
				clc 
				rts ; NO ERROR POSSIBLE.
*
OFFNEWL			lda #$FF-NLINEN
				and (FCBPTR),Y
				sta (FCBPTR),Y ; CLEAR NEW-LINE BIT.
OFFRTS			clc ; THE NEW LINE CHARACTER DOES'T MATTER...
				rts 
* PAGE
*
GETINFO			jsr FINDFILE ; LOOK FOR FILE THEY WANT OT KNOW ABOUT.
				bcc GTINFO1 ; BRANCH IF NO ERRORS.
				cmp #BADPATH ; WAS IT A ROOT DIRECTORY FILE?
				sec ; (IN CASE OF NO MATCH)
				bne GINFOERR
				lda #$F0
				sta DFIL+D.STOR ; FOR GET INFO, REPORT PROPER STORAGE TYPE
				lda #0 ; FORCE A COUNT OF FREE BLOCKS.
				sta REQL
				sta REQH
				jsr TSFRBLK ; (RETURNS IF IMMEDIATELY IF COUNT HAS PREVIOUSLY BEEN TAKEN)
				ldy #VCBTFRE+1
				lda (VCBPTR),Y ; RETURN TOTAL BLOCKS AND TOTAL IN USE.
				sta REQH ; FIRST TRANSFER 'FREE' BLOCKS TO ZPAGE FOR LATER SUBTRACT
				dey 
				lda (VCBPTR),Y ; TO DETERMINE THE 'USED' COUNT
				sta REQL
				dey 
				lda (VCBPTR),Y ; TRANSFER TO 'D.' TABLE AS AUX I.D.
				sta DFIL+D.AUXID+1 ; (TOTAL BLOCK COUNT IS CONSIDERED AUX I.D. FOR THE VOLUME)
				tax 
				dey 
				lda (VCBPTR),Y
				sta DFIL+D.AUXID
				sec ; NOW SUBTRACT AND REPORT THE NUMBER OF BLOCKS 'IN USE'
				sbc REQL
				sta DFIL+D.USAGE
				txa 
				sbc REQH
				sta DFIL+D.USAGE+1
GTINFO1			ldy #0 ; TRANSFER BYTES FROM THERE INTERNAL ORDER TO CALL SPEC VIA 'INFTABL'
TRANSLATION
GTINFO2			lda INFTABL,Y
				bpl GTINFO3 ; BRANCH IF THIS IS DATA IS VALID AS IS.
				and #$7F ; IS THIS THE 4TH BYTE OF THE EOF PARAMETER?
				beq GTINFO4 ; YES, AND IT'S ALWAYS A ZERO.
				cmp #D.STOR+1 ; IS THIS THE STORAGE TYPE BYTE?
				bne GINFOEND ; NO, IT'S THE END OF INFO THAT CAN BE RETURNED.
				lda DFIL+D.STOR ; GET STORAGE TYPE
				lsr
				lsr
				lsr
				lsr
				bpl GTINFO4 ; BRANCH ALWAYS
*
GTINFO3			tax ; USE AS OFFSET INTO 'D.' TABLE.
				lda DFIL,X
GTINFO4			sta (C.FILIST),Y ; PASS TO USER'S BUFFER
				iny 
				cpy C.FILSTLN ; HAS REQUEST BEEN FILLED?

				bne GTINFO2 ; NO, PASS NEXT
GINFOEND		clc ; INDICATE NO ERRORS
GINFOERR		rts
*
*
* PAGE
*
SETINFO			jsr FINDFILE ; FIND WHAT USER WANTS...
				bcs SINFOERR ; RETURN ANY FAILURE.
				lda C.FILSTLN ; TEST FOR NUL CHANGE
				beq SINFEND ; BRANCH IF NOTHING TO CHANGE.
				ldy #0 ; INIT POINTER TO USER SUPPLIED LIST.
				lda (C.FILIST),Y ; FETCH FILE ATTRIBUTES
				and #$1C ; FORBIDDEN BITS? <SRS 82.162>
				beq SETINF1 ; NO
				lda #ACCSERR ; YES
				sec 
				rts ; RETURN AN ERROR
SETINF1			lda BACKMASK ; GET CURRENT BACKMASK <SRS 82.162>
* BACKUP KNOWS HOW TO RESET THIS BIT. <SRS 82.162>
				sta BKBITFLG ; BIT (USED BY DREVISE)
SETINF1X		ldx INFTABL,Y ; GET INDEX INTO CORESPONDING 'D.' TABLE
				bmi SETINF2 ; BRANCH IF WE'VE REACHED STORAGE TYPE PARAMETER
				lda (C.FILIST),Y
				sta DFIL,X
				iny ; HAS USER'S REQUEST BEEN SATISFIED?
				cpy C.FILSTLN
				bne SETINF1X ; NO, MOVE NEXT BYTE.
SINFEND			jmp DREVISE ; GO UPDATE DIRECTORY WITH CURRENT TIME.
*
SETINF2			ldy C.FILSTLN ; TEST TO SEE IF USER WANTS HIS TIME STAMP ADDED
				cpy #$F ; (LIST MUST BE AT LEAST $F BYTES LONG)
				bcc SINFEND ; NO PUT CURRENT TIME INSTEAD.
				ldy #$B ; MOVE IN THE NEXT GROUP OF BYTES
SETINF3			ldx INFTABL,Y
				bmi SINFEND1
				lda (C.FILIST),Y
				sta DFIL,X
				iny 
				cpy C.FILSTLN ; SATISFACTION YET?
				bne SETINF3 ; NOPE, KEEP EM PUMPIN'
SINFEND1		jmp DREVISE1
*
BKBITFLG		.bs 1 ; FOR TURNING OFF BACKUP BIT
*
*
INFTABL			.da D.ATTR,D.FILID,D.AUXID,D.AUXID+1
				.da D.STOR+1+$80,D.EOF,D.EOF+1,D.EOF+2 ; (D.STOR=0 THUS D.STOR+1 WAS NECESSARY)
				.da 80,D.USAGE,D.USAGE+1,D.MODDT ; (THE $80 IS FOR THE FOURTH BYTE OF EOF)
				.da D.MODDT+1,D.MODTM,D.MODTM+1,FF ; TABLE ALWAYS ENDS IN $FF
* PAGE
*
RENAME			jsr LOOKFILE ; LOOK FOR SOURCE (ORIGINAL) FILE.
				bcc RNAME0 ; BRANCH IF FOUND.
				cmp #BADPATH ; TRYING TO RENAME A VOLUME?
				bne RNAMERR ; NO, RETURN OTHER ERROR.
				jsr RENPATH ; SYNTAX NEW NAME.
				bcs RNAMERR
				lda WRKPATH ; FIND OUT IF ONLY ROOTNAME FOR NEW NAME
				cmp PATHNML
				bne RNBADPTH ; NOT SINGLE NAME, RETURN ERROR!
				ldy #VCBSTAT ; TEST FOR OPEN FILES BEFORE CHANGING
				lda (VCBPTR),Y
				bpl RNAMEVOL ; BRANCH IF VOLUME NOT BUSY
				lda #FILBUSY
SINFOERR		.eq *
				rts ; (CARRY IS SET)
RNAMEVOL		ldy #0 ; GET NEWNAME'S LENGTH.
				lda (WRKPATH),Y
				tay 
				ora #$F0 ; (ROOT FILE STORAGE TYPE)
				jsr MVROTNAM ; UPDATE ROOT DIRECTORY.
				bcs RNAMERR
				ldy #0
				lda (WRKPATH),Y ; UPDATE VCB ALSO.
				tay 
RNMEVOL			lda (WRKPATH),Y
				sta (VCBPTR),Y
				dey 
				bpl RNMEVOL
				clc 

				rts 
*
RNAME0			jsr RENPATH ; SET UP AND SYNTAX NEW NAME.
				bcs RNAMERR
				ldy #0 ; VERIFY THAT BOTH NAMES HAVE SAME ROOT.
				lda (PATHNML),Y
				tay 
TSTSMROT		lda (PATHNML),Y ; COMPARE NEWNAME'S ROOT NAME WITH
				cmp (VCBPTR),Y ; OLD NAME'S VOLUME NAME.
				bne RNBADPTH ; RETURN 'BADPATH' IF NOT SAME VOLUME.
				dey 
				bpl TSTSMROT ; (TEST SAME 'ROT')
				jsr LOOKFILE ; TEST FOR DUPLICATE FILE NAME.
				bcs TSTFNF1 ; BRANCH IF ERROR TO TEST FOR FILE NOT FOUND.
				lda #DUPERR ; TELL USER THAT NEW NAME ALREADY EXISTS.
RNAMERR			sec
				rts 
* PAGE
TSTFNF1			cmp #FNFERR ; WAS IT A VALID FILE NOT FOUND?
				bne RNAMERR ; NO, RETURN OTHER ERROR CODE.
				ldx #2 ; NOW MOVE NEW NAME'S OWNERSHIP (DIRECTORY HEADER) I.D.
SVENEWID		lda D.DEV,X ; THIS CONSISTS OF THE UNIT NUMBER,
				sta NPATHDEV,X ; AND THE ADDRESS OF THE DIRECTORY THE FILE
				dex ; WASN'T FOUND IN. LOGIC BY NEGATION...
				bpl SVENEWID
				jsr SETPATH ; NOW SYNTAX THE PATHNAME OF THE FILE TO BE CHANGED.
				bcs RNAMERR
				jsr FINDFILE ; GET ALL THE INFO ON THIS ONE.
				bcs RNAMERR
				jsr TSTOPEN ; DON'T ALLOW RENAME TO OCCUR IF FILE IS IN USE.
				lda #FILBUSY ; ANTICIPATE ERROR
				bcs RNAMERR
				lda DFIL+D.ATTR ; TEST BIT THAT SAYS IT'S OK TO RENAME
				and #RENAMEN
				bne RNAME1 ; BRANCH IF IT'S ALRIGHT TO RENAME.
				lda #ACCSERR ; OTHERWISE REPORT ILLEGAL ACCESS.
				sec 
				rts 
*
RNAME1			ldx #2 ; NOW TEST TO SEE IF NEW PATHNAME FITS IN THE
SAMOWNR			lda D.DEV,X ; SAME DIRECTORY FILE.
				cmp NPATHDEV,X
				beq RNAME2
RNBADPTH		lda #BADPATH ; TELL USER THAT PATHNAMES INCOMPATABLE.
				sec 
				rts 
*
RNAME2			dex ; TEST ALL THREE BYTES.
				bpl SAMOWNR
				jsr RENPATH ; WELL... SINCE BOTH NAMES WOULD GO INTO THE
				bcs RNAMERR ; DIRECTORY, RE-SYNTAX THE NEW NAME TO GET LOCAL NAME ADDRESS.
				tya ; (Y CONTAINS THE LOCAL NAME LENGTH+1)
				beq RNBADPTH ; REPORT ERROR IF LENGTH INFO NOT IMMEDIATELY AVAILABLE.
				dey ; (REMOVE THE +1)
RNAME3			lda (WRKPATH),Y ; MOVE LOCAL NAME TO DIR ENTRY WORKSPACE.
				sta DFIL+D.STOR,Y
				dey 
				bne RNAME3
				lda DFIL+D.STOR ; PRESERVE FILE STORAGE TYPE.
				and #$F0 ; STRIP OFF OLD NAME LENGTH.
				tax 
				ora (WRKPATH),Y ; ADD IN NEW NAME'S LENGTH
				sta DFIL+D.STOR
				cpx #DIRTYP*16 ; THAT FILE MUST BE CHANGED ALSO.
				bne RNAMDONE ; BRANCH IF NOT DIRECTORY TYPE.
* PAGE
				lda DFIL+D.FRST ; READ IN FIRST (HEADER) BLOCK OF SUB DIRECTORY
				sta BLOKNML
				lda DFIL+D.FRST+1
				sta BLOKNMH
				jsr RDGBUF
				bcs RNAMERR ; REPORT ERRORS
				ldy #0 ; CHANGE THE HEADER'S NAME TO MATCH THE OWNER'S NEW NAME.
				lda (WRKPATH),Y ; GET LOCAL NAME LENGTH AGAIN
				tay 
				ora #HEDTYP*16 ; ASSUME IT'S A HEADER.
				jsr MVROTNAM
				bcs RNAMERR
RNAMDONE		jmp DREVISE1 ; END BY UPDATING ALL PATH DIRECTORIES
*
*

MVROTNAM		sta GBUF+4
MVHEDNAM		lda (WRKPATH),Y
				sta GBUF+4,Y
				dey 
				bne MVHEDNAM
				jmp WRTGBUF ; WRITE CHANGED HEADER BLOCK.
*
*
RENPATH			lda C.NWPATH ; GET ADDRESS TO NEW PATHNAME.
				sta TPATH
				lda C.NWPATH+1 ; SET UP FOR SYNTAXING ROUTINE (SYNPATH).
				sta TPATH+1
				lda SSNWPATH ; (MOVE BYTE FOR SISTER PAGE, TOO.)
				sta SISTPATH
				jmp SYNPATH ; GO SYNTAX IT. (RETURNS LAST LOCAL NAME LENGTH IN Y).
*
*
DEALBLK			ldy #0 ; BEGIN AT THE BEGINNING.
DALBLK1			sty SAPTR ; SAVE CURRENT INDEX.
				lda GBUF,Y ; GET ADDRESS (LOW) OF BLOCK TO BE DEALLOCATED.
				cmp GBUF+$100,Y ; TEST FOR NUL BLOCK.
				bne DALBLK2 ; BRANCH IF NOT NUL.
				cmp #0
				beq DALBLK3 ; SKIP IT IF NUL.
DALBLK2			ldx GBUF+$100,Y ; GET THE REST OF THE BLOCK ADDRESS.
				jsr DEALLOC ; FREE IT UP ON VOLUME BIT MAP.
				bcs DALBLKERR ; RETURN ANY ERROR.
				ldy SAPTR ; GET INDEX TO SAPLING LEVEL INDEX BLOCK AGAIN.
DALBLK3			iny ; POINT AT NEXT BLOCK ADDRESS.
				bne DALBLK1 ; BRANCH IF MORE TO DEALLOCATE (OR TEST).
				clc ; INDICATE NO ERROR.
DALBLKERR		rts
*
*
* PAGE
*
DESTROY			jsr FINDFILE ; LOOK FOR FILE TO BE WIPED OUT.
				bcs DESTERR ; PASS BACK ANY ERROR.
				jsr TSTOPEN ; IS THIS FILE OPEN?
				lda TOTENT
				beq DSTROY1 ; BRANCH IF FILE NOT OPEN.
				lda #FILBUSY
				sec ; INFORM USER THAT FILE CAN'T BE DESTORYED AT THIS TIME.
				rts 
*
DSTROY1			lda #0 ; FORCE PROPER FREE COUNT IN VOLUME.
				sta REQL ; (NO DISK ACCESS OCCURS IF ALREADY PROPER)
				sta REQH
				jsr TSFRBLK
				bcc DSTROY2
				cmp #OVRERR ; WAS IT JUST A FULL DISK?
				sec 
				bne DESTERR ; NOPE, REPORT ERROR.
*
DSTROY2			lda DFIL+D.ATTR ; MAKE SURE IT'S OK TO DESTROY THIS FILE.
				and #DSTROYEN
				bne DSTROY3 ; BRANCH IF OK.
				lda #ACCSERR ; TELL USER IT'S NOT KOSHER.
				jsr SYSERR ; (RETURNS TO CALLER OF DESTORY)
*
DSTROY3			jsr TWRPROT1 ; BEFORE GOING THRU DEALLOCATION,
				bcs DESTERR ; TEST FOR WRITE PROTECTED HARDWARE.
				lda DFIL+D.STOR ; FIND OUT WHICH STORAGE TYPE.
				and #$F0 ; STRIP OFF NAME LENGTH.
				cmp #TRETYP+1*$10 ; IS IT A SEED, SAPLING, OR TREE?
				bcc DSTREE ; BRANCH IF IT IS.
				jmp DSTDIR ; OTHERWISE TEST FOR DIRECTORY DESTROY.
*
DSTREE			jsr GTTINDX ; GET A BIT MAP BUFFER AND TEMPORARY INDEX BUFFER.
				bcs DESTERR
				lda DFIL+D.STOR ; GET STORAGE TYPE AGAIN
				and #$F0
				cmp #TRETYP*$10 ; IS THIS A TREE (FULL 2-LEVEL)?
				bne DSTSAP ; NO, TEST FOR SAPLING.
				jsr RDFRST ; READ IN ROOT INDEX FOR THIS FILE.
				bcc DSTRE2 ; BRANCH IF ALL IS WELL.
DESTERR			rts ; OTHERWISE RETURN ERROR.
*
DSTSAP			cmp #SAPTYP*$10 ; IS IT A SAPLING
				bne DSTLAST ; NO, JUST DEALLOCATE FIRST (AND ONLY) BLOCK.
				jsr ZTMPIDX ; CLEAR OUT TEMPORARY INDEX BUFFER.

				lda DFIL+D.FRST ; MAKE THIS SAP LOOK LIKE A TREE...
				ldy #0 ; THIS IS DONE BY PLACING THE FIRST BLOCK ADDRESS
				sta (TINDX),Y ; IN THE TEMP (TOP) INDEX BUFFER AS
				inc TINDX+1
				lda DFIL+D.FRST+1 ; A SUB INDEX WOULD APPEAR.
				sta (TINDX),Y
				dec TINDX+1
DSTRE2			ldy #0 ; BEGIN SCAN OF TOP LEVEL INDEX AT ZERO.
DSTNXT			sty TREPTR ; SAVE POINTER TO TREE LEVEL.
				lda (TINDX),Y ; GET BLOCK ADDRESS OF A SUB INDEX BLOCK
				inc TINDX+1 ; (TEST FOR NUL BLOCK)
				cmp (TINDX),Y
				bne DSTRE3 ; BRANCH IF WE'VE GOT AN BLOCK TO DEALLOCATE.
				cmp #0 ; IS ENTIRE ADDRESS ZERO?
				beq DSTRE4 ; YES, DO NEXT. (CARRY SET)
DSTRE3			clc ; INDICATE THERE IS A BLOCK OF INDEXES TO FREE UP.
				sta BLOKNML
				lda (TINDX),Y ; GET HI ADDRESS TOO.
				sta BLOKNMH
DSTRE4			dec TINDX+1 ; (RESTORE PROPER ADDRESS FOR BUFFER)
				bcs DSTNXT1 ; BRANCH IF NO SUB INDEX.
				jsr RDGBUF ; USE GENERAL BUFFER FOR SUB INDEX BUFFER.
				bcs DESTERR
				jsr DEALBLK ; GO FREE UP BLOCKS IN SUB INDEX
				bcs DESTERR
				ldy TREPTR ; AND FREE UP SUB INDEX BLOCK TOO.
				inc TINDX+1
				lda (TINDX),Y
				tax 
				dec TINDX+1
				lda (TINDX),Y
				jsr DEALLOC
				bcs DESTERR
				ldy TREPTR
DSTNXT1			iny ; HAVE ALL SUB INDEXES BEEN LOCATED?
				bne DSTNXT ; NO, DO NEXT...
DSTLAST			lda DFIL+D.FRST ; DEALLOCATE FIRST BLCOK OF FILE.
				ldx DFIL+D.FRST+1
				jsr DEALLOC
				bcs DESTERR
				lda #0 ; UPDATE DIRECTORY TO FREE ENTRY SPACE.
				sta DFIL+D.STOR
				cmp H.FCNT ; FILE ENTRY WRAP?
				bne DST1 ; BRANCH IF NO CARRY ADJUSTMENT
				dec H.FCNT+1 ; TAKE CARRY FROM HIGH BYTE OF FILE ENTRIES
DST1			dec H.FCNT ; MARK HEADER WITH ONE LESS FILE
				ldx BMTAB ; UPDATE (LAST) BITMAP.
				jsr BMAPUP
				bcs DESTERR
				ldy #VCBTFRE
				lda DFIL+D.USAGE
				adc (VCBPTR),Y
				sta (VCBPTR),Y ; UPDATE CURRENT FREE BLOCK COUNT.
				iny 
				lda DFIL+D.USAGE+1
				adc (VCBPTR),Y
				sta (VCBPTR),Y
				lda #0 ; FORCE RESCAN FROM FIRST BITMAP
				ldy #VCBCMAP
				sta (VCBPTR),Y
				jmp DREVISE ; UPDATE DIRECTORY LAST...
*
* PAGE
*
DSTDIR			cmp #DIRTYP*16 ; IS THIS A DIRECTORY FILE?
				beq DSDIR1 ; YES, PROCEED.
				lda #CPTERR ; FILE IS NOT COMPATABLE.
				jsr SYSERR ; GIVE UP.
*
DSDIR1			jsr FNDBMAP ; MAKE SURE A BUFFER IS AVAILABLE FOR THE BITMAP.
				bcs DSDIRERR
				lda DFIL+D.FRST ; READ IN FIRST BLOCK OF DIRECTORY INTO GBUF.
				sta BLOKNML
				lda DFIL+D.FRST+1
				sta BLOKNMH
				jsr RDGBUF
				bcs DSDIRERR
				lda GBUF+HCENT+4 ; FIND OUT IF ANY FILES EXIST ON THIS DIRECTORY.
				bne DSDIRACC ; BRANCH IF ANY EXIST.
				lda GBUF+HCENT+5
				beq DSDIR2

DSDIRACC		lda #ACCSERR
				jsr SYSERR
*
DSDIR2			lda GBUF+2 ; GET FORWARD LINK.
				cmp GBUF+3 ; TEST FOR NO LINK.
				bne DSDIR3
				cmp #0
				beq DSTLAST ; IF NO LINK, THEN FINISHED.
DSDIR3			ldx GBUF+3
				jsr DEALLOC ; FREE THIS BLOCK.
				bcs DSDIRERR
				lda GBUF+2
				sta BLOKNML
				lda GBUF+3
				sta BLOKNMH ; READ IN LINKED BLOCK.
				jsr RDGBUF
				bcc DSDIR2 ; LOOP UNTIL ALL ARE FREED.
DSDIRERR		rts
*
*
* PAGE
WORKSPC			.eq *
V.STATUS		.bs 1 ; VOLUME STATUS, INCLUDES 'ACTIVE' IN BIT 7
H.CREDT			.bs 2 ; DIRECTORY CREATION DATE
				.bs 2 ; DIRECTORY CREATION TIME
				.bs 1 ; VERSION UNDER WHICH THIS DIRECTORY WAS CREATED
				.bs 1 ; EARLIEST VERSION THAT IT'S COMPATABLE WITH
H.ATTR			.bs 1 ; ATTRIBUTES (PROTECT BIT, ETC.)
H.ENTLN			.bs 1 ; LENGTH OF EACH ENTRY IN THIS DIRECTORY.
H.MAXENT		.bs 1 ; MAXIMUM NUMBER OF ENTRIES PER BLOCK
H.FCNT			.bs 2 ; CURRENT NUMBER OF FILES IN THIS DIRECTORY
				.bs 2 ; ADDRESS OF FIRST ALLOCATION BIT MAP
				.bs 2 ; TOTAL NUMBER OF BLOCKS ON THIS UNIT
				.bs 5 ; (FOR FUTURE EXPANSION)
*
D.DEV			.bs 1 ; DEVICE NUMBER OF THIS DIRECTORY ENTRY
D.HEAD			.bs 2 ; ADDRESS OF <SUB> DIRECTORY HEADER
D.ENTBLK		.bs 2 ; ADDRESS OF BLOCK WHICH CONTAINS THIS ENTRY
D.ENTNUM		.bs 1 ; ENTRY NUMBER WITHIN BLOCK.
DFIL			.eq *
D.STOR			.eq *-DFIL ; STORAGE TYPE * 16 + FILE NAME LENGTH
				.bs 1
; *-DFIL ; FILE NAME
				.bs 15
D.FILID			.eq *-DFIL ; USER'S IDENTIFICATION BYTE
				.bs 1
D.FRST			.eq *-DFIL ; FIRST BLOCK OF FILE
				.bs 2
D.USAGE			.eq *-DFIL ; NUMBER OF BLOCKS CURRENTLY ALLOCATED TO THIS FILE
				.bs 2
D.EOF			.eq *-DFIL ; CURRENT END OF FILE MARKER
				.bs 3
D.CREDT			.eq *-DFIL ; DATE OF FILE'S CREATION
				.bs 2
; *-DFIL ; TIME OF FILE'S CREATION
				.bs 2
; EQU *-DFIL ; SOS VERSION THAT CREATED THIS FILE
				.bs 1
D.COMP			.eq *-DFIL ; BACKWARD VERSION COMPATABILTY
				.bs 1
D.ATTR			.eq *-DFIL ; 'PROTECT', READ/WRITE 'ENABLE' ETC.
				.bs 1
D.AUXID			.eq *-DFIL ; USER AUXILLARY IDENTIFACATION
				.bs 2
D.MODDT			.eq *-DFIL ; FILE'S LAST MODIFICATION DATE
				.bs 2
D.MODTM			.eq *-DFIL ; FILE'S LAST MODIFICATION TIME
				.bs 2
D.DHDR			.eq *-DFIL ; HEADER BLOCK ADDRESS OF FILE'S DIRECTORY
				.bs 2
*
CMDADR			.bs 2
SCRTCH			.bs 13 ; SCRATCH AREA FOR ALLOCATION ADDRESS CONVERSION
OLDEOF			.bs 3 ; TEMP USED IN W/R
OLDMARK			.bs 3 ; USED BY 'RDPOSN' AND 'WRITE'
SCRHIGH			.eq <SCRTCH ; AND DEVICE NUMBERS FROM BOB'S CODE.
*
* CHN SWAPOUT/IN,4,2

*************************************************************************
* END OF APPLE /// SOS 1.3 SOURCE CODE FILE: DESTROY

*************************************************************************




*--------------------------------------
MAN
SAVE /A3OSX.BUILD/SOS/SOS.S.DESTROY
LOAD /A3OSX.BUILD/SOS/SOS.S
ASM
