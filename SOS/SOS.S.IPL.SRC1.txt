NEW
AUTO 3,1
*--------------------------------------

*************************************************************************
* APPLE /// SOS 1.3 SOURCE CODE FILE: IPL.SRC1
*************************************************************************
* ASSEMBLER: APPLE ][ 6502 ASSEMBLER from APPLE COMPUTER TOOLKIT

*				.TI "SOS 1.1 INTRPTS. & PROC. LAUNCH"
* REL
* INCLUDE SOSORG,6,1,254
				.ph ORGIPL FIXME: check if we need this
ZZORG			.eq *
* FIXME - MSB OFF
* REP 60
* COPYRIGHT (C) APPLE COMPUTER INC. 1980
* ALL RIGHTS RESERVED
* REP 60
*
* THIS MODULE IS RESPONSIBLE FOR FIELDING ALL INTERRUPTS
* AND RELAUNCHING THE INTERRUPTED CODE AFTER THE INTERRUPTS
* HAVE BEEN PROCESSED. THE MAJOR FUNCTIONAL AREAS ARE:
*
* GENERAL INTERRUPT RECEIVER
* NMI INTERRUPT RECEIVER
* DISPATCHER
* INTERRUPT ALLOCATION & DEALLOCATION
* EVENT QUEUE MANAGER
* TABLE INITIALIZATION
*
* REP 60
*
* SUBROUTINE ENTRY POINTS
*
* ENTRY IRQ.RCVR ;GENERAL INTERRUPT RECEIVER
* ENTRY NMI.RCVR ;NON-MASKABLE INTRPT RCVR
* ENTRY DISPATCH ;DISPATCHER
* ENTRY ALLOCSIR ;SIR ALLOCATION
* ENTRY DEALCSIR ;SIR DEALLOCATION
* ENTRY SELC800 ;SELECT I/O EXPANSION ROM
* ENTRY NMIDSBL ;DISABLE NMI
* ENTRY NMIENBL ;ENABLE NMI
* ENTRY NMIDBUG ;NMI DEBUG ENTRY
* ENTRY NMICONT ;NMI DEBUG CONTINUATION
* ENTRY QUEEVENT ;QUEUE AN EVENT
*
* EXTERNAL SUBROUTINES & DATA
*
* EXTRN SCMGR
* EXTRN CHKBUF
*
* SYSTEM DEATH ERRORS
*
* EXTRN SYSDEATH
* EXTRN BADBRK
* EXTRN BADINT1
* EXTRN BADINT2
* EXTRN NMIHANG
* EXTRN EVQOVFL
* EXTRN STKOVFL
*
* LINKAGE DATA FOR INITIALIZATION ROUTINES
*
* ENTRY EV.QUEUE
* ENTRY EVQ.CNT
* ENTRY EVQ.SIZ
* ENTRY EVQ.LEN
* ENTRY EVQ.FREE
* ENTRY EVQ.LINK
* ENTRY SIRTABLE
* ENTRY SIRTBLSIZ
* ENTRY ZPGSTACK
* ENTRY ZPGSTART
*
* SYSGLOB DATA
*
* EXTRN SERR
* EXTRN CEVPRI ;CALLER'S EVENT PRIORITY
* EXTRN SYSBANK ;SYSTEM BANK

* EXTRN KYBDNMI
* EXTRN NMISPSV
* EXTRN NMIFLAG ;NMI PENDING FLAG
* EXTRN SCRNMODE ;CURRENT SCREEN MODE
* EXTRN SIRTEMP ;FOR ALLOCSIR & DEALCSIR
* EXTRN SIRARGSIZ
* EXTRN IRQCNTR ;FLASE IRQ COUNTER
* EXTRN NMICNTR ;TWO BYTE COUNTER
* EXTRN QEVTEMP
* EXTRN QEV.THIS
* EXTRN QEV.LAST
* EXTRN BACKMASK
*
* CONSTANT DECLARATIONS
*
FALSE			.eq $00
BITON0			.eq $01
BITON1			.eq $02
BITON2			.eq $04
BITON4			.eq $10
BITON5			.eq $20
BITON6			.eq $40
BITON7			.eq $80
BITOFF3			.eq $F7
BITOFF4			.eq $EF
BITOFF5			.eq $DF
BITOFF6			.eq $BF
BITOFF7			.eq $7F
BACKBIT			.eq $20 ; BACKUP BIT MASK
*
* SYSTEM CONTROL REGISTERS
*
B.REG			.eq $FFEF ;BANK REGISTER
E.REG			.eq $FFDF ;ENVIRONMENT REGISTER
Z.REG			.eq $FFD0 ;ZERO PAGE REGISTER
*
* 6522 REGISTERS
*
D.IFR			.eq $FFDD
D.IER			.eq $FFDE
E.IORB			.eq $FFE0
E.IFR			.eq $FFED
E.IER			.eq $FFEE
E.IORA			.eq $FFEF
* PAGE
*
* REGISTER PRESERVATION EQUATES
* FOR USE DURING INTERRUPT PROCESSING
*
A.SAVE			.eq $103
S.SAVE			.eq $104
SP.SAVE			.eq $1FF
E.SAVE			.eq $1FE
Z.SAVE			.eq $1FD
B.SAVE			.eq $1FC
EXPNSLOT		.da 00 ;CURRENT I/O EXPANSION SLOT
*
* STATUS LOCATIONS FOR INTERRUPT POLLING
*
ACIASTAT		.eq $C0F1
ANYSLOT			.da BITON1
SLOT1			.eq $C065
SLOT2			.eq $C064
SLOT3			.da BITON5
SLOT4			.da BITON4
*
* INTERRUPT ZERO PAGE STORAGE & EQUATES
*
SIRARGS			.eq $F9 ;AND $FA
QEVARGS			.eq $FB ;AND $FC
IRQADDR			.eq $FD ;AND $FE
ZPGSP			.eq $FF
ZPGSTART		.eq $F8
ZPGSTOP			.eq $28
ZPGSPACE		.eq $20
ZPGSTACK		.da ZPGSTART
*
* SYSTEM INTERNAL RESOURCE
* TABLE STORAGE AND EQUATES
*
SIRTBLSIZ		.eq $18

SIRTABLE		.bs SIRTBLSIZ
SIRADR.L		.bs SIRTBLSIZ
NMIADR.L		.bs 1 ;MUST PRECEED SIRADR.H
SIRADR.H		.bs SIRTBLSIZ
SIRADR.B		.bs SIRTBLSIZ
*
* EVENT QUEUE STORAGE AND EQUATES
*
EVQ.SIZ			.eq 6 ;ENTRY SIZE
EVQ.CNT			.eq $07 ;ENTRY COUNT
EVQ.LEN			.eq $2A ;(EVQ.SIZ*EVQ.CNT)
EV.QUEUE		.bs EVQ.LEN
EVQ.FREE		.eq EV.QUEUE+2 ;FIRST FREE ENTRY INDEX
EVQ.LINK		.eq EV.QUEUE+0 ;NEXT ACTIVE ENTRY INDEX
EVQ.PRI			.eq EV.QUEUE+1 ;EVENT PRIORITY
EVQ.ID			.eq EV.QUEUE+2 ;EVENT IDENTIFICATION
EVQ.ADRL		.eq EV.QUEUE+3 ;EVENT ADDRESS: LOW BYTE
EVQ.ADRH		.eq EV.QUEUE+4 ;EVENT ADDRESS: HIGH BYTE
EVQ.BANK		.eq EV.QUEUE+5 ;EVENT ADDRESS: BANK
*				.TI "GENERAL INTERRUPT RECEIVER"
* REP 60
*
* THIS IS THE GENERAL INTERRUPT RECEIVER. WHEN AN
* INTERRUPT OCCURS, THE CPU PASSES CONTROL TO THE GIR
* THROUGH THE IRQ VECTOR. THE GIR IS RESPONSIBLE FOR
* SAVING THE CURRENT ENVIRONMENT, SETTING UP THE SOS
* ENVIRONMENT, AND CALLING THE APPROPRIATE CODE MODULE.
* IF THE INTERRUPT WAS CAUSED BY A BRK, THE GIR CALLS
* THE SYSTEM CALL MANAGER. OTHERWISE, THE GIR POLLS THE
* I/O DEVICES AND CALLS THE APPROPRIATE MASTER INTERRUPT
* HANDLER. WHEN THE SCM OR MIH RETURNS, THE GIR PASSES
* CONTROL TO THE DISPATCHER.
*
* REP 60
*
IRQ.RCVR		.eq *
*
* SAVE CPU REGISTERS A, X, & Y ON CURRENT STACK
*
				pha 
				txa 
				pha 
				tya 
				pha 
*
* CHECK FOR STACK OVERFLOW AND
* SAVE INTERRUPTED STATUS IN Y REGISTER.
*
				tsx 
				cpx #$FA
				bcc GIR005
				lda #STKOVFL
				jsr SYSDEATH
GIR005			ldy S.SAVE,X
*
* SET UP INTERRUPT ENVIRONMENT:
* BINARY ARITHMETIC, 2 MHZ, I/O ENABLED,
* RAM WRITE ENABLED, PRIMARY STACK,
* AND $F000 RAM SELECTED. PRESERVE
* USER STATE OF SCREEN AND RESET LOCK.
*
				cld 
				lda E.REG
				tax 
				and #BITON5+BITON4
				ora #BITON6+BITON2
				sta E.REG
*
* IF NOT ALREADY ON PRIMARY STACK, SAVE USER'S STACK
* POINTER AND SET UP SOS STACK POINTER.
*
				txa 
				and #BITON2
				bne GIR010
				txa 
				tsx 
				stx SP.SAVE
				ldx #E.SAVE
				txs 
				tax 
*

* SAVE E, Z, B, & I/O EXPANSION SLOT ON SOS STACK
* IF BRK THEN CALL SCMGR ELSE POLL I/O DEVICES
*
GIR010			txa
				pha 
				lda Z.REG
				pha 
				lda B.REG
				pha 
				lda EXPNSLOT
				pha 
				bit $CFFF
				bit $C020 ;RESET I/O SPACE
				lda #$00
				sta EXPNSLOT
				tya 
				and #BITON4
				beq POLL.IO
*
* CALL SYSTEM CALL MANAGER; ON RETURN, PUT ERROR CODE IN
* USER'S A REGISTER AND SET RETURN STATUS, THEN DISPATCH.
*
				tsx ;CHECK FOR
				cpx #B.SAVE-2 ; REENTRANT
				beq GIR020 ; SYSTEM CALL
				lda #BADBRK
				jsr SYSDEATH
GIR020			lda E.REG ;SELECT $C000 RAM
				and #BITOFF6
				sta E.REG
				cli ;ENABLE INTERRUPTS
				jsr SCMGR ;CALL THE SYSTEM CALL MGR
				lda #BACKBIT ; GET THE MASK
				sta BACKMASK ; SET IT IN SYSGLOB
				jsr CHKBUF
				sei 
				ldx SP.SAVE
				lda Z.SAVE
				eor #BITON0 ;SET ZERO PAGE TO
				sta Z.REG ; CALLER'S STACK
				lda SERR
				sta >A.SAVE,X
				php 
				lda >S.SAVE,X
				and #$7D
				sta >S.SAVE,X
				pla 
				and #$82
				ora >S.SAVE,X
				sta >S.SAVE,X
				jmp DISPATCH
* PAGE
*
* SET INTERRUPT ZERO PAGE AND SOS BANK
* THEN POLL I/O DEVICES
*
POLL.IO			bit E.IORA ;VERIFY THAT 'IRQ IS LOW
				bpl PIO006
				inc IRQCNTR ;BUMP FALSE IRQ COUNTER
				bne PIO004
				inc IRQCNTR+1
PIO004			jmp DISPATCH
PIO006			lda #0 ;SET INTERRUPT ZERO PAGE
				sta Z.REG
				lda E.REG
				ora #BITON7 ;FORCE 1 MHZ FOR
				sta E.REG ; READING ACIA STATUS
				and #BITOFF7
				ldx #$01
				ldy ACIASTAT ;ANY INTERRUPT ON ACIA?
				sta E.REG
				bmi PIO070
				lda E.IFR ;ANY INTERRUPT ON E-6522?
				bpl PIO020 ; NO
				and E.IER
				ldy #7
				ldx #$02
PIO010			lsr
				bcs PIO070
				inx 
				dey 

				bne PIO010
				beq PIO035
PIO020			lda D.IFR ;ANY INTERRUPT ON D-6522?
				bpl PIO035
				and D.IER
				bit ANYSLOT ;ANY SLOT INTERRUPT?
				bne PIO040 ; YES
				ldy #7
				ldx #$09
PIO030			lsr
				bcs PIO070
				inx 
				dey 
				bne PIO030
PIO035			ldx #$10 ;INTERRUPT NOT FOUND
				bne PIO050
PIO040			ldx #$11
				bit SLOT1 ;SLOT 1?
				bpl PIO070
				inx 
				bit SLOT2 ;SLOT 2?
				bpl PIO070
				lda E.IORA
				inx 
				bit SLOT3 ;SLOT 3?
				beq PIO070
				inx 
				bit SLOT4 ;SLOT 4?
				beq PIO070
				ldx #$0A
*
* BAD INTERRUPT -- SYSTEM DEATH
*
PIO050			lda #BADINT1 ;INTERRUPT NOT FOUND
				jsr SYSDEATH
PIO060			lda #BADINT2 ;BAD ZERO PAGE ALLOCATION
				jsr SYSDEATH
*
* INTERRUPTING DEVICE FOUND
* ALLOCATE ZERO PAGE AND CALL MASTER INTERRUPT HANDLER
*
* NOTE:
* SINCE READING THE ACIA'S STATUS REGISTER RESETS THE
* DSR AND DCD BITS, THE STATUS READ BY THE POLLING
* ROUTINE MUST BE PASSED TO THE INTERRUPT HANDLER;
* THE Y REGISTER HAS BEEN SELECTED FOR THIS PURPOSE.
* THE CURRENT IMPLEMENTATION DOES NOT USE Y IN CALLING
* THE INTERRUPT HANDLER. IF SUBSEQUENT REVISIONS
* NEED TO USE Y, THE STATUS MUST BE PRESERVED AND
* RESTORED BEFORE CALLING THE INTERRUPT HANDLER.
*
CALLMIH			jmp (IRQADDR)
*
PIO070			lda SIRTABLE,X ;INTERRUPT ALLOCATED?
				bpl PIO050 ; NO
				lda SIRADR.L,X ;GET INTERRUPT ADDRESS
				sta IRQADDR
				ora SIRADR.H,X ;CHECK FOR ADDRESS = $00
				beq PIO050 ; BAD ADDRESS
				lda SIRADR.H,X
				sta IRQADDR+1
				lda SIRADR.B,X
				sta B.REG
				lda ZPGSTACK ;ALLOCATE MIH ZERO PAGE
				cmp #ZPGSTOP+ZPGSPACE
				bcc PIO060 ;TOO MANY NESTED INTERRUPTS
				sbc #ZPGSPACE
				sta ZPGSTACK
				sta ZPGSP
				tax 
				jsr CALLMIH ;CALL INTERRUPT HANDLER
				sei 
				lda #$00
				sta Z.REG
				clc 
				lda ZPGSTACK ;DEALLOCATE MIH ZERO PAGE
				adc #ZPGSPACE
				sta ZPGSTACK
				sta ZPGSP
				lda #BITON1
				sta D.IFR ;CLEAR ANY SLOT INTERRUPT

				jmp DISPATCH
*				.TI "NON-MASKABLE INTERRUPT RECEIVER"
* REP 60
*
* THIS IS THE NON-MASKABLE INTERRUPT RECEIVER. WHEN AN
* NMI OCCURS, THE CPU PASSES CONTROL TO THE NMI RECEIVER
* THROUGH THE NMI VECTOR. THE OPERATION OF THE NMI
* RECEIVER IS ESSENTIALLY THE SAME AS THE GIR EXCEPT
* THAT IT IS NOT CONCERNED WITH BRK, AND THE ONLY VALID
* SOURCE OF AN NMI IS THE KEYBOARD OR THE I/O DEVICE THAT
* HAS ALLOCATED THE NMI RESOURCE.
*
* REP 60
*
*
NMI.RCVR		.eq *
*
* SAVE CPU REGISTERS A, X, & Y ON CURRENT STACK
*
				pha 
				txa 
				pha 
				tya 
				pha 
*
* CHECK FOR STACK OVERFLOW
*
				tsx 
				cpx #$FA
				bcc NMI005
				lda #STKOVFL
				jsr SYSDEATH
*
* SET UP INTERRUPT ENVIRONMENT:
* BINARY ARITHMETIC, 2 MHZ, I/O ENABLED,
* RAM WRITE ENABLED, PRIMARY STACK,
* AND $F000 RAM SELECTED. PRESERVE
* USER STATE OF SCREEN AND RESET LOCK.
*
NMI005			cld
				lda E.REG
				tax 
				and #BITON5+BITON4
				ora #BITON6+BITON2
				sta E.REG
*
* IF NOT ALREADY ON PRIMARY STACK, SAVE USER'S
* STACK POINTER AND SET UP SOS STACK POINTER.
*
				txa 
				and #BITON2
				bne NMI010
				txa 
				tsx 
				stx SP.SAVE
				ldx #E.SAVE
				txs 
				tax 
*
* SAVE SYSTEM CONTROL REGISTERS E, Z, & B ON SOS STACK
*
NMI010			txa
				pha 
				lda Z.REG
				pha 
				lda B.REG
				pha 
				lda EXPNSLOT
				pha 
				bit $CFFF
				bit $C020 ;RESET I/O SPACE
				lda #$00
				sta EXPNSLOT
*
* SET INTERRUPT ZERO PAGE
*
				lda #0
				sta Z.REG
*
* SEE IF NMI IS FROM KEYBOARD OR I/O DEVICE
*

				lda E.IORB
				bmi NMI030
*
* NMI IS FROM I/O DEVICE
*
				lda SIRTABLE ;NMI ALLOCATED?
				bpl NMI020
				jsr CALLNMI
				sei 
				jmp DISPATCH
CALLNMI			lda SIRADR.L
				sta NMIADR.L
				lda SIRADR.B
				sta B.REG
				jmp (NMIADR.L)
*
* BAD INTERRUPT -- SYSTEM DEATH
*
NMI020			lda #BADINT1 ;NMI NOT ALLOCATED
				jsr SYSDEATH
*
* NMI IS FROM THE KEYBOARD
*
NMI030			lda SYSBANK
				sta B.REG
				jsr KYBDNMI
				sei 
				jmp DISPATCH
*				.TI "DISPATCHER"
* REP 60
*
* THIS IS THE DISPATCHER. UPON COMPLETION, ALL SOS CALLS
* AND INTERRUPT HANDLERS RETURN CONTROL TO THE DISPATCHER.
* ITS PURPOSE IS TO SET UP THE APPROPRIATE ENVIRONMENT AND
* PASS CONTROL TO WHATEVER CODE SHOULD RUN NEXT.
*
* WHEN SOS IS INTERRUPTED, CONTROL ALWAYS RETURNS TO THE
* INTERRUPTED CODE. HOWEVER, WHEN THE USER IS INTERRUPTED,
* BY EITHER A SOS CALL OR AN INTERRUPT, THE DISPATCHER
* MUST CHECK THE EVENT QUEUE. IF THERE IS AN ACTIVE EVENT
* WITH A PRIORITY HIGHER THAN THE CURRENT EVENT FENCE,
* CONTROL IS PASSED TO THE EVENT CODE. OTHERWISE, CONTROL
* RETURNS TO THE INTERRUPTED CODE.
*
* REP 60
*
DISPATCH		.eq *
*
* DISABLE INTERRUPTS AND RESTORE
* SYSTEM CONTROL REGISTERS B & Z
*
				sei 
				lda E.REG
				ora #BITON6 ;ENABLE I/O
				sta E.REG
				pla 
				jsr SELC800 ;RESTORE I/O SPACE
				pla 
				sta B.REG
				pla 
				sta Z.REG
*
* CHECK SAVED ENVIRONMENT REGISTER
* IF RETURNING TO PRIMARY STACK
* THEN RESTORE E REG AND RELAUNCH SOS
* ELSE RESET STACK POINTER & RESTORE E REG
*
				pla 
				ora #BITON5 ;SET SCREEN STATE TO
				bit SCRNMODE ; CURRENT SCREEN MODE
				bmi DSP005
				and #BITOFF5
DSP005			tay
				and #BITON2
				beq DSP010
				sty E.REG
				bne DSP030
DSP010			pla
				tax 
				txs 
				sty E.REG

*
* CHECK FOR ACTIVE EVENT WITH PRIORITY > FENCE
*
DSP020			lda CEVPRI
				ldx EVQ.LINK
				cmp EVQ.PRI,X
				bcs DSP030
*
* PROCESS ACTIVE EVENT TRAP
* SAVE E, Z, B, & CALLER'S PRIORITY ON STACK THEN CALL
* EVENT. UPON RETURN, RESTORE PRIORITY, B, Z, & E THEN
* CHECK FOR MORE EVENTS.
*
				lda E.REG
				pha 
				lda Z.REG
				pha 
				lda B.REG
				pha 
				lda CEVPRI
				pha 
				jsr DO.EVENT
				sei 
				pla 
				sta CEVPRI
				pla 
				sta B.REG
				pla 
				sta Z.REG
				pla 
				ora #BITON5 ;SET SCREEN STATE TO
				bit SCRNMODE ; CURRENT SCREEN MODE
				bmi DSP025
				and #BITOFF5
DSP025			sta E.REG
				jmp DSP020
*
* RESTORE CPU REGISTERS Y, X, & A AND LAUNCH
*
DSP030			pla
				tay 
				pla 
				tax 
				pla 
				rti 
* PAGE
* REP 60
*
* THIS SUBROUTINE CALLS THE HIGHEST PRIORITY ACTIVE EVENT.
* FIRST, IT DELINKS THE FIRST ENTRY ON THE ACTIVE LIST AND
* LINKS IT TO THE FREE LIST. THEN, IT SETS UP THE BANK,
* ADDRESS, ID, & STATUS AND CALLS THE EVENT VIA AN RTI.
*
* REP 60
*
DO.EVENT		.eq *
*
* WRITE ENABLE RAM
*
				ldy E.REG
				tya 
				and #BITOFF3
				sta E.REG
*
* DELINK ENTRY FROM ACTIVE LIST AND RELINK IT TO FREE LIST
*
				ldx EVQ.LINK
				lda EVQ.LINK,X
				sta EVQ.LINK
				lda EVQ.FREE
				sta EVQ.LINK,X
				stx EVQ.FREE
*
* SET FENCE TO EVENT PRIORITY THEN RESTORE E REG
*
				lda EVQ.PRI,X
				sta CEVPRI
				sty E.REG
*
* SET UP B, Z, E, ADDRESS, ID, & STATUS
*

				lda EVQ.BANK,X
				sta B.REG
				lda EVQ.ADRH,X
				pha 
				lda EVQ.ADRL,X
				pha 
				ldy EVQ.ID,X
				php 
				pla 
				and #$82
				pha 
				tya 
				rti 

* CHN IPL.SRC2

*************************************************************************
* END OF APPLE /// SOS 1.3 SOURCE CODE FILE: IPL.SRC1
*************************************************************************





*--------------------------------------
MAN
SAVE /A3OSX.BUILD/SOS/SOS.S.IPL.SRC1
LOAD /A3OSX.BUILD/SOS/SOS.S
ASM
