NEW
AUTO 3,1
*--------------------------------------

*************************************************************************
* APPLE /// SOS 1.3 SOURCE CODE FILE: CFMGR.SRC
*************************************************************************
* ASSEMBLER: APPLE ][ 6502 ASSEMBLER from APPLE COMPUTER TOOLKIT

*				.TI "SOS 1.1 CHARACTER FILE MANAGER"
* REL
* INCLUDE SOSORG,6,1,254
				.ph ORGCFM FIXME: check if we need this
ZZORG			.eq *
* FIXME - MSB OFF
* REP 60
* COPYRIGHT (C) APPLE COMPUTER INC. 1980
* ALL RIGHTS RESERVED
* REP 60
*
* CHARACTER FILE MANAGER (VERSION = 1.1O )
* (DATE = 8/04/81)
*
* THIS MODULE TRANSFORMS CHARACTER FILE SYSTEM CALLS INTO
* DEVICE CALLS TO THE APPROPRIATE DEVICE HANDLER. ONLY
* OPEN, NEWLINE, READ, WRITE AND CLOSE CALLS ARE PERMITTED
* ON CHARACTER FILES.
*
* REP 60
*
* ENTRY CFMGR
*
* ENTRY CFCB.MAX
* ENTRY CFCB.DEV
*
* EXTRN DMGR
* EXTRN LEVEL
* EXTRN MAX.DNUM
* EXTRN SXPAGE
*
* EXTRN SYSERR
* EXTRN SERR
* EXTRN BADSCNUM
* EXTRN CFCBFULL
* EXTRN BADREFNUM
* EXTRN FNFERR
* PAGE
* REP 60
*
* DATA DECLARATIONS
*
* REP 60
*
* FILE CALL PARM LOCATIONS ON SOS ZPAGE
*
F.TPARMX		.eq $A0
REQCODE			.eq F.TPARMX
O.PATH			.eq F.TPARMX+1 ; OPEN'S PATHNAME LOC
O.REFNUM		.eq F.TPARMX+3 ; OPEN'S REFNUM LOC
REFNUM			.eq F.TPARMX+1 ; REFNUM'S LOC IN OTHER CALLS
NL.ISNL			.eq F.TPARMX+2 ; NEWLINE'S ISNEWLINE LOC
NL.NLCHR		.eq F.TPARMX+3 ; NEWLINE'S NEWLINECHAR LOC
RW.BUF			.eq F.TPARMX+2 ; READ/WRITE'S BUF LOC
RW.BYTES		.eq F.TPARMX+4 ; READ/WRITE'S BYTES LOC
RD.BYTESRD		.eq F.TPARMX+6 ; READ'S BYTESREAD LOC
*
* FILE REQUEST CODE VALUES
*
OPEN			.eq 8
NEWLINE			.eq 9
READ			.eq $A
WRITE			.eq $B
CLOSE			.eq $C
* PAGE
* DEVICE CALL PARM LOCATIONS ON SOS ZPAGE
*
D.TPARMX		.eq $C0
D.SCNUM			.eq D.TPARMX ; DEVICE SYS CALL # LOC
GDN.DNAME		.eq D.TPARMX+1 ; GETDEVNUM DNAME LOC
GDN.DNUM		.eq D.TPARMX+3 ; GETDEVNUM DNUM LOC

D.DNUM			.eq D.TPARMX+1 ; OPN/CLOSE/RD/WR/CTRL'S DNUM LOC
DRW.BUF			.eq D.TPARMX+2 ; RD/WR'S BUF LOC
DRW.BYTES		.eq D.TPARMX+4 ; RD/WR'S BYTES LOC
DRD.BYTESRD		.eq D.TPARMX+8 ; RD/WR'S BYTESREAD LOC
DC.CCODE		.eq D.TPARMX+2 ; DCTRL'S CTRLCODE LOC
DC.CLIST		.eq D.TPARMX+3 ; DCTRL'S CTRLLIST LOC
*
* DEVICE REQUEST CODE VALUES
*
DREAD			.eq $0
DWRITE			.eq $1
DCTRL			.eq $3
GETDEVNUM		.eq $4
DOPEN			.eq $6
DCLOSE			.eq $7
*
CTRL.LIST		.bs 2 ; CONTAINER FOR NEWLINE DCTRL CALL
NEWLINECC		.eq 2 ; NEWLINE CTRL CODE
*
* GETDNUM VARS
*
DNUM.TEMP		.bs 1
*
* CLOSEALL VARS
*
DCLOSE.ERR		.eq F.TPARMX+$F
DCLOSE.TBL		.eq $200
TRUE			.eq $80
FALSE			.eq $0
*
*
* REP 60
*
* CHARACTER FILE CONTROL BLOCK TABLE
* (ENTRY 0 IS NOT USED)
*
* REP 60
CFCB.MAX		.eq 17
CFCB.DEV		.bs CFCB.MAX
CFCB.LVL		.bs CFCB.MAX
* PAGE
* REP 60
*
* CHARACTER FILE MANAGER - MAIN ENTRY POINT
*
* REP 60
CFMGR			.eq *
*
* SWITCH, BASED ON REQUEST CODE
*
				lda REQCODE
				cmp #OPEN
				beq CFOPEN ; "OPEN"
				cmp #NEWLINE
				beq CFNEWLINE ; "NEWLINE"
				cmp #READ
				beq CFREAD ; "READ"
				cmp #WRITE
				bne CFM010
				jmp CFWRITE ; "WRITE"
CFM010			cmp #CLOSE
				bne CFM020
				jmp CFCLOSE ; "CLOSE"
CFM020			lda #BADSCNUM
				jsr SYSERR ; ERR EXIT
* PAGE
* REP 60
* OPEN(IN.PATHNAME; OUT.REFNUM; IN.OPENLIST,LENGTH) SYSTEM CALL
* REP 60
CFOPEN			.eq * ; BUILD "D.OPEN" CALL
				jsr GETDNUM ; MAP PATH TO DEV#
				bcs CFOP.ERR1 ; ERR - FILE NOT FOUND
				sta D.DNUM
*
				jsr REQ.CFCB ; BUILD NEW CFCB ENTRY
				bcs CFOP.ERR1 ; ERR - CFCB FULL
				ldx #0
				sta (O.REFNUM,X) ; RETURN REFNUM TO CALLER
				cpy #1
				bne CFOP.EXIT ; DEVICE ALREADY OPEN
*

				lda #DOPEN
				sta D.SCNUM
				jsr DMGR ; DOPEN CALL
				bcs CFOP.ERR
CFOP.EXIT		rts ; NORMAL EXIT
*
CFOP.ERR		lda SERR ;KLUDGE - 1.0 DRIVERS DON'T SUPPORT CARRY ERR PROTOCOL
				beq CFOP.EXIT ;NO ERROR
				ldx #0 ; RELEASE CFCB ENTRY
				lda (O.REFNUM,X)
				jsr REL.CFCB
CFOP.ERR1		rts ; ERR EXIT
* PAGE
* REP 60
* NEWLINE(IN.REFNUM,IS .NEWLINE,NEWLINE.CHAR) SYSTEM CALL
* REP 60
CFNEWLINE		.eq * ; BUILD "D.CONTROL" CALL
				lda #DCTRL
				sta D.SCNUM
				lda REFNUM
				jsr GET.CFCB ; MAP REFNUM TO DEV #
				bcs CFNL.ERR ; ERR - BAD REFNUM
*
				sta D.DNUM
				lda #NEWLINECC
				sta DC.CCODE
*
				lda #CTRL.LIST
				sta DC.CLIST
				lda /CTRL.LIST
				sta DC.CLIST+1
				lda #0
				sta SXPAGE+DC.CLIST+1
*
				lda NL.ISNL
				sta CTRL.LIST
				lda NL.NLCHR
				sta CTRL.LIST+1
*
				jsr DMGR ; DCONTROL CALL
				rts ; NORMAL EXIT
*
CFNL.ERR		rts ; ERR EXIT
* PAGE
* REP 60
* READ(IN.REFNUM,BUF,BYTES,BYTESREAD) SYSTEM CALL
* REP 60
CFREAD			.eq * ; BUILD "D.READ" CALL
				lda #DREAD
				sta D.SCNUM
				lda REFNUM
				jsr GET.CFCB ; MAP REFNUM TO DEV #
				bcs CFRD.ERR ; ERR - BAD REFNUM
*
				sta D.DNUM
				ldx #3
CFRD010			lda RW.BUF,X
				sta DRW.BUF,X
				dex 
				bpl CFRD010
*
				lda RD.BYTESRD
				sta DRD.BYTESRD
				lda RD.BYTESRD+1
				sta DRD.BYTESRD+1
*
				lda SXPAGE+RW.BUF+1
				sta SXPAGE+DRW.BUF+1
				lda SXPAGE+RW.BYTES+1
				sta SXPAGE+DRW.BYTES+1
				lda SXPAGE+RD.BYTESRD+1
				sta SXPAGE+DRD.BYTESRD+1
*
				jsr DMGR ; DREAD CALL
				rts ; NORMAL EXIT
*
CFRD.ERR		rts ; ERR EXIT
* PAGE
* REP 60
* WRITE(IN.REFNUM,BUF,BYTES) SYSTEM CALL
* REP 60

CFWRITE			.eq * ; BUILD "D.WRITE" CALL
				lda #DWRITE
				sta D.SCNUM
				lda REFNUM
				jsr GET.CFCB ; MAP REFNUM TO DEV #
				bcs CFWR.ERR ; ERR - BAD REFNUM
				sta D.DNUM
				ldx #3
CFWR010			lda RW.BUF,X
				sta DRW.BUF,X
				dex 
				bpl CFWR010
				lda SXPAGE+RW.BUF+1
				sta SXPAGE+DRW.BUF+1
				lda SXPAGE+RW.BYTES+1
				sta SXPAGE+DRW.BYTES+1
*
				jsr DMGR ; DWRITE CALL
				rts ; NORMAL EXIT
*
CFWR.ERR		rts ; ERR EXIT
* PAGE
* REP 60
* CLOSE(IN.REFNUM) SYSTEM CALL
* REP 60
CFCLOSE			.eq * ; BUILD "D.CLOSE" CALL
				lda #DCLOSE
				sta D.SCNUM
				lda REFNUM
				beq CLOSEALL
*
				jsr REL.CFCB ; RELEASE CFCB ENTRY
				bcs CFCL010
				sta D.DNUM
				tya 
				bne CFCL010
				jsr DMGR ; DCLOSE CALL
CFCL010			rts ; NORMAL EXIT
*
* PAGE
* REP 60
*
* CLOSE ALL CHARACTER FILES W/LEVELS >= TO CURRENT SYSTEM FILE LEVEL.
*
* REP 60
*
CLOSEALL		.eq *
				lda #FALSE ; SET ENTRIES IN DEV CLOSE TBL TO FALSE
				ldx MAX.DNUM
CFCL020			sta DCLOSE.TBL,X
				dex 
				bpl CFCL020
*
				ldx #CFCB.MAX-1 ; CLOSE ALL DEVICES >= TO CURRENT LEVEL
CFCL030			lda CFCB.DEV,X ; AND MARK TRUE IN DEV CLOSE TBL
				tay 
				bmi CFCL050
				lda CFCB.LVL,X
				cmp LEVEL
				bcc CFCL050
				lda #TRUE
				sta DCLOSE.TBL,Y
				sec 
				ror CFCB.DEV,X
CFCL050			dex
				bne CFCL030
*
				ldx #CFCB.MAX-1 ; DON'T CLOSE DEVICES < CURRENT LEVEL
CFCL060			lda CFCB.DEV,X
				tay 
				bmi CFCL070
				lda #FALSE
				sta DCLOSE.TBL,Y
CFCL070			dex
				bne CFCL060
*
				lda #0
				sta DCLOSE.ERR
				ldx MAX.DNUM ; ISSUE D'CLOSE CALLS TO ALL DEVICES MARKED AS TRUE
CFCL080			lda DCLOSE.TBL,X ; IN DEV CLOSE TABLE
				bpl CFCL090

				txa 
				pha 
				stx D.DNUM
				jsr DMGR
				pla 
				tax 
				lda SERR
				beq CFCL090 ; IF ERROR,
				sta DCLOSE.ERR ; THEN SAVE IT
CFCL090			dex
				bne CFCL080
*
				lda DCLOSE.ERR ; IF $0 THEN NO ERRORS FROM D.CLOSE CALLS
				bne CFCL.ERR
				rts ; NORMAL EXIT
CFCL.ERR		jsr SYSERR ; RETURN LAST D.CLOSE ERROR REPORTED
* PAGE
* REP 60
*
* GET DEVICE NUMBER
*
* INPUT: CPATH
* OUTPUT: DEVICE NUMBER (A)
* ERROR: CARRY SET ("FILE NOT FOUND")
*
* GETDNUM FIRST CALLS THE DMGR (GETDEVNUM) MAP THE PATHNAME
* TO A DEVICE #. GETDNUM THEN ENSURES THAT THE PATHNAME
* IS NOT A BLOCK DEVICE BY CHECKING THE DBLKLST TABLE.
*
* REP 60
*
GETDNUM			.eq *
				lda #GETDEVNUM
				sta D.SCNUM
*
				lda O.PATH
				sta GDN.DNAME
				lda O.PATH+1
				sta GDN.DNAME+1
*
				lda #DNUM.TEMP
				sta GDN.DNUM
				lda /DNUM.TEMP
				sta GDN.DNUM+1
*
				lda SXPAGE+O.PATH+1
				sta SXPAGE+GDN.DNAME+1
				lda #0
				sta SXPAGE+GDN.DNUM+1
*
				jsr DMGR
				bcs GETD.ERR ; D.NAME NOT FOUND
				bmi GETD.ERR ; BLOCK DEVICE FOUND
				lda DNUM.TEMP
				rts 
*
GETD.ERR		lda #FNFERR
				jsr SYSERR
* PAGE
* REP 60
* REQUEST FCB ENTRY
*
* INPUT: DNUM (A)
* OUTPUT: REFNUM (A), OPENCT (Y)
* ERROR: CARRY SET ("CFCB FULL")
*
* REQ.CFCB FIRST SEARCHES THE CFCB TABLE USING THE DEV#
* AS A KEY. IF FOUND THE OPENCT IS INCREMENTED, OTHERWISE,
* REQ.CFCB FINDS A FREE ENTRY AND STORES THE DEV# AND LEVEL #.
*
* REP 60
*
REQ.CFCB		.eq *
				ldx #CFCB.MAX-1
				tay 
REQ010			lda CFCB.DEV,X
				bmi REQ020
				dex 
				bne REQ010
				lda #CFCBFULL
				jsr SYSERR

REQ020			tya
				sta CFCB.DEV,X
				lda LEVEL
				sta CFCB.LVL,X
				txa 
				pha 
				tya 
				jsr OPENCOUNT
				pla 
				ora #$80
				clc 
				rts ; NORMAL EXIT
* PAGE
* REP 60
*
* RELEASE FCB ENTRY
*
* INPUT: REFNUM (A)
* OUTPUT: DNUM (A), OPENCT (Y)
* ERROR: CARRY SET ("INVALID REFNUM")
*
* USES REFNUM AS AN CFCB TABLE INDEX TO RELEASE A CFCB ENTRY.
*
* REP 60
REL.CFCB		.eq *
				and #$7F
				cmp #CFCB.MAX
				bcs REL.ERR
				tax 
				lda CFCB.DEV,X
				bmi REL.ERR
				sec ; MARK ENTRY FREE
				ror CFCB.DEV,X
				jsr OPENCOUNT
				clc 
				rts ; NORMAL EXIT
*
REL.ERR			lda #BADREFNUM
				jsr SYSERR
* REP 60
*
* OPENCOUNT SUBROUTINE
*
* INPUT: DEVNUM (A)
* OUTPUT: DEVNUM (A), OPENCTR (Y)
*
* OPENCTR:=COUNT OF ALL CFCB ENTRIES W/CFCB.DEV=DEVNUM
*
* REP 60
OPENCOUNT		.eq *
				ldy #0
				ldx #CFCB.MAX-1
OPNCT010		cmp CFCB.DEV,X
				bne OPNCT020
				iny 
OPNCT020		dex
				bne OPNCT010
				rts 
* PAGE
* REP 60
*
* GET FCB ENTRY
*
* INPUT: REFNUM (A)
* OUTPUT: DNUM (A)
* ERROR: CARRY SET ("INVALID REFNUM")
*
* USES REFNUM AS AN INDEX TO RETURN THE CORRESPONDING DEVICE #.
* IF THE ENTRY INDICATED BY REFNUM IS A FREE ENTRY, THEN AN
* ERROR, "INVALID REF NUM" IS RETURNED.
*
* REP 60
GET.CFCB		.eq *
				and #$7F
				cmp #CFCB.MAX
				bcs GET.ERR
				tax 
				lda CFCB.DEV,X
				bmi GET.ERR
				clc 
				rts ; NORMAL EXIT

*
GET.ERR			lda #BADREFNUM
				jsr SYSERR ; ERR EXIT
*
* LST ON
ZZEND			.eq *
ZZLEN			.eq ZZEND-ZZORG
* IFNE ZZLEN-LENCFM
* FAIL 2,"SOSORG FILE IS INCORRECT FOR CFMGR"
* FIN

*************************************************************************
* END OF APPLE /// SOS 1.3 SOURCE CODE FILE: CFMGR.SRC
*************************************************************************




*--------------------------------------
MAN
SAVE /A3OSX.BUILD/SOS/SOS.S.CFMGR
LOAD /A3OSX.BUILD/SOS/SOS.S
ASM
